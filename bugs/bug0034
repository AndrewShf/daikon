Version:      $Id$
Owner:        Mike <mernst>, Toh <tohn>
Cc:           Jeremy <mistere>
Tool:         Daikon V3
Summary:      Some invariants not printing for ENTER program points in IOA
Severity:     Boneheaded
Status:       New
Reproducible: Yes
Description:

[mistere]

The commented-out code for modbits has to do with orig() variables on
EXIT samples.  My understanding is that it only makes a difference
when you have multiple EXITS for a given ENTER.  The add_changed logic
should be the same.

I suspect the differences between V2 and V3 are the fact that equality
invariants are printed via equivalence classes in V2, but via
IntEqual invariants in V3.  I believe that the equivalence class
doesn't take number of modified samples into account, whereas
IntEquality does.

[tohn] 

dfeIOA has been changed to do the appropriate thing.  I tried using
modbit-munge.pl (as I think the equivalent in V3 was commented out)
but its change detection wasn't sufficient to detect all the changes
that happened.  In particular, when pc[p] is instrumented as a single
string, it is considered "changed" if pc or p changes, but
modbit-munge will not see this, as the actual value of pc[p] doesn't
change in certain important transitions.  So now, modbits are simply
turned on for ENTER program points, at least until time-stamp based
detection is implemented.

As for the difference in output between V3 and V2, I've generated a
set of .decls and .dtrace files to test.  You will find them at:

~tohn/temp/buge/
                {BadModbit.decls, BadModbit.dtrace}
                {GoodModbit.decls, GoodModbit.dtrace}

It's the same run, but under different modbit generations in the
Simulator.  The .txt files in the directory are from V3.  Is this bug
"closed"?

[mistere]
This is more Mike's area of expertise, so I'll add him to the owner list.
I also clarified some text below.

[tohn]
(Jeremy and I have talked about this already; this is just to put the
ideas in writing)

ENTER program points in IOA have very few variables with modbits set
(in particular, only variables that were function arguments).  Thus,
some equality invariants, like pc[turn] = pc[p] do not appear, even
though they appear in Daikon 2 and in the exit program points (see
~tohn/research/IOA_Toolkit/Examples/Peterson).

In V3, it is supressed due to few modified samples.  In V2, this
wasn't an issue because equivalence classes were established without
regard for the few missing samples check.

What is the proper solution though?  Simply ignoring this test for
equality may fix this problem, but if few variables are modified on
entry, it may cause other less-noticable problems for IOA traces.  In
short, what does it mean for something's modbit to be set at the ENTER
program point?  What does it mean in IOA?

[mernst]
I pointed out to Toh that dfeIOA's technique for setting modbits is
completely wrong.  It should be corrected.  That doesn't explain the
different behavior, of course.

One possibility is that for some reason Daikon's simple checks that correct
some modbit failures are behaving differently in the two versions.  (See
variable dkconfig_add_changed.)  Toh agreed to look into this.

If that doesn't yield any information, then could you provide a specific
test case (.decls and .dtrace files, and command lines) that shows
different behaviors for the two versions?  Otherwise it is too hard to
reproduce.

--
$Log$
Revision 1.7  2002-04-08 21:46:43  mistere
Spelling.

Revision 1.6  2002/04/08 21:45:18  mistere
changed bug0034

Revision 1.5  2002/04/08 21:34:00  tohn
changed bug0034

Revision 1.4  2002/04/05 19:57:12  mernst
changed bug0034

Revision 1.3  2002/04/03 20:18:14  mistere
Manually update to use Cc field wher appropriate.

Revision 1.2  2002/03/28 19:48:24  mistere
changed bug0034

Revision 1.1  2002/03/28 19:37:13  tohn
new bug0034

