THE INVARIANT DETECTION ENGINE

The invariant detection engine reports properties that are likely to hold
at certain program points.  The reported properties are the kind of
arithmetic equations that you might write in an assert statement or a
formal specification, such as "x > abs(y)" or "x = 3*y + 4*z - 7" or "x = 0
(mod 4)".  These invariants can be useful in program understanding and a
host of other applications.  The technique is to run the program and
examine the values it computes, looking for patterns and relationships
among those values.  Front ends exist for C, C++, and Lisp; a Java version
is in progress.

Table of contents of this document:
 * Installing the invariant detection engine
 * Using the invariant detection engine
 * Manifest (list of files in the distribution)
 * Getting more help


Installing the invariant detection engine
=========================================

1. Download the invariants.tar.gz file.
2. In the directory where you want to install it, unpack the tarfile:
     tar zxvf invariants.tar.gz
   This creates an invariants/ subdirectory.
3. Set the environment variable INVARIANTS_HOME to point the directory.
   In csh:
     setenv INVARIANTS_HOME /directory/goes/here
   In sh:
     INVARIANTS_HOME=/directory/goes/here
     export INVARIANTS_HOME
4. Adjust the path to Perl in the first line of the 'instrumentor' script.
5. If you want to detect invariants in C code, download the appropriate
   version of the C front end and rename it to edgcpfe in a directory on
   your path.
6. If you don't already have the Python programming language installed,
   download it from http://www.python.org/.  If you intend to use
   compressed data files, you will need Python 1.5.2.


Using the invariant detection engine
====================================

Detecting invariants involves three steps:
 1. Instrument the program to add instructions that output variable values.
 2. Run the program (probably using a test suite) to create data trace files.
 3. Run the invariant engine over the data trace files to detect invariants.


Step 1:  Instrumentation
------------------------

There are three different front ends -- for C, Java, and Lisp -- which add
instrumentation instructions.

C front end:
 a. Run the instrumentor on your C source files:
      instrumentor <filename1> <filename2> ...
    The instrumentor:
     * copies your original files to <filename1>.uninst
     * overwrites the original files with instrumented versions
     * creates declaration files named <filename>.c.decls
    You may wish to perform this operation with a copy of your program,
    to safeguard your original source code.
 b. Create or modify a Makefile.  Either:
     * If you have no Makefile, add your source files to Makefile-sample
     * If you have a Makefile, add "dump_trace.o" to the list of object
       files that need to be created (and linked to create your executable)
 c. Copy the appropriate files to your directory, including
    dump_trace.c, dump_trace.h, 
 d. Build your program in the usual way, perhaps by running "make"; this
    creates an instrumented executable.

Lisp front end:
  ;; a. Load all the support code.
  (load "load-all")
  ;; b. Add instrumentation code to the beginning and end  of each
  ;;    function, and to each loop head.  The instrumentation writes the
  ;;    values of all the live variables to a file. 
  (instrument-file "gries.lisp" "gries-instrumented.lisp")

  For efficiency, you might want to compile the Lisp files and run the
  compiled versions; do the following after (load "load-all")
    (compile-all)	;; only needs to be done once (ever)
    (load-all)		;; only needs to be done explicitly after compiling


Java front end:
  This is still under development.
  When complete, there will be two options:
    * first instrument (step 1), then run the program (step 2)
    * an integrated command that does both of these steps
 not be separate steps for instrumentation and
    running the program; instead, one command will accomplish both, though


Step 2:  Run the program
------------------------

You should be able to run the instrumented program in just the same way you
did before; the only behavioral change will be writing a .dtrace file (for
the Lisp and Java front ends) or a .trace file (for the C front end).  Run
the program over some test suite in order to create a collection of trace
files.

When running a program in C, you will need a file label.txt which contains
a single integer.  (One is provided in the distribution.)

In Lisp, you might do the following after (load "load-all"):
  ;; Load the instrumented code.
  (load "gries-instrumented")
  ;; Run the instrumented code.  This runs all the test-* functions; 
  ;; each test-* function creates one *.dtrace file
  (test-all)



Step 3:  Detect invariants in the data trace files
--------------------------------------------------

Run the Python interpreter using the shell command "python" or the Emacs
command M-x run-python.  It is convenient to run Python in the directory
containing invariants.py and the other Python source files, so that you
don't have to set the PYTHONPATH environment variable.  You can download
Python from http://www.python.org/.

In Python, issue the following commands:

  import invariants			      # load the invariants.py file
  invariants.read_declarations('*.decls',1)   # read the function declarations
  invariants.read_data_traces('p*.dtrace')    # read the trace files
  invariants.all_numeric_invariants()	      # compute and print invariants

The three functions above each take an optional regular expression for
program point, so that only certain program points are processed.  (This
can make the invariant detection engine run faster.)  For details, see
the documentation strings in their definitions in invariants.py.

To do all this from a single shell command, do the following:
  python -O -c "__debug__ = 0; import invariants; invariants.read_declarations('*.decls',1); invariants.read_data_traces('p*.dtrace'); invariants.all_numeric_invariants()"

In the output, the "_orig" suffix refers to the original value of a formal
parameter, for parameters possibly modified in the function body.
":::BEGIN", ":::END", and ":::LOOP" are tags identifying at which program
the instrumentation was inserted; invariants are program-point-specific.
There is some redundancy in the output (e.g., both "Z = max(Y, X)" and
"Z = max(X, Y)" are reported, as are both "Y > X" and "X < Y").


Manifest (list of files in the distribution)
============================================

User documentation
  README	This file

C front end (you will also need the edgcpfe executable; see "Installation")
  dump_trace.c		Writing data values to a data trace
  dump_trace.h		Header files for the above
  Makefile-sample	Sample Makefile for linking in the above
  instrumentor		Script for running instrumenter on multiple C files
  label.txt		Auxiliary file for output filename selection at runtime

Lisp front end
  load-all.lisp		Shell for loading other Lisp files
  instrument.lisp	Instrumenting Lisp programs to write data traces
  data-trace.lisp	Writing data values to a data trace

Lisp example files
  gries.lisp		Programs from Gries's "The Science of Programming"
  gries-helper.lisp	Support for Gries-style synax and for testing
  gries-instrumented.lisp	Instrumented version of gries.lisp
  inv-medic.lisp	Support for finding invariants in the Medic program

Invariant detection engine
  invariants.py		The invariant detector itself
  util.py		Utility functions used by the invariant detector
  invariants.py.doc	Internal documentation on data structures and design

Miscellaneous files
  Makefile		Makefile for the invariant detection system
  VERSION		Timestamp of this distribution


Getting more help
=================

If you have any questions, can suggest ways to improve the documentation,
find bugs in the system, or have suggestions for its improvement, please
send email to mernst@cs.washington.edu and I will do my best to help.

The invariant detector is further described in the paper ``Dynamically
Discovering Likely Program Invariants to Support Program Evolution'' by
Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin, in
Proceedings of the 19th International Conference on Software Engineering
(ICSE '99), Los Angeles, CA, May 19-21, 1999.  This paper is available at
http://www.cs.washington.edu/homes/mernst/pubs/invariants-icse99-abstract.html
