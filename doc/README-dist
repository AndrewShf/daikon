If you have any questions, can suggest ways to improve the documentation,
find bugs in the system, or have suggestions for its improvement, please
let me know and I'll do my best to help.

The invariant detector is further described in the paper ``Dynamically
Discovering Likely Program Invariants to Support Program Evolution'' by
Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin, in
Proceedings of the 19th International Conference on Software Engineering
(ICSE '99), Los Angeles, CA, May 19-21, 1999.  This paper is available at
http://www.cs.washington.edu/homes/mernst/pubs/invariants-icse99-abstract.html


Installing the invariant detection engine
=========================================

1. Download the invariants.tar.gz file.
2. In the directory where you want to install it, unpack the tarfile:
     tar zxvf invariants.tar.gz
   This creates an invariants/ subdirectory.
3. Set the environment variable INVARIANTS_HOME to point the directory.
   In csh:
     setenv INVARIANTS_HOME /directory/goes/here
   In sh:
     INVARIANTS_HOME=/directory/goes/here
     export INVARIANTS_HOME
4. If you want to detect invariants in C code, download the appropriate
   version of the C front end and rename it to edgcpfe.
5. If you don't already have the Python programming language installed,
   download it from http://www.python.org/.


Using the invariant detection engine
====================================

Detecting invariants involves three steps:
 1. Instrument the program to add instructions that output variable values.
 2. Run the program (probably using a test suite) to create data trace files.
 3. Run the invariant engine over the data trace files to detect invariants.


Step 1:  Instrumentation
------------------------

There are three different front ends -- for C, Java, and Lisp -- which add
instrumentation instructions.

C front end:
 a. Run the instrumentor on your C source files:
      instrumentor <filename1> <filename2> ...
    The instrumentor:
     * copies your original files to <filename1>.uninst
     * overwrites the original files with instrumented versions
     * creates declaration files named <filename>.c.decls
    You may wish to perform this operation with a copy of your program,
    to safeguard your original source code.
 c. Create or modify a Makefile.  Either:
     * add "dump_trace.c" to your Makefile, or
     * add your source files to Makefile-sample
 d. Build your program in the usual way, perhaps by running "make"; this
    creates an instrumented executable.

Lisp front end:
  (load "load-all")
  ;; Add instrumentation code to the beginning and end of each function, and
  ;; to each loop head.
  ;; The instrumentation writes the values of all the live variables to a file.
  (instrument-file "gries.lisp" "gries-instrumented.lisp")
  (load "gries-instrumented.lisp")
  ;; run all test-* functions; each test-* function creates one *.dtrace file
  (test-all)

  For efficiency, you might want to compile the Lisp files and run the
  compiled versions:
    (compile-all)	;; only needs to be done once (ever)
    (load-all)		;; only needs to be done explicitly after compiling


Java front end:
  This is still under development.
  When complete, there will be two options:
    * first instrument (step 1), then run the program (step 2)
    * an integrated command that does both of these steps
 not be separate steps for instrumentation and
    running the program; instead, one command will accomplish both, though


Step 2:  Run the program
------------------------

You should be able to run the instrumented program in just the same way you
did before; the only behavioral change will be writing a .dtrace file (for
the Lisp and Java front ends) or a .trace file (for the C front end).  Run
the program over some test suite in order to create a collection of trace
files.

When running a program in C, you will need a file label.txt which contains
a single integer.  (One is provided in the distribution.)


Step 3:  Detect invariants in the data trace files
--------------------------------------------------

Run the Python interpreter using the shell command "python" or the Emacs
command M-x run-python.  It is convenient to run Python in the directory
containing invariants.py and the other Python source files, so that you
don't have to set the PYTHONPATH environment variable.  You can download
Python from http://www.python.org/.

In Python, issue the following commands:

  import invariants			      # load the invariants.py file
  invariants.read_declarations('*.decls',1)   # read the function declarations
  invariants.read_data_traces('p*.dtrace')    # read the trace files
  invariants.all_numeric_invariants()	      # compute and print invariants

The three functions above each take an optional regular expression for
program point, so that only certain program points are processed.  (This
can make the invariant detection engine run faster.)  For details, see
the documentation strings in their definitions in invariants.py.

To do all this from a single shell command, do the following:
  python -O -c "__debug__ = 0; import invariants; invariants.read_declarations('*.decls',1); invariants.read_data_traces('p*.dtrace'); invariants.all_numeric_invariants()"

In the output, the "_orig" suffix refers to the original value of a formal
parameter, for parameters possibly modified in the function body.
":::BEGIN", ":::END", and ":::LOOP" are tags identifying at which program
the instrumentation was inserted; invariants are program-point-specific.
There is some redundancy in the output (e.g., both "Z = max(Y, X)" and
"Z = max(X, Y)" are reported, as are both "Y > X" and "X < Y").
