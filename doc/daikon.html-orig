<html>
<head>
<TITLE>Daikon invariant detector</TITLE>
</head>
<body>

<img src="daikon.gif" alt="Daikon logo">

<h1>Daikon invariant detector</h1>			<!-- omit from toc -->


The <a href="http://sdg.lcs.mit.edu/~mernst/daikon/">Daikon
invariant detector</a> reports properties that are likely to hold at
certain points in a program.  The reported properties are arithmetic
equations such as you might write in an assert statement or a formal
specification; for example, "x > abs(y)" or "x = 3*y + 4*z - 7" or "x = 0
(mod 4)".  These invariants can be useful in program understanding and a
host of other applications.  Daikon operates by running the program and
examining the values it computes, looking for patterns and relationships
among those values.  <a href="#instrumentation">Front ends</a> exist for <a
href="#java-front-end">Java</a>, <a href="#c-front-end">C</a>, and <a
href="#lisp-front-end">Lisp</a>; of these, the Java front end is the most
robust, complete, and featureful, and is the most actively supported.<p>

Table of contents: <!-- auto-generated by html-toc -->
<ul>
  <li><a href="#install">Installing Daikon</a>
  <li><a href="#run">Using Daikon to detect invariants</a>
    <ul>
      <li><a href="#instrumentation">Step 1:  Instrumentation</a>
        <ul>
          <li><a href="#java-front-end">Java front end</a>
          <li><a href="#c-front-end">C front end</a>
          <li><a href="#lisp-front-end">Lisp front end</a>
        </ul>
      <li><a href="#run-program">Step 2:  Run the program</a>
      <li><a href="#run-daikon">Step 3:  Detect invariants in the data trace files</a>
        <ul>
          <li><a href="#example">Example</a>
          <li><a href="#interpret-output">Interpreting the output</a>
        </ul>
    </ul>
  <li><a href="#manifest">Manifest (list of files in the distribution)</a>
  <li><a href="#license">License</a>
  <li><a href="#credits">Credits</a>
  <li><a href="#help">In case of trouble</a>
    <ul>
      <li><a href="#help-dfej">Problems with dfej</a>
        <ul>
          <li><a href="#help-dfej-compile">Problems compiling dfej</a>
          <li><a href="#help-dfej-run">Problems running dfej</a>
        </ul>
      <li><a href="#problems-running-instrumented">Problems running instrumented code</a>
      <li><a href="#problems-running-daikon">Problems running Daikon</a>
      <li><a href="#other-problems">Other problems</a>
    </ul>
  <li><a href="#more-help">Getting more help</a>
    <ul>
      <li><a href="#known-bugs">Known bugs</a>
    </ul>
</ul>
<p>


<hr>
<h1><a name="install">Installing Daikon</a></h1>

Requirements for running Daikon:
<ol>
  <li>A <a href="http://java.sun.com">Java virtual machine</a>.
      Daikon is written in Java, so this is needed to run Daikon.
      Daikon works with either a Java 1.2 or a Java 1.3 JVM and Java compiler.
  <li>A C++ compiler such as <a href="http://gcc.gnu.org/">gcc</a>,
      if you wish to use the Daikon front end for Java.  (This front end,
      which permits you to detect invariants in Java programs, is
      written in C++.)
</ol>

Installing Daikon:
<ol>
  <li>Download the <tt><a href="http://sdg.lcs.mit.edu/~mernst/daikon/download/daikon.tar.gz">daikon.tar.gz</a></tt>
      file from
      <a href="http://sdg.lcs.mit.edu/~mernst/daikon/download/">http://sdg.lcs.mit.edu/~mernst/daikon/download/</a>.
      <p>

      Daikon is also available via anonymous CVS.  <a
      href="mailto:mernst@lcs.mit.edu">Send email</a> if you desire such
      access, and I will provide you the repository name and password.
  <li>In the directory where you want to install Daikon (we'll call this
      the <tt><em>parent</em></tt> directory), unpack the tarfile:
<pre>
       tar zxvf daikon.tar.gz
</pre>
      This creates a <tt><em>parent</em>/daikon/</tt> subdirectory.
  <li>Add the Daikon Java files to your Java class path.  For instance, in
      csh put the following in your <tt>.cshrc</tt> file:
<pre>
      setenv CLASSPATH <em>parent</em>/daikon/java:${CLASSPATH}
</pre>
      The distribution includes compiled <tt>.class</tt> files, but in
      order to recompile them, simply type <tt>make</tt> in any directory
      under <tt><em>parent</em>/daikon/java/daikon/</tt>.
  <li>Add the <tt><em>parent</em>/daikon/bin/</tt> directory to your path.  (Your
      path is a list of directories in which the shell searches for
      commands; this permits you to type just the program name rather than
      supplying a full pathname.)  In csh, put the following in your
      <tt>.cshrc</tt> file:
<pre>
      set path = (<em>parent</em>/daikon/bin $path)
</pre>
<!--
  <li>Set the environment variable <tt>DAIKON_HOME</tt> to point the directory.<p>
      In csh:
<pre>
      setenv DAIKON_HOME <i>/directory/goes/here</i>
</pre>
      In sh:
<pre>
      DAIKON_HOME=<i>/directory/goes/here</i>
      export DAIKON_HOME
</pre>
-->
  <li>Prepare the front ends for use.  If you wish to detect invariants in
      programs written in a particular language, you need a front end for
      that source language.  The available front ends are:
    <ul>
      <li><a name="build-dfej"><b>Java front end</b></a>:
          Either download a binary version of the dfej Java instrumenter
          from the same place that you obtained Daikon itself (<a
          href="http://sdg.lcs.mit.edu/~mernst/daikon/download/">http://sdg.lcs.mit.edu/~mernst/daikon/download/</a>),
          or build dfej from the sources provided in the distribution by
          following these steps:
        <ol>
	  <li><tt>cd java-front-end</tt>
          <li><tt>./configure --enable-debug</tt><br>
              You must supply the --enable-debug argument to configure.
	  <li>If you are running under Solaris, you may need to edit
	      <tt>Makefile</tt> to indicate use of the libw library; change<br>
	      <q><tt>LDFLAGS=-L. -o $(EXECUTABLE)</tt></q><br>
	      to<br>
	      <tt>LDFLAGS=-L. -lw -o $(EXECUTABLE)</tt>
	  <li><tt>make</tt>
	  <li>Add <tt>java-front-end/src/dfej</tt> to your path; either
            <ul>
	      <li>copy or link the <tt>dfej</tt> program to a directory on
	          your path, or
	      <li>add the <tt>java-front-end/src</tt> directory to your path;
		  for instance, in csh place the following in your
		  <tt>.cshrc</tt> file:<br>
		  <tt>set path = (<em>parent</em>/daikon/java-front-end/src $path)</tt><br>
	    </ul>
          <li><a name="rt.jar_on_classpath"></a>Make sure that <tt>rt.jar</tt> is on your Java class path.
              For instance, in csh place something like the following in your
	      <tt>.cshrc</tt> file:<br>
<pre>
        setenv CLASSPATH ${CLASSPATH}:$HOME/java/jdk/jre/lib/rt.jar
</pre>
  <li>Add the Daikon Java files to your Java class path.  For instance, in
      csh put the following in your <tt>.cshrc</tt> file:
<pre>
      setenv CLASSPATH <em>parent</em>/daikon/java:${CLASSPATH}
</pre>
        </ol>
      <li><b>C front end</b>:
        Supporting files for the C front end are found in the 
	<tt>c-front-end/</tt> directory, but you must download the
	front end itself.<p>

        See the <a href="#c-front-end">warrning about the C front end</a>.
        <ol>
	  <li>Download a binary version of the Daikon C front end from the
	      same place that you obtained Daikon itself:  <a
	      href="http://sdg.lcs.mit.edu/~mernst/daikon/download/">http://sdg.lcs.mit.edu/~mernst/daikon/download/</a>.
	      Due to licensing restrictions, we are unable to distribute
	      source for this program.  Rename the downloaded file to
	      <tt>edgcpfe</tt> in a directory on your path.  (You will not
	      run the <tt>edgcpfe</tt> program directly,
	      but only via the <tt>c-front-end/dfec</tt> script.)
	  <li>Optionally set the path to Perl in the first line of the
	      <tt>c-front-edn/dfec</tt> script.  This is not necessary, but
	      will make the script start up faster.
        </ol>
      <li><b>Lisp front end</b>:  no special work to be done.
          The front end appears in the distribution in the
	  <tt>lisp-front-end/</tt> directory.
    </ul>
</ol>


<hr>
<h1><a name="run">Using Daikon to detect invariants</a></h1>


Detecting invariants involves three steps:
<ol>
  <li><a href="#instrumentation">Instrument the program</a> to add instructions that output variable values.
  <li><a href="#run-program">Run the program</a> (probably using a test suite) to create data trace files.
  <li><a href="#run-daikon">Run the Daikon invariant engine</a> over the data trace files to detect invariants.
</ol>


<h2><a name="instrumentation"></a>Step 1:  Instrumentation</h2>


There are three different front ends -- for Java, C, and Lisp.  Each of
these front ends modifies your program so that, in addition to performing
its original task, it also writes variable values to a data trace file.
<ul>
  <li><a href="#java-front-end">Java front end</a>
  <li><a href="#c-front-end">C front end</a>
  <li><a href="#lisp-front-end">Lisp front end</a>
</ul>


<h3><a name="java-front-end">Java front end</a></h3>

The Daikon front end for Java should work on Java code which corresponds to
any version of the Java language, from 1.0 to 1.3.
<p>

<ol>
  <li>Run <tt>dfej</tt>, the Daikon front end for Java, on your Java source
      files:
<pre>
      dfej <i>filename1.java</i> <i>filename2.java</i> ...
</pre>
      The Daikon Java front end:
      <ol>
        <li>writes instrumented versions of the files
            to a <tt>daikon-java/</tt> directory
	<li>creates declaration files named
            <tt><i>filename1.java</i>.decls</tt>, etc. in a
            <tt>daikon-output/</tt> directory.
      </ol>
      Only the specified Java files will be instrumented; other files will
      be run uninstrumented.  This permits you to control the scope of
      invariant detection.<p>

      In any of the specified files, all classes defined in any of those
      files will be instrumented.  For instance, after
<pre>
      dfej Foo.java Bar.java
</pre>
      the instrumented versions of Foo.java and Bar.java will output
      information about all Foo objects (including Foo objects that are
      components of Bar objects, that are arguments to Bar functions,
      etc.), and likewise for Bar objects.
      After
<pre>
      dfej Foo.java
      dfej Bar.java
</pre>
      the same functions (all those in the Foo and Bar classes) will be
      instrumented, but in Foo functions, no detail will be provided about
      the structure of any Bar objects that might appear.  In other words,
      the instrumenter assumes that the only classes instrumented (and
      about which information is desired) are those presented to it on the
      command line.  One way to determine all the .java files that are
      included in a specified program is to run the following commands:
<pre>
      find . -name '*.class' -print | xargs rm -f
      javac MyProgram.java
      find . -name '*.class' -print
</pre>
      <p>

      See the <tt>dfej</tt> usage message for more information.
</ol>

<h3><a name="c-front-end">C front end</a></h3>

<b>Warning:</b> While the C front end works correctly on a number of
programs, it is known to fail on some legal C programs.  (As of November
2000, a new C/C++ front end is in progress; it will address all the
problems noted here.)  The old C front end may issue errors when it is run
(and refuse to produce an instrumented program), may produce an
instrumented program that fails to compile (because the instrumented
program contains C errors), or may produce an instrumented program that
core-dumps when it is run.  Problems are more likely with C++ programs than
with C programs.  We will attempt to fix problems that are reported to us,
but can make no promises regarding the old C front end.  By contrast, the <a
href="#java-front-end">Java front end</a> is functional and supported.<p>

<ol>
  <li>Run <tt>dfec</tt> on your C source files (but not on .h header files):
<pre>
      dfec <i>filename1.c</i> <i>filename2.c</i> ...
</pre>
     <tt>dfec</tt> is written in Perl.  If Perl is not available, you may
     instead use <tt>dfec.sh</tt>, which is written in sh shell script.<p>

     The Daikon C front end:
     <ol>
       <li>copies your original files to <tt><i>filename1.c</i>.uninst</tt>,
	   etc.<br>
       <li>overwrites the original files with instrumented versions
       <li>creates declaration files named <tt><i>filename1.c</i>.decls</tt>, etc.
     </ol>
     You may wish to perform this operation with a copy of your program,
     to safeguard your original source code.<p>

     If you supply the <tt>-d <i>directory</i></tt> argument (before
     the file names), then the instrumented source files are placed in the
     specified directory instead (and no backup files need be made).
 <li>Copy files <tt>dump_trace.c</tt> and <tt>dump_trace.h</tt> to the
     directory with the instrumented source files.
 <li>Create or modify a <tt>Makefile</tt>.  Either:
   <ul>
     <li>If you have no <tt>Makefile</tt>, copy <tt>Makefile-sample</tt>
         to <tt>Makefile</tt> and add the names of your source files to its
         <tt>OBJS</tt>, and edit its <tt>EXEC</tt> executable name.
     <li>If you have a <tt>Makefile</tt>, add <tt>dump_trace.o</tt> to the
         list of object files that need to be created (and linked to create
         your executable).
   </ul>
 <li>Create an instrumented executable by building your program in the
     usual way (perhaps by running <tt>make</tt> or <tt>cc</tt> or <tt>gcc</tt>).
</ol>


<h3><a name="lisp-front-end">Lisp front end</a></h3>

<ol>
  <li>Load all the support code.
<pre>
  (load "load-all")
</pre>
  <li>Add instrumentation code to the beginning and end  of each
      function, and to each loop head.  The instrumentation writes the
      values of all the live variables to a file. 
<pre>
  (instrument-file "gries.lisp" "gries-instrumented.lisp")
</pre>
</ol>

  For efficiency, you might want to compile the Lisp files and run the
  compiled versions; do the following after <tt>(load "load-all")</tt>:
<pre>
    (compile-all)	;; only needs to be done once (ever)
    (load-all)		;; only needs to be done explicitly after compiling
</pre>


<h2><a name="run-program">Step 2:  Run the program</a></h2>

Run the program over some test suite in order to create a
collection of data trace files.
You can run the instrumented program in just the same way you did before;
the only behavioral change will be writing a <tt>.dtrace</tt> file to the
<tt>daikon-output/</tt> subdirectory (which is created if it does not
already exist).  Only one <tt>.dtrace</tt> file is created, even though
multiple <tt>.decls</tt> files might have been created (one for each source
file) when the program was instrumented.<p>


<ul>
  <li><b>Java programs</b>:  After instrumentation, there are two versions
      of the program:  the original version, and the instrumented version
      which appears in the <tt>daikon-java/</tt> directory.  Make sure that
      the <tt>daikon-java/</tt> directory appears on your class path before
      the directory containing the original Java code.  You can do this by
      running the program from that directory, if "." (the current
      directory) appears early on your class path, or you can add the
      <tt>daikon-java/</tt> directory to your class path explicitly.<p>

      <ul>
	<li><b>Java applets</b>: There are some additional steps you
        have to take if you are running an applet.
	<ul>
	  <li> Copy or create symbolic links to <u>all</u> class
	       files, jar files, input files, and html files that your
	       applet needs to the <tt>daikon-java/</tt> directory.
	       This includes the daikon directory.  For example, to
	       create a link to the daikon directory, type (while in
	       the <tt>daikon-java/</tt> directory):
<pre>
       ln -s <i>path-to-daikon</i> daikon
</pre>
	  <li> By default, the Java 2 applet security model does not
	  allow applets to write files.  To get around this so that
	  Daikon can write its .dtrace files, create a file named
	  javaPolicy in the <tt>daikon-java/</tt> directory that
	  contains the text
<pre>
       grant {
           permission java.io.FilePermission "<<ALL FILES>>", "read, write, delete, execute";
       };
</pre>
	  Do not use this policy file with untrusted applets.
	  <li> Run the applet:
<pre>
       appletviewer -J-Djava.security.policy=javaPolicy <i>html-file</i>
</pre>
	</ul>
      </ul>

      After running your Java application or applet, run
      <tt>bin/modbit-munge.pl</tt> on the resulting <tt>.dtrace</tt>
      file:
<pre>
    modbit-munge.pl <em>myprog</em>.dtrace
</pre>
      This step fixes up some potential problems that may appear in the
      trace file.
  <li><b>C programs</b>:  If you do not supply a file <tt>label.txt</tt> which
      contains a single integer (a sample is provided in the distribution), one
      will be created for you.  This determines the name of the data trace
      file.
  <li><b>Lisp programs</b>:  To run the Gries example programs, after
      having done <tt>(load "load-all")</tt>:
<pre>
    ;; Load the instrumented code.
    (load "gries-instrumented")
    ;; Run the instrumented code.  This runs all the test-* functions; 
    ;; each test-* function creates one *.dtrace file
    (test-all)
</pre>
</ul>


<h2><a name="run-daikon">Step 3:  Detect invariants in the data trace files</a></h2>

Run the Daikon invariant detector via the command
<pre>
    java daikon.Daikon <em>decl-files...</em> <em>trace-files...</em>
</pre>

The <em>decl-files</em> are declaratation (<tt>.decl</tt>) files created at
instrumentation time.
The <em>trace-files</em> are data trace (<tt>.dtrace</tt>) files created by
running the instrumented program.
Be sure to include all declaration files that are needed for the particular
data trace file; the simplest way is to include all the declaration files
created when instrumenting the proram that is read.

<h3><a name="example"></a>Example</h3>

To try out Daikon, run the following commands:
<pre>
    cd <em>parent</em>/daikon/examples/gries
    java daikon.Daikon gries-instrumented.decls p180-15.1.1.dtrace
</pre>


<h3><a name="interpret-output">Interpreting the output</a></h3>

In the output, the "_orig" suffix refers to the original value of a formal
parameter, for parameters possibly modified in the function body.
Negative array indices count from the end of the array; for instance, index
"-1" denotes the last element of the array.<p>

":::ENTER", ":::EXIT", and ":::LOOP" are tags identifying at which program
point the instrumentation was inserted; these invariants are
program-point-specific.  ":::CLASS" and ":::CLASS-STATIC" indicate class
invariants (sometimes called object invariants) which always hold for any
object of the given class, from the point of view of a client or user.
These properties hold at entry to and exit from every public method of the
class.<p>

When "a" is an array, then
<ul>
  <li>"a" is the identity of a -- think of it as a
      comparison over hash codes
  <li>"a.class" is the runtime type of a, which may
      differ from its declared type for arrays of non-primitive type;
      "a.class" is omitted for arrays of primitive type
  <li>"a.[]" is the contents of a, namely an array; "a=b" implies "a.[] =
      b.[]" but the reverse is not true
  <li>"a.[].class" is an array of types, representing the run-time classes
      of the contents of a; it is omitted for arrays of primitive type
</ul>
<p>


<hr>
<h1><a name="manifest">Manifest (list of files in the distribution)</a></h1>

<pre>
User documentation
  daikon.html		This file; the main Daikon documentation
  README		Says to see daikon.html instead
  daikon.gif		The Daikon logo

Java front end
  java-front-end/	A modified version of the <a href="http://oss.software.ibm.com/developerworks/opensource/jikes/project/">Jikes Java compiler</a>
    src/                Source code
      dfej              The main executable (Daikon front end for Java);
                          you must build this yourself (see <a href="#build-dfej">instructions</a>)

C front end
  c-front-end/
    dump_trace.c	Writing data values to a data trace
    dump_trace.h	Header files for the above
    Makefile-sample	Sample Makefile for linking in the above
    dfec		Script for instrumenting C files (you will also
                          need the edgcpfe executable; see "<a
                          href="#install">Installing Daikon</a>")
    dfec.sh		Version of dfec written in shell script, not Perl
    label.txt		Auxiliary file for output filename selection at runtime

Lisp front end and example files
  lisp-front-end/
    load-all.lisp	Shell for loading other Lisp files
    instrument.lisp	Instrumenting Lisp programs to write data traces
    data-trace.lisp	Writing data values to a data trace
    gries.lisp		Programs from Gries's "The Science of Programming"
    gries-helper.lisp	Support for Gries-style syntax and for testing
    gries-instrumented.lisp	Instrumented version of gries.lisp
    inv-medic.lisp	Support for finding invariants in the Medic program

Invariant detection engine
  java/			Source code for Daikon, which is written in Java
    Daikon.java         The entry point for Daikon

Auxiliary programs
  bin/			Helper scripts and programs

Miscellaneous files
  Makefile		Makefile for the invariant detection system
  VERSION		Timestamp of this distribution
  dtrace-format.txt	Documentation of the trace file format; somewhat old
  daikon-python/        An old version of Daikon, written in Python.
  			  The current version does not require Python.
</pre>


<hr>
<h1><a name="license">License</a></h1>

Daikon is made available for education, research, and evaluation purposes
(not for direct commercial gain), and there is no warranty.  All rights are
reserved, and copyright is held by the authors.  If you have difficulties
with the software, let us know and we will try to correct the problem, but
we cannot make any guarantees of support, or any other guarantees regarding
the software.  As a condition of use, you agree to promptly communicate any
changes, improvements, or enhancements to the authors for inclusion in a
future release under these same conditions.  If you do not agree to this
license, please do not use or examine the software.  For other licensing
terms, <a href="mailto:mernst@lcs.mit.edu">contact the author</a>.<p>

If you use Daikon, please <a href="mailto:mernst@lcs.mit.edu">send
email to Michael Ernst &lt;mernst@lcs.mit.edu&gt;</a>, so that you
can be informed of new versions, enhancements, and bug fixes.  I would also
appreciate a brief description of how you are using Daikon, because I am
curious about how users exploit it (and am eager for anecdotes about its
successes and failures), and I want to make it more effective for its
users.<p>


<hr>
<h1><a name="credits">Credits</a></h1>

The following individuals have contributed to Daikon:
<ul>
  <li><a href="http://www.cs.washington.edu/homes/jake/">Jake Cockrell</a>
  <li>Adam Czeisler
  <li><a href="http://sdg.lcs.mit.edu/~mernst/">Michael Ernst</a>
  <li><a href="http://www.cs.ucsd.edu/~wgg/">Bill Griswold</a>
  <li>Josh Kataoka
  <li><a href="http://www.cs.washington.edu/homes/notkin/">David Notkin</a>
</ul>
<p>

Many of our colleagues have been generous with their feedback and advice,
for which we are grateful.
<a href="http://www.cs.washington.edu/homes/csk/">Craig Kaplan</a>
carved the Daikon logo.
This work was supported in part by NSF grants CCR-9506779 and CCR-9508745,
an IBM Cooperative Fellowship, and a gift from Edison Design Group.
<p>


<hr>
<h1><a name="help">In case of trouble</a></h1>

<h2><a name="help-dfej">Problems with dfej</a></h2>

<h3><a name="help-dfej-compile">Problems compiling dfej</a></h3>

gcc 2.95.2 on Linux raises an internal error when compiling stream.cpp
using the -Wall flag.  You can simply compile that file without the -Wall
flag.
<p>

If you get an error like
<pre>
body.cpp:183: `class AstLocalVariableDeclarationStatement' has no member named `lex_stream_opt'
</pre>
then you probably failed to add the <tt>-DJIKES_DEBUG</tt> flag to the
COMPILE and CXXCOMPILE lines of <tt>src/Makefile</tt>.  (This should not be
necessary any longer, as <tt>platform.h</tt> includes the definition.)
<p>

<h3><a name="help-dfej-run">Problems running dfej</a></h3>

If you get an error like
<pre>
% dfej MyFile.java
MyFile.java:0:0:0:0: Error: Could not find package named: 
                ./java/util
MyFile.java:0:0:0:0: Error: Could not find package named: 
                ./java/lang
</pre>
then you need to <a href="#rt.jar_on_classpath">add <tt>rt.jar</tt> to your
CLASSPATH</a>.
<p>

dfej does not handle anonymous classes like that created by the expression
<pre>
  new ItemListener() {
      public void itemStateChanged( ItemEvent evt ) {
	 ...
      }
  }
</pre>
For now, the workaround is to run dfej on all files except
AspectTraverseComboBox.java and Menus.java.  (I haven't tested the dfej
output, however.)
<p>



<h2><a name="problems-running-instrumented"></a>Problems running instrumented code</h2>


<h2><a name="problems-running-daikon"></a>Problems running Daikon</h2>



<h2><a name="other-problems"></a>Other problems</h2>


<hr>
<h1><a name="more-help">Getting more help</a></h1>

If you have any questions, can suggest ways to improve the documentation,
find bugs in the system, or have suggestions for its improvement, please
<a href="mailto:mernst@lcs.mit.edu">send email to Michael Ernst
&lt;mernst@lcs.mit.edu&gt;</a>.  While Daikon is a research prototype
and not rock-solid, I will do my best to assist you and to correct any
problems, so please don't hesitate to ask for help or report difficulties.<p>

Your bug report will be most helpful if you include:
<ul>
  <li>the contents of the <tt>VERSION</tt> file, which indicates the
      release date of your copy of Daikon.  If you are not using the most
      recent version, it is best if you <a
      href="http://sdg.lcs.mit.edu/~mernst/daikon/download/">download</a>
      a newer version to see whether your problem has already been corrected.
  <li>a description of exactly what you did and exactly what went wrong.
      For instance, a transcript of your commands and the system's output
      may provide this information.
  <li>input files that permit the problem to be replicated.  For instance,
      this might include your source files (both original and
      instrumented), <tt>.decl</tt> files, and <tt>.dtrace</tt> files.  It
      is often more difficult to reproduce an error than to correct it, so
      please do not force me to spend a lot of time verifying the problem.
      Also, if I can't reproduce the problem, then I will probably be
      unable to fix it.
  <li>any other information that you consider relevant
</ul><p>

<h2><a name="known-bugs">Known bugs</a></h2>

The following problems are already known and are being corrected.  (You may
report them again, to encourage me to release the fix faster, if you like.)
<ul>
  <li>Java front end:
    <ul>
      <li>Inner classes:  Daikon inserts static members; this is not legal
	  in inner classes.  The members should be non-static or should be
	  inserted into the parent class.
      <li>Invalid modbits:  The front end sometimes produces invalid
          modbits.  This can be solved by postprocessing the data trace
          files using the <tt>modbit-munge.pl</tt> program.
      <li>Floating-point values are often ignored; the infrastructure is
          there, but I haven't gotten around to writing code to test for
          specific invariants.
    </ul>
  <li>C front end:  The C front end is not very robust, and is not being
      currently maintained.  See the <a href="#c-front-end">warning</a>
      about using it.
  <li>Lisp front end:  The Lisp front end achieves only partial coverage of
      the Lisp programming language.
</ul><p>


Dynamic invariant detection is further described in several papers, including:
<ul>
  <li><a href="http://sdg.lcs.mit.edu/~mernst/pubs/invariants-tse-abstract.html">Dynamically
      Discovering Likely Program Invariants to Support Program
      Evolution</a> (IEEE TSE, to appear)
  <li><a href="http://sdg.lcs.mit.edu/~mernst/pubs/invariants-icse2000-abstract.html">Quickly Detecting Relevant Program Invariants</a> (ICSE 2000)
  <li><a href="http://sdg.lcs.mit.edu/~mernst/pubs/invariants-pointers-abstract.html">Dynamically
  Discovering Pointer-Based Program Invariants</a> (technical report)
</ul>



<hr>

<a href="http://sdg.lcs.mit.edu/~mernst/daikon/">Daikon homepage</a><p>

<address>
<a href="http://sdg.lcs.mit.edu/~mernst/">Michael Ernst</a>
<a href="mailto:mernst@lcs.mit.edu">&lt;mernst@lcs.mit.edu&gt;</a>
</address>

</body>
</html>
