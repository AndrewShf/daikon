<html>
<head>
<TITLE>Daikon invariant detector</TITLE>
</head>
<body>

<h1>Daikon invariant detector</h1>


The Daikon invariant detector reports properties that are likely to hold at
certain points in a program.  The reported properties are the kind of
arithmetic equations that you might write in an assert statement or a
formal specification, such as "x > abs(y)" or "x = 3*y + 4*z - 7" or "x = 0
(mod 4)".  These invariants can be useful in program understanding and a
host of other applications.  Daikon operates by running the program and
examining the values it computes, looking for patterns and relationships
among those values.  <a href="#front-ends">Front ends</a> exist for <a
href="#c-front-end">C/C++</a>, <a href="#lisp-front-end">Lisp</a>, and <a
href="#java-front-end">Java</a>.<p>

Table of contents:
<ul>
  <li><a href="#install">Installing Daikon</a>
  <li><a href="#run">Using Daikon to detect invariants</a>
    <ul>
      <li><a href="#instrument">Step 1:  Instrumentation</a>
        <ul>
	  <li><a href="#c-front-end">C/C++ front end</a>
	  <li><a href="#lisp-front-end">Lisp front end</a>
	  <li><a href="#java-front-end">Java front end</a>
        </ul>
      <li><a href="#run-program">Step 2:  Run the program</a>
        <ul>
	  <li><a href="#run-program-examples">Examples</a>
        </ul>
      <li><a href="#run-daikon">Step 3:  Detect invariants in the data trace files</a>
        <ul>
	  <li><a href="#interpret-output">Interpreting the output</a>
        </ul>
    </ul>
  <li><a href="#manifest">Manifest (list of files in the distribution)</a>
  <li><a href="#license">License</a>
  <li><a href="#help">Getting more help</a>
</ul>



<h2><a name="install">Installing Daikon</a></h2>

<ol>
  <li>Download the <tt><a href="http://www.cs.washington.edu/homes/mernst/daikon/download/daikon.tar.gz">daikon.tar.gz</a></tt> file.
  <li>In the directory where you want to install Daikon, unpack the tarfile:
<pre>
       tar zxvf daikon.tar.gz
</pre>
     This creates a <tt>daikon/</tt> subdirectory.
  <li>Set the environment variable <tt>DAIKON_HOME</tt> to point the directory.<p>
     In csh:
<pre>
       setenv DAIKON_HOME <i>/directory/goes/here</i>
</pre>
     In sh:
<pre>
       DAIKON_HOME=<i>/directory/goes/here</i>
       export DAIKON_HOME
</pre>
  <li>Adjust the path to Perl in the first line of the
      <tt>instrumentor</tt> script.
  <li>If you want to detect invariants in C code, download the appropriate
      version of the Daikon C front end (from the same place that you obtained
      Daikon itself:  <a
      href="http://www.cs.washington.edu/homes/mernst/daikon/download/">http://www.cs.washington.edu/homes/mernst/daikon/download/</a>)
      and rename it to <tt>edgcpfe</tt> in a directory on
      your path.  (You will not run the <tt>edgcpfe</tt> program directly,
      but only via the <tt>instrumentor</tt> script.)
      The Lisp and Java front ends, and supporting files for
      the C front end, are distributed with Daikon itself.
  <li>If you don't already have the Python programming language installed,
      download it from <a
      href="http://www.python.org/">http://www.python.org</a>.  If you
      intend to use 
      compressed data files, you will need Python 1.5.2 or later.
      There is a second implementation of Python, called JPython, which you
      can consider using instead; see <a
      href="http://www.jpython.org/">http://www.jpython.org/</a>.
</ol>


<h2><a name="run">Using Daikon to detect invariants</a></h2>


Detecting invariants involves three steps:
<ol>
  <li><a href="#instrument">Instrument the program</a> to add instructions that output variable values.
  <li><a href="#run-program">Run the program</a> (probably using a test suite) to create data trace files.
  <li><a href="#run-daikon">Run the Daikon invariant engine</a> over the data trace files to detect invariants.
</ol>


<h3><a name="front-ends"><a name="instrument">Step 1:  Instrumentation</a></a></h3>


There are three different front ends -- for C, Java, and Lisp.  Each of
these front ends modifies your program so that, in addition to performing
its original task, it also writes variable values to a data trace file.
<ul>
  <li><a href="#c-front-end">C/C++ front end</a>
  <li><a href="#java-front-end">Java front end</a>
  <li><a href="#lisp-front-end">Lisp front end</a>
</ul>


<h4><a name="c-front-end">C/C++ front end</a></h4>

<ol>
  <li>Run the instrumentor on your C source files (but not on .h header files):
<pre>
      instrumentor <i>filename1.c</i> <i>filename2.c</i> ...
</pre>
    The instrumentor:
    <ol>
      <li>copies your original files to <tt><i>filename1.c</i>.uninst</tt>, etc.
      <li>overwrites the original files with instrumented versions
      <li>creates declaration files named <tt><i>filename1.c</i>.decls</tt>, etc.
    </ol>
    You may wish to perform this operation with a copy of your program,
    to safeguard your original source code.
 <li>Copy files <tt>dump_trace.c</tt> and <tt>dump_trace.h</tt> to your
     directory.
 <li>Create or modify a <tt>Makefile</tt>.  Either:
   <ul>
     <li>If you have no <tt>Makefile</tt>, copy <tt>Makefile-sample</tt>
         to <tt>Makefile</tt> and add the names of your source files to its
         <tt>OBJS</tt>, and edit its <tt>EXEC</tt> executable name.
     <li>If you have a </tt>Makefile</tt>, add <tt>dump_trace.o</tt> to the
         list of object files that need to be created (and linked to create
         your executable).
   </ul>
 <li>Copy the appropriate files to your directory, including
    <tt>dump_trace.c</tt> and <tt>dump_trace.h</tt>.
 <li>Create an instrumented executable by building your program in the
     usual way (perhaps by running <tt>make</tt>).
</ol>


<h4><a name="lisp-front-end">Lisp front end</a></h4>

<ol>
  <li>Load all the support code.
<pre>
  (load "load-all")
</pre>
  <li>Add instrumentation code to the beginning and end  of each
      function, and to each loop head.  The instrumentation writes the
      values of all the live variables to a file. 
<pre>
  (instrument-file "gries.lisp" "gries-instrumented.lisp")
</pre>
</ol>

  For efficiency, you might want to compile the Lisp files and run the
  compiled versions; do the following after <tt>(load "load-all")</tt>:
<pre>
    (compile-all)	;; only needs to be done once (ever)
    (load-all)		;; only needs to be done explicitly after compiling
</pre>


<h4><a name="java-front-end">Java front end</a></h4>

*****
All this is obsolete.
*****
<pre>
  For legal reasons, the Java front end cannot be distributed at this time
  (early June, 1999), because it uses a commercially-developed library for
  bytecode manipulation.  Legal papers are in process to make that library
  distributable; I am promised they will be ready "very soon".  You can:
   * wait for me to get permission to distribute the library,
   * instrument Java source code by hand, using some helper routines that I
     can provide, or
   * provide me with sources and let me try out your code.

  The steps of instrumentation and running the program are integrated.  In
  the command that runs your program, simply replace "java" by "java Xform
  -x DaikonTransformer", and the program will run as usual but also write
  declaration and data trace files to a subdirectory named "daikon-output/".
</pre>

<h3><a name="run-program">Step 2:  Run the program</a></h3>

You can run the instrumented program in just the same way you did before;
the only behavioral change will be writing a <tt>.dtrace</tt> file.
Run the program over some test suite in order to create a collection of
data trace files.<p>

<h4><a name="run-program-examples">Examples</a></h4>

For C programs, if you do not supply a file <tt>label.txt</tt> which
contains a single integer (a sample is provided in the distribution), one
will be created for you.  This determines the name of the data trace
file.<p>

In Lisp, here is how you would run the Gries example programs, after having
done <tt>(load "load-all")</tt>:
<pre>
  ;; Load the instrumented code.
  (load "gries-instrumented")
  ;; Run the instrumented code.  This runs all the test-* functions; 
  ;; each test-* function creates one *.dtrace file
  (test-all)
</pre>


<h3><a name="run-daikon">Step 3:  Detect invariants in the data trace files</a></h3>

Run the Python interpreter using the shell command <tt>python</tt> or the
Emacs command <tt>M-x run-python</tt>.  It is convenient to run Python in
the directory containing <tt>daikon.py</tt> and the other Python source
files, so that you don't have to set the <tt>PYTHONPATH</tt> environment
variable.  You can download Python from <a
href="http://www.python.org/">http://www.python.org/</a>.<p>

In Python, issue the following commands:
<pre>
  import daikon 			  # load the daikon.py file
  daikon.read_declarations('*.decls',1)   # read the function declarations
  daikon.read_data_traces('p*.dtrace')    # read the trace files
  daikon.all_numeric_invariants()	  # compute and print invariants
</pre>

The three functions above each take an optional regular expression for
program point, so that only certain program points are processed.  (This
can make the invariant detection engine run faster.)  For details, see
the documentation strings in their definitions in <tt>daikon.py</tt>.<p>

To do all this from a single shell command, do the following:
<pre>
  python -O -c "__debug__ = 0; import daikon; \
    daikon.read_declarations('*.decls',1); \
    daikon.read_data_traces('p*.dtrace'); \
    daikon.all_numeric_invariants()"
</pre>

<h4><a name="interpret-output">Interpreting the output</a></h4>

In the output, the "_orig" suffix refers to the original value of a formal
parameter, for parameters possibly modified in the function body.
":::BEGIN", ":::END", and ":::LOOP" are tags identifying at which program
the instrumentation was inserted; invariants are program-point-specific.
There is some redundancy in the output (e.g., both "Z = max(Y, X)" and
"Z = max(X, Y)" are reported, as are both "Y > X" and "X < Y").


<h2><a name="manifest">Manifest (list of files in the distribution)</a></h2>

<pre>
User documentation
  daikon.html		This file
  README		Says to see daikon.html instead

C front end (you will also need the edgcpfe executable; see "Installation")
  dump_trace.c		Writing data values to a data trace
  dump_trace.h		Header files for the above
  Makefile-sample	Sample Makefile for linking in the above
  instrumentor		Script for running instrumenter on multiple C files
  label.txt		Auxiliary file for output filename selection at runtime

Lisp front end
  load-all.lisp		Shell for loading other Lisp files
  instrument.lisp	Instrumenting Lisp programs to write data traces
  data-trace.lisp	Writing data values to a data trace

Lisp example files
  gries.lisp		Programs from Gries's "The Science of Programming"
  gries-helper.lisp	Support for Gries-style synax and for testing
  gries-instrumented.lisp	Instrumented version of gries.lisp
  inv-medic.lisp	Support for finding invariants in the Medic program

Invariant detection engine
  daikon.py		The invariant detector itself
  util.py		Utility functions used by the invariant detector
  daikon.py.doc		Internal documentation on data structures and design

Miscellaneous files
  Makefile		Makefile for the invariant detection system
  VERSION		Timestamp of this distribution
</pre>


<h2><a name="license">License</a></h2>

Daikon is made available for education, research, and evaluation purposes
(not for direct commercial gain), and there is no warranty.  All rights are
reserved, and copyright is held by the authors.  If you have difficulties
with the software, let us know and we will try to correct the problem, but
we cannot make any guarantees of support, or any other guarantees regarding
the software.  As a condition of use, you agree to promptly communicate any
changes, improvements, or enhancements to the authors for inclusion in a
future release under these same conditions.  If you do not agree to this
license, please do not use or examine the software.<p>

If you use Daikon, please <a href="mailto:mernst@cs.washington.edu">send
email to Michael Ernst &lt;mernst@cs.washington.edu&gt;</a>, so that you
can be informed of new versions, enhancements, and bug fixes.  I would also
appreciate a brief description of how you are using Daikon, because I am
curious about how users exploit it (and am eager for anecdotes about its
successes and failures), and I want to make it more effective for its
users.<p>


<h2><a name="help">Getting more help</a></h2>

If you have any questions, can suggest ways to improve the documentation,
find bugs in the system, or have suggestions for its improvement, please
<a href="mailto:mernst@cs.washington.edu">send email to Michael Ernst
&lt;mernst@cs.washington.edu&gt;</a>.  While Daikon is a research prototype
and not rock-solid, I will do my best to assist you and to correct any
problems, so please don't hesitate to ask for help or report difficulties.
And don't let any shortcomings of this implementation dissuade you about
the promise of the research!<p>

The invariant detector is further described in the paper <a
href="http://www.cs.washington.edu/homes/mernst/pubs/invariants-icse99-abstract.html">``Dynamically
Discovering Likely Program Invariants to Support Program Evolution''</a> by
Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin, in
Proceedings of the 19th International Conference on Software Engineering
(ICSE '99), Los Angeles, CA, May 19-21, 1999.<p>

<address>
Michael Ernst 
<a href="mailto:mernst@cs.washington.edu">&lt;mernst@cs.washington.edu&gt</a>
</address>

</body>
</html>
