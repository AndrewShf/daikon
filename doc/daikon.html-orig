<html>
<head>
<TITLE>Daikon invariant detector</TITLE>
</head>
<body>

<h1>Daikon invariant detector</h1>


The Daikon invariant detector reports properties that are likely to hold at
certain points in a program.  The reported properties are arithmetic
equations such as you might write in an assert statement or a formal
specification; for example, "x > abs(y)" or "x = 3*y + 4*z - 7" or "x = 0
(mod 4)".  These invariants can be useful in program understanding and a
host of other applications.  Daikon operates by running the program and
examining the values it computes, looking for patterns and relationships
among those values.  <a href="#front-ends">Front ends</a> exist for <a
href="#java-front-end">Java</a>, <a href="#c-front-end">C/C++</a>, and <a
href="#lisp-front-end">Lisp</a>; of these, the Java front end is the most
robust, complete, and featureful, and is the most actively supported.<p>

Table of contents:
<ul>
  <li><a href="#install">Installing Daikon</a>
  <li><a href="#run">Using Daikon to detect invariants</a>
    <ul>
      <li><a href="#instrument">Step 1:  Instrumentation</a>
        <ul>
	  <li><a href="#java-front-end">Java front end</a>
	  <li><a href="#c-front-end">C/C++ front end</a>
	  <li><a href="#lisp-front-end">Lisp front end</a>
        </ul>
      <li><a href="#run-program">Step 2:  Run the program</a>
      <li><a href="#run-daikon">Step 3:  Detect invariants in the data trace files</a>
        <ul>
	  <li><a href="#interpret-output">Interpreting the output</a>
        </ul>
    </ul>
  <li><a href="#manifest">Manifest (list of files in the distribution)</a>
  <li><a href="#license">License</a>
  <li><a href="#help">Getting more help</a>
</ul>



<h2><a name="install">Installing Daikon</a></h2>

<ol>
  <li>Download the <tt><a href="http://www.cs.washington.edu/homes/mernst/daikon/download/daikon.tar.gz">daikon.tar.gz</a></tt>
      file from
      <a href="http://www.cs.washington.edu/homes/mernst/daikon/download/">http://www.cs.washington.edu/homes/mernst/daikon/download/</a>.
  <li>In the directory where you want to install Daikon, unpack the tarfile:
<pre>
       tar zxvf daikon.tar.gz
</pre>
     This creates a <tt>daikon/</tt> subdirectory.
<!--
  <li>Set the environment variable <tt>DAIKON_HOME</tt> to point the directory.<p>
     In csh:
<pre>
       setenv DAIKON_HOME <i>/directory/goes/here</i>
</pre>
     In sh:
<pre>
       DAIKON_HOME=<i>/directory/goes/here</i>
       export DAIKON_HOME
</pre>
-->
  <li>Prepare the front ends for use, if you plan to detect invariants in
      programs written in those source languages:
    <ul>
      <li>Java front end:  Build the <tt>dfej</tt> Java instrumenter.  In
          the <tt>jikes-front-end/src</tt> directory, do:
        <ol>
          <li><tt>./configure --enable-symbols</tt>
	  <li><tt>make</tt>
        </ol>
        You must supply the --enable-symbol argument to configure.
      <li>C front end:
        <ol>
	  <li>Download a binary version of the Daikon C front end from the
	      same place that you obtained Daikon itself:  <a
	      href="http://www.cs.washington.edu/homes/mernst/daikon/download/">http://www.cs.washington.edu/homes/mernst/daikon/download/</a>.
	      Due to licensing restrictions, we are unable to distribute
	      source for this program.  Rename the downloaded file to
	      <tt>edgcpfe</tt> in a directory on your path.  (You will not
	      run the <tt>edgcpfe</tt> program directly,
	      but only via the <tt>dfec</tt> script.)
	      The Lisp and Java front ends, and supporting files for
	      the C front end, are distributed with Daikon itself.
	  <li>Optionally set the path to Perl in the first line of the
	      <tt>dfec</tt> script.  This is not necessary, but
	      will make the script start up faster.
        </ol>
      <li>Lisp front end:  no special work to be done.
    </ul>
  <li>If you don't already have the Python programming language installed,
      download it from <a
      href="http://www.python.org/">http://www.python.org</a>.  If you
      intend to use 
      compressed data trace files, you will need Python 1.5.2 or later.
      There is a second implementation of Python, called JPython, which you
      can consider using instead; see <a
      href="http://www.jpython.org/">http://www.jpython.org/</a>.
</ol>


<h2><a name="run">Using Daikon to detect invariants</a></h2>


Detecting invariants involves three steps:
<ol>
  <li><a href="#instrument">Instrument the program</a> to add instructions that output variable values.
  <li><a href="#run-program">Run the program</a> (probably using a test suite) to create data trace files.
  <li><a href="#run-daikon">Run the Daikon invariant engine</a> over the data trace files to detect invariants.
</ol>


<h3><a name="front-ends"><a name="instrument">Step 1:  Instrumentation</a></a></h3>


There are three different front ends -- for C, Java, and Lisp.  Each of
these front ends modifies your program so that, in addition to performing
its original task, it also writes variable values to a data trace file.
<ul>
  <li><a href="#java-front-end">Java front end</a>
  <li><a href="#c-front-end">C/C++ front end</a>
  <li><a href="#lisp-front-end">Lisp front end</a>
</ul>


<h4><a name="java-front-end">Java front end</a></h4>

<ol>
  <li>Run <tt>dfej</tt>, the Daikon front end for Java, on your Java source
      files:
<pre>
      dfej <i>filename1.java</i> <i>filename2.java</i> ...
</pre>
      The Daikon Java front end:
      <ol>
        <li>writes instrumented versions of the files
            to a <tt>daikon-java/</tt> directory
	<li>creates declaration files named
            <tt><i>filename1.java</i>.decls</tt>, etc. in a
            <tt>daikon-output/</tt> directory.
      </ol>
      Only the specified Java files will be instrumented; other files will
      be run uninstrumented.  This permits you to control the scope of
      invariant detection.<p>

      In any of the specified files, all classes defined in any of those
      files will be instrumented.  For instance, after
<pre>
      dfej Foo.java Bar.java
</pre>
      the instrumented versions of Foo.java and Bar.java will output
      information about all Foo objects (including Foo objects that are
      components of Bar objects, that are arguments to Bar functions,
      etc.), and likewise for Bar objects.
      After
<pre>
      dfej Foo.java
      dfej Bar.java
</pre>
      the same functions (all those in the Foo and Bar classes) will be
      instrumented, but in Foo functions, no detail will be provided about
      the structure of any Bar objects that might appear.  In other words,
      the instrumenter assumes that the only classes instrumented (and
      about which information is desired) are those presented to it on the
      command line.  One way to determine all the .java files that are
      included in a specified program is to run the following commands:
<pre>
      find . -name '*.class' -print | xargs rm -f
      javac MyProgram.java
      find . -name '*.class' -print
</pre>
      <p>

      See the <tt>dfej</tt> usage message for more information.<p>
</ol>

<h4><a name="c-front-end">C/C++ front end</a></h4>

<b>Warning:</b> While the C front end works correctly on a number of
programs, it is known to fail on some legal C programs.  The C front end
may issue errors when it is run (and refuse to produce an instrumented
program), may produce an instrumented program that fails to compile
(because the instrumented program contains C errors), or may produce an
instrumented program that core-dumps when it is run.  Problems are more
likely with C++ programs than with C programs.  We will attempt to fix
problems that are reported to us, but can make no promises, because our
current focus is on the <a href="#java-front-end">Java front end</a>.<p>

<ol>
  <li>Run <tt>dfec</tt> on your C source files (but not on .h header files):
<pre>
      dfec <i>filename1.c</i> <i>filename2.c</i> ...
</pre>
     <tt>dfec</tt> is written in Perl.  If Perl is not available, you may
     instead use <tt>dfec.sh</tt>, which is written in sh shell script.<p>

     The Daikon C/C++ front end:
     <ol>
       <li>copies your original files to <tt><i>filename1.c</i>.uninst</tt>,
	   etc.<br>
       <li>overwrites the original files with instrumented versions
       <li>creates declaration files named <tt><i>filename1.c</i>.decls</tt>, etc.
     </ol>
     You may wish to perform this operation with a copy of your program,
     to safeguard your original source code.<p>

     If you supply the </tt>-d <i>directory</i></tt> argument (before
     the file names), then the instrumented source files are placed in the
     specified directory instead (and no backup files need be made).
 <li>Copy files <tt>dump_trace.c</tt> and <tt>dump_trace.h</tt> to the
     directory with the instrumented source files.
 <li>Create or modify a <tt>Makefile</tt>.  Either:
   <ul>
     <li>If you have no <tt>Makefile</tt>, copy <tt>Makefile-sample</tt>
         to <tt>Makefile</tt> and add the names of your source files to its
         <tt>OBJS</tt>, and edit its <tt>EXEC</tt> executable name.
     <li>If you have a </tt>Makefile</tt>, add <tt>dump_trace.o</tt> to the
         list of object files that need to be created (and linked to create
         your executable).
   </ul>
 <li>Create an instrumented executable by building your program in the
     usual way (perhaps by running <tt>make</tt> or <tt>cc</tt> or <tt>gcc</tt>).
</ol>


<h4><a name="lisp-front-end">Lisp front end</a></h4>

<ol>
  <li>Load all the support code.
<pre>
  (load "load-all")
</pre>
  <li>Add instrumentation code to the beginning and end  of each
      function, and to each loop head.  The instrumentation writes the
      values of all the live variables to a file. 
<pre>
  (instrument-file "gries.lisp" "gries-instrumented.lisp")
</pre>
</ol>

  For efficiency, you might want to compile the Lisp files and run the
  compiled versions; do the following after <tt>(load "load-all")</tt>:
<pre>
    (compile-all)	;; only needs to be done once (ever)
    (load-all)		;; only needs to be done explicitly after compiling
</pre>


<h3><a name="run-program">Step 2:  Run the program</a></h3>

Run the program over some test suite in order to create a
collection of data trace files.
You can run the instrumented program in just the same way you did before;
the only behavioral change will be writing a <tt>.dtrace</tt> file to the
<tt>daikon-output/</tt> subdirectory (which is created if it does not
already exist).<p>


<ul>
  <li>For Java programs, make sure the <tt>daikon-java/</tt> directory
      appears on your CLASSPATH before the directory containing the
      original Java code.
  <li>For C/C++ programs, if you do not supply a file <tt>label.txt</tt> which
      contains a single integer (a sample is provided in the distribution), one
      will be created for you.  This determines the name of the data trace
      file.<p>
  <li>In Lisp, here is how you would run the Gries example programs, after
      having done <tt>(load "load-all")</tt>:
<pre>
    ;; Load the instrumented code.
    (load "gries-instrumented")
    ;; Run the instrumented code.  This runs all the test-* functions; 
    ;; each test-* function creates one *.dtrace file
    (test-all)
</pre>
</ul>


<h3><a name="run-daikon">Step 3:  Detect invariants in the data trace files</a></h3>

Run the Python interpreter using the shell command <tt>python</tt> or the
Emacs command <tt>M-x py-shell</tt>.  (In order to run <tt>M-x
py-shell</tt>, you will need a copy of the <a
href="http://www.python.org/emacs/python-mode/">Python Mode for Emacs</a>.)
It is convenient to run Python in the directory containing
<tt>daikon.py</tt> and the other Python source files, so that you don't
have to set the <tt>PYTHONPATH</tt> environment variable.<p>

In Python, issue the following commands:
<pre>
  import daikon 			  # load the daikon.py file
  daikon.read_declarations('<i>filename.decls</i>',1)   # read the function declarations
  daikon.read_data_traces('<i>filename.dtrace</i>')    # read the trace files
  daikon.all_numeric_invariants()	  # compute and print invariants
</pre>
The <tt><i>filename</i></tt> arguments may also be shell wildcards, such as
"<tt>p*.dtrace</tt>", in order to read multiple files.  The three functions
above each take an optional regular expression for program point, so that
only certain program points are processed.  (This can make the invariant
detection engine run faster.)  For details, see the documentation strings
in the function definitions in <tt>daikon.py</tt>.<p>

To do all this from a single shell command, do the following:
<pre>
  python -O -c "__debug__ = 0; import daikon; \
    daikon.read_declarations('<i>filename.decls</i>',1); \
    daikon.read_data_traces('<i>filename.dtrace</i>'); \
    daikon.all_numeric_invariants()"
</pre>

<h4><a name="interpret-output">Interpreting the output</a></h4>

In the output, the "_orig" suffix refers to the original value of a formal
parameter, for parameters possibly modified in the function body.
Negative array indices count from the end of the array; for instance, index
"-1" denotes the last element of the array.<p>

":::ENTER", ":::EXIT", and ":::LOOP" are tags identifying at which program
point the instrumentation was inserted; these invariants are
program-point-specific.  ":::CLASS" and ":::CLASS-STATIC" indicate class
invariants (sometimes called object invariants) which always hold for any
object of the given class, from the point of view of a client or user.
These properties hold at entry to and exit from every public method of the
class.<p>


<h2><a name="manifest">Manifest (list of files in the distribution)</a></h2>

<pre>
User documentation
  daikon.html		This file
  README		Says to see daikon.html instead

Java front end
  java-front-end/	A modified version of the <a href="http://www.ibm.com/research/jikes">Jikes Java compiler</a>
                          The main executable is dfej (Daikon front end for Java)

C front end
  c-front-end/
    dump_trace.c	Writing data values to a data trace
    dump_trace.h	Header files for the above
    Makefile-sample	Sample Makefile for linking in the above
    dfec		Script for instrumenting C files (you will also
                          need the edgcpfe executable; see "<a
                          href="#install">Installing Daikon</a>")
    dfec.sh		Version of dfec written in shell script, not Perl
    label.txt		Auxiliary file for output filename selection at runtime

Lisp front end and example files
  lisp-front-end/
    load-all.lisp	Shell for loading other Lisp files
    instrument.lisp	Instrumenting Lisp programs to write data traces
    data-trace.lisp	Writing data values to a data trace
    gries.lisp		Programs from Gries's "The Science of Programming"
    gries-helper.lisp	Support for Gries-style syntax and for testing
    gries-instrumented.lisp	Instrumented version of gries.lisp
    inv-medic.lisp	Support for finding invariants in the Medic program

Invariant detection engine
  daikon.py		The invariant detector itself
  util.py		Utility functions used by the invariant detector
  daikon.py.doc		Internal documentation on data structures and design

Miscellaneous files
  Makefile		Makefile for the invariant detection system
  VERSION		Timestamp of this distribution
</pre>


<h2><a name="license">License</a></h2>

Daikon is made available for education, research, and evaluation purposes
(not for direct commercial gain), and there is no warranty.  All rights are
reserved, and copyright is held by the authors.  If you have difficulties
with the software, let us know and we will try to correct the problem, but
we cannot make any guarantees of support, or any other guarantees regarding
the software.  As a condition of use, you agree to promptly communicate any
changes, improvements, or enhancements to the authors for inclusion in a
future release under these same conditions.  If you do not agree to this
license, please do not use or examine the software.<p>

If you use Daikon, please <a href="mailto:mernst@cs.washington.edu">send
email to Michael Ernst &lt;mernst@cs.washington.edu&gt;</a>, so that you
can be informed of new versions, enhancements, and bug fixes.  I would also
appreciate a brief description of how you are using Daikon, because I am
curious about how users exploit it (and am eager for anecdotes about its
successes and failures), and I want to make it more effective for its
users.<p>


<h2><a name="help">Getting more help</a></h2>

If you have any questions, can suggest ways to improve the documentation,
find bugs in the system, or have suggestions for its improvement, please
<a href="mailto:mernst@cs.washington.edu">send email to Michael Ernst
&lt;mernst@cs.washington.edu&gt;</a>.  While Daikon is a research prototype
and not rock-solid, I will do my best to assist you and to correct any
problems, so please don't hesitate to ask for help or report difficulties.
And don't let any shortcomings of this implementation dissuade you about
the promise of the research!<p>

Your bug report will be most helpful if you include:
<ul>
  <li>the contents of the VERSION file, which indicates the release date of
      your copy of Daikon
  <li>a description of exactly what you did and exactly what went wrong.
      For instance, a transcript of your commands and the system's output
      may provide this information.
  <li>input files that permit the problem to be replicated.  For instance,
      this might include your source files (both original and
      instrumented), .decl files, and .dtrace files.  It is often more
      difficult to reproduce an error than to correct it, so please don't
      make me spend a lot of time verifying the problem.  Also, if I can't
      reproduce the problem, then I will probably be unable to fix it.
  <li>any other information that you consider relevant
</ul><p>

The invariant detector is further described in the paper <a
href="http://www.cs.washington.edu/homes/mernst/pubs/invariants-icse99-abstract.html">``Dynamically
Discovering Likely Program Invariants to Support Program Evolution''</a> by
Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin, in
Proceedings of the 19th International Conference on Software Engineering
(ICSE '99), Los Angeles, CA, May 19-21, 1999.<p>

<address>
<a href="http://www.cs.washington.edu/homes/mernst/">Michael Ernst</a>
<a href="mailto:mernst@cs.washington.edu">&lt;mernst@cs.washington.edu&gt</a>
</address>

</body>
</html>
