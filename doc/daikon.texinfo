\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename daikon.info
@settitle The Daikon Invariant Detector User Manual
@c %**end of header

@c To update all the nodes and menus all at once:   C-u C-c C-u m
@c You shouldn't need to do that, though; the Makefile does it for you.

@c I can't get this to work, don't know why.  MDE 4/2001.
@c @alias directory = file

@c texi2html doesn't work if I use this macro
@c @macro daikonurl{}
@c http://pag.lcs.mit.edu/daikon/
@c @end macro

@c Problem: with texinfo 4.0, the HTML formatting leaves the "{}" after
@c uses of the macro.  (Formatting seems fine for info, for printing, etc.)
@c So for now, I have inlined all instances of the macro.  Yuck.
@c Another solution would be to use "makeinfo -E" (then process the
@c resulting file with "makeinfo --html").
@macro daikonemail{}
@email{daikon@@pag.lcs.mit.edu}
@end macro

@c @setchapternewpage odd

@c @ifinfo
@c This is a short example of a complete Texinfo file.
@c 
@c Copyright 1990 Free Software Foundation, Inc.
@c @end ifinfo

@c avoid black boxes marking overfull hboxes in TeX output
@finalout

@titlepage
@sp 10
@c Could also use @title, @subtitle, @author here.
@center @titlefont{Daikon Invariant Detector User Manual}

@sp 2
@center Daikon version 2.3.8

@sp 1
@c Daikon version 2.3.8 date
@center May 11, 2002

@sp 5
@c reads daikon.eps, daikon.pdf, daikon.txt, daikon.png, or daikon.jpg
@image{images/daikon-logo,4in,}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998-2002
@c Copyright @copyright{} 1998-2001 Michael Ernst
@end titlepage

@html
<img src="images/daikon-logo.gif" alt="Daikon logo">

<h1>Daikon Invariant Detector User Manual</h1>

This is the user manual for the Daikon invariant detector.
It describes Daikon version 2.3.8, released May 11, 2002.

@end html

@c Putting this lower in the HTML version looks a little bit strange,
@c but it's acceptable. 
@ifnothtml
@contents
@end ifnothtml

@node    Top, Introduction, (dir), (dir)
@comment node-name, next,          previous, up

@ifnottex
This is the user manual for the Daikon invariant detector.
It describes Daikon version 2.3.8, released May 11, 2002.
@end ifnottex

@menu
* Introduction::                
* Installing::                  
* Example use::                 
* Detecting invariants::        
* Daikon output::               
* GUIs::                        
* Front ends::                  
* Enhancing Daikon output::     
* Tools::                       
* Extending Daikon::            
* Troubleshooting::             
* Details::                     
* File formats::                
* Index::

@ifhtml
@contents
@end ifhtml
@ifnothtml

@detailmenu
 --- The Detailed Node Listing ---

Installing Daikon

* Installing dfej::             
* Installing dfec::             
* Installing the Context GUI::  
* Requirements::                

Installing dfec, the Daikon front end for C/C++

* dfec EDG sources::            

Requirements for running Daikon

* Windows requirements::        

Example use of Daikon

* Step-by-step instructions::   
* Summary::                     
* Automating the process::      
* Understanding the invariants::  
* Second Java example::         
* C examples::                  

C examples

* C examples summary::          
* Rijndael example::            

Using Daikon to detect invariants

* Instrumentation::             
* Run the instrumented program::  
* Detect invariants::           
* All-in-one script::           

Instrumentation

* Instrumenting Java programs::  
* Instrumenting C/C++ programs::  

Run the instrumented program

* Run Java::                    

Details on running instrumented Java programs

* Java applets::                

Detect invariants in the data trace files

* Command line options::        

All-in-one script daikon.pl

* daikon.pl arguments::         

Daikon output

* Interpreting output::         
* Printing invariants::         
* Invariant Diff::              

Interpreting Daikon output

* Program points::              
* Variable names::              
* Invariant syntax::            

GUIs for displaying invariants

* Tree GUI::                    
* Context GUI::                 

Tree-structured invariant browser

* Invoking Tree GUI::           
* Invariants Display::          
* Control panel::               

Control panel

* Property filters::            
* Variable filters::            

Context GUI

* Context GUI with Emacs::      
* Context GUI project root directory::  
* .dci files::                  

Front ends

* Java front end dfej::         
* C/C++ front end dfec::        

Java front end dfej

* dfej options::                
* Scope of instrumentation::    
* Refined runtime types::       

C/C++ front end dfec

* dfec command-line arguments::  
* Pointer type disambiguation::  
* Uninitialized array elements::  
* dfec requirements::           

Pointer type disambiguation

* Pointer type disambiguation example::  

dfec requirements

* Requirements for instrumented programs::  
* gcc version::                 

Enhancing Daikon output

* Configuration options::       
* Conditional invariants::      

Configuration options

* List of configuration options::  

Conditional invariants and implications

* Splitter info file::          
* Indiscriminate splitting::    
* Example splitter info file::  

Splitter info file

* Program point sections::      
* Replacement sections::        

Example splitter info file

* Example class::               
* Resulting .spinfo file::      

Tools

* MergeESC::                    

Extending Daikon

* Compiling Daikon::            
* New invariants::              
* New derived variables::       
* New formatting for invariants::  
* New front ends::              

Troubleshooting

* Installation problems::       
* dfej problems::               
* dfec problems::               
* Daikon problems::             
* Other problems::              
* Reporting bugs::              
* Known bugs::                  
* Further reading::             

Problems with dfej

* dfej compilation problems::   
* dfej invocation problems::    

Problems running dfej

* Ajax errors::                 

Problems running Daikon

* No return from procedure::    
* Out of memory::               
* Simplify errors::             
* Method needs to be implemented::  

Other problems

* Large dtrace files::          
* Tree GUI font errors::        

Reporting bugs

* Known bugs::                  
* Further reading::             

Details

* History::                     
* License::                     
* Credits::                     

File formats

* Conventions::                 
* Declaration files::           
* Data trace files::            
* Examples::                    

Declaration files

* pptname format::              

Examples

* Example declaration file::    
* Example data trace file::     

@end detailmenu
@end ifnothtml
@end menu

@node    Introduction, Installing, Top, Top
@chapter Introduction

The @uref{http://pag.lcs.mit.edu/daikon, ,Daikon invariant detector}
reports likely program invariants.  An invariants is a property that
holds a a certain point or points in a program; these are often seen in
assert statements, documentation, and formal specifications.  Examples
include arithmetic equations such as "x > abs(y)", "x = 3*y + 4*z - 7",
or "x = 0 (mod 4)", and properties over arrays and other collections,
including those accessed via pointers.  Daikon also reports implications
(invariants whose truth depends on some other property), such as "p !=
null => p.content in elementcollection".

Invariants can be useful in program understanding and a host of other
applications.  Daikon operates by running the program and examining the
values it computes, looking for patterns and relationships among those
values.  Front ends (@pxref{Instrumentation}) exist for the Java, C, and
IOA languages; it is easy to extend Daikon to other applications.


@node    Installing, Example use, Introduction, Top
@chapter Installing Daikon
@cindex installing Daikon

In order to install Daikon, perform the following steps.
@xref{Requirements}, for a few additional requirements running Daikon
(in short, you must be able to run Java programs, because Daikon is
written in Java).  Differences between various versions of Daikon appear
in the file @file{doc/CHANGES} in the distribution.

@enumerate
@item
Download Daikon from
from @uref{http://pag.lcs.mit.edu/daikon/download/}.

@cindex pre-compiled distribution
@cindex source distribution

There are two distributions to choose from.  The pre-compiled
distribution,
@uref{http://pag.lcs.mit.edu/daikon/download/daikon-compiled.tar.gz,,@file{daikon-compiled.tar.gz}},
permits you to run Daikon and to detect invariants, but does not permit
you to modify Daikon or to rebuild it.  The source distribution,
@uref{http://pag.lcs.mit.edu/daikon/download/daikon-source.tar.gz,,@file{daikon-source.tar.gz}},
includes everything from the pre-compiled distribution
plus sources for Daikon and for dfej.

@cindex anonymous CVS access to Daikon sources
Daikon is also available via anonymous CVS.  Send email to
@email{daikon@@pag.lcs.mit.edu} if you desire such access.

@cindex @var{daikonparent} directory
@item
In the directory where you want to install Daikon (we'll call this
the @var{daikonparent} directory), unpack the tarfile; for example:
@example
tar zxvf daikon-source.tar.gz
@end example
@noindent
This creates a @file{@var{daikonparent}/daikon/} subdirectory.

@item
@cindex C shell
@cindex csh shell
@cindex tcsh shell
Set a few environment variables.  If you use the csh or tcsh shell, add the
following to your @file{.cshrc} file:
@example
source @var{daikonparent}/daikon/bin/daikon.cshrc
@end example
@noindent
@cindex Bourne shell
@cindex bash shell
If you use the bash shell, add the following to your
@file{.bash_profile} file:
@example
source @var{daikonparent}/daikon/bin/daikon.bashrc
@end example

Also, you must edit the @file{daikon.cshrc} or @file{daikon.bashrc} file
to indicate the @var{daikonparent} directory and to perform any desired
customizations.  (Alternately, you may place such customizations in your
own @file{.cshrc} or @file{.bash_profile} file.)

Before proceeding, you should execute the @command{source} command you
placed in your shell initialization file, or else log out and log back
in to achieve the same effect.

@item
If you set the environment variable DAIKONCLASS_SOURCES in
@file{daikon.cshrc} or @file{daikon.bashrc}, indicating that you wish to
compile the Daikon sources yourself, then you must now compile them.
@example
cd $DAIKONDIR/java
make
@end example

@c @item
@c Add the Daikon Java files to your Java class path.  There are two
@c different ways to do this; you should choose one or the other.
@c 
@c @itemize @bullet
@c @item
@c The first technique is to run Daikon from the precompiled bytecode files
@c in @file{daikon.jar}.  This is the easiest way to proceed, and it must
@c be used if you downloaded the pre-compiled Daikon distribution.
@c 
@c Add the supplied @file{daikon.jar}
@c file to your classpath.
@c For instance, if your shell is @command{csh}, add the following to your
@c @file{.cshrc} file: 
@c @example
@c setenv CLASSPATH @var{daikonparent}/daikon/daikon.jar:$@{CLASSPATH@}
@c @end example
@c 
@c @item
@c Alternately, you may run run Daikon from @file{.class} files that you
@c compile yourself.  This permits you to modify Daikon (most users will
@c not need to do so), and may be used if you downloaded the source
@c distribution.
@c 
@c Add the @file{@var{daikonparent}/daikon/java/} directory to
@c your classpath.  If your shell is @command{csh}, add the
@c following to your @file{.cshrc} file.
@c @example
@c setenv CLASSPATH @var{daikonparent}/daikon/java:$@{CLASSPATH@}
@c @end example
@c 
@c The distribution includes compiled @file{.class} files, so you do not
@c need to compile them yourself unless you make changes; @xref{Compiling
@c Daikon}.
@c 
@c @end itemize
@c 
@c @item
@c Add the @file{@var{daikonparent}/daikon/bin/} directory to your path.  (Your
@c path is a list of directories in which the shell searches for
@c commands; this permits you to type just the program name rather than
@c supplying a full pathname.)  In csh, add the following to your
@c @file{.cshrc} file:
@c @example
@c set path = (@var{daikonparent}/daikon/bin $path)
@c @end example

@end enumerate

@menu
* Installing dfej::             
* Installing dfec::             
* Installing the Context GUI::  
* Requirements::                
@end menu

@node    Installing dfej, Installing dfec, Installing, Installing
@section Installing dfej, the Daikon front end for Java

@cindex installing dfej
@cindex dfej installation

If you wish to detect invariants in Java programs, perform the following
steps.

@enumerate
@c @item
@c Ensure that @file{rt.jar} is on your Java class path.  For instance, if
@c your shell is @command{csh}, place something like the following in your
@c @file{.cshrc} file:
@c @example
@c setenv CLASSPATH $@{CLASSPATH@}:$HOME/java/jdk/jre/lib/rt.jar
@c @end example
@c (Don't use @samp{~username}; use @samp{$HOME}, as in the example.)

@item
Obtain or build an executable for dfej, the Daikon front end for Java.

@itemize @bullet
@item
The easiest approach is to download a precompiled version of @command{dfej}
from @url{http://pag.lcs.mit.edu/daikon/download/}.  Place that
executable somewhere on your path, and you are ready to run dfej.  (If
no executable is available for your architecture, send mail to
@email{daikon@@pag.lcs.mit.edu} and we may be able to produce an executable for you.)

@item
Alternately, you can build dfej from the sources, which are included in
the Daikon source distribution.  
To build dfej, see file @file{INSTALL} in the dfej sources.  In
summary, you should be able to build dfej by running the following
commands:
@example
cd daikon/front-end/java
./configure
make
@end example
@noindent
after which file @file{src/dfej} (on Windows, @file{src/dfej.exe}) is
the dfej executable.  It is already on your path.

If the @file{front-end/java} directory does not exist in your
distribution, then download the Daikon source distribution from
@uref{http://pag.lcs.mit.edu/daikon/}.

If you are running under Solaris, you may need to edit
@file{Makefile} to indicate use of the @file{libw} library; change
@example
LDFLAGS=-L. -o $(EXECUTABLE)
@end example
@noindent
to
@example
LDFLAGS=-L. -lw -o $(EXECUTABLE)
@end example

If you are running under Microsoft Windows, you should install the
@uref{http://sources.redhat.com/cygwin/,Cygwin toolset}; see
@ref{Windows requirements}.  Without Cygwin, compiling dfej under
Windows is likely to be much more difficult.


@c (or, alternately, at
@c @uref{ftp://ftp.freesoftware.com/pub/sourceware/cygwin/latest/setup.exe}).

If you modify the source code for dfej (which is not recommended
unless you know what you are doing), just run @command{make} again to
build a new binary.

@end itemize
@end enumerate

@node    Installing dfec, Installing the Context GUI, Installing dfej, Installing
@section Installing dfec, the Daikon front end for C/C++

@cindex installing dfec
@cindex dfec installation

If you wish to detect invariants in C programs, perform the following
steps.

@enumerate
@item
Download the dfec distribution from
@uref{http://pag.lcs.mit.edu/daikon/download};
choose the version for your architecture and operating system.  The
distribution includes both the dfec executable and
Lackwit.  Lackwit is a variable comparability analysis package that
makes invariant detection more accurate and efficient.
@item
Unpack the tarfile.
@example
cd $DAIKONDIR/front-end
tar zxvf dfec-linux-x86.tar.gz
@end example
@item
Compile the Daikon C runtime library.
@example
cd $DAIKONDIR/front-end/c
make
@end example
@noindent
This creates the file @file{daikon_runtime.o}; you will use it (and
@file{daikon_runtime.h}, which also appears in @file{front-end/c})
when compiling C and C++ programs in which you wish to detect invariants.
@end enumerate

@menu
* dfec EDG sources::            
@end menu

@node    dfec EDG sources,  , Installing dfec, Installing dfec
@subsection Installing dfec from EDG sources

@cindex EDG C/C++ front end
@cindex Edison Design Group C/C++ front end

License restrictions prohibit us from distributing the source for dfec,
except to other parties who hold a license to the EDG (Edison Design
Group) C/C++ front end.  If you hold such a license, send mail to
@email{daikon@@pag.lcs.mit.edu} to obtain a patch to the EDG front end
(version 2.45).  The patch file is named @file{dfec-src.tgz}.  To build
dfec for yourself, perform the following steps:
@enumerate
@item Unpack the EDG 2.45 source tree somewhere.
@item Unpack @file{dfec-src.tgz} in the @file{release_2.45/src/}
subdirectory.  This installs new Makefiles and adds the dfec source
modifications.
@item Run @command{make} from the @file{release_2.45/} subdirectory.
This creates the dfec executable,  @file{release_2.45/bin/dfec}.
@end enumerate

@c how to put something on your path:
@c 	      <li>copy or link the @command{dfej} program to a directory on
@c 	          your path, or
@c 	      <li>add the @file{java-front-end/src} directory to your path;
@c 		  for instance, in csh place the following in your
@c 		  @file{.cshrc} file:<br>
@c 		  <tt>set path = (<em>daikonparent</em>/daikon/java-front-end/src $path)</tt><br>

@node    Installing the Context GUI, Requirements, Installing dfec, Installing
@section Installing the Context GUI

If you wish to run the Daikon Context GUI (@pxref{Context GUI}), perform
the following two steps:

@enumerate
@item
If you wish to use the Context GUI with Java code, then
download and install JDE, the Java Development Environment for Emacs,
from @url{http://jde.sunsite.dk}.
If you wish to use the Context GUI with C code, no extra packages are needed.
@item
Add the Emacs Lisp code for the Daikon Context GUI to your Emacs load
path.  Add the following to your @file{.emacs} or @file{prj.el} file:
@example
  ;; Daikon Context GUI
  (add-to-list 'load-path (substitute-in-file-name "$DAIKONDIR/emacs"))
  (autoload 'daikon-context-gui "daikon-context-gui" "Daikon Context GUI" t)
  (custom-set-variables '(jde-global-classpath '("$CLASSPATH")))
@end example
@end enumerate

@node    Requirements,  , Installing the Context GUI, Installing
@section Requirements for running Daikon

In order to run Daikon, you must have a Java 1.3 (or later) JVM
(@uref{http://java.sun.com,, Java Virtual Machine}).

If you wish to re-compile Daikon from scratch, you will need the C
preprocessor, @command{cpp}.  If you have a C compiler, you almost
certainly have @command{cpp}.

You also need a compiler for whatever language your target programs are
written in.  For instance, if you wish to analyze Java programs, you
need a Java compiler such as @command{javac} or @command{jikes}.  If you
wish to analyze C or C++ programs, you need a C or C++ compiler such as
@command{gcc}.  (In fact, @command{dfec} assumes that @command{gcc} is
installed.)

If you wish to build the Daikon front end for Java (dfej) yourself,
rather than using a precompiled binary provided at
@uref{http://pag.lcs.mit.edu/daikon/}, you need a C++ compiler such as
@uref{http://gcc.gnu.org/,, gcc}.  (The dfej front end, which permits you to
detect invariants in Java programs, is written in C++, and sources are
distributed with Daikon.)

@menu
* Windows requirements::        
@end menu

@node    Windows requirements,  , Requirements, Requirements
@subsection Windows requirements for running Daikon

@cindex Windows
@cindex Microsoft Windows
@cindex Cygwin toolset

If you are running Daikon under Windows, we strongly recommend that you
install the @uref{http://sources.redhat.com/cygwin/,Cygwin toolset},
which contains everything you need to compile and run Unix programs
under Windows.  You can install Cygwin by simply running the program
found at @uref{http://sources.redhat.com/cygwin/setup.exe}.

@c ** Commented out with the elimination of the need for modbit-munge
@c You may also need to install
@c @uref{http://www.activestate.com/ASPN,ActiveState Perl} in order to run
@c the @command{modbit-munge.pl} script.  A user reports that Cygwin perl
@c does not deal properly with files whose lines are separated by
@c "@samp{\r\n}", which is the DOS default.  It deals fine with files whose
@c lines are separated with "@samp{\n}", which is the Unix default.  By
@c contrast, ActiveState Perl deals properly with both varieties.  You can
@c download ActiveState Perl from
@c @uref{http://www.activestate.com/ASPN/Downloads/ActivePerl/index/}.


@node    Example use, Detecting invariants, Installing, Top
@chapter Example use of Daikon
@cindex example use of Daikon

This chapter gives step-by-step instructions for running Daikon on a
sample Java program, @file{StackAr.java}.  @xref{Second Java example}, for
another Java example.  @xref{C examples}, for C examples.
@xref{Detecting invariants}, for complete details about running
Daikon.


@menu
* Step-by-step instructions::   
* Summary::                     
* Automating the process::      
* Understanding the invariants::  
* Second Java example::         
* C examples::                  
@end menu

@node    Step-by-step instructions, Summary, Example use, Example use
@section Step-by-step instructions

@c We recommend you run Daikon on Unix, but it can also be run on Windows.

You need to perform three basic tasks:  instrument the target program
(steps 1-4), run the instrumented program to create a data trace file
(steps 5-7), and run Daikon over the data trace file to produce
invariants (steps 8-9).

You must first install Daikon if you haven't done so already; see
@ref{Installing}.


@enumerate
@item Change to the directory containing the @file{StackAr.java} program.
@example
cd examples/StackAr
@end example

@item Compile the original version of the program.  You must use the
@option{-g} flag to include debugging information in the compiled classfiles.
@example
javac -g DataStructures/*.java
@end example


@item Instrument the @file{StackAr.java} file.
@example
dfej DataStructures/StackAr.java
@end example
@noindent
(These instructions assume you have the current working directory (".")
in your CLASSPATH.  If that is not the case, then run @command{dfej
-ajaxap=.}  instead of @command{dfej}.)

We instrument only this one file because we are only interested in the
invariants of the StackAr class, not the other classes in the program.

This command creates two directories, @file{daikon-instrumented} and
@file{daikon-output}.  It creates an instrumented version of
@file{StackAr.java} at @file{daikon-instrumented/DataStructures/StackAr.java}.
It creates a declaration file at
@file{daikon-output/DataStructures/StackAr.decls}.

@item Compile the instrumented version of StackAr.java.
@c I think this comment about "." on the classpath is correct.  -MDE 8/26/01
(This step requires "." to be on your classpath.)

@example
javac daikon-instrumented/DataStructures/StackAr.java
@end example

@item Run the StackAr test suite, using the instrumented
@file{StackAr.class} class file instead of the original (but the
original version of all other files):

@example
java -classpath "daikon-instrumented:$CLASSPATH" DataStructures.StackArTester
@end example

(On Windows, use ``;'' as the path separator.)

This will generate a trace file at
@file{daikon-output/StackAr.dtrace}.  This could take anywhere from
a few seconds to a few minutes, depending on the speed of your
computer.

@item Change to the @file{daikon-output} directory to analyze
the output.

@example
cd daikon-output
@end example

@c @item Due to a bug in the Java front end, there can be problems in the
@c trace file.  Run the @command{modbit-munge} script to fix these problems:
@c @table @r
@c @item Unix
@c @t{modbit-munge.pl StackAr.dtrace}
@c @item Windows
@c @t{modbit-munge.bat StackAr.dtrace}
@c @end table

@item Run Daikon on the trace file.

@example
java daikon.Daikon -o StackAr.inv DataStructures/StackAr.decls StackAr.dtrace
@end example

The invariants are printed to standard output, and a binary
representation of the invariants is written to
@file{StackAr.inv}.

@item Examine the invariants.  There are five ways to do this.
@itemize @bullet
@item Examine the output from running Daikon.  (You may find it
convenient to capture the output in a file; add @command{> StackAr.txt}
to the end of the command that runs Daikon.)

@item Use the PrintInvariants program to display the invariants.

@example
java daikon.PrintInvariants StackAr.inv
@end example

For more options to the PrintInvariants program, @xref{Printing
invariants}.

@item Use the MergeEsc program to insert the invariants as comments
into the Java source program.

@example
java daikon.tools.jtb.MergeESC StackAr.inv ../DataStructures/StackAr.java
@end example

Now examine file @file{../DataStructures/StackAr.java-escannotated}.
For more information about the MergeESC program, @xref{MergeESC}.

@item Use the Daikon Tree GUI to browse the invariants.  The Tree GUI
contains a tree that hierarchically organizes program points according
to their class and method.  Using the GUI, you can look at invariants
for only the methods and program points you care about.

@example
java daikon.gui.treeGUI.InvariantsGUI StackAr.inv
@end example

@item Use the Daikon Context GUI to browse the invariants.  As you move
the cursor in an editor window, the Context GUI displays the invariants
applicable to the current location (class or method).  For details on
running the Context GUI, see @ref{Context GUI}.  The Context GUI can
also be run from the command line:
@example
java daikon.gui.contextGUI.ContextGUI StackAr.inv
@end example
@end itemize

@end enumerate

@node    Summary, Automating the process, Step-by-step instructions, Example use
@section Summary

The steps above can be divided into three stages:

@itemize @bullet
@item Instrumentation (steps 1-4)
@example
cd examples/StackAr
javac -g DataStructures/*.java
dfej DataStructures/StackAr.java
javac daikon-instrumented/DataStructures/StackAr.java
@end example

@c @item Trace file generation (steps 5-7)

@item Trace file generation (step 5)
@example
java -classpath "daikon-instrumented:$CLASSPATH" DataStructures.StackArTester
@end example

(On Windows, use ``;'' as the path separator.)

@c cd daikon-output
@c modbit-munge.pl StackAr.dtrace
@c @end example

@item Invariant detection (steps 6-8)
@example
cd daikon-output
java daikon.Daikon -o StackAr.inv DataStructures/StackAr.decls StackAr.dtrace
java daikon.gui.treeGUI.InvariantsGUI StackAr.inv
@end example

@end itemize

@node    Automating the process, Understanding the invariants, Summary, Example use
@section Automating the process

The script @command{daikon.pl} automates all steps of the invariant
detection process.

@example
cd examples/StackAr
daikon.pl DataStructures.StackArTester
@end example

This command instruments your program, generates a trace file, and
displays the invariants in the Tree GUI.  Currently, this script only works
on Unix.  For more details, @xref{All-in-one script}.


@node    Understanding the invariants, Second Java example, Automating the process, Example use
@section Understanding the invariants

This section examines some of the invariants for the StackAr example.
For more help interpreting invariants, see @ref{Interpreting output}.

The StackAr example is an array-based stack implementation.  Take a
look at @file{DataStructures/StackAr.java} to get a sense of the
implementation.  Now, look at the first section of Daikon output. In
the Tree GUI, expand the node labeled @command{StackAr}, then select the
node labeled @command{StackAr:Object}.

@emph{(Note: The invariants displayed in the Tree GUI may be different than the
invariants written to standard out by Daikon.  This is because the
invariants are being filtered differently.  We are currently working
to resolve this issue.)}

@example
======================================================================
StackAr:::OBJECT
this.theArray != null
this.theArray.class == "[Ljava.lang.Object;"
this.topOfStack >= -1
this.theArray[this.topOfStack+1..] elements == null
this.theArray[0..this.topOfStack] elements != null
this.topOfStack <= size(this.theArray[])-1
======================================================================
@end example

These six annotations describe the representation invariant.  The
array is never null, and its runtime type is @code{Object[]}.  The
@code{topOfStack} index is at least -1 and is less than the length
of the array.  Finally, the elements of the array are non-null if
their index is no more than @code{topOfStack} and are null
otherwise.

Next, look at the invariants for the @code{top()} method.  In
the Tree GUI, expand the node labeled @command{top()Ljava/lang/Object;}.
@code{top()} has two different exit points, at lines 78 and 79
in the original source.  There is a set of invariants for each exit
point, as well as a set of invariants that hold for all exit points.
Look at the invariants when @code{top()} returns at line 79.  In
the Tree GUI, select the node labeled @command{EXIT79}.

@example
======================================================================
StackAr.top():::EXIT79
return == this.theArray[this.topOfStack]
this.theArray == orig(this.theArray)
this.theArray[] == orig(this.theArray[])
this.topOfStack == orig(this.topOfStack)
return != null
this.topOfStack >= 0
this.theArray[this.topOfStack+1..] elements == this.theArray[-1]
======================================================================
@end example

The return value is never null, and is equal to the array element at
index @code{topOfStack}.  The top of the stack is at least 0.  The
array, the elements of the array, and @code{topOfStack} are not
modified by this method - this method is an "observer".  The
last invariant is not particularly interesting.

@node    Second Java example, C examples, Understanding the invariants, Example use
@section A second Java example

A second example is located in the @file{examples/QueueAr} subdirectory.
Run this sample using the following steps:

@itemize @bullet
@item Instrumentation (steps 1-4)
@example
cd examples/QueueAr
javac -g DataStructures/*.java
dfej DataStructures/QueueAr.java
javac daikon-instrumented/DataStructures/QueueAr.java
@end example

@c @item Trace file generation (steps 5-7)
@item Trace file generation (step 5)
@example
java -classpath "daikon-instrumented:$CLASSPATH" DataStructures.QueueArTester
@c cd daikon-output
@c modbit-munge.pl QueueAr.dtrace
@end example

(On Windows, use ``;'' as the path separator.)

@item Invariant detection (steps 6-8)
@example
cd daikon-output
java daikon.Daikon -o QueueAr.inv DataStructures/QueueAr.decls QueueAr.dtrace
java daikon.gui.treeGUI.InvariantsGUI QueueAr.inv
@end example

@end itemize

@node    C examples,  , Second Java example, Example use
@section C examples

The Daikon distribution comes with several example C programs in the
@file{examples/c-examples} directory to enable users to become familiar
with Daikon.

In order to detect invariants over C programs, you must
install dfec, the Daikon front end for C; see @ref{Installing dfec}.


To detect invariants for a program, you need to perform three basic
tasks: instrument the target program (steps 1-3), run the instrumented
program to create a data trace file (step 4), and run Daikon over the
data trace file to produce invariants (steps 5-6).  The following
instructions are for the print_tokens example.  The other examples can
be run in exactly the same manner.

@enumerate
@item Change to the directory containing the print_tokens program.
@example
cd $DAIKONDIR/examples/c-examples/print_tokens
@end example

@item Instrument the program using dfec, the C front end.
Run the front end over all the C source files and
the user-created header files they depend on.
@example
dfec print_tokens.c stream.h tokens.h
@end example
@noindent
This command creates two directories, @file{daikon-instrumented}
and @file{daikon-output}.  It creates an instrumented and preprocessed
version of @file{print_tokens.c} at
@file{daikon-instrumented/print_tokens.cc}.  It 
creates a declaration file at @file{daikon-output/print_tokens.decls}.

@quotation
Note for Windows users:
Under Windows, you must insert in the source file a gcc-specific
__attribute__ for the _ctype_ variable, which is used in our test
suite.  Run the following commands:
@example
alias fix="sed -f $DFECDIR/fix.sed"
(cd daikon-instrumented; fix print_tokens.cc > print_tokens_fixed.cc)
@end example
@end quotation

@item Compile and link the instrumented program to create the
executable @file{print_tokens} in the current directory.

@example
g++ -g -w -o print_tokens daikon-instrumented/print_tokens_fixed.cc $DFECDIR/daikon_runtime.o
@end example
@quotation
Note for Windows users:  Name the executable print_tokens.exe, not
print_tokens:
@example
g++ -g -w -o print_tokens.exe daikon-instrumented/print_tokens_fixed.cc $DFECDIR/daikon_runtime.o
@end example
@end quotation

@item Run the print_tokens test suite.  First set the DTRACEAPPEND
environment variable, so that a final @file{.dtrace} file contains
information from all runs, rather than each run overwriting the file
so that it contains only information from the last run.  (For more
details about the DTRACEAPPEND environment variable, see @ref{dfej
options} and @ref{dfec command-line arguments}.)

If you use the bash shell, run the following commands:
@example
export DTRACEAPPEND=1
sh tests.sh
@end example

If you use the csh or tcsh shell, run the following commands:
@example
setenv DTRACEAPPEND 1
sh tests.sh
@end example

These commands create a data trace file at
@file{daikon-output/print_tokens.dtrace}.

@item Run Daikon on the trace file.
@example
java -Xmx256m daikon.Daikon -o print_tokens.inv \
     daikon-output/print_tokens.decls daikon-output/print_tokens.dtrace
@end example
@noindent
The invariants are printed to standard out, and a binary representation
of the invariants is written to @file{print_tokens.inv}.

@item Examine the invariants.  As described in the Daikon manual, there are
several ways to do this:
@itemize 
@item Examine the output from running Daikon.
@item Use the PrintInvariants program to display the invariants.
@item Use the Daikon Tree GUI to browse the invariants.
@item Use the Daikon Context GUI to browse the invariants.
@end itemize
@noindent
For help understanding the invariants, see @ref{Interpreting output}.

@end enumerate

@menu
* C examples summary::          
* Rijndael example::            
@end menu

@node    C examples summary, Rijndael example, C examples, C examples
@subsection C examples summary

The above steps can be divided into three stages:

Instrumentation (Steps 1-3)
@example
cd $DAIKONDIR/examples/c-examples/print_tokens
dfec print_tokens.c stream.h tokens.h
g++ -g -w -o print_tokens daikon-instrumented/print_tokens_fixed.cc $DFECDIR/daikon_runtime.o
@end example

Trace File Generation (Step 4)
@example
export DTRACEAPPEND=1
sh tests.sh
@end example

Invariant Detection (Step 5)
@example
java -Xmx256m daikon.Daikon -o print_tokens.inv \
     daikon-output/print_tokens.decls daikon-output/print_tokens.dtrace
@end example


@node    Rijndael example,  , C examples summary, C examples
@subsection Rijndael example

The rijndael program requires some special instructions, due to the
size of its data trace file.  The data trace file is over 1GB in size
when first created, so make sure you have adequate disk space.

First, you should set the TRACE_KAT_MCT variable when you run the C
front end; this causes the Rijndael program to produce output when
running the test suite.  Replace the dfec command in step 2 above by
this one:
@example
dfec -DTRACE_KAT_MCT rijndael.c rijndael-alg-ref.h rijndael-api-ref.h
@end example

Second, you will need to manually reduce the size of the dtrace file.
Run these commands after step 4 above.
@example
head -1000000 daikon-output/rijndael.dtrace > \
      daikon-output/rijndael.truncated.dtrace
trace-untruncate daikon-output/rijndael.truncated.dtrace
@end example
@noindent
The first command selects the first million lines of the file, and the
second command cleans up the end of the file, in case we truncate in
the middle of a data structure.

Finally, run Daikon using the truncated trace file (step 5).
@example
java -Xmx256m daikon.Daikon -o rijndael.inv \
      daikon-output/rijndael.decls daikon-output/rijndael.truncated.dtrace
@end example


@node    Detecting invariants, Daikon output, Example use, Top
@chapter Using Daikon to detect invariants

Detecting invariants involves three steps:
@enumerate
@item
Run @command{dfej} or @command{dfec} to instrument the target program
(@pxref{Instrumentation}).
This modifies a copy of the target program so that, in addition to
performing its original task, it also writes variable values to a data
trace file.

@item
Run the instrumented program in the usual way, probably using a test
suite (@pxref{Run the instrumented program}).  This creates data trace
files.

@item
Run the Daikon invariant detector over the data trace files
(@pxref{Detect invariants}).  This detects invariants in the data trace
files.  You can display the invariants textually or via a graphical user
interface.
@end enumerate



@menu
* Instrumentation::             
* Run the instrumented program::  
* Detect invariants::           
* All-in-one script::           
@end menu

@node    Instrumentation, Run the instrumented program, Detecting invariants, Detecting invariants
@section Instrumentation

Instrumentation performs two actions:
@itemize @bullet
@item
Instrumentation adds instructions to the target program so that, in
addition to performing its original task, it also writes variable values
to a data trace file.  The changes are made to a copy of the target
program; your original version is not modified.
@item
Instrumentation creates declaration files that describe the format of
the data trace files.  For instance, these declaration files describe
the names of procedures and variables that appear in the data trace file.
@end itemize

Two instrumenters are part of Daikon:  @command{dfej} for Java programs and
@command{dfec} for C and C++.  The names @command{dfej} and @command{dfec} stand
for "Daikon front end for Java" and "Daikon front end for C/C++".  The
Java front end is robust; the C front end is moderately robust, and
the C++ front end is experimental.

A front end for the IOA programming language is distributed separately
(see @url{http://theory.lcs.mit.edu/tds/ioa.html}).
An earlier version of Daikon included a Lisp front end, but it is no
longer supported.

@menu
* Instrumenting Java programs::  
* Instrumenting C/C++ programs::  
@end menu

@node    Instrumenting Java programs, Instrumenting C/C++ programs, Instrumentation, Instrumentation
@subsection Instrumenting Java programs

To instrument Java source programs, simply invoke @command{dfej}, the
Daikon front end for Java, on them:
@example
      dfej @var{filename1}.java @var{filename2}.java @var{...}
@end example

After running dfej, compile the instrumented version of the code, which
by default appears in the @file{daikon-instrumented/} directory.

The Daikon front end for Java has two effects:
@itemize @bullet
@item
dfej writes instrumented versions of the files to a
@file{daikon-instrumented/} directory.
@item
dfej creates declaration files named @file{@var{filename1}.decls}, etc.@
in a @file{daikon-output/} directory.
@end itemize

For more information about dfej, see @ref{Java front end dfej}.


@node    Instrumenting C/C++ programs,  , Instrumenting Java programs, Instrumentation
@subsection Instrumenting C/C++ programs

To instrument C/C++ source, invoke @command{dfec} on all the source and
header files at once:
@example
     dfec @var{...options...} @var{myprog}.cc
@end example

You may want to specify one or more command-line options;
see @ref{dfec command-line arguments}.
If the @command{dfec} command produces errors, first check whether running
@command{gcc -Wall} on the code produces errors; if so, fix them before
proceeding to use @command{dfec}.

After dfec is run, you must compile the instrumented source, linking
it with the object file for the Daikon runtime library and the stdc++
library.  By default, dfec places instrumented source in the
@file{daikon-instrumented/} directory.
@example
      g++ -g -o @var{myprog} daikon-instrumented/@var{myprog}.cc $DFECDIR/daikon_runtime.o
@end example
@noindent
In addition, you may want to specify the @option{-w} flag to g++, to
suppress warnings.  dfec's output is valid C++ but may cause g++ to
issue warnings.

The Daikon front end for C/C++ has three effects:
@itemize @bullet
@item
dfec writes instrumented versions of the files to a
@file{daikon-instrumented/} directory 
@item
dfec creates declaration files named
@file{@var{myprog}.decls}, etc.@: in a
@file{daikon-output/} directory.
@item
optionally, dfec may create a pointer
type disambiguation file named
@file{@var{myprog}.disambig} in the
same directory as the @file{@var{myprog}.decls}
file.
@end itemize

For more information about dfec, including more detailed documentation
on its command-line options, see @ref{C/C++ front end dfec}.


@c <ol>
@c      <tt>dfec</tt> is written in Perl.  If Perl is not available, you may
@c      instead use <tt>dfec.sh</tt>, which is written in sh shell script.<p>
@c 
@c      The Daikon C front end:
@c      <ol>
@c        <li>copies your original files to @file{<i>myprog1.c</i>.uninst},
@c 	   etc.<br>
@c        <li>overwrites the original files with instrumented versions
@c        <li>creates declaration files named @file{<i>myprog1.c</i>.decls}, etc.
@c      </ol>
@c      You may wish to perform this operation with a copy of your program,
@c      to safeguard your original source code.<p>
@c 
@c      If you supply the @option{-d <i>directory</i>} argument (before
@c      the file names), then the instrumented source files are placed in the
@c      specified directory instead (and no backup files need be made).
@c  <li>Create or modify a @file{Makefile}.  Either:
@c    <ul>
@c      <li>If you have no @file{Makefile}, copy @file{Makefile-sample}
@c          to @file{Makefile} and add the names of your source files to its
@c          <tt>OBJS</tt>, and edit its <tt>EXEC</tt> executable name.
@c      <li>If you have a @file{Makefile}, add @file{dump_trace.o} to the
@c          list of object files that need to be created (and linked to create
@c          your executable).
@c    </ul>
@c  <li>Create an instrumented executable by building your program in the
@c      usual way (perhaps by running <tt>make</tt> or <tt>cc</tt> or <tt>gcc</tt>).
@c </ol>


@node    Run the instrumented program, Detect invariants, Instrumentation, Detecting invariants
@section Run the instrumented program

To create data trace files, run the instrumented program over some test
suite of your own choosing, such as regression tests or a typical user
input session.  You can run the instrumented program in just the same
way you did before; the only behavioral change is writing a
@file{.dtrace} file.  Only one @file{.dtrace} file is created, even
though multiple @file{.decls} files might have been created (one for
each source file) when the program was instrumented.

By default, the instrumented Java or C/C++ program creates its @file{.dtrace}
file in the @file{daikon-output/} subdirectory of the current directory,
and it defaults to overwriting any previously existing @file{.dtrace} file.

@c    For C/C++
@c  programs, however, you can set the DTRACEAPPEND environmental variable,
@c  which will cause each subsequent run of the program to append to the
@c  @file{.dtrace} file, which is useful if your test suite requires multiple
@c  invocations of the program.

Environment variables DTRACEFILE and DTRACEAPPEND can override the
default behaviors.  For details, see @ref{dfej options} and @ref{dfec
command-line arguments}.

@c After running your program, run @command{bin/modbit-munge.pl} on the
@c resulting @file{.dtrace} files:
@c @example
@c modbit-munge.pl @var{myprog}.dtrace
@c @end example
@c @noindent
@c This step fixes up some potential problems that may appear in the
@c @file{.dtrace} file.


@menu
* Run Java::                    
@end menu

@node    Run Java,  , Run the instrumented program, Run the instrumented program
@subsection Details on running instrumented Java programs

After instrumentation, there are two versions of your Java program:
the original version, which is unmodified, and the instrumented
version, which appears in the @file{daikon-instrumented/} directory.
Make sure that the @file{daikon-instrumented/} directory appears on
your class path before the directory containing the original Java
code.  You can do this by running the program from that directory, if
@file{.} (the current directory) appears early on your class path, or
you can add the relevant @file{daikon-instrumented/} directory to your
class path explicitly.


@menu
* Java applets::                
@end menu

@node    Java applets,  , Run Java, Run Java
@subsubsection Java applets

In order to run an applet, you must take two additional steps.

@enumerate
@item
Copy or link all class files, jar files, input files, and html files
that your applet needs to the @file{daikon-instrumented/} directory.  This
includes the @file{daikon/java} directory itself.  For example, to
create a link to the @file{daikon/java} directory, type (while in the
@file{daikon-instrumented/} directory):
@example
ln -s $DAIKONDIR/java/daikon .
@end example

@item
By default, the Java 2 applet security model does not allow applets to
write files.  To get around this so that Daikon can write its @file{.dtrace}
files, create a file named @file{javaPolicy} in the @file{daikon-instrumented/}
directory that contains the text
@example
grant @{
    permission java.io.FilePermission
      "<<ALL FILES>>", "read, write, delete, execute";
@};
@end example
@noindent
Do not use this policy file with untrusted applets.

@item
Finally, run the applet:
@example
       appletviewer -J-Djava.security.policy=javaPolicy @var{html-file}
@end example
@end enumerate


@node    Detect invariants, All-in-one script, Run the instrumented program, Detecting invariants
@section Detect invariants in the data trace files

Run the Daikon invariant detector via the command
@example
    java daikon.Daikon @i{[@var{flags}]} @var{decl-files...} @var{dtrace-files...} @var{spinfo-files...}
@end example
@noindent
(For help in interpreting the output, @xref{Interpreting output}.)

The @var{decl-files} are declaration (@file{.decl}) files created at
instrumentation time.
The @var{dtrace-files} are data trace (@file{.dtrace}) files created by
running the instrumented program.
The @var{spinfo-files} are splitter info (@file{.spinfo}) files created
automatically or by hand.
The files may appear in any order;
the file type is determined by whether the file name contains
@file{.decls}, @file{.dtrace}, or @file{.spinfo}.

Be sure to include all declaration files that are needed for the particular
data trace file; the simplest way is to include every the declaration file
created when instrumenting the program.

The optional flags are described in @ref{Command line options}.

@menu
* Command line options::        
@end menu

@node    Command line options,  , Detect invariants, Detect invariants
@subsection Command line options for Daikon
@cindex command line options for Daikon
@cindex flags for Daikon

The Daikon invariant detector is invoked as follows:
@example
    java daikon.Daikon @i{[@var{flags}]} @var{decl-files...} @var{dtrace-files...} @var{spinfo-files...}
@end example

This section describes the optional flags.


@c Unfortunately, @option{} adds quotes in the Info and printed output
@c which is not necessary in a table.  However, @t and @code compress
@c the two hyphens to 1 in Info and HTML output, which is even worse.
@table @option
@item -h
@item --help
Print usage message.

@item --ppt @var{ppt_regexp}
Only process program points whose names match the regular expression,
which uses Perl syntax.

@item --ppt_omit @var{ppt_regexp}
Do not process program points whose names match the regular expression,
which uses Perl syntax.  This takes priority over the
@option{--ppt} argument.

@item --var_omit @var{var_regexp}
Ignore variables (whether in the trace file or derived) whose names
match the regular expression, which uses Perl syntax.

@item -o @var{inv_file}
Serialize invariants to the specified file; they can later be
postprocessed, compared, etc.

@item --config @var{filename}
Load the configuration settings specified in the given file.
@xref{Configuration options}, for details.

@item --config_option @var{name}=@var{value}
Specify a single configuration setting.
@xref{Configuration options}, for details.

@item --files_from @var{filename}
Read a list of @var{decl}, @var{dtrace}, or @var{spinfo} files from the
given text file, one filename per line, as an alternative to providing
them on the command line.

@item --no_text_output
Don't print invariants as text output.  This option may be used in
conjunction with the @option{-o} option.

@item --suppress_cont
Suppress display of implied invariants (by controlling ppt).

@item --suppress_post
Suppress display of obvious postconditions on prestate.

@item --prob_limit @var{pct}
Set the probability limit for justifying invariants.  @var{pct} must be
between 0 and 1; the default is .01 (1%).  Smaller values yield stronger
filtering.

@item --esc_output
Write output in ESC-like format.

@item --simplify_output
Write output in Simplify format.

@item --output_num_samples
@cindex samples breakdown output
@cindex mux output
Output numbers of values and samples for invariants and program points;
this is a debugging flag.  (That is, it helps you understand why Daikon
produced the output that it did.)

The ``Samples breakdown'' output indicates how many samples in the
@file{.dtrace} file had a modified value (``m''), had an unmodified
value (``u''), and had a missing value (``x'').  The summary uses a
capital letter if the sample had any of the corresponding type of
variable, and a lower-case letter if it had none.  These types affect
statistical tests that determine whether a particular invariant (that
was true over all the test runs) is printed.

Only variables that appear in both the pre-state and the post-state
(variables that are in scope at both procedure exit and entry) are
eligible to be listed as modified or unmodified.  This is why the list
of all variables is not the union of the modified and unmodified
variables.

@item --dbg @var{category}
@item --debug
@cindex debugging flags
These debugging options cause output to be written to a log file (by
default, to the terminal).  The @option{--dbg @var{category}} option
enables debugging output for a specific part of Daikon; it may be
specified multiple times, permitting find-grained control over debugging
output.  The @option{--debug} option turns on all debugging flags.
(This produces a lot of output!)  Most @var{category}s are class or
package names in the Daikon implementation, such as @code{daikon.split}
or @code{daikon.derive.binary.SequencesJoin}.  Only classes that check
the appropriate categories are affected by the debug flags; you can
determine this by looking for a call to @samp{Category.getInstance} in
the specific class.  The debugging/logging output is implemented via the
Log4j package.

@end table


@node    All-in-one script,  , Detect invariants, Detecting invariants
@section All-in-one script daikon.pl

The @command{daikon.pl} script automates all steps of the invariant
detection process:  instrumentation, trace file generation, invariant
display.  Currently, this script only works on Unix.
This script is not the preferred way to run Daikon, but some
users may find it helpful.

Running @command{daikon.pl} without without any arguments will display usage information:
@example
% daikon.pl
Usage: daikon.pl [OPTIONS] MAIN_CLASS [MAIN_ARGUMENTS]
Options:
  -o, --output FILE   Save invariants in FILE.inv
  ...
@end example

You must supply at least the name of a "main" class that provides
the method @code{public static void main(String[] args)}.
@command{daikon.pl} runs this class to exercise your program.

@c <!--
@c <h2><a xname="example">Example</a></h2>
@c 
@c You can try an example provided by the staff:
@c <pre>
@c   athena% cd ~/6.170
@c   athena% mkdir daikon-testing; cd daikon-testing
@c   athena% cp -rp /mit/6.170/handouts/daikon/example .
@c   athena% daikon --verbose xxx
@c </pre>
@c This will run <tt>xxx</tt>, detect invariants for the program, and
@c display the daikon Tree GUI to browse the results.  See the <a
@c href="#interpret-output">interpreting the output</a> section below for
@c details on the meaning of the invariants.
@c 
@c <p>Each run of daikon creates two files: an <tt>.inv</tt> file that
@c contains the invariants in a special format, and a
@c <tt>.src.tar.gz</tt> file that contains a snapshot of the program
@c source.  You may specify names for these files using the <tt>--output
@c <i>file</i></tt> parameter to daikon.  For example <tt>--output
@c mytest</tt> will create <tt>mytest.inv</tt> and
@c <tt>mytest.src.tar.gz</tt>.
@c 
@c <p>If your main class requires arguments, you may place them after the
@c class name, just as if you were running <tt>java</tt> instead of
@c <tt>daikon</tt>.
@c -->

@menu
* daikon.pl arguments::         
@end menu

@node    daikon.pl arguments,  , All-in-one script, All-in-one script
@subsection Command line options for daikon.pl

@table @option
@item -o
@item --output @var{file}
Save invariants in @file{@var{file}.inv} and source in
@file{@var{file}.src.tar.gz}.  If no name 
is given, a name is automatically generated and used.

@item -t
@item --textfile
Save a textual listing of invariants to a @file{.txt} file.

@item -v
@item --verbose
Display progress messages while running.

@item -c
@item --cleanup
Remove files left over from an interrupted session before starting.
Should be used only when @code{daikon.pl} detects left-over files and instructs
you to use this option.

@item -n
@item --nogui
Create the invariants file (and @file{.txt} file,
if @option{-t} is given), but do not start the Tree GUI.
@end table



@node    Daikon output, GUIs, Detecting invariants, Top
@chapter Daikon output


@menu
* Interpreting output::         
* Printing invariants::         
* Invariant Diff::              
@end menu

@node    Interpreting output, Printing invariants, Daikon output, Daikon output
@section Interpreting Daikon output

@cindex @samp{Exiting}, in Daikon output

If nothing gets printed before the @samp{Exiting} line, then Daikon
found no invariants.  You can get a little bit more information by using
the @option{--output_num_samples} flag to Daikon (@pxref{Command line
options}).

Daikon does not display redundant invariants --- those that are implied
by other invariants in the output --- because such results would merely
clutter the output without adding any valuable information.  For
instance, if Daikon reports ``x==y'', then it never also reports
``x-1==y-1''.  (You can print all invariants, even redundant ones, by
saving the invariants to a @file{.inv} file and then using the
PrintInvariants (@pxref{Printing invariants}) or Diff (@pxref{Invariant
Diff}) programs to print the results.)

@menu
* Program points::              
* Variable names::              
* Invariant syntax::            
@end menu

@node    Program points, Variable names, Interpreting output, Interpreting output
@subsection Program points
@cindex program point

A program point is a specific place in the source code, such as
immediately before a particular line of code.  Daikon's output is
organized by program points, both in the textual output and in the GUIs.

@cindex :::ENTER program point
@cindex ENTER program point
@cindex precondition

For example, @code{foo():::ENTER} is the point at the entry to procedure
@code{foo()}; the invariants at that point are the preconditions for the
@code{foo()} method, properties that are always true when the procedure
is invoked.

@cindex :::EXIT program point
@cindex EXIT program point
@cindex postcondition

Likewise, @code{foo():::EXIT} is the program point at the procedure
exit, and invariants there are postconditions.  When there are multiple
exit points from a procedure (for instance, because of multiple
@code{return} statements), the different exits are differentiated by
suffixing them with their line numbers; for instance,
@code{StackAr.top():::EXIT79}.  The exit point lacking a line number (in
this example, @code{StackAr.top():::EXIT}) collects the postconditions
that are true at every numbered exit point.  This is an example of a
program point that represents a collection of locations in the program
source rather than a single location.

@cindex :::OBJECT program point
@cindex OBJECT program point
@cindex :::CLASS program point
@cindex CLASS program point

Two other program point tags are @code{:::OBJECT} and @code{:::CLASS}.
The former indicates object invariants (sometimes called representation
invariants or class invariants) that always hold for any object of the
given class, from the point of view of a client or user.  These
properties hold at entry to and exit from every public method of the
class.  The @code{:::CLASS} tag is just like @code{:::OBJECT}, but only
for static variables, which have only one value for all objects.

The Java instrumenter dfej selects names for program points that include
an indication of the argument and return types for each method.  These
signatures are presented in the JVML format:  one character for each
primitive type (@samp{B} for byte, @samp{C} for character, @samp{Z} for
boolean (so as not to clash with byte), etc.);
@samp{L}@var{classname}@samp{;} for object types; and a @samp{[} prefix
for each level of array nesting.


@node    Variable names, Invariant syntax, Program points, Interpreting output
@subsection Variable names

@cindex @code{orig()} variable (pre-state value)
@cindex @code{.class} variable
@cindex @code{.toString} variable
@cindex @code{-1} array index (counts from end of array)
@cindex negative array index (counts from end of array)
@cindex @code{a[]} variable (array contents)

Here is an incomplete list of the conventions used by Daikon for
variable names.

@itemize @bullet
@item
@code{orig(x)} refers to the value of formal parameter @code{x} upon
entry to a procedure (because the procedure body might modify the value
of @code{x}).  These variables appear only at @code{:::EXIT} program
points.
@item
@code{a} is the identity of @code{a} --- think of it as a
comparison over hash codes
@item
@code{a.class} is the runtime type of @code{a}, which may
differ from its declared type
@c "a.class" is omitted for arrays of primitive type
@item
@code{a[]} is the contents of array @code{a}, namely a sequence of
elements; "a=b" implies "a[]=b[]" but the reverse is not true
@item
@code{a[].class} is an array of types, representing the run-time classes
of the contents of @code{a}; it is omitted for arrays of primitive type
@item
@code{a[-1]} denotes the last element of array @code{a};
it is syntactic sugar for @code{a[a.length-1]}.
@item
@code{s.toString} is the string value of String @code{s}, namely a
sequence of characters
@end itemize

Daikon does not produce output for local variables, only for variables
visible from outside a procedure.  Thus, its output forms a
specification (mostly) from the view of a client of a procedure.  A
future version of Daikon will permit output of local variables as a user
option.


@node    Invariant syntax,  , Variable names, Interpreting output
@subsection Invariant syntax

Daikon's default format is a mix of Java, mathematical logic, and some
additional extensions.
(In the future, Daikon will produce output in JML format; when
that is the case, this section of the manual will simply refer the
reader to the @uref{http://www.cs.iastate.edu/~leavens/JML.html, ,JML
Manual}.  Daikon's current ESC output format is a variant of JML format.)


@cindex has only one value, in invariant output

The output "@var{var} has only one value" means that every time that
variable @var{var} was encountered, it had the same value.  However,
that value is not interesting to report.  Typically this means that
@var{var} always referred to the same object.  Users may care that the
variable was never rebound to a different object, but it would not be
helpful to print out what the hashcode or address of that object
happened to be at runtime.  "@var{var} has only one value" differs from
saying that var is unmodified.  

A variable can have only one value but not be reported as unmodified
because the variable is not a parameter to a procedure --- for instance,
if a routine always returns the same object, or in a class invariant.  A
variable can be reported as unmodified but not have only one value
because the variable is never modified during any execution of the
procedure, but has different values on different invocations of the
procedure.


@node    Printing invariants, Invariant Diff, Interpreting output, Daikon output
@section Printing invariants

@cindex printing invariants
@cindex PrintInvariants program

Daikon provides many options for controlling how invariants are printed.
Often, you may want to print the same set of invariants several
different ways.  However, you only want to run Daikon once, since it may
be very time consuming.  The PrintInvariants utility prints a set of
invariants from a @file{.inv} file.

PrintInvariants is invoked as follows:
@example
    java daikon.PrintInvariants @i{[@var{flags}]} @var{inv-file}
@end example

PrintInvariants shares many flags with Daikon:

@table @option
@item -h
@item --help
Print usage message.

@item --suppress_cont
Suppress display of implied invariants (by controlling ppt).

@item --suppress_post
Suppress display of obvious postconditions on prestate.

@item --esc_output
Write output in ESC-like format.

@item --simplify_output
Write output in Simplify format.

@item --output_num_samples
Output numbers of values and samples for invariants and program points;
for debugging.
@end table


@node    Invariant Diff,  , Printing invariants, Daikon output
@section Invariant Diff

@cindex invariant diff
@cindex diff, over invariants
@cindex comparing invariants

The invariant diff utility is designed to output the differences between
two sets of invariants.  This is useful, for example, if you want to
compare the invariants generated by two versions of the same program.

Invariant diff is invoked as follows:
@example
    java daikon.diff.Diff @i{[@var{flags}]...} @var{file1} [@var{file2}] 
@end example

file1 and file2 are serialized invariants produced by running Daikon or Diff
with the "-o" flag.  If @file{file2} is not specified,
@file{file1} is compared with the empty set of invariants.

This section describes the optional flags.

@table @option
@item -h
Print usage message.

@item -d
Display the tree of differing invariants (default).  Invariants that are
the same in file1 and file2 are not printed.  At least one of the
invariants must be justified.  Does not print "uninteresting" invariants
(currently some OneOf and Bound invariants).

@item -u
Include "uninteresting" invariants in the tree of differing invariants.

@item -a
Display the tree of all invariants.  Includes invariants that are the
same in file1 and file2, and unjustified invariants.

@item -s
For internal use only.  Display the statistics between two sets of
invariants.  The pairs of invariants are placed in bins according to the
type of the invariant and the type of the difference.

@item -t
For internal use only.  Display the same statistics as @option{-s}, but as a
tab-separated list.

@item -m
Compute (file1 - file2).  This is all the invariants that appear in
file1 but not file2.  Unjustified invariants are treated as if they
don't exist.  Output is written as a serialized InvMap to the file
specified with the -o option.  To view the contents of the serialized
InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -x
Compute (file1 XOR file2).  This is all the invariants that appear in
one file but not the other.  Unjustified invariants are treated as if
they don't exist.  Output is written as a serialized InvMap to the file
specified with the -o option.  To view the contents of the serialized
InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -n
Compute (file1 UNION file2).  This is all the invariants that appear in
either file.  If the same invariant appears in both files, the one with
the better justification is chosen.  Output is written as a serialized
InvMap to the file specified with the -o option.  To view the contents
of the serialized InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -o @var{inv_file}
Used in combination with the -m or -x option.  Writes the output as a
serialized InvMap to the specified file.

@item -j
For internal use only.  Treat justification as a continuous value when
gathering statistics.  By default, justification is treated as
a binary value -- an invariant is either justified or it is not.  For
example, assume invariant I1 has a probability of .01, and I2 has a
probability of .5.  By default, this will be a difference of 1,
since I1 is justified but I2 is not.  With this option, this will be a
difference of .49, the difference in the probabilities.  This only
applies when one invariant is justified, and the other is unjustified.

@item -p
Examine all program points.  By default, only procedure entries and
combined procedure exits are examined.  This option also causes
conditional program points to be examined.

@item -e
Print empty program points. By default, program points are not printed
if they contain no differences.

@item -v
Verbose output.  Invariants are printed using the repr() method, instead
of the format() method.

@item -l
For debugging use only.  Prints logging information describing the state
of the program as it runs.

@item --invSortComparator1 @var{classname}
@item --invSortComparator2 @var{classname}
@item --invPairComparator @var{classname}
Use the specified class as a custom comparator.  A custom comparator can
be used for any of 3 operations: sorting the first set of invariants,
sorting the second set of invariants, and combining the two sets into
the pair tree.  The specified class must implement the Comparator
interface, and accept objects of type Invariant.

@end table


@node    GUIs, Front ends, Daikon output, Top
@chapter GUIs for displaying invariants

By default, Daikon outputs a textual list of invariants; this list may
be very long.  Daikon's graphical user interfaces (GUIs) are designed to
make the task of browsing invariants easier.

There are two GUIs to choose from.  The Tree GUI that lets users browse
the hierarchy of invariants directly.  The Context GUI lets users browse
the code in a text editor; the Context GUI concurrently displays the
invariants for the browsed code.


@menu
* Tree GUI::                    
* Context GUI::                 
@end menu

@node    Tree GUI, Context GUI, GUIs, GUIs
@section Tree-structured invariant browser
@cindex Tree GUI
@cindex GUI, tree

The Tree GUI contains a tree that
hierarchically organizes program points according to their class and
method.  Using the Tree GUI, you can look at invariants for only the methods
and program points you care about.  You can also sort invariants by a
property (e.g., probability) or filter invariants (e.g., only look at
invariants containing a certain variable).

This invariant browser consists of two windows.  The main window is the
Invariants Display, which gives a tree-structured view of program
points; you can navigate through the program points and view invariants.
The other window is the Filter Control Panel, where you can control
which invariants from each program point are displayed in the Invariants
Display.

@menu
* Invoking Tree GUI::           
* Invariants Display::          
* Control panel::               
@end menu

@node    Invoking Tree GUI, Invariants Display, Tree GUI, Tree GUI
@subsection Starting the invariant browser

To use the Tree GUI, first make a @file{.inv} file by invoking Daikon with
the @option{-o} option; for instance, to create @file{foo.inv}, run
@example
java daikon.Daikon -o foo.inv @var{decl-files...} @var{trace-files...}
@end example

Then, run the Tree GUI with the @file{.inv} file as an argument:
@example
java daikon.gui.treeGUI.InvariantsGUI foo.inv
@end example

If you run the Tree GUI with no arguments, it presents a file browser that
asks you to choose a @file{.inv} file for viewing.


@node    Invariants Display, Control panel, Invoking Tree GUI, Tree GUI
@subsection Invariants Display

@ifnotinfo
@image{images/gui-InvariantsDisplay-small,3in,}
@c </td>
@c <td width=20></td>
@c <td><img src="gui-InvariantsDisplay-small.gif" width=298 height=348></td>
@c </tr></table>
@end ifnotinfo

@table @strong
@item File menu

The @command{Load file} menu option brings up a file browser that you
can use to select another @file{.inv} file.  The @command{Quit} menu
options lets you quit the Tree GUI.

@item Program point tree
The top part of the Invariants Display consists of the Program point
tree --- a hierarchy of program points broken down by class and method.
Click on various program points in the tree to see tables of invariants
for those program points.  You may use the @key{Ctrl} and @key{Shift}
keys to make an arbitrary selection of program points.  Selecting a
class or method automatically selects all the program points
associated with that method or class.

@item Invariant tables
Invariant tables that display the actual invariants appear at the bottom
of the Invariants Display.

@itemize @bullet
@item
Use @key{Alt} along with the @key{up} or @key{down} arrow keys to scroll
by a table at a time.
@item
Sort a column in a table by clicking on the column header.  Shift-click
to sort the column in reverse order.
@end itemize

@end table

@node    Control panel,  , Invariants Display, Tree GUI
@subsection Control panel

The Control Panel determines which invariants are displayed.
@c As of 2/2002
(This picture of the Control Panel is slightly out of date; it needs to
be updated.)

@c Force a paragraph break so the image is on its own line.
@*

@ifnotinfo
@c @ifhtml
@c <p>
@c @end ifhtml
@image{images/gui-ControlPanel,3in,}
@c <center><table><tr><td>
@c <img src="gui-ControlPanel.gif" width=411 height=425>
@c </td></tr></table></center><p>
@end ifnotinfo


@menu
* Property filters::            
* Variable filters::            
@end menu

@node    Property filters, Variable filters, Control panel, Control panel
@subsubsection Property filters

Property filters narrow down the list of invariants that are displayed.
You can adjust which Property filters are being applied.  By default,
all Property filters are enabled.  Daikon supports the following
property filters:

@table @var

@item Suppress controlled invariants

A controlled invariant is an invariant that is "controlled" --- or
implied --- by another program point.  For example, for Java instrumented
code each class is associated with an object program point, which
contain invariants that are found at the entry and exit of all public
methods.  So in addition to the usual program points such as
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, daikon outputs invariants for the
artificial program point @code{StackAr:::OBJECT}.  The invariants for
@code{StackAr:::OBJECT} control the invariants for
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, because the former imply the latter.
Because of this redundancy, controlled invariants are not displayed by
default.  Note that if for some reason, the controlling invariant is not
displayed (for example, because it's unjustified), then the controlled
invariant @emph{will} be displayed.

@item Suppress implied postcondition invariants

Implied postcondition invariants are invariants involving @code{orig()}
variables that exist as precondition invariants.  For example, say that
@code{StackAr.isEmpty():::ENTER} has the invariant ``x==y''.  Then in
@code{StackAr.isEmpty():::EXIT48}, the invariant ``orig(x)==orig(y)''
is an implied postcondition invariant and will not be displayed by
default.

@item Suppress invariants containing non-canonical variables

For many program points there are sets of variables that are equal to
each other.  When this happens, one variable from the set is chosen to
be the canonical variable.  This filter hides invariants involving the
remaining non-canonical variables, because they are implied by
invariants involving the canonical variable.

@item Suppress invariants containing only constants

This filter suppresses invariants containing only constants.

@item Suppress invariants with few modified samples

This filter suppresses invariants with a relatively few number of
modified samples.  An example of such an invariant would be the
following: ``x >= 5'', where ``x'' is observed to be 5 three times
and 10 five times.  The observed values of @code{x} --- i.e., the samples of
@code{x} --- did not change enough for Daikon to be confident that this
invariant is an actual invariant.

@item Suppress obvious invariants

This filter suppresses invariants because they are obvious from looking
at other invariants.  Some examples are:

@itemize @bullet

@item If ``size(args[])==0'' is shown, then ``size(args[])-1==-1'' is
obvious and will not be displayed by default.
@item If ``this.topOfStack < size(this.theArray[])-1'' is shown, then
``this.topOfStack < size(this.theArray[])'' is obvious and will not be
displayed by default.
@end itemize

@item Suppress obvious equality invariants

Like ``Suppress obvious invariants'', but applies only to equality
invarians fo the form ``x==y''.

@item Eliminate invariants based on Simplify

Daikon can use the Simplify theorem-prover to eliminate even more
implied invariants than Daikon's built-in tests are able to eliminte.
Simplify must be separately obtained (from
@url{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to take advantage of this filter.

@item Suppress unjustified invariants

For every invariant, Daikon estimates the probability of that invariant
happening by chance.  If that probability is less than the limit, then
the invariant is deemed to be an actual invariant, not just a chance
occurrence.  Currently the limit is .01%.  So by default, only invariants
with probabilities of less than .01% are shown.

@end table

@node    Variable filters,  , Property filters, Control panel
@subsubsection Variable filters

Variable filters let you display only the invariants that contain
certain variables.  The left-hand box displays the variables that you
are interested in.  By default, the box is empty and invariants containing
any variables are displayed.  There are two ways to add variables to the
variables list:
@enumerate
@item 
Type the name of the variable into the @command{Add variable}
textfield, and click the @command{Add variable} button (or just press
@key{enter}).
@item
Each Invariant table in the Invariants Display has a @command{Show
variables} button.  Click on that button to see a list of variables for
that program point.  Select any set of variables and click the
@command{Filter on selected variables} button.
@end enumerate

To remove variables from the variables list, select the variables in
question and click on the @command{Remove selected
variables} button.

If you click on the @command{any variable} checkbox,
invariants are displayed if they contain any of the variables in the
variables list.  If you click on the @command{all
variables} checkbox, invariants are displayed if they contain all
of the variables in the variables list.



@node    Context GUI,  , Tree GUI, GUIs
@section Context GUI
@cindex Context GUI
@cindex GUI, context

The Daikon Context GUI displays invariants for the Java or C code displayed
in a text editor or code browser; as the cursor moves, the invariant
display is updated.

@c Force a paragraph break so the image is on its own line.
@*

@ifnotinfo
@c @ifhtml
@c <p>
@c @end ifhtml
@image{images/context-gui,5in,}
@c <center><table><tr><td>
@c <img src="context-gui.gif" width=411 height=425>
@c </td></tr></table></center><p>
@end ifnotinfo

Currently, the Context GUI is integrated with the Emacs text editor.
However, users can extend it to other Java or C editors.  The Context GUI can
also be run stand-alone. This provides the user the ability to browse
the invariants without having to load up the text editor in case the
user wants to do a quick lookup on invariants.

The Daikon Context GUI was written at UCSD by Greg Jay (gjay@@ucsd.edu)
and Bill Griswold (wgg@@cs.ucsd.edu).

@menu
* Context GUI with Emacs::      
* Context GUI project root directory::  
* .dci files::                  
@end menu

@node    Context GUI with Emacs, Context GUI project root directory, Context GUI, Context GUI
@subsection Running the Context GUI with Emacs
@cindex Emacs, with Context GUI

In order to use the Context GUI, perform the following steps:
@enumerate
@item
Use the Daikon invariant detector to create a @file{.inv} file containing the
invariants.
@example
  java daikon.Daikon -o foo.inv decl-files... trace-files...
@end example

@item
To load up the @file{.inv} files into the Context GUI do one of the
following:
@itemize @bullet
@item
Put the @file{.inv} files in the same directory as the file Emacs is visiting
when you invoke @kbd{M-x daikon-context-gui} (if the project root directory is
changed, this will not happen), or
@item
Change the project root directory where the Context GUI
searches for @file{.inv} files (see below), or
@item
Add the file by hand using the menu option on the Context GUI.
@end itemize

@item
Start the Context GUI by typing @kbd{M-x daikon-context-gui}
while visiting a Java or C file in Emacs. To start the GUI standalone enter
on the command prompt
@example
  java daikon.gui.contextGUI.ContextGUI
@end example
@end enumerate


@node    Context GUI project root directory, .dci files, Context GUI with Emacs, Context GUI
@subsection Changing the Project Root directory for finding .inv files
@cindex project root directory, for Context GUI

When the Context GUI starts, it automatically loads @file{.inv}
files from the directory specified by the
@samp{daikon-context-gui-project-root-directory} defcustom variable.  If
none has been specified, daikon-context-gui will load files from the
current directory.  You can set
@samp{daikon-context-gui-project-root-directory} in your @file{.emacs}
file or your JDE @file{prj.el} file:
@example
   (custom-set-variables '(daikon-context-gui-project-root-directory '("@var{PATH}")))
@end example

Alternately, you may set it via the Emacs customization editor:
@enumerate
@item
Invoke the Emacs customization editor.  Either
       1a) Type @kbd{M-x customize}
     or
       1b) Click Help on the menu bar,
           Then Customize->Browse Customization Groups
@item
Expand the Programming Subgroups
@item
Click on the Tools Group
@item
Search for Daikon GUI and then click on Go To Group
@item
Edit the field Daikon Gui Project Root Directory to the
     desired path, in quotes
@end enumerate

@node    .dci files,  , Context GUI project root directory, Context GUI
@subsection .dci files
@cindex .dci files, for Context GUI
@cindex dci files, for Context GUI

The Context GUI creates @file{.dci} files as a preprocessing system for
the program when it reads in the @file{.inv} files. This is done so that
the @file{.inv} files do not have to be processed every time, therefore
saving time for people on slow computers/connections. However, the files
are not created every time, but only done when the @file{.inv} is
changed. If you are experiencing problems, you should try deleting the
@file{.dci} file with the convention of @file{.@var{filename}.dci}. If
you would like to run the conversion before starting up the program,
reducing load up time, then use the ConvertInvToDci Java program:

@example
  java daikon.gui.contextGUI.ConvertInvToDci file.inv
@end example

@node    Front ends, Enhancing Daikon output, GUIs, Top
@chapter Front ends


@menu
* Java front end dfej::         
* C/C++ front end dfec::        
@end menu

@node    Java front end dfej, C/C++ front end dfec, Front ends, Front ends
@section Java front end dfej

@cindex front end for Java
@cindex Java front end
@cindex dfej (Daikon front end for Java)

This section contains details about dfej, the Daikon front end for Java.

For brief information about running dfej, see @ref{Instrumenting Java programs}.
For information about installing dfej, see @ref{Installing dfej}.
The @command{dfej} usage message also contains some usage information;
run @command{dfej --help} to see it.

@command{dfej} works on Java code that corresponds to any version of
the Java language, from 1.0 to 1.3.

The Daikon front end for Java has two effects:
@itemize @bullet
@item
  dfej writes instrumented versions of the files, by default in directory
  @file{daikon-instrumented/}
@item
  dfej creates declaration files named
  @file{@var{filename1}.decls}, etc., by default in directory
  @file{daikon-output/}
@end itemize


@menu
* dfej options::                
* Scope of instrumentation::    
* Refined runtime types::       
@end menu

@node    dfej options, Scope of instrumentation, Java front end dfej, Java front end dfej
@subsection dfej options

The simplest way to invoke dfej is simply to supply it a list of Java files:
@example
      dfej @var{filename1}.java @var{filename2}.java @var{...}
@end example

dfej also accepts the following options, which should be provided before
the first Java file name.

@c The options can be divided into the following
@c categories:
@c @table @b
@c @item where (in what directory) to produce output
@c 
@c @end table

Details of the options are as follows:

@table @t
@item -daikon_debug
Produce debugging information.

@item -daikon_depth=@var{n}
Depth to which to examine structure components (default 2).
This parameter determines which variables dfej causes to be output at
runtime.  For instance, suppose that a program contained the following
data structures and variables:
@example
  class A @{
    int x;
    B b;
  @}
  class B @{
    int y;
    int z;
  @}
  A myA;

  class Link @{
    int val;
    Link next;
  @}
  Link myList;
@end example
@itemize @bullet
@item
If depth=0, only the identities (hashcodes) of @code{myA} and
@code{myList} would be examined; those variables could be determined to
be equal or not equal to other variables.
@item
If depth=1, then also @code{MyA.b}, @code{myList.next}, and the integers
@code{myA.x} and @code{myList.val} would be examined.
@item
If depth=2, then also @code{MyA.b.y}, @code{MyA.b.y},
@code{myList.next.next}, and @code{myList.next.val} would be examined.
@end itemize

Values that do not exist are not examined.  For instance, if @code{myA}
is @code{null} on a particular execution of a program point, then
@code{myA.b} is not accessed on that execution regardless of the depth
parameter.

@item +daikon_functions
Produce data trace output at function entry/exit (default).

@item -daikon_functions
Do not produce data trace output at function entry/exit.

@item +daikon_classes
Produce data trace output for class invariants (default).

@item -daikon_classes
Do not produce data trace output for class invariants.

@c @item +daikon_loops
@c Produce data trace output for loop invariants.
@c @emph{This option has no effect:  loop invariants are not currently supported.}
@c 
@c @item -daikon_loops
@c Do not produce data trace output for loop invariants (default).

@item -daikon_omit=@var{string}
Do not produce data trace output for matching classes/functions.  This
reduces the size of the data trace file and also may make the
instrumented program run faster, since it need not output those variables.

The @option{-daikon_omit} argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its class, fully qualified function name, or complete program point
name exactly matches one of the omitting criteria.

For example, to avoid detecting invariants over an iterator class, you
can call dfej like so:
@example
  dfej '-daikon_omit=HashSetLinear$HslIterator' HashSetLinear.java
@end example

As another example, to avoid detecting invariants over a particular
method, you could use:
@example
  dfej '-daikon_omit=StackAr.topAndPop()Ljava/lang/Object;' StackAr.java
@end example

Finally, to avoid detecting invariants at a particular program point,
try:
@example
  dfej '-daikon_omit=StackAr.<init>(I)V:::EXIT33' StackAr.java
@end example

The argument is treated as a literal string by default.  However, if
surrounded by a forward slash (/) on either side, it is interpreted as a
regular expression.

For example, to avoid detecting invariants over all classes in package
daikon.util, you can call dfej like so:
@example
  dfej '-daikon_omit=/^daikon\.util\..*/' *.java
@end example


@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
@cindex DTRACEAPPEND environment variable
@cindex environment variable DTRACEAPPEND
@item -tracefilename=@var{filename}
Specifies the default name for the @file{.dtrace} file (default
@file{daikon-output/@var{CLASSNAME}.dtrace}).  The filename is relative
to the current directory at runtime, or is absolute.  If the DTRACEFILE
environment variable is set when the instrumented program is run, it
overrides this default.  Furthermore, if the DTRACEAPPEND environment
variable is set to any value, the dtrace file will be appended to
instead of overwritten.  Compressed data trace files may not be appended
to.  In some cases you may find a single large data trace file more
convenient; in other cases, a collection of smaller data trace files may
give you more control over which subsets of runs to invoke Daikon on.

@item -declsfiledir=@var{decldir}
Specifies the directory in which to create
@file{@var{PACKAGES}/@var{CLASSNAME}.decls} (default
@file{daikon-output}, unless @option{-declsfiledirflat} is
specified).  @var{PACKAGES} is the relative path from the current
directory to the source file; that is, the relative path from
@var{decldir} to the @file{.decls} file is the same as the relative
path from the current directory to the source file.  The directory
structure of the @file{.decls} files mirrors the directory structure of
the source files.

@item -declsfiledirflat=@var{decldir}
Specifies the directory in which to create @file{@var{CLASSNAME}.decls}
(no default).  All @file{.decls} files appear in the same directory.

@item -instrsourcedir=@var{instrdir}
Specifies the directory in which to write instrumented source files
(default @file{daikon-instrumented/}).  The instrumented files have the
same names and directory structure as the original input files.

@c not yet implemented for dfej as of 6/13/2001
@c If the value of this field is @samp{.} (i.e., a single period), then
@c instrumented files replace the original versions in the original
@c directories, but the original source files are backed up by appending
@c @file{.uninst}.  More specifically,
@c @enumerate
@c @item each instrumented file is copied from @file{filename} to
@c @file{filename.uninst}, unless filename @file{filename.uninst} already
@c exists, in which case no copying occurs
@c @item the system reads from @file{filename.uninst} and writes to
@c @file{filename}.
@c @end enumerate
@c This behavior permits in-place instrumentation, which may be desirable
@c to ease compiling the instrumented code.  (This feature is probably more
@c important for C/C++ than for Java programs.)  Running the instrumenter a
@c second time reads the original source code rather than inserting an
@c additional set of instrumentation into the already-instrumented source
@c code files.

@quotation
Note for Java:

If you do not override the default value of this variable (and possibly
even if you do, if you do not set it to @samp{.}), then you should run
@command{dfej} from a directory in your classpath.  For example, if
directory @file{parent/} is in your classpath and you want to instrument
@file{parent/foo/Bar.java}, you should run @samp{dfej foo/Bar.java} from
directory @file{parent/}.  This will create a file
@file{parent/daikon-instrumented/foo/Bar.java}.  You must add directory
@file{parent/daikon-instrumented} to your classpath.

(The reason for running @command{dfej} from a directory in your
classpath is that it allows the directory structure to remain consistent
with the package structure. If @file{Bar.java} specifies its package, it
does so with a line like @samp{package foo;}.  If you run @command{dfej}
from the @file{parent/foo} directory, the instrumented version of
@file{Bar.java} will go in @file{parent/foo/daikon-instrumented/Bar.java}; this
is not consistent with the package structure.)
@end quotation

@item -noajax
@cindex AJAX_DIR environment variable
@cindex environment variable AJAX_DIR
Do not use Ajax.  Ordinarily, the Ajax module
"ComparablePairsDescFileReader" updates the variable comparability
information in the @file{.decls} file.  The comparability information
can indicate which variables should not be compared to one another.
(For instance, the number of people that a recipe serves should not be
compared to the page number in a cookbook where the recipe is found,
even if both are integers.)  Use of Ajax to update this information is
entirely optional; its effect is to suppress invariants over incomparable
variables.  These comparisons are usually  nonsensical, so using Ajax makes
Daikon report fewer irrelevant invariants.

Use of Ajax requires environment variable AJAX_DIR to be set to a
directory containing various Ajax helper files (such as
@file{main-harness.csal}, @file{tweaked-classes.zip}, etc.).  The proper
directory is @file{java/ajax-ship} in the Daikon distribution and is set
by the provided @file{daikon.cshrc} and @file{daikon.bashrc}
initialization files.

@item -ajaxap=@var{apdir}
This is the directory in which the Ajax comparability module looks
for @file{.class} files for the current application.  (It is a classpath
entry, so the @file{.class} files might appear in a subdirectory named
for the appropriate package.  If this option is not supplied, the
@option{-classpath} argument is used.  A sensible value is required for
code that (for example) calls libraries that do not appear under the
current directory.

@item -ajaxap=@var{apdir}
Classpath to give to Ajax in its "-cp" flag, similar to -ajaxap.

@item -ajax_runnable=@var{class}
This is a Java class, in dot-delimited form (e.g., "foo.bar.Baz"), that
contains a @samp{public static void main(String[])} method.  This class
need not be one of the instrumented ones.  If it is not supplied, the
first instrumented class with such a @samp{main} method is used instead.

@c @item -ajax_runnables=@var{classes}
@c This is a whitespace-separated list of Java classes, in dot-delimited
@c form (e.g., "foo.bar.Baz"), that contain @samp{public static void
@c main(String[])} methods.  Those Java classes need not be among the
@c instrumented ones.  In addition, all such @samp{main} methods in the
@c instrumented classes are also used as entry points.  In order to run,
@c Ajax requires the name of at least one runnable class.
@c (Actually, Ajax requires the name of exactly one runnable class.)
@c 
@c @item -ajax_all_runnables=@var{classes}
@c Just like @option{-ajax_runnables}, except that no @samp{main} methods
@c in the instrumented classes are used as entry points.

@item -ajaxdumpdir=@var{dumpdir}
This is the directory in which the Ajax comparability module writes its
log file, named @file{ajax.log}.  By default, @file{ajax.log} is written
to the current directory.

@end table

When conflicting options are specified (for instance, both
@option{+daikon_functions} and @option{-daikon_functions}, or both
@option{-declsfiledir} and @option{-declsfiledirflat}), the last one
takes precedence.


@node    Scope of instrumentation, Refined runtime types, dfej options, Java front end dfej
@subsection Controlling what classes are instrumented

Only the specified Java files are instrumented; other files are
run uninstrumented.  This permits you to control the scope of invariant
detection.

In any of the specified files, all classes defined in any of those
files are instrumented.  For instance, after
@example
dfej Foo.java Bar.java
@end example
@noindent
the instrumented versions of @file{Foo.java} and @file{Bar.java} output
information about all Foo objects (including Foo objects that are
components of Bar objects, that are arguments to Bar functions, etc.),
and likewise for Bar objects.

After
@example
dfej Foo.java
dfej Bar.java
@end example
@noindent
the same functions (all those in the @file{Foo} and @file{Bar} classes)
are instrumented, but in Foo functions, no detail is provided
about the structure of any Bar objects that might appear.  In other
words, the instrumenter assumes that the only classes instrumented (and
about which information is desired) are those presented to it on the
command line.  One way to determine all the @file{.java} files that are
included in a specified program is to run the following commands:
@example
find . -name '*.class' -print | xargs rm -f
javac MyProgram.java
find . -name '*.class' -print
@end example

@command{dfej} tracks all modifications of instrumented classes; if you
do not instrument all users of a class, then modifications in
uninstrumented classes may not be detected.  This can affect Daikon's
statistical tests, but in practice usually has little impact. The program 
makes approximations to the missing modification information.

@c (The @command{modbit-munge.pl} script makes approximations to the missing
@c modification information.


@node    Refined runtime types,  , Scope of instrumentation, Java front end dfej
@subsection Refined runtime types

Daikon uses the declared types of variables to determine what fields
those variables have and what methods may be legally applied to those
variables.  However, sometimes the declared type is excessively general:
the runtime value may be guaranteed to be of a more specific type.  This
often results from use of polymorphic datatypes or methods.  For
instance, a Java variable may be declared as @code{Object} even though
it always holds an @code{Integer}.  In that case, methods such as
@code{intValue} may be safely called on the object, even though it is
not applicable to arbitrary @code{Object}s.

You can indicate the runtime type of a variable to dfej by inserting a
@example
  /*refined_type: Integer*/ 
@end example
@noindent
comment immediately before the declared type (but after any modifiers like
"public" or "static").  For example, a list element that only contains
@code{Integer}s might be annotated as follows:
@example
  class ListNode @{
    /*refined_type: Integer*/ Object element;
    ListNode next;

    ListNode( /*refined_type: Integer*/ Object theElement ) @{ ... @}
    ListNode( /*refined_type: Integer*/ Object theElement, ListNode n ) @{ ... @}
  @}
@end example



@c 
@c <hr>
@c <h1><a name="manifest">Manifest (list of files in the distribution)</a></h1>
@c 
@c @example
@c User documentation
@c   daikon.html		This file; the main Daikon documentation
@c   README		Says to see daikon.html instead
@c   daikon.gif		The Daikon logo
@c 
@c Java front end
@c   java-front-end/	A modified version of the <a href="http://oss.software.ibm.com/developerworks/opensource/jikes/project/">Jikes Java compiler</a>
@c     src/                Source code
@c       dfej              The main executable (Daikon front end for Java);
@c                           you must build this yourself (see <a href="#build-dfej">instructions</a>)
@c 
@c C front end
@c   c-front-end/
@c     dump_trace.c	Writing data values to a data trace
@c     dump_trace.h	Header files for the above
@c     Makefile-sample	Sample Makefile for linking in the above
@c     dfec		Script for instrumenting C files (you also
@c                           need the edgcpfe executable; see "<a
@c                           href="#install">Installing Daikon</a>")
@c     dfec.sh		Version of dfec written in shell script, not Perl
@c     label.txt		Auxiliary file for output filename selection at runtime
@c 
@c Invariant detector
@c   java/			Source code for Daikon, which is written in Java
@c     Daikon.java         The entry point for Daikon
@c 
@c Auxiliary programs
@c   bin/			Helper scripts and programs
@c 
@c Miscellaneous files
@c   Makefile		Makefile for the invariant detection system
@c   VERSION		Timestamp of this distribution
@c   dtrace-format.txt	Documentation of the trace file format; somewhat old
@c   daikon-python/        An old version of Daikon, written in Python.
@c   			  The current version does not require Python.
@c @end example



@node    C/C++ front end dfec,  , Java front end dfej, Front ends
@section C/C++ front end dfec

@cindex front end for C/C++
@cindex C/C++ front end
@cindex dfec (Daikon front end for C/C++)


This section contains details about dfec, the Daikon front end for C/C++.
For brief information about running dfec, see @ref{Instrumenting C/C++ programs}.
For information about installing dfec, see @ref{Installing dfec}.

Recall that dynamic invariant detection over a C/C++ program requires
three steps:
@enumerate
@item
Run dfec, creating an instrumented version of the program and a
declaration file.
@item
Run the instrumented program, creating data trace files.
@item
Run Daikon on the declaration files and data trace files.
@end enumerate

This section discusses the steps in more detail, with an emphasis on the
first step.

@c The three crucial files are @command{dfec}, 
@c @file{daikon_runtime.h}, and 
@c @file{daikon_runtime.o}.

To instrument a C file, run @command{dfec} on it.  dfec produces
instrumented source as well as a @file{.decls} file.  dfec must be run
on all source files, including any header files that contain
code or definitions to be instrumented (header files typically end in
@file{.h}).  All files to be included
in a single executable must be instrumented simultaneously; for example,
@example
  dfec file1.c file2.c file1.h file2.h
@end example

Even if you do not wish to detect invariants in one of the files, it must be run
through dfec so it can correctly interact with the instrumented versions
of the other files.  @xref{dfec command-line arguments},
for instructions on how to exclude files from instrumentation.

Running @command{dfec @var{arguments} myprog.c} creates
a file named @file{myprog.cc} in the @file{daikon-instrumented/}
directory.  (It has a @file{.cc} extension, regardless of its original
extension.)  It also creates a file named @file{myprog.decls}, which
appears in the @file{daikon-output/} directory by default.  To change
these defaults, see @ref{dfec command-line arguments}.


@c Before compiling the instrumented program, either copy or link
@c @file{daikon_runtime.h} and @file{daikon_runtime.o} from
@c @file{daikon/front-end/c/} to the current directory.  (See
@c @ref{Installing dfec}, for details on creating @file{daikon_runtime.o}.)
@c @example
@c   cp -p $DFECDIR/daikon_runtime.h $DFECDIR/daikon_runtime.o .
@c @end example

Compile the instrumented program in the usual way, except that the link
step should include @file{daikon_runtime.o}, and the compiler should be
@command{g++}, since the instrumented files are C++ files.
For instance,
@example
  gcc -g -o @var{exefile} myprog.c
@end example
@noindent
would become
@example
  g++ -g -o @var{exefile} daikon-instrumented/myprog.cc $DFECDIR/daikon_runtime.o
@end example

@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
Now you can run your executable in the usual way.  Running the
executable creates a @file{myprog.dtrace} file.  By default, this file
appears in @file{daikon-output/}, and subsequent runs overwrite to that
file.  This default can be overridden via the @option{--tracefilename}
argument to dfec or the DTRACEFILE environment variable at runtime.

Given the @file{myprog.decls} file that dfec created and the
@file{myprog.dtrace} file that running the instrumented program created,
you can run Daikon:
@example
  java daikon.Daikon daikon-output/myprog.decls daikon-output/myprog.dtrace
@end example

@menu
* dfec command-line arguments::  
* Pointer type disambiguation::  
* Uninitialized array elements::  
* dfec requirements::           
@end menu

@node    dfec command-line arguments, Pointer type disambiguation, C/C++ front end dfec, C/C++ front end dfec
@subsection dfec command-line arguments

This section describes dfec's command-line options.
@table @option

@item -I@var{path}
Adds @var{path} to the end of the system include path.  The system
include path that @command{gcc} uses is automatically detected by dfec,
so you should not have to use the @option{-I} option unless you wish to
use additional include
paths or @command{gcc} defaults to using header files
that cannot be processed by @command{dfec}.
For example,
@example
  dfec -I/usr/local/.../2.95.3/include myprog.c
@end example
@c  @noindent
@c  To determine your system include path, run
@c  @example
@c  touch searchpath.cc; gcc -v -E searchpath.cc > /dev/null; rm searchpath.cc
@c  @end example
@c  @noindent
@c  and look for what follows "@samp{#include <...> search starts here:}".


@c [this is deprecated - we want the c++ searchpath only.]
@c For instance, on
@c Unix run one of these commands, depending on whether you want the C or
@c C++ search path:
@c @example
@c touch searchpath.c; gcc -v -E searchpath.c > /dev/null; rm searchpath.c
@c touch searchpath.cc; gcc -v -E searchpath.cc > /dev/null; rm searchpath.cc
@c @end example


@item -D@var{macro}=@var{value}
Defines the preprocessor macro @var{macro} to be @var{value}.
@c    For example,
@c  to get dfec to correctly traverse the include files on our system, we use
@c  @example
@c    dfec @var{...includepath...} -D__GNUG__=1 -D__null=0
@c  @end example


@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
@cindex DTRACEAPPEND environment variable
@cindex environment variable DTRACEAPPEND
@item --tracefilename=@var{filename}
Specifies the default name for the @file{.dtrace} file (default
@file{daikon-output/@var{myprog}.dtrace}, where @file{@var{myprog}.c} is
the instrumented program file that contains the main() function).
A relative filename is interpreted with respect
to the current directory at runtime, not at compile time.
If the DTRACEFILE environment
variable is set (to a file name) when the instrumented program is run,
it overrides the default specified by this flag.  Furthermore, if the DTRACEAPPEND environment
variable is set to any value at runtime, the dtrace file is appended to
instead of overwritten, which can be handy if you have a script to run
the instrumented program multiple times.

@item --declsfiledir=@var{decldir}
Specifies the directory in which to create
@file{@var{PATH}/@var{myprog}.decls} (default
@file{daikon-output/}, unless @option{--declsfiledirflat} is
specified).  @var{PATH} is the relative path from the current
directory to the source file; that is, the relative path from
@var{decldir} to the @file{.decls} file is the same as the relative
path from the current directory to the source file.  The directory
structure of the @file{.decls} files mirrors the directory structure of
the source files.

@item --declsfiledirflat=@var{decldir}
Specifies the directory in which to create @file{@var{myprog}.decls}
(no default).  All @file{.decls} files appear in the same directory.

@item --instrsourcedir=@var{instrdir}
Specifies the directory in which to write instrumented source files
(default @file{daikon-instrumented/}).  The instrumented files have the
same names and directory structure as the original input @file{.c} or @file{.cc} files, with the
slight exception that the file suffix is always set to @file{.cc}, so if you
instrument @file{@var{myprog}.c}, you will end up with
@file{daikon-instrumented/@var{myprog}.cc}.  Header files (files with a @file{.h} extension) are textually substituted into the instrumented @file{.cc} files, so they do not appear in the instrumented source directory.  If @var{instrdir} is ``.'',
then instrumentation is performed in-place, first copying the source
file @file{myprog.c} to @file{myprog.c.uninst}, then overwriting
@file{myprog.c} with instrumented source.  If @file{myprog.c.uninst}
already exists, it is left in place:  the copy step is not performed.
This is useful in situations with Makefiles that you don't want to
change, or when compiling a system requires many files to be in place.


@item --disambigfilename=@var{filename}
Specifies the filename for the pointer type disambiguation file
(@pxref{Pointer type disambiguation}).  If
this file exists, dfec uses it
to make decisions about how to output the referents of pointer
variables.  If the file does not exist, dfec creates it,
specifying default instrumentation behavior for all
pointer types.  It may then be edited and used on subsequent runs.

@item --disambig
Tells dfec to create or read pointer type disambiguation with the default filename,
which is @file{@var{myprog}.disambig} in the same directory as the
@file{.decls} file.  For more information, see
@ref{Pointer type disambiguation}.

@item -l
This is the only command-line switch that can be used in the midst of the
list of filenames.  It precedes a file that should not be instrumented.
For instance, if you have two source files, @file{file1.c} and @file{file2.c},
and each has its own header file, but you don't want to instrument the
functions defined in @file{file2.c}, you would instrument as follows:
@example
  dfec file1.c -l file2.c file1.h file2.h
@end example

@item --help
Displays a usage message.

@item --no-lackwit
Turns off Lackwit postprocessing of the @file{.decls} file.  You can also
turn off Lackwit postprocessing by unsetting the LACKWIT_HOME environment
variable.

@item --struct-depth=@var{N}
For nested or recursive types (structs or classes that have members that
are also structs or classes), this argument specifies how deep to instrument.
For example, given a simple linked list structure as follows:
@example
struct node @{
  struct node *next;
  int val;
@} list;
@end example
@noindent
Setting the struct instrumentation depth to 1 would cause the runtime
library to output @var{node.val} and @var{node.next}.  Setting the
struct instrumentation depth to 2 would cause the runtime library to
output @var{node.val}, @var{node.next}, @var{node.next->val}, and
@var{node.next->next}.  The default instrumentation depth is 3, which
allows Daikon to capture invariants about nonadjacent nodes, but results
in larger dtrace files than smaller values do.

@end table

When conflicting options are specified (for instance, both
@option{--declsfiledir} and @option{--declsfiledirflat}), the last one
takes precedence.

@node    Pointer type disambiguation, Uninitialized array elements, dfec command-line arguments, C/C++ front end dfec
@subsection Pointer type disambiguation

@cindex pointer type disambiguation
@cindex disambiguation of pointer types

dfec permits users (or external analyses) to specify whether pointers
refer to arrays or to single values.  For example, in
@example
void sum(int * array, int * result) @{ ... @}  // definition of "sum"
...
int a[40];
int total;
...
sum(a, &total);        // use of "sum"
@end example
@noindent
the first pointer parameter refers to an array while the second refers to
a single value.  dfec (and Daikon) should treat these values
differently.  For instance, @code{*array} is better printed as @code{array[0]},
and @code{result[]} isn't a sensible array at all.  By default, dfec treats
all pointers as referencing arrays.  Eliminating unnecessary array
variables --- in this case, preventing Daikon from treating @code{result} as a
single-element array --- can speed up Daikon and improve its output.
(See the example below.)

Information about whether each pointer refers to an array or a single
element can be specified in a ``disambig file'' that resides in the
same directory as the decls file.  The @option{--disambig} option
instructs dfec to read this file.  (dfec can also produce the file
automatically, permitting users to edit it for use on subsequent runs,
rather than having to create it from scratch.)  The disambig file
lists all the instrumented program points, and under each, a list of
all the variables in scope at that program point, along with the types
that the variables are instrumented as.  For pointer variables, there
are two options:  @samp{A} for array, and @samp{P} for pointer to
single value.  For variables of type @code{char}, there are two
options:  @samp{I} for integer (i.e., numerical value), and @samp{C}
for character.  This allows you to choose whether a @code{char}
variable refers to an ASCII character or a short numerical value that
mathematical invariants should be calculated over.

The disambig file contains an entry for each program point and for every
user-defined class or struct in instrumentation scope.  Members of structs
or classes can be disambiguated just like variables at a program point.
These entries must appear in the order that they are defined in program
source --- even though there are names in the disambig file, they are there
only for human reference, and if the source code is modified in a manner
that rearranges function or class definitions, then the disambig file will
need to be regenerated by dfec, and re-edited to produce the correct
disambiguation.  Because of this, is it not recommended to use disambig
files generated by external programs until later versions of dfec, when
the disambiguation mechanism is more robust.



@c This isn't really relevant to users of Daikon, though it is quite
@c interesting from an implementation point of view.
@c A C/C++ pointer type is output to the decls and dtrace files in two
@c ways: firstly, as the memory address it points to (the equivalent of the
@c java hashcode), and secondly, its contents.  By default, the
@c contents of an array or pointer type is the list of values pointed to by
@c the pointer variable.  The Daikon runtime library keeps track of all
@c pointer variables, and notes what the highest referenced value beyond a
@c base is, and assumes that all values between the base and that are
@c valid.  Then, when outputting to the decls and dtrace files, it outputs
@c the full list of ``known valid'' values.  In addition to this, there are
@c certain safety features built into the Daikon runtime library, such as
@c bounds-checking on arrays that have been declared with static size.
@c However, not all pointers point to arrays; many are simply pointers to
@c single elements.


@menu
* Pointer type disambiguation example::  
@end menu

@node    Pointer type disambiguation example,  , Pointer type disambiguation, Pointer type disambiguation
@subsubsection Pointer type disambiguation example

Consider this file:

@example
  void foo(int *bar) @{
    (*bar)++;
  @}

  int main() @{
    int baz=6;
    foo(&baz);
  @}
@end example

In @code{foo()}, @code{bar} is an @code{int *}.  By default, dfec would
instrument @code{bar} as an array of int, keeping track of how many ints
@code{bar} addressed (in this case, only one), and outputting
@code{bar[]} to the @file{.decls} and @file{.dtrace} files as a
sequence, which yields these invariants:

@example
======================================================================
std.foo(int *;):::ENTER
bar[0] == min(bar[]) == max(bar[]) == sum(bar[])
bar has only one value
bar[] == [6]
bar[] elements == 6
size(bar[]) == 1
======================================================================
std.foo(int *;):::EXIT1
bar == orig(bar)
bar[0] == min(bar[]) == max(bar[]) == sum(bar[])
orig(bar[0]) == min(orig(bar[])) == max(orig(bar[])) == sum(orig(bar[]))
bar has only one value
bar[] == [7]
bar[] elements == 7
orig(bar[]) == [6]
orig(bar[]) elements == 6
size(bar[]) == 1
@end example

This is a bit wordy.  But, by running dfec with the @option{--disambig}
option, we create the @file{daikon-output/@var{myprog}.disambig} file,
which we can then edit and feed back to dfec to change how the pointer
is instrumented.
@example
  dfec @var{...options...} --disambig @var{myprog}.cc
@end example

This creates the @file{daikon-output/@var{myprog}.disambig} file.  It
contains, at the top:

@example
std.foo(int *;)void:::ENTER
bar
A

std.foo(int *;)void:::EXIT1
bar
A
@end example

This means that at the two program points corresponding to the entry and
exit of foo(), the variable bar is instrumented as an @samp{A}rray type.  To
change it so dfec instruments it as a @samp{P}ointer type, change the
two @samp{A} entries to @samp{P} entries:
@example
std.foo(int *;)void:::ENTER
bar
P

std.foo(int *;)void:::EXIT1
bar
P
@end example

Then, running dfec again with the @option{--disambig}
option causes dfec to open the existing
@file{daikon-output/@var{myprog}.disambig} file, reading the definitions
you gave, and changing the instrumentation accordingly:
@example
  dfec @var{...options...} --disambig @var{myprog}.cc
@end example

This means that bar will be instrumented as a @samp{P}ointer to a
single element.  If you compile and run the program, then run Daikon
on the output, you'll see much cleaner invariants:
@example
======================================================================
std.foo(int *;):::ENTER
bar has only one value
*bar == 6
======================================================================
std.foo(int *;):::EXIT1
bar == orig(bar)
bar has only one value
*bar == 7
orig(*bar) == 6
@end example


@node    Uninitialized array elements, dfec requirements, Pointer type disambiguation, C/C++ front end dfec
@subsection Uninitialized array elements

The C/C++ front end keeps track of the maximum read or written element
of each array.  This enables it to avoid outputting (meaningless)
uninitialized elements.  For example, consider the following code:
@example
char * mystring = malloc(100);
strcpy(mystring, "hello");
@end example
@noindent
Even though mystring has 100 elements, only the first six of them are
valid.  dfec will only communicate those first six elements to
Daikon.  After a subsequent operation:
@example
strcat(mystring, ", world");
@end example
@noindent
dfec would communicate 13 elements to Daikon.

dfec tracks all array accesses in the instrumented program, and dfec
also contains special-case handling for certain library routines,
including all the stdc library functions found in @file{string.h}.
However, array accesses in files not supplied to dfec (for instance,
in other library functions) might not be recorded, causing too little
of the array to be output to Daikon.

The rest of this section describes how to add 
other functions can be added to dfec's list of special-case functions.
Suppose system header file @file{<bar.h>} contains a function with signature
@example
  int foo(char *arg1, char *arg2)
@end example
@noindent
Then you would need to do these things:

@enumerate
@item
Add a @code{#include} directive for @file{<bar.h>} to @file{daikon_runtime.cc}.
For clarity, this should go in the section where the other overloaded functions
go.  You can find this section by searching for this text:
@example
/* functions that we're overloading with DAIKON_* implementations: */
#include <string.h>
@end example

@item
Add an instrumented implementation to @file{daikon_runtime.cc}.  This requires
knowledge of how smartpointers and the basemap work.  Typically, the
instrumented implementation calls the normal library function, then
manually adjusts the max_seen pointers in the basemap to their correct values,
based on semantic knowledge about the function itself.  For examples, see
the implementations provided for @file{string.h}.
The signature of the function must be changed in two ways:  the name should
have "DAIKON_" prepended to it, to avoid namespace pollution (the calls are
resolved through a macro definition explained below), and the argument and
return value types must be changed as well to reflect the use of
smartpointers.  In this example, @code{foo()} as above would be declared as
@example
int DAIKON_foo(DaikonSmartPointer<char> arg1, DaikonSmartPointer<char> arg2);
@end example

@item
Add a macro definition and a function declaration to @file{daikon_runtime.h}.
There is a large section of these near the end of the file.  In the case of
@code{foo()} above, we would need to insert:
@example
extern int DAIKON_foo(DaikonSmartPointer<char> arg1, DaikonSmartPointer<char> arg2);
#define foo DAIKON_foo
@end example
You can find the section to add this in by searching for
@example
/* add other user-overloaded functions here */
@end example
Be sure to place the declaration and macro definition before the @code{#endif}
signifying the end of the !COMPILING_DAIKON_RUNTIME block.  If you put the
macro definition outside this block, then the runtime library will fail to
compile.

@end enumerate


@node    dfec requirements,  , Uninitialized array elements, C/C++ front end dfec
@subsection dfec requirements

@menu
* Requirements for instrumented programs::  
* gcc version::                 
@end menu

@node    Requirements for instrumented programs, gcc version, dfec requirements, dfec requirements
@subsubsection Requirements for instrumented programs


Before running @command{dfec}, you should ensure that your code compiles
cleanly.  We recommend that you use @command{gcc -g -Wall}, as
@command{dfec} issues warnings about a number of erroneous C constructs
that @command{gcc} and other compilers accept.

@cindex ANSI C
@cindex K&R C
@cindex C prototypes
@cindex prototypes, C

@command{dfec} only instruments ANSI C programs.  dfec does not
support K&R C or other non-ANSI/ISO C dialects; convert such programs
to ISO C before running dfec.  The @command{protoize} program
(distributed with gcc, among other places) helps to perform this task
by converting K&R prototypes to ANSI prototypes.  Compiling with
@command{gcc -g -Wall} will report many problems with non-ANSI code.
You

@command{dfec} technically only instruments C++ programs.  However,
most ANSI C programs are also legal C++ programs.  Programs that
define symbols that are C++ keywords, such as @samp{bool}, require
that these symbols be changed to another name that does not conflict
with the C++ namespace (for example, @samp{bool} can be changed to
@samp{boolean}).


@c [the following limitation is deprecated as of 7/02/2001.]
@c [global/local/class vars are now scoped with '::', '', and 'this->'.]
@c @c 4/10/2001
@c When a local variable shadows a global variable of the same name, dfec
@c tries to output both to the @file{.dtrace} and @file{.decls} files.  The
@c instrumented C program will run fine, but the local variable will be
@c output twice, and Daikon will issue an error when it is given files
@c containing two variables of the same name.




@node    gcc version,  , Requirements for instrumented programs, dfec requirements
@subsubsection gcc version


@cindex gcc version for use with dfec
@cindex gcc 3
@cindex gcc 2.96

@command{dfec} works with gcc 2.95.3.  It is not known to work with other
compilers or other versions of gcc.  In particular, gcc 3 does not
work, nor does ``gcc 2.96'' (which is not an official gcc release but
appears in some Linux distributions).
You can download gcc 2.95.3 from @url{http://gcc.gnu.org/releases.html}.

gcc is easy to install; see the @uref{http://gcc.gnu.org/install/, ,
GCC installations instructions}.  If you do not wish to read them,
then the following commands may work for you.  They do not require
that you have superuser priviliges on your machine.  They create
directory @file{/tmp/build-gcc-2.95.3}, then build gcc and install
gcc under directory @file{/tmp/build-gcc-2.95.3/gcc-installation}.
You may wish to adjust those directory names.

@example
  cd /tmp
  mkdir build-gcc-2.95.3
  cd build-gcc-2.95.3
  wget ftp://prep.ai.mit.edu/pub/gnu/gcc/gcc-2.95.3.tar.gz
  gunzip gcc-2.95.3.tar.gz
  tar xf gcc-2.95.3.tar
  mkdir gcc-2.95.3-build
  cd gcc-2.95.3-build
  ../gcc-2.95.3/configure --prefix=/tmp/build-gcc-2.95.3/gcc-installation
  make bootstrap
  make install
@end example

To test the installation, do the following:
@example
  which gcc
  gcc -v
  set path = (/tmp/build-gcc-2.95.3/gcc-installation $path)
  which gcc
  gcc -v
@end example

Now you can just use it; "gcc" refers to the new version.  You should
also add the "set path" command to your .cshrc file.  If you use sh or
bash rather than csh, then add the following to your @file{.bashrc} or
equivalent file.
@example
  export PATH=/tmp/build-gcc-2.95.3/gcc-installation:$PATH
@end example


@node    Enhancing Daikon output, Tools, Front ends, Top
@chapter Enhancing Daikon output

@menu
* Configuration options::       
* Conditional invariants::      
@end menu

@node    Configuration options, Conditional invariants, Enhancing Daikon output, Enhancing Daikon output
@section Configuration options

@cindex configuration options
@cindex dkconfig_ variables

Many aspects of Daikon's behavior can be controlled by setting various
configuration parameters.  These configuration parameters control which
invariants are checked and reported, the statistical tests for
invariants, which derived variables are created, and more.

The configuration options are set by creating a configuration file and
supplying it to Daikon on the command line using the @option{--config
@var{filename}} option.  Daikon always first reads the default values in
@file{daikon/java/daikon/config/defaults.txt}, then reads all supplied
configuration files in order, possibly overriding the defaults.  You may
wish to use the supplied default configuration file as an example when
creating your own configuration files (which only need include the
specific configuration options you wish to change).

You may also specify configuration setting directly on the command line,
using the @option{--config_option @var{name}=@var{value}} option.

The debugging flags @option{--debug} and @option{--dbg @var{category}}
(@pxref{Command line options}) permit Daikon to produce debugging
output, but do not affect the invariants that it computes.

@menu
* List of configuration options::  
@end menu

@node    List of configuration options,  , Configuration options, Configuration options
@subsection List of configuration options

This is a list of all Daikon configuration options.
The configuration option name contains the
Java classes in which it is defined.  (In the Daikon source code, the
configuration value is stored in a variable whose name contains a
@code{dkconfig_} prefix, but that should be irrelevant to users.)
To learn more about a specific invariants or derived variables, see
its source code.

@table @asis
@include config-options.texinfo
@end table


@node    Conditional invariants,  , Configuration options, Enhancing Daikon output
@section Conditional invariants and implications
@cindex splitting
@cindex splitting condition
@cindex conditional invariant
@cindex invariant, conditional
@cindex implication invariant
@cindex invariant, implication

Conditional invariants are invariants that are true only part of the time.
For instance, the postcondition for the absolute value procedure is
@example
if arg < 0
  then return == -arg
  else return == arg
@end example
@noindent
The invariant @code{return == -arg} is a conditional invariant because
it depends on the predicate @code{arg < 0} being true.  An
@emph{implication} is a compound invariant that includes both the
predicate and the conditional invariant (also called the consequent).

Daikon must be supplied with the predicate for an implication.  Daikon has
certain built-in predicates that it uses for finding conditional invariants;
examples are which return statement was executed in a procedure and whether a
boolean procedure returns true or false.  Additionally, Daikon can read
predicates from a file called a splitter info (@file{.spinfo}) file and find
implications based on those predicates. The splitter info file can be produced
automatically, such as by the CreateSpinfo and
@command{createspinfo.pl} programs.  Users can also create splitter
info files by hand or manually augment automatically-created ones.

To detect conditional invariants and implications:
@enumerate
@item
Create the splitter info file, either automatically or by hand.
@item
Run Daikon with the @file{.spinfo} file as one of its arguments.  
(The order of arguments does not matter.)
For example,
@example
java daikon.Daikon Foo.decls Foo.spinfo Foo.dtrace
@end example
@end enumerate

@cindex createspinfo.pl program
@cindex CreateSpinfo program

The CreateSpinfo program takes Java source code as input and creates a
splitter info file for each input file; for instance,
@example
java daikon.tools.jtb.CreateSpinfo Foo.java Bar.java
@end example
@noindent
creates the splitter info files @file{Foo.spinfo} and
@file{Bar.spinfo}.  The resulting splitter info file contains each
boolean expression that appears in the source code.  The conditional
statements that the programmer used in the source code are likely to
have important semantic properties.  This simple heuristic of using
these conditional statements as predicates for conditional invariant
detection is often quite effective.  Users may optionally edit the
splitter info file to enhance it, or may create a splitter info file
by hand.

The @command{createspinfo.pl} program (found in the @file{$DAIKONDIR/bin}
directory) performs the same function, for C/C++ source code.  It can be used with the commandline
@example
createspinfo.pl foo.c
@end example
@noindent

The term ``splitter'' comes from Daikon's technique for detecting
implications and conditional invariants.  For each predicate, Daikon
creates two conditional program points --- one for program executions
that satisfy the condition and one for those that don't --- and splits
the data trace into two parts.  Invariant detection is then performed
on the conditional program points (that is, the parts of the data
trace) separately and any invariants detected are reported as
conditional invariants (as implications).


@menu
* Splitter info file::          
* Indiscriminate splitting::    
* Example splitter info file::  
@end menu

@node    Splitter info file, Indiscriminate splitting, Conditional invariants, Conditional invariants
@subsection Splitter info file
@cindex splitter info file
@cindex .spinfo file
@cindex spinfo file

A splitter info file contains the conditions that Daikon should use to
create conditional invariants.  Each section in the @file{.spinfo}
file consists of a sequence of non-blank lines; sections are separated
by blank lines.  There are two types of sections:  program point
sections and replacement sections.
@xref{Example splitter info file}, for an example splitter info file.

@menu
* Program point sections::      
* Replacement sections::        
@end menu

@node    Program point sections, Replacement sections, Splitter info file, Splitter info file
@subsubsection Program point sections

Program point sections have a line specifying a program point name
followed by lines specifying the condition(s) associated with that
program point, each condition on its own line.  For example, a typical
entry is

@example
PPT_NAME @var{pptname}
condition1
condition2
...
@end example
@noindent
@var{pptname} can be any string that matches a part of the desired
program point name as printed in the decls file.  In finding matching
program points, Daikon uses the first program point that matches
@code{pptname}.

Each condition is a Java expression of boolean type.  All variables
that appear in the condition must also appear in the declaration of
the program point in the @file{.decls} file.  (In other words, all the
variables must be in scope at the program point(s) where the Splitter
is intended to operate.) The automatically generated Splitter source
code fails to compile (but Daikon proceeds without it) if a variable
name in a condition is not found at the matching program point.


@node    Replacement sections,  , Program point sections, Splitter info file
@subsubsection Replacement sections

Ordinarily, a splitting condition may not invoke user-defined methods,
because when Daikon reads data trace files, it does not have access to the
program source.  A replace section of the splitter info file can specify
the bodies of methods, permitting conditions to invoke those methods.  The
format is as follows:
@example
REPLACE
procedure1
replacement1
procedure2
replacement2
...
@end example
@noindent
where @samp{replacement@var{i}} is a Java expression for the body
of @samp{procedure@var{i}}.  In each condition, Daikon replaces procedure
calls by their replacements.  A replace section may appear anywhere in
the splitter info file.

@node    Indiscriminate splitting, Example splitter info file, Splitter info file, Conditional invariants
@subsection Indiscriminate splitting

Ordinarily, each condition in an @file{.spinfo} file gives rise to
conditional invariants only at the program point in whose section the
condition appears.  Alternately, every condition can be used at every
program point, regardless of where in the @file{.spinfo} file the
condition appeared; this latter approach is called ``indiscriminate
splitting''.

The advantage of indiscriminate splitting is that a condition that is
useful at one program point may also be useful at another --- if the
same variables are in scope or other variables of the same name are in
scope.  The disadvantage of indiscriminate splitting is that often the
condition is not applicable everywhere, and when it is, it may not be
useful at all such locations, so checking for many conditional
invariants may slow down Daikon without a corresponding benefit. 
Indiscriminate splitting can result in Daikon attempting
to use many conditions that are inappropriate at certain program
points, for instance because the program point does not have (in
scope) all the variables that are used in the condition.  For example,
the condition @code{myArray.length == x} is inapplicable at a program
point if either of @samp{myArray} and @samp{x} is not in scope at that
program point.  In this case, Daikon prints a warning message and
proceeds, using conditions wherever they are valid.

By default, Daikon uses indiscriminate splitting.  To use
non-indiscriminate spliting, place the following line in a file that is
passed to Daikon via the @option{--config} flag (@pxref{Command line
options}):
@example
daikon.split.SplitterList.all_splitters = false
@end example


@node    Example splitter info file,  , Indiscriminate splitting, Conditional invariants
@subsection Example splitter info file

Below is an implementation of a simple Queue for positive integers and
the @file{.spinfo} file that @command{createspinfo.pl} would create for
that class.

@menu
* Example class::               
* Resulting .spinfo file::      
@end menu

@node    Example class, Resulting .spinfo file, Example splitter info file, Example splitter info file
@subsubsection Example class

@smallexample
class simpleStack @{
 
  private int[] myArray;
  private int currentSize;
 
  public simpleStack(int capacity) @{
    myArray = new int[capacity];
    currentSize = 0;
  @}
 
  /** Adds an element to the back of the stack, if the stack is not full.
    * Returns true if this succeeds, false otherwise.  **/
  public String push(int x) @{
    if ( !isFull() && x >= 0) @{
      myArray[currentSize] = x;
      currentSize++;
      return true;
    @} else @{
      return false;
    @}
  @}
 
  /** Returns the most recently inserted stack element.
    * Returns -1 if the stack is empty. **/
  public int pop() @{
    if ( !isEmpty() ) @{
      currentSize--;
      return myArray[currentSize];
    @} else @{
      return -1;
    @}
  @}

 /** Returns true if the stack is empty, false otherwise. **/
  private boolean isEmpty() @{
    return (currentSize == 0);
  @}

  /** Returns true if the stack is full, false otherwise. **/
  private boolean isFull() @{
    return (currentSize == myArray.length);
  @}
@}
@end smallexample

@node    Resulting .spinfo file,  , Example class, Example splitter info file
@subsubsection Resulting .spinfo file

@smallexample
REPLACE
isFull()
currentSize == myArray.length
isEmpty()
currentSize == 0

PPT_NAME  simpleStack.push
!isFull() && x >= 0

PPT_NAME  simpleStack.pop
!isEmpty()
@end smallexample

PPT_NAME  simpleStack.isFull
(currentSize == myArray.length - 1)

PPT_NAME  simpleStack.isEmpty
(currentSize == 0)


@node    Tools, Extending Daikon, Enhancing Daikon output, Top
@chapter Tools

This chapter gives information about tools that are part of the Daikon
distribution and are not described elsewhere in the manual.

@menu
* MergeESC::                    
@end menu

@node    MergeESC,  , Tools, Tools
@section MergeESC

@cindex MergeESC tool
@cindex ESC output format
@cindex output format, ESC

The MergeESC program inserts Daikon-generated invariants into Java
source code as ESC/JML annotations.  These annotations are comments that
can be automatically verified or otherwise manipulated by other tools.
Invoke MergeESC like this:
@example
  java daikon.tools.jtb.MergeESC Myprog.inv Myprog.java Myprog2.java ...
@end example

The first argument is a Daikon @file{.inv} file produced by running
Daikon with the @option{-o} command-line argument.  All subsequent
arguments are .java files.  The original .java files are left
unmodified, but MergeESC produces new @file{-escannotated} versions that
include the Daikon invariants as comments.


@node    Extending Daikon, Troubleshooting, Tools, Top
@chapter Extending Daikon

@cindex extending Daikon
@cindex changing Daikon
@cindex customizing Daikon
@cindex modifying Daikon

This chapter describes how to customize or modify Daikon.

Readers are also referred to Chapter 7, ``Implementation'', of
@cite{Dynamically Discovering Likely Program Invariants} by Michael
D. Ernst, PhD dissertation, University of Washington Department of
Computer Science and Engineering, Seattle, Washington, USA, August 2000.
This document is available online at
@url{http://pag.lcs.mit.edu/~mernst/pubs/invariants-thesis-abstract.html}.



@menu
* Compiling Daikon::            
* New invariants::              
* New derived variables::       
* New formatting for invariants::  
* New front ends::              
@end menu

@node    Compiling Daikon, New invariants, Extending Daikon, Extending Daikon
@section Compiling Daikon
@cindex compiling daikon

To compile Daikon, type @command{make} in any directory under
@file{daikon/java/}.  The distribution includes compiled
@file{.class} files, so you do not need to compile them yourself unless
you make changes.

@cindex .jpp files
@cindex jpp files

In order to compile Daikon, you need the C preprocessor
@command{cpp}, which is used to convert each @file{.jpp} file in the
distribution into multiple @file{.java} files, which are then compiled.
If you do not have @command{cpp}, you may run @command{make avoid-jpp}, in
which case changes to @code{.jpp} files will not be reflected in the
@file{.java} files or the compiled @file{.class} files.  (The purpose
of the @file{.jpp} files is to avoid code duplication by placing
common code in a single file, then generating other files that need to
include that common code.)

@cindex Jikes compiler
@cindex javac compiler, overriding
@cindex Java compiler, specifying
You may wish to create a @file{Makefile.user} file in the @file{daikon/}
directory to set your Java compiler.  For instance, it might contain
@example
  JAVAC ?= jikes -g +E +F
@end example

For more information about compiling Daikon, see the comments in the Makefiles.


@node    New invariants, New derived variables, Compiling Daikon, Extending Daikon
@section New invariants

You can easily write your own invariants and have Daikon check them,
in addition to all the other invariants that are already part of Daikon.
Adding a new invariant to Daikon requires writing one Java class, adding
a line to another file (a factory class) to inform Daikon of the new
class, and recompiling Daikon.

You can find a simple example of an invariant in file
@file{java/daikon/inv/unary/scalar/Positive.java}.  This invariant is
true if the variable is always positive (greater than zero).  This
invariant is subsumed by other invariants in the system; it is provided
only as a pedagogical example.  To enable the invariant, uncomment the
appropriate line in @file{SingleScalarFactory.java}, then recompile
Daikon.


A Java class defining an invariant is a concrete subclass of one of
the following abstract classes:
@itemize @bullet
@item
@samp{SingleScalar}, for invariants over a single numeric (scalar) variable,
such as "x != 0".
@item
@samp{TwoScalar}, for invariants over two numeric variables, such as "y
= abs(x)".
@item
@samp{ThreeScalar}, for invariants over three numeric variables, such as
"z = ax + by + c".
@item
@samp{SingleSequence}, for invariants over one sequence (array)
variable, such as "a[] contains no duplicates".
@item
@samp{TwoSequence}, for invariants over two sequences, such as "a[] is a
subsequence of b[]".
@item
@samp{SequenceScalar}, for invariants over a scalar and a sequence, such
as "x is a member of a[]".
@end itemize
@noindent
A complete list of the types appears in classes @samp{PptSlice1},
@samp{PptSlice2}, and @samp{PptSlice3}, in their respective
@samp{instantiate_invariants} methods.

Daikon's invariants are first instantiated, then are presented samples
(tuples of values for all the variables of interest to the invariant;
this might be a 1-tuple, a 2-tuple, or a 3-tuple) in turn.  If any
sample falsifies the invariant, the invariant destroys itself.  All
remaining invariants at the end of the program run can be reported as
likely to be true.

The key methods of the new invariant are
@table @samp
@item @r{constructor}
Creates a new invariant object.  Its typical implementation is
@example
  super(ppt);
@end example
@item instantiate
returns either a new invariant object or null.  For instance,
@samp{instantiate} might check whether particular conditions that are
required for the invariant to be sensible hold.  Its typical
implementation is
@example
  return new @var{InvName}(ppt);
@end example
@item add_modified
presents a tuple of values to the invariant.  The @samp{count} variable
indicates how many samples have this value.  For example, three calls to
@samp{add_modified} with a @samp{count} parameter of 1 is equivalent to
one call to @samp{add_modified} with a @samp{count} parameter of 3.
@item computeProbability
returns the probability that the observed data could have happened by
chance alone.  The result usually falls between 0 and 1, where 1 means
the values seen so far certainly happened by chance and 0 means they
could never have happened by chance.  The method may also return one of
the following constants in the @samp{Invariant} class (which see for
documentation): @samp{PROBABILITY_JUSTIFIED},
@samp{PROBABILITY_UNJUSTIFIED}, @samp{PROBABILITY_UNKNOWN},
@samp{PROBABILITY_NEVER}.

For example, suppose your new invariant has a 50% chance of being true
by chance for each sample.  ("x is even" is an example of such an
invariant.)  Then a reasonable body for @samp{computeProbability} would
be
@example
  return Math.pow(.5, ppt.num_values());
@end example
@noindent
If 5 values had been seen, then this implementation would return 1/32,
which is the likelihood that all 5 values seen so far were even purely
by chance.  Invariants are only printed if their probabilities are small
enough (by default, less than .01).
@item format
returns a high-level printed representation of the
invariant, for user output.  The @samp{repr} formatting routines
produces low-level, detailed output for debugging.  When first writing
an invariant, you can make @samp{repr}, @samp{format_esc}, and
@samp{format_simplify} all simply call @samp{format}, then fix up the
implementations later as needed.
@end table

After the invariant is written, add a call to its @samp{instantiate}
method in pass 2 of the @samp{instantiate} method of the appropriate
factory; for instance, add a line like
@example
  result.add(MyInvariant.instantiate(ppt));
@end example
@noindent
to @samp{SingleScalarFactory.instantiate}.


@node    New derived variables, New formatting for invariants, New invariants, Extending Daikon
@section New derived variables

(To be written)


@node    New formatting for invariants, New front ends, New derived variables, Extending Daikon
@section New formatting for invariants

@cindex output format, defining new

Daikon can print invariants in five formats:  its native format, Java
format, IOA format (for use with the IOA programming language), ESC
format (which is a subset of the JML specification language), and
Simplify format (for use by the Simplify theorem-prover).

To support a new output format, you need to do two things:
@itemize @bullet
@item
(This description will change in Daikon version 2.3.8.)
Add, to every subclass of @samp{Invariant}, a
@samp{format_@var{newtype}()} method.  Each subclass of Invariant
already has three such methods --- @samp{format()}, @samp{format_esc()},
and @samp{format_simplify()} --- for you to crib from.
@item
Edit @samp{PptTopLevel.print_invariants()} to add a call to your new
method, near the calls to the other formatting methods.
@end itemize


@node    New front ends,  , New formatting for invariants, Extending Daikon
@section New front ends

@cindex front end, writing

A front end for Daikon produces files in Daikon's input format ---
@file{.decls} files and @file{.dtrace} files --- enabling Daikon to
operate on data that would otherwise be inaccessible to it.
(Typically, Daikon front ends arrange to obtain information from
program executions, though front ends have been also been built for
stock data, weather forecasts, and truck weight data, among others.)

A front end for Daikon takes as input a target program to be analyzed.
The front end produces two outputs:  a @file{.decls} file and an
instrumented program.  Executing the instrumented program produces a
@file{.dtrace} file.
For more information about these files, see @ref{File formats}.

Conceptually, instrumentation is very simple.  For instance, suppose we
wish to instrument file @file{Example.java}.
@example
class Example @{
  // Return either the square of x or the square of (x+1).
  int squar(int x, boolean b) @{
    if (b)
      x++;
    return x*x;
  @}
@}
@end example

The @file{.decls} file might look like the following.
@example
DECLARE
Example.squar:::ENTER
x
int
int
1
b
boolean
int
2

DECLARE
Example.squar:::EXIT
x
int
int
1
b
boolean
int
2
return
int
int
1
@end example

The instrumented @file{.java} file might look like the following.
@example
class Example @{
  static @{
    daikon.Runtime.setDtraceMaybe("daikon-output/StackAr.dtrace");
  @}

  // Return either the square of x or the square of (x+1).
  int squar(int x, boolean b) @{
    synchronized (daikon.Runtime.dtrace) @{
      daikon.Runtime.dtrace.println();
      daikon.Runtime.dtrace.println("Example.squar:::ENTER");
      daikon.Runtime.dtrace.println("x");
      daikon.Runtime.dtrace.println(x);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("b");
      daikon.Runtime.dtrace.println(b ? 1 : 0);
      daikon.Runtime.dtrace.println(1);  // modified bit
    @}

    if (b)
      x++;

    int daikon_return_value = x*x;
    synchronized (daikon.Runtime.dtrace) @{
      daikon.Runtime.dtrace.println();
      daikon.Runtime.dtrace.println("Example.squar:::EXIT");
      daikon.Runtime.dtrace.println("x");
      daikon.Runtime.dtrace.println(x);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("b");
      daikon.Runtime.dtrace.println(b ? 1 : 0);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("return");
      daikon.Runtime.dtrace.println(daikon_return_value);
      daikon.Runtime.dtrace.println(1);  // modified bit
    @}

    return daikon_return_value;
  @}
@}
@end example


@node    Troubleshooting, Details, Extending Daikon, Top
@chapter Troubleshooting

@cindex troubleshooting
@cindex warning messages
@cindex error messages

This chapter gives solutions for certain problems you might have with
Daikon; it also tells you how to report bugs in a useful manner.


@menu
* Installation problems::       
* dfej problems::               
* dfec problems::               
* Daikon problems::             
* Other problems::              
* Reporting bugs::              
* Known bugs::                  
* Further reading::             
@end menu


@node    Installation problems, dfej problems, Troubleshooting, Troubleshooting
@section Problems installing Daikon

The tar file may appear to contain a file named @file{././@@LongLink}.
This is inserted in a tar file when a filename is longer than a specific
maximum length (often 100 characters).  If you see this file, then your
version of the tar program does not recognize this indication.  It is
possible that some filenames (including the one contained in
@file{././@@LongLink}) have been truncated.

@c As of Daikon 2.3.5 (March 1, 2002), the two affected files were:
@c daikon/java/jakarta-oro-2.0.3/docs/classes/org/apache/oro/text/regex/MalformedPatternException.class
@c daikon/java/jakarta-oro-2.0.3/docs/classes/org/apache/oro/text/perl/MalformedPerl5PatternException.class


@node    dfej problems, dfec problems, Installation problems, Troubleshooting
@section Problems with dfej

@menu
* dfej compilation problems::   
* dfej invocation problems::    
@end menu

@node    dfej compilation problems, dfej invocation problems, dfej problems, dfej problems
@subsection Problems compiling dfej


gcc 2.95.2 on Linux raises an internal error when compiling
@file{stream.cpp} using the @option{-Wall} flag.  You can simply compile
that file without the @option{-Wall} flag.

@cindex cannot convert `const char **' to `char **'

If you get an error like
@example
stream.cpp: In method `void LexStream::ProcessInputUnicode (const char *, long int)':
stream.cpp:901: cannot convert `const char **' to `char **' for
argument `2' to `iconv (void *, char **, size_t *, char **, size_t *)'
@end example
@noindent
then undefine preprocessor macro @code{HAVE_ICONV_H} and try compiling
again.
(This has been reported on Red Hat Linux 7.0.)

@c reported 12/19/2001 by Tao Xie
Also reported on Red Hat Linux 7.0 is the following error:
@example
daikon-context.cpp:466: no matching function for call to `pair<Ast *, 
Ast *>::pair (Ast *&, void *)'
@end example
@noindent
We do not yet have a fix, but if you find one, please let us know.


@node    dfej invocation problems,  , dfej compilation problems, dfej problems
@subsection Problems running dfej

@cindex could not find package named, dfej error

If you get an error like
@example
% dfej MyProg.java
MyProg.java:0:0:0:0: Error: Could not find package named: 
                ./java/util
MyProg.java:0:0:0:0: Error: Could not find package named: 
                ./java/lang
@end example
@noindent
then you need to add @file{rt.jar} to your
CLASSPATH.  This should be automatic, if you are using the
@file{daikon.bashrc} or @file{daikon.cshrc} file and have set the
JDKDIR environment variable correctly.  Also see @ref{Installing dfej}.


If you get a warning like
@example
     *** Warning: the file "/cygdrive/c/jswdk-1.0.1/jspengine.jar" is not a valid zip file.
@end example
@noindent
then you have set your CLASSPATH incorrectly:  it names a nonexistent
file or a file that is not a @file{.jar} Java archive.  You should adjust
your CLASSPATH to remove the offending file.  This warning has no effect
on the operation of dfej, however.


@menu
* Ajax errors::                 
@end menu

@node    Ajax errors,  , dfej invocation problems, dfej invocation problems
@subsubsection Ajax errors

@cindex Ajax, problem with

The warning ``Problem with Ajax; using original .decls files instead''
indicates that the Ajax variable comparator could not run.  Ajax
indicates which variables are comparable to which other variables.  This
information can reduce the amount of spurious output from Daikon by
preventing it from making spurious comparisons and reporting irrelevant
output.  For example, two integer variables that never appear together
in an expression (and that don't appear with variables that appear
together, etc.)@ should not be compared to one another, because those
variables are likely to be entirely unrelated and any properties over
them are incidental and uninformative.

As of December 2001, Ajax cannot deal with JDK 1.2 (or later) libraries,
and it sometimes has other problems.  If Ajax cannot be run, then a more
primitive method of determining comparability is used instead.  Even if
Ajax cannot be run, Daikon proceeds without error.

@cindex Invalid class loading, warning

Ajax may produce the warning message ``Invalid class loading ...'';
you will notice this if environment variable DFEJ_VERBOSE is set.
You may safely ignore this message if Ajax does not produce any
further warnings or errors.  The message results from Ajax's inability
to handle JDK 1.2 libraries.


@node    dfec problems, Daikon problems, dfej problems, Troubleshooting
@section Problems with dfec

@cindex daikon_runtime error
@cindex error, daikon_runtime
@cindex attempted to access index error
@cindex error, attempted to access index

A program instrumented by dfec may produce a message such as
@example
daikon_runtime: attempted to access index 5 of a 4-length array!
@end example
Such a message indicates that there is an error in your program.  Your
program attempts to read or write memory beyond the end of an array.
You should fix this error before proceeding to try to detect
invariants.  If you do not do so, then the program's results cannot be
relied on, because the erroneous array access might corrupt (or access
meaningless values from) other variables, the Daikon runtime data
structures, or your program's stack.  When this occurs, the Daikon
runtime immediately halts your program to let you know where the error
occurred and to prevent memory corruption.  The Daikon runtime's
discovery of these errors, while not directly related to invariant
detection, is a pleasant side effect of using Daikon.

To learn exactly where the error occurred in your program, you can
either run a debugger (such as @uref{http://sources.redhat.com/gdb/, ,
GDB}) on the @file{core} file left behind when the Daikon runtime
halts the instrumented program, or you can run the instrumented
program under the debugger.  Correct the error, then re-instrument it
and run it again.

@c 5/15/2002
(In a future release, we plan to permit programs to continue running
even if they commit memory errors, in certain cases and when users set
special flags to enable this behavior.)



@c @node    Instrumented code problems, Daikon problems, dfej problems, Troubleshooting
@c @section Problems running instrumented code


@node    Daikon problems, Other problems, dfec problems, Troubleshooting
@section Problems running Daikon

You may find the debugging flags @option{--debug} and @option{--dbg
@var{category}} useful if you wish to track down bugs or better
understand Daikon's operation; @xref{Command line options}.
@xref{Configuration options}, for another way to adjust Daikon's output.


@menu
* No return from procedure::    
* Out of memory::               
* Simplify errors::             
* Method needs to be implemented::  
@end menu

@node    No return from procedure, Out of memory, Daikon problems, Daikon problems
@subsection No return from procedure

@cindex no return from procedure, warning
@cindex return from procedure, warning

Daikon sometimes issues a warning that a procedure in the target program
was entered but never exited (that is, the target program abnormally
terminated).  Thus, the @file{.dtrace} file contains more entry records
than exit records for the given procedure.  Some procedures that were
entered were never recorded to have exited: either they threw an
exception, skipping the instrumentation code that would have recorded
normal termination, or the target program's run was interrupted.

In some cases, exceptional exit from a procedure can cause
@code{orig(@var{x})} values to be incorrect.  This depends on the
technique used to associate procedure exits with entries.  Daikon has
two such techniques --- the nonce technique and the stack technique.  If
a @file{.dtrace} file uses the nonce technique, @code{orig(@var{x})}
values are guaranteed to be correct.  If a @file{.dtrace} file uses the
stack technique, then incorrect @code{orig(@var{x})} values are likely
to occur.  You can tell which technique Daikon will use by examining the
@file{.dtrace} file.  If the second line of each entry in the
@file{.dtrace} file is "this_invocation_nonce", then Daikon uses the
nonce technique.  Otherwise, it uses the stack technique.  Which
technique is used is determined by the front end, which creates the
@file{.dtrace} file, and typically cannot be controlled by the user.



@node    Out of memory, Simplify errors, No return from procedure, Daikon problems
@subsection Out of memory

@cindex out of memory error
@cindex java.lang.OutOfMemoryError

If Daikon runs out of memory, generating a message like
@example
        Exception in thread "main" java.lang.OutOfMemoryError
                <<no stack trace available>>
@end example
@noindent
then the problem is likely to be an excessively large @file{.dtrace}
file.  In addition to the solutions discussed in @ref{Large dtrace
files}, you can try increasing the amount of memory available to Java
with the @option{-mx} argument to @command{java}.  (This flag is
JVM-specific; see your JVM documentation for details.)  The default is
only 1 megabyte; to permit use of up to 256 megabytes, you would run
Java like so:
@example
        java -mx256m ...
@end example

Another possible problem is the creation of too many derived variables.
If you supply the @option{--output_num_samples} argument to Daikon
(@pxref{Command line options}), then it will list all
variables at each program point.  If some of these are of no interest,
you may wish to suppress their creation.  (This manual does not
presently tell you how to do that, but you can see the source code or
ask an expert.)

Any output generated before the out-of-memory error is perfectly valid.


@node    Simplify errors, Method needs to be implemented, Out of memory, Daikon problems
@subsection Simplify errors

@cindex Simplify, could not utilize

The warning ``Could not utilize Simplify'' indicates that the Simplify
theorem-prover could not be run; this usually indicates that the
@command{Simplify} binary was not found on the user's path.
Simplify must be separately obtained (from
@url{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to use it.

If Simplify is not used, certain redundant (logically implied)
invariants may appear in Daikon's output.  The output is otherwise
correct.


@node    Method needs to be implemented,  , Simplify errors, Daikon problems
@subsection Method needs to be implemented

@cindex method needs to be implemented warning
@cindex needs to be implemented warning

Daikon may produce output like the following (but all on one line):
@example
method daikon.inv.binary.twoSequence.SubSequence.format_esc()
needs to be implemented:
this.theArray[0..this.topOfStack] is a subsequence of
orig(this.theArray[0..this.topOfStack])
@end example
@noindent
This indicates that a particular invariant (shown on the last two lines
above) cannot be formatted using the current formatting.  In this example,
the invariant can be formatted using Daikon's default
formatting (which is how it is shown above), but (as of April 2002)
Daikon cannot output it in ESC format, so Daikon prints the above
message instead.  The message also shows exactly what Java method needs
to be implemented to correct the problem.  You can ignore such messages,
or else use an output formatting that can handle those invariants.
MergeESC (@pxref{MergeESC}) automatically ignores unformattable invariants.


@node    Other problems, Reporting bugs, Daikon problems, Troubleshooting
@section Other problems

@menu
* Large dtrace files::          
* Tree GUI font errors::        
@end menu

@node    Large dtrace files, Tree GUI font errors, Other problems, Other problems
@subsection Large data trace (.dtrace) files

Running instrumented code can create very large
@file{.dtrace} files.  This can be a problem because writing the large
files can slow the target programs substantially, because the large files
may fill up your disk, or because Daikon is unable to process the large
files.  There are several solutions to this problem.

@enumerate
@item 
You can terminate the instrumented program when it has created a
sufficiently large @file{.dtrace} file.  If you interrupt the program
while it is in the middle of writing a record to the @file{.dtrace}
file, the last record may be only partially written.  Use the
@command{daikon/bin/trace-untruncate} script to remove the last,
possibly partial, record from the file:
@example
  trace-untruncate @var{myfile}.dtrace
@end example
@noindent
modifies @file{myfile.dtrace} in place to remove the last record.
@item
You can instrument fewer files.
@itemize
@item With dfej, only supply it the files you wish to instrument.
@item With dfec, use the @option{-l} command on the command line
immediately before any file you wish not to instrument.
@end itemize

@item 
You can instrument fewer methods.
@itemize
@item With dfej, use the 
@example
  -daikon_omit=@var{string}
@end example
@noindent
argument.  (For a list of dfej's options, see @ref{dfej
options}.)  Dfej will not produce data trace output for classes or
procedures that match @var{string}.  Running the instrumented program
will result in a smaller @file{.dtrace} file that contains fewer
records.
@item With dfec, you would need to split the single file into two
files, then suppress instrumentation of one of them with the
@option{-l} flag.
@end itemize

@item
You can reduce the number of variables that are output by reducing the
class/structure instrumentation depth.
@itemize
@item With dfej, use the @option{-daikon_depth=@var{N}} option.
@item With dfec, use the @option{--struct-depth=@var{N}} option.
@end itemize

@item 
You can pare down an existing @file{.dtrace} file using the
@command{invariants/scripts/trace-purge-fns.pl} and
@command{trace-purge-vars.pl} scripts. These remove (or retain) certain
program points, or certain variables, from @file{.dtrace} files; see
their documentation (at the top of the files) for details.  Removing
program points obviously prevents Daikon from considering them;
removing variables can eliminate certain large uses of memory or keep
Daikon from doing uninteresting comparisons.

@item 
To make Daikon ignore some program points, use its
@example
  -r @var{ppt_regexp}
@end example
@noindent
argument.  (Run "@command{java daikon.Daikon}" to see a list of
arguments.)  With the @option{-r} flag, only program points matching
the regular expression are processed.  This can take the place of the
@command{trace-purge-fns.pl} script.
@end enumerate



@node    Tree GUI font errors,  , Large dtrace files, Other problems
@subsection Tree GUI font errors

@cindex font not found

When running the Tree GUI on Linux, you may get font errors such as the following:

@example
Font specified in font.properties not found
  [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
@end example

These errors are harmless; the Tree GUI will still run correctly.  To
prevent these errors from appearing in the future, take the following
steps:

@itemize @bullet
@item
Find out where your JDK root directory is.  In general, the JDK root directory
is where you run java from: @file{@var{JDK_ROOT}/bin/java}.
@item
Edit @file{@var{JDK_ROOT}/jre/lib/font.properties}, and comment out all lines
with the offending fonts.  For example, to eliminate the error messages
shown above, one would comment out all lines containing "fontspecific".
@end itemize

If you don't have permission to edit @file{font.properties}, ask
your system administrator to do so.


@node    Reporting bugs, Known bugs, Other problems, Troubleshooting
@section Reporting bugs

@cindex reporting bugs
@cindex bugs, reporting

If you have any questions, can suggest ways to improve the documentation,
find bugs in the system, or have suggestions for its improvement, please
send email to @email{daikon@@pag.lcs.mit.edu}.  While Daikon is a research prototype,
we will try to assist you and to correct any problems, so please don't
hesitate to ask for help or report difficulties.

Your bug report will be most helpful if you include:
@itemize @bullet
@item
the version of Daikon, which appears in the file @file{daikon/README}
and is also printend when you run Daikon.
If you are not using the most recent version, download a newer version
from @uref{http://pag.lcs.mit.edu/daikon/} to see whether your problem
has already been corrected.
@item
a description of exactly what you did, exactly what happened, and what
you expected to happen instead.
For instance, a transcript of your commands and the system's output
may provide this information.  (A transcript is @strong{much} more
useful than a vague description.)
@item
input files that permit the problem to be replicated.  The
most important thing is the original, uninstrumented source files.
It is also helpful to include instrumented source files,
@file{.decl} files, and @file{.dtrace} files.
@item
any other information that you consider relevant.
@end itemize

It is frequently more difficult to reproduce an error than to correct
it; if you make it easy to reproduce and verify the problem, then it is
much more likely to be corrected.

@menu
* Known bugs::                  
* Further reading::             
@end menu

@node    Known bugs, Further reading, Reporting bugs, Troubleshooting
@section Known bugs

The following problems are already known.  (You may report them again,
to encourage us to release the fix faster, if you like.)
@itemize @bullet
@item C/C++ front end:
@itemize @bullet
@item
@cindex shadowed variables in C
Produces bad @file{.dtrace} and @file{.decls} files when a local
variable shadows a global one.
@end itemize
@item Daikon:
@itemize @bullet
@item
@cindex floating-point values
Floating-point values are often ignored; the infrastructure is
there, but I haven't gotten around to writing code to test for
specific invariants.
@end itemize
@end itemize

@node    Further reading,  , Known bugs, Troubleshooting
@section Further reading

For further reading, see the list of publications at the 
Daikon homepage, @url{http://pag.lcs.mit.edu/daikon/}.


@node    Details, File formats, Troubleshooting, Top
@chapter Details

The Daikon invariant detector is named after an Asian radish.
``Daikon'' is pronounced like the combination of the two one-syllable
English words "die-con".


@menu
* History::                     
* License::                     
* Credits::                     
@end menu

@node    History, License, Details, Details
@section History
@cindex history of Daikon

This manual describes Daikon version 2.3.8, released May 11, 2002.
A list of revisions since mid-2001 can be found in file
@file{daikon/doc/CHANGES} in the distribution; this section gives a
high-level view of the package's history.

There have been two major implementations of Daikon, with different
features and capabilities.  Readers of technical papers may be confused
by the apparently different claims about Daikon's capabilities.  These
apparent contradictions result from the papers referring to the current
version of Daikon at the time of publication.  This section of the
manual clarifies the development of the Daikon tool in order to reduce
such confusion.

@cindex Lisp front end
@cindex front end for Lisp
@cindex loop heads, instrumenting
@cindex instrumenting loop heads
@cindex Python implementation of Daikon
@cindex Daikon 1

Daikon 1 was written in the Python programming language in 1998.  It included
front ends for C, Java, and Lisp.  The C front end was extremely limited
and failed to operate correctly on all C programs:  sometimes it
suffered a segmentation fault while instrumenting a target program, and even
when that did not happen, sometimes the instrumented program
segmentation-faulted while running.  The Lisp front end operated
correctly on all Lisp programs, but only instrumented certain common
constructs, leaving other language features uninstrumented.  The Java front
end was reasonably reliable.  The Lisp front end instrumented procedure
entries, exits, and loop heads; the C front ends instrumented only
procedure entries and exits; and the Java front end instrumented program
points for object invariants as well as procedure entries and exits.

Daikon 2 was a complete rewrite in the Java programming language and was
the first version to contain a substantive manual.  Daikon 2 uses the
same Java front end as did Daikon 1, though with certain enhancements.
(Actually, there have been 5 Java front ends; the first two were
binary rewriters; the next two were source code rewriters; and the
last (experimental as of May 2002) one is a binary rewriter.)
Its C/C++ front end is rewritten from scratch; it instruments only
procedure entries and exits.  A front end also exists for the IOA
programming language, but is not included in the Daikon distribution.


@node    License, Credits, History, Details
@section License


Daikon is made available for education, research, and evaluation
purposes (not for direct commercial gain), and there is no warranty.
All rights are reserved, and copyright is held by the authors.  If you
have difficulties with the software, let us know and we will do our best
to correct the problem.  Unfortunately, we cannot make any guarantees of
support, or any other guarantees regarding the software.  As a condition
of use, you agree to promptly communicate any changes, improvements, or
enhancements to the authors for inclusion in a future release under
these same conditions.  If you do not agree to this license, please do
not use or examine the software.  Other licensing terms are available;
send mail to @email{daikon@@pag.lcs.mit.edu}.

If you use Daikon, please send mail to @email{daikon@@pag.lcs.mit.edu}, so that you can
be informed of new versions, enhancements, and bug fixes.  We would also
appreciate a brief description of how you are using Daikon, because we
are curious about how users exploit it (and are eager for anecdotes about
its successes and failures), and we want to make Daikon more effective
for its users.


@node    Credits,  , License, Details
@section Credits

@cindex contributors to Daikon

The following individuals have contributed to Daikon:
@itemize @bullet
@item Jake Cockrell
@item Adam Czeisler
@item Nii Dodoo
@item @uref{http://pag.lcs.mit.edu/~mernst/,,Michael Ernst}
@item @uref{http://www.cs.ucsd.edu/~wgg/,,William Griswold}
@item @uref{http://web.mit.edu/mhao/www/,,Melissa Hao}
@item @uref{http://web.mit.edu/mharder/www/,,Michael Harder}
@item Greg Jay
@item Josh Kataoka
@item @uref{http://web.mit.edu/mistere/www/,,Jeremy Nimmer}
@item @uref{http://www.cs.washington.edu/homes/notkin/,,David Notkin}
@end itemize

@uref{http://www.cs.washington.edu/homes/csk/,,Craig Kaplan} carved the
Daikon logo.

The feedback of Daikon users has been very valuable.  We are
particularly grateful to Rich Angros, Tadashi Araragi, David Cok, Engelbert
Hubbers, and Manos Renieris.  Many others have also been generous with
their feedback, for which we are grateful.

@c This work was supported in part by NSF grants CCR-9506779 and CCR-9508745,
@c an IBM Cooperative Fellowship, and a gift from Edison Design Group.

If your name has been inadvertently omitted from this section, please
let us know so we can correct the oversight.


@node     File formats, Index, Details, Top
@appendix File formats

@cindex file formats

This chapter contains information about the file format of Daikon's data
trace and declaration files.  It is of most information to those who
wish to write a front end (@pxref{Instrumentation}), enabling Daikon to
detect invariants in another programming language.

Data trace files contain runtime values for variables at particular program
points.  Each record in a data trace file represents one execution of a
program point.  The record names a program point and lists a number of
variables and their runtime values.  This dynamic information about values
at a program point is generated when an instrumented program is run.  By
convention, data trace files have the suffix @file{.dtrace}.

A declaration file describes the structure of the data trace file; it
lists the program points that may appear in the data trace file and, for
each program point, which variables appear at that program point.  This
static lexical information about a program point can be determined when
a program is instrumented.  By convention, declaration files have the
suffix @file{.decls} or @file{.decl}.

(Actually, both declarations and data trace records may appear together in
a single file.  In that case, the program point information must precede
the first appearance of values at that point, but it is not required that
all the program point declarations appear before any values are written to
the file.  This is intended to provide flexibility for instrumentation
implementations.  However, it is encouraged to place declarations in
different files than data traces.)


@menu
* Conventions::                 
* Declaration files::           
* Data trace files::            
* Examples::                    
@end menu

@node    Conventions, Declaration files, File formats, File formats
@section File format conventions


Daikon files are textual, to permit easier viewing and editing by humans.
Each record is separated by one or more blank line.
To permit easier parsing by programs, each piece of information in a record
is on a separate line

Any line starting with a pound sign (#) is ignored as a comment (except
inside a record, where comments are not permitted)


@node    Declaration files, Data trace files, Conventions, File formats
@section Declaration files


A declaration file consists of a sequence of program point declarations
separated by blank lines.

The format of the program point information is:
@example
  DECLARE
  program-point-name
  varname1
  declared-type1
  representation-type1 [= constant-value1]
  comparable1
  varname2
  declared-type2
  representation-type2 [= constant-value2]
  comparable2
  ...
@end example

Program point information includes:
@itemize @bullet
@item
name ("tag") of this program point, an arbitrary string containing no
tab or newline characters.  This name contains information such as the
class name or method name; what information is contained depends on
which instrumenter is being used.  @xref{pptname format}, for a full
specification of the naming format.

By convention, the entry and exit points for a function have names of
a special form so that they can be associated with one another.
(Currently, those names end with ":::ENTER" and ":::EXIT".)  This
convention permits instrumenters not to remember the original values of
variables and output them at the procedure exit point.

Another convention is to have another program point whose name ends
with ":::OBJECT" for the representation invariant of an object or
class.  This program point is not created automatically, because
there isn't a way to know whether a particular method is a private
helper method or not --- that is, whether the representation
invariants should hold on entry to and exit from it.

@item
for each variable:
@itemize @bullet
@item
name: an arbitrary, uninterpreted string containing no tabs or
newlines.  However, the names of array-valued variables must end
with "[]".  For instance, "a" might stand for the array object itself
(appearing in the trace file as a unique ID or hashcode), and "a[]" would
stand for the array contents (appearing in the trace file as a sequence
of values).
@item
declared type:  this is what the programmer used in the
declaration of the variable.  
This is currently uninterpreted, except that array types must be
suffixed by the proper number of "[]" to indicate their dimensionality.
Names for standard types should use Java's names (e.g., "int",
"boolean", etc.), but names for user-defined or language-specific types
can be arbitrary strings.
@item
representation type:  this describes what will appear in the data
trace file.  For instance, the declared type might be "char[]" but
the representation type might be "String".  Or, the declared type
might be "Object" but the representation type might be "int"
(because only the object's hashcode, not the object itself, is
written to the data trace file).

The representation type is currently constrained to be integer, hashcode
(a particular variety of integer), boolean, string, or array of integer
or string.

The representation type may optionally be followed by an equals
sign and a value; in that case, the variable is known to have a
compile-time constant value and should be omitted from the data
trace file.
@end itemize
Arrays types are followed by square brackets:  "int[]", "char[][]".
@item
comparable variables.  These indicate
which other variables are comparable to this one, which is typically
obtained via type-inference based analysis.  There are two formats,
"implicit" and "explicit", for this information.  (See below for how
to specify which format the information is in.)
@itemize @bullet
@item
An implicit comparability is an integer.  Comparisons
succeed exactly if either integer is negative or if both integers are
the same.  An implicit comparability for an array type may contain an
integer for each index and for the contents; for instance, "5[22][17]"
for a two-dimensional array.  Comparisons succeed if comparisons over
each component succeed.
@item
If no information is supplied (i.e.,, this line is blank), then
the variable is compared to all other variables of the same type.
@end itemize
@end itemize

Future enhancements may include:
@itemize @bullet
@item
permit variables to be omitted if they haven't changed (but always
outputting the bit permits us to write a sanity checker)
@item
permit variables to appear in any order (not sure this is so worthwhile)
@item
specify which @file{.decl} files should be used (including their pathnames
and/or MD5 hashes)
@end itemize

A declaration file optionally starts with a "VarComparability" record,
which might look like the following:
@example
  VarComparability
  explicit
@end example
@noindent
This controls how the comparability field in the declarations is interpreted.


@menu
* pptname format::              
@end menu


@node    pptname format,  , Declaration files, Declaration files
@subsection Program point name format specification

Instrumenting code creates a @file{.decls} file that contains program
point names such as:

@example
  StackAr.makeEmpty()V:::EXIT54
  StackAr.makeEmpty()V:::ENTER
  StackAr.top()Ljava/lang/Object;:::EXIT64
  StackAr.top()Ljava/lang/Object;:::EXIT65
  StackAr.top()Ljava/lang/Object;:::ENTER
@end example

This section describes the format of these program point names.  Someone
writing an instrumenter for a new language must be sure to follow this
format specification.

A program point name is a string with no tabs or newlines in it. The basic
format is:

@example
  topLevel.bottomLevel:::pptInfo
@end example

For the first example given above, the top level of the hierarchy would
be @file{StackAr}, the bottom level would be @file{makeEmpty()V}, and the
program point information would be @file{EXIT54}.

@file{topLevel} and @file{bottomLevel} can represent anything. Currently
for Java, @file{topLevel} consists of the class name while
@file{bottomLevel} consists of the method name and method signature. For
C, @file{topLevel} could consist of a filename and @file{bottomLevel}
could consist of a method name and signature. For IOA, @file{topLevel}
could consist of an Automaton name and @file{bottomLevel} could consist of
information for a transition state.

@file{topLevel} may contain any number of periods ('.'). @file{bottomLevel}
and @file{pptInfo} may not contain any periods. The string ":::" may only
appear once.

@file{topLevel} and @file{pptInfo} are required (i.e., they must be non-empty),
as are the period to the right of @file{topLevel} and the colons to the
left of @file{pptInfo}. However, @file{bottomLevel} is optional. For
example, the Java instrumenter creates an artificial object program point
which contains invariants that are true for all of an object's methods,
rather than for just one method:

@example
  StackAr.:::OBJECT
@end example


@node    Data trace files, Examples, Declaration files, File formats
@section Data trace files


The format of the value information is:
@example
  program-point-name
  varname1
  var-value-1
  var-modified-1
  varname2
  var-value-2
  var-modified-2
  ...
@end example

Value information includes:
@itemize @bullet
@item name of the program point
@item for each variable:
@itemize @bullet
@item name
@item value
@itemize @bullet
@item    integer: sequence of digits, optionally preceded by a minus sign
@item    string: characters surrounded by double-quotes; internal
double-quotes and backslashes are escaped by a backslash; newlines and
carriage returns are represented as "\n" and "\r", respectively
@item    array: elements are listed on one line, separated by spaces.
The entire array contents are in square brackets.  (Also, the array name
should end in "[]"; use "a[]" for array contents, but "a" for the identity
of the array itself.)
@end itemize
@item modified? (0 or 1).
This value is 0 if the variable has not been assigned to since the
last time this program point was executed, and 1 if the variable has
been assigned to since then.  It is safe for an implementation to
always set it to 1.  It is also safe to always set it to 0, as daikon
fixes up the modbits.

@c if the
@c modbit-munge.pl script is run on the resulting @file{.dtrace} file to fix up
@c the modbits.
@end itemize

The variables should appear in the same order as they did in the
declaration of the program point, without omissions or additions.
@end itemize

As a special case, the first variable in a record may be
"this_invocation_nonce", in which case there is no modification
information, only a value.  The nonce is used to match up procedure entries
(whose names end with ":::ENTER") with procedure exits (whose names end
with ":::EXIT"); this is necessary in concurrent systems because there may
be several invocations of a procedure active at once and they do not
necessarily follow a stack discipline, being exited in the reverse order of
entry.  For non-concurrent systems, this nonce is not necessary and may be
omitted.


@node    Examples,  , Data trace files, File formats
@section Examples


Here are two files, p180-15.1.1.decls and (part of) p180-15.1.1.dtrace, for
a program that sums the values in an integer array.

@menu
* Example declaration file::    
* Example data trace file::     
@end menu

@node    Example declaration file, Example data trace file, Examples, Examples
@subsection Example declaration file

This is part of the file @file{StackAr.decls}, a declaration file for
the @file{StackAr.java} program (@pxref{Example use}).

@example
DECLARE
StackAr.push(Ljava/lang/Object;)V:::ENTER
x
Object
int
1
x.class
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr.push(Ljava/lang/Object;)V:::EXIT96
x
Object
int
1
x.class
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr:::OBJECT
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0
@end example


@node    Example data trace file,  , Example declaration file, Examples
@subsection Example data trace file

This is part of file @file{StackAr.dtrace}, which you can create by
running the instrumented @file{StackAr.java} program (@pxref{Example
use}).  This excerpt contains only the first two calls to @code{push}
and the first return from @code{push}, along with the associated object
program point records; omitted records are indicated by ellipses.


@example
...

StackAr.push(Ljava/lang/Object;)V:::ENTER
this_invocation_nonce
55
x
1217030
1
x.class
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

...

StackAr.push(Ljava/lang/Object;)V:::EXIT96
this_invocation_nonce
55
x
1217030
1
x.class
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[1217030]
1
this.theArray[].class
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[1217030]
1
this.theArray[].class
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

...

StackAr.push(Ljava/lang/Object;)V:::ENTER
this_invocation_nonce
94
x
1482257
1
x.class
"DataStructures.StackAr"
1
this.theArray
350965
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
350965
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

...
@end example



@node     Index,  , File formats, Top
@unnumbered Index

@printindex cp


@bye

