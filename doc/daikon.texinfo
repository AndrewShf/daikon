\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename daikon.info
@settitle The Daikon Invariant Detector User Manual
@c %**end of header

@c To update all the nodes and menus all at once:   C-u C-c C-u m
@c You shouldn't need to do that, though; the Makefile does it for you.

@c I can't get this to work, don't know why.  MDE 4/2001.
@c @alias directory = file

@c texi2html doesn't work if I use this macro
@c @macro daikonurl{}
@c http://pag.csail.mit.edu/daikon/
@c @end macro

@c Note about ``@table @option''.
@c Unfortunately, @option{} adds quotes in the Info and printed output
@c which is not necessary in a table.  However, @t and @code compress any
@c two adjacent hyphens to one in Info and HTML output, which is even worse.

@c Problem: with texinfo 4.0, the HTML formatting leaves the "{}" after
@c uses of the macro.  (Formatting seems fine for info, for printing, etc.)
@c So for now, I have inlined all instances of the macro.  Yuck.
@c Another solution would be to use "makeinfo -E" (then process the
@c resulting file with "makeinfo --html").
@macro daikonemail{}
@email{daikon-developers@@lists.csail.mit.edu}
@end macro

@c @setchapternewpage odd

@c @ifinfo
@c @c This text appears only in the Info Version.
@c 
@c Copyright 1998-2005
@c @end ifinfo

@c Avoid black boxes marking overfull hboxes in TeX output.
@finalout

@titlepage
@sp 10
@c Could also use @title, @subtitle, @author here.
@center @titlefont{Daikon Invariant Detector User Manual}

@sp 2
@center Daikon version 4.1.3

@sp 1
@c Daikon version 4.1.3 date
@center July 1, 2005

@sp 5
@c reads daikon-logo.{eps,pdf} (not .txt, .png, or .jpg, because info
@c and HTML don't get the title page)
@image{images/daikon-logo,4in,}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998-2005
@c Copyright @copyright{} 1998-2001 Michael Ernst
@end titlepage

@html
<img src="images/daikon-logo.gif" alt="Daikon logo">
@end html
@c Why is this here?  It duplicates the stuff further down.
@c @html
@c <h1>Daikon Invariant Detector User Manual</h1>
@c
@c This is the user manual for the Daikon invariant detector.
@c It describes Daikon version 4.1.3, released July 1, 2005.
@c @end html

@c Putting this lower in the HTML version looks a little bit strange,
@c but it's acceptable. 
@ifnothtml
@contents
@end ifnothtml

@node    Top, Introduction, (dir), (dir)
@comment node-name, next,          previous, up

@ifnottex
@c Unfortunately, the Daikon logo doesn't look good in ASCII.
@c @ifinfo
@c @image{images/daikon-logo,4in,}
@c 
@c @end ifinfo
This is the user manual for the Daikon invariant detector.
It describes Daikon version 4.1.3, released July 1, 2005.
@end ifnottex

@menu
* Introduction::                
* Installing Daikon::           
* Example usage::               
* Running Daikon::              
* Daikon output::               
* Enhancing Daikon output::     
* Front ends::                  
* Tools::                       
* Troubleshooting::             
* Details::                     
* File formats::                
* Index::

@ifhtml
@contents
@end ifhtml
@ifnothtml

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Mailing lists::               

Installing Daikon

* Minimal installation::        
* Complete installation::       

Complete installation instructions

* Requirements::                
* Installation steps::          
* Windows installation notes::  
* Cygwin installation notes::   

Example usage for Java, C, and Perl

* Detecting invariants in Java programs::  
* Detecting invariants in C programs::  
* Detecting invariants in Perl programs::  

Detecting invariants in Java programs

* Eclipse plug-in::             
* StackAr example::             
* Understanding the invariants::  

Detecting invariants in C programs

* C examples::                  
* Dealing with large examples::  

Detecting invariants in Perl programs

* Instrumenting Perl programs::  
* Perl examples::               

Running Daikon

* Options to control Daikon output::  
* Options to control invariant detection::  
* Processing only part of the trace file::  
* Daikon configuration options::  
* Daikon debugging options::    

Daikon output

* Invariant syntax::            
* Program points::              
* Variable names::              
* Interpreting output::         
* Invariant list::              
* Invariant filters::           

Variable names

* orig variable example::       

Interpreting Daikon output

* Equal variables::             

Enhancing Daikon output

* Configuration options::       
* Conditional invariants::      
* Enhancing conditional invariant detection::  
* Loop invariants::             

Configuration options

* List of configuration options::  

Conditional invariants and implications

* Splitter info file::          
* Indiscriminate splitting::    
* Example splitter info file::  

Splitter info file

* Program point sections::      
* Replacement sections::        

Example splitter info file

* Example class::               
* Resulting .spinfo file::      

Enhancing conditional invariant detection

* Static analysis for splitters::  
* Cluster analysis for splitters::  
* Random selection for splitters::  

Front ends

* Chicory::                     
* Kvasir::                      
* dfepl::                       
* convertcsv.pl::               
* dfej::                        
* dfec::                        
* Other front ends::            

Java front end Chicory

* Chicory options::             

C front end Kvasir

* Using Kvasir::                
* Kvasir options::              
* Pointer type disambiguation::  
* Online execution::            
* Installing Kvasir::           
* Kvasir limitations::          

Pointer type disambiguation

* Pointer type disambiguation example::  

Perl front end dfepl

* dfepl options::               

Source-based Java front end dfej

* Instrumenting Java programs::  
* dfej options::                
* Run dfej Java::               
* Scope of instrumentation::    
* Refined runtime types::       
* Installing dfej::             
* All-in-one script::           

Instrumenting Java programs

* StackAr example with dfej::   
* Summary of Daikon use with dfej::  
* Automating the process::      
* Second Java example::         

Details on running dfej-instrumented Java programs

* Java applets::                

All-in-one script daikon.pl

* daikon.pl arguments::         

Source-based C front end dfec

* Instrumenting C programs with dfec::  
* dfec examples::               
* dfec command-line arguments::  
* dfec runtime customization::  
* Instrumentation scope::       
* dfec requirements::           
* Installing dfec::             

dfec examples

* Dfec C examples summary::     

Instrumentation scope

* Memory tracking details::     
* Memory tracking in libraries::  

dfec requirements

* C program requirements::      
* Header file dependencies::    
* gcc version::                 

Installing dfec, the source-based Daikon front end for C

* dfec EDG sources::            

Tools for use with Daikon

* Tools for manipulating invariants::  
* DtraceDiff utility::          

Tools for manipulating invariants

* Printing invariants::         
* Invariant Diff::              
* Annotate::                    
* Runtime-check instrumenter::  
* InvariantChecker::            
* LogicalCompare::              

Invariant Diff

* Annotate::                    
* Runtime-check instrumenter::  
* InvariantChecker::            
* LogicalCompare::              

Runtime-check instrumenter (runtimechecker)

* Accessing violations::        

Troubleshooting

* Daikon problems::             
* Large dtrace files::          
* Parsing Java 5.0 code::       
* Chicory problems::            
* dfej problems::               
* Eclipse plug-in problems::    
* dfec problems::               
* Reporting bugs::              
* Known bugs::                  
* Further reading::             

Problems running Daikon

* Too much output::             
* No samples::                  
* No return from procedure::    
* Unsupported class version::   
* Out of memory::               
* Simplify errors::             
* Contradictory invariants::    
* Method needs to be implemented::  
* Daikon runs slowly::          

Large data trace (.dtrace) files

* Reducing program points::     
* Reducing variables::          
* Reducing executions::         

Problems with Chicory

* VerifyError constant pool index error::  

Problems with dfej

* dfej installation problems::  
* dfej invocation problems::    
* dfej javac problems::         
* JVM initialization error::    

Problems running dfej

* Ajax errors::                 

Problems with dfec

* dfec instrumentation problems::  
* Compilation and linking of instrumented code problems::  
* Running instrumented code problems::  

Problems running dfec

* Lackwit problems::            

Problems compiling and linking instrumented programs

* Compiler problems::           
* Linker problems::             

Details

* History::                     
* License::                     
* Mailing lists reminder::      
* Credits::                     

File formats

* Conventions::                 
* Declarations::                
* Data trace records::          
* Example files::               

Declarations

* Program point declarations::  
* pptname format::              
* VarComparability declaration::  
* ListImplementors declaration::  

Example files

* Example declaration file::    
* Example data trace file::     

@end detailmenu
@end ifnothtml
@end menu

@node    Introduction, Installing Daikon, Top, Top
@chapter Introduction

@c If you edit the introduction, then re-generate daikon.html and insert
@c its ``Introduction'' section into $inv/doc/www/index.html .


@uref{http://pag.csail.mit.edu/daikon/, ,Daikon} is an implementation of
dynamic detection of likely invariants; that is, the Daikon invariant
detector reports likely program invariants.  An invariant is a property
that holds at a certain point or points in a program; these are often
seen in assert statements, documentation, and formal specifications.
Invariants can be useful in program understanding and a host of other
applications.  Examples include ``.field > abs(y)''; ``y = 2*x+3''; ``array
a is sorted''; ``for all list objects lst, lst.next.prev = lst''; ``for all
treenode objects n, n.left.value < n.right.value''; ``p != null =>
p.content in myArray''; and many more.  You can extend Daikon to add new
properties.

Dynamic invariant detection runs a program, observes the values that the
program computes, and then reports properties that were true over the
observed executions.  
@c Daikon's output, which is sometimes called an ``operational abstraction'',
@c looks like a formal specification, or the contents of assert statements.
Daikon can detect properties in Java,
Perl, C, and @uref{http://theory.csail.mit.edu/tds/ioa/, ,IOA} programs;
in spreadsheet files; and in other data sources.  (Dynamic invariant
detection is a machine learning technique that can be applied to
arbitrary data.)  It is easy to extend Daikon to other applications; as
one example, an interface exists to the
@uref{http://ase.arc.nasa.gov/visser/jpf/, , Java PathFinder model
checker}.

Daikon is freely available for download from
@uref{http://pag.csail.mit.edu/daikon/download/}.  The distribution
includes both source code and
@uref{http://pag.csail.mit.edu/daikon/download/doc/, ,documentation},
and Daikon's license permits unrestricted use (@pxref{License}).  Many
researchers and practitioners have used Daikon; those uses, and Daikon
itself, are described in various
@uref{http://pag.csail.mit.edu/daikon/pubs/, ,publications}.

More information on Daikon can be found in the Daikon Developer
Manual.  For instance, the Daikon Developer Manual indicates how to
extend Daikon with new invariants, new derived variables, and front
ends for new languages.  It also contains information about the
implementation and about debugging flags.

@menu
* Mailing lists::               
@end menu

@node    Mailing lists,  , Introduction, Introduction
@section Mailing lists
@cindex mailing lists
@cindex daikon-announce mailing list
@cindex daikon-discuss mailing list
@cindex daikon-developers mailing list

The following mailing lists (and their archives) are available:
@table @samp
@item daikon-announce@@lists.csail.mit.edu
A low-volume, announcement-only list.  For example,
announcements of new releases are sent to this list.
To subscribe, visit
@uref{http://lists.csail.mit.edu/mailman/listinfo/daikon-announce}.
@item daikon-discuss@@lists.csail.mit.edu
A moderated list for the community of Daikon users.  Use it to share
tips and successes, and to get help with questions or problems (after
checking the documentation).  To subscribe, visit
@uref{http://lists.csail.mit.edu/mailman/listinfo/daikon-discuss}.
@item daikon-developers@@lists.csail.mit.edu
This list goes to the Daikon maintainers.  Use it for bug reports,
suggestions, and the like.  If you are an active contributor to Daikon,
you may send mail to the list asking to be added.
@end table


@node    Installing Daikon, Example usage, Introduction, Top
@chapter Installing Daikon
@cindex installing Daikon

This section describes two ways to install Daikon.  The first gives a
minimal installation that is adequate for the needs of most users.
The second gives a complete installation that some users may prefer.

Use the minimal installation instructions if you only wish to detect
invariants in Java programs.  Use the complete installation instructions
(which are easy to follow) if you wish to detect invariants in C or Perl
programs, or if you wish to edit the source code of Daikon itself.

Differences between various versions of Daikon appear
in the file @file{doc/CHANGES} in the distribution.  
You may wish to subscribe to one of the mailing lists
(@pxref{Mailing lists}), in order to be notified of new releases or join
discussions with other Daikon users and developers.


@menu
* Minimal installation::        
* Complete installation::       
@end menu

@node    Minimal installation, Complete installation, Installing Daikon, Installing Daikon
@section Minimal installation instructions

Daikon is written in Java.  In order to run Daikon, all you really need
is the @file{daikon.jar} file, which is included in the distribution or
can be downloaded separately from
@uref{http://pag.csail.mit.edu/daikon/download/daikon.jar}.  Place
@file{daikon.jar} on your classpath so that Java can find it.  You are
now ready to use Daikon!

Here are a few additional details.  You must have a Java 5.0 (or later)
JVM (@uref{http://java.sun.com,, Java Virtual Machine}).  The
@file{tools.jar} file that comes with your JVM must also be on your
classpath.


@node    Complete installation,  , Minimal installation, Installing Daikon
@section Complete installation instructions

This section gives step-by-step instructions for installing Daikon.
The instructions in @ref{Installation steps} are targeted for
Unix users.  If you use another operating system such as Windows, you
may need to adjust the instructions.  (Contributions to this manual
for other operating systems are welcome.)

@menu
* Requirements::                
* Installation steps::          
* Windows installation notes::  
* Cygwin installation notes::   
@end menu


@node    Requirements, Installation steps, Complete installation, Complete installation
@subsection Requirements for running Daikon

In order to run Daikon, you must have a Java 5.0 (or later) JVM
(@uref{http://java.sun.com,, Java Virtual Machine}).

Unless you are using Chicory, the classfile-based front end for Java, 
you also need a compiler for whatever language your target programs are
written in.  For instance, if you
wish to analyze C or C++ programs, you need a C or C++ compiler such as
GCC.

If you wish to edit the Daikon sources, then re-compile Daikon, you
will need a java compiler (javac) and the C preprocessor, cpp.  If you
have a C compiler, you almost certainly have cpp.

@node  Installation steps, Windows installation notes, Requirements, Complete installation
@subsection Installation steps

@enumerate
@item
In the directory where you want to install Daikon (we'll call this
the @var{daikonparent} directory), 
download and unpack Daikon.  Daikon is available as a tar file from
@uref{http://pag.csail.mit.edu/daikon/download/daikon.tar.gz},
or as a zip file from
@uref{http://pag.csail.mit.edu/daikon/download/daikon.zip}.
The two files contain the same information; you only need one of them.
For example, you could use one of the following sets of commands:
@example
cd @var{daikonparent}
wget http://pag.csail.mit.edu/daikon/download/daikon.tar.gz
tar zxf daikon.tar.gz
@end example
@noindent
or
@example
cd @var{daikonparent}
wget http://pag.csail.mit.edu/daikon/download/daikon.zip
unzip daikon.zip
@end example
@noindent
This creates a @file{@var{daikonparent}/daikon/} subdirectory.

@item
Set up your environment.  You need to arrange for @file{daikon.jar} to
be on your Java classpath.  One easy way to do this is to make your
shell initialization file set the @env{DAIKONPARENT} environment variable (to
an absolute pathname) and source the appropriate Daikon environment
file.  (Alternately, you could set your classpath yourself.)
@itemize 
@item
@cindex C shell
@cindex csh shell
@cindex tcsh shell
If you use the csh or tcsh shell, add the
following to your @file{.cshrc} file:
@example
setenv DAIKONPARENT @var{daikonparent}
source $DAIKONPARENT/daikon/bin/daikon.cshrc
@end example
@noindent
@item
@cindex Bourne shell
@cindex bash shell
If you use the bash shell, add the following to your
@file{.bash_profile} file:
@example
export DAIKONPARENT=@var{daikonparent}
source $DAIKONPARENT/daikon/bin/daikon.bashrc
@end example
@item
If you use Windows, add the following to your startup file:
@example
set DAIKONPARENT=@var{daikonparent}
@end example
before sourcing file @file{$DAIKONPARENT\daikon\bin\daikonenv.bat}.
@end itemize
@noindent

After editing your shell initialization file, either execute the commands
you placed in it, or else log out and log back in to achieve the same
effect.

You can examine the appropriate Daikon environment file to learn of
other variables you can customize.

@item
Optionally, build various executables used by Daikon, such as
the C front end Kvasir
(@pxref{Installing Kvasir}), the source-based Java front end dfej
(@pxref{Installing dfej}), and the source-based C front end dfec
(@pxref{Installing dfec}).

@end enumerate


@node    Windows installation notes, Cygwin installation notes, Installation steps, Complete installation
@subsection Windows installation notes

@cindex Windows
@cindex Microsoft Windows

If you are running Daikon under Microsoft Windows, you have two
options:  using native Windows utilities, or using the Cygwin
environment.

Daikon and most of its related programs, such as Chicory, run under
Windows as command-line applications.  You should invoke them from a
command shell --- either an Windows command shell or a Cygwin command
shell --- rather than by double-clicking their icons.  In any event,
double-clicking would not supply the proper arguments to the program.

The first option is to run Daikon using native Windows utilities.
Before running Daikon, you must invoke the @file{daikonenv.bat} batch
file (once) in the Windows command shell to set up the environment
properly.  To automatically run something (such as a batch file) every
time the Windows command shell is started, set the value of this
registry key to the program you want to run:
@example
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\AutoRun
@end example
@noindent
You may also wish to set two registry entries to enable automatic completion:
@example
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\CompletionChar
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\PathCompletionChar
@end example
@noindent
The values for these registry entries are ASCII key codes.  Tab is 9.


@node    Cygwin installation notes,  , Windows installation notes, Complete installation
@subsection Cygwin installation notes

@cindex Cygwin toolset

The second option for Windows is to run Daikon using the Cygwin
toolset (available at @uref{http://sources.redhat.com/cygwin/}), which
contains everything you need to compile and run Unix programs under
Windows.  You can install Cygwin by simply running the program found
at @uref{http://sources.redhat.com/cygwin/setup.exe}.  

There is an incompatibility between Cygwin and programs compiled for
Windows.  (The incompatibility does not exist if the program was
compiled for Cygwin.)  The incompatibility is that Windows programs
use the semicolon (@samp{;}) as their path separator (for instance,
for @env{CLASSPATH}), but Unix and Cygwin programs use the colon (@samp{:})
as their path separator.  The dfej executable compiled on Cygwin seems
to accept both Windows-style and Cygwin/Unix-style paths.

The @file{cygwin-runner.pl} script in the @file{bin/} directory may
help you run windows-native Java tools from within the Cygwin
environment.  It translates Unix @samp{:}-separated pathlists to
Windows @samp{;}-separated pathlists, changes filenames to their 8.3
``old style'' name (e.g., @file{My Documents} to @file{MYDOCU~1}),
changes forward slashes to backslashes, and translates paths with
Cygwin mount points to simple @file{C:\}-like paths.

For now, @file{cygwin-runner.pl} doesn't touch environment variables,
but you can still use it for classpath by getting your classpath onto
the command line explicitly:
@example
$ dfej -classpath $CLASSPATH DataStructures/StackAr.java
@end example
(It would be nice to patch cygwin-runner to translate environment
variables, too.  For example, always translate @env{CLASSPATH}, or
always translate anything listed in @env{CYGWIN_RUNNER_ENV} (e.g.,
@samp{CYGWIN_RUNNER_ENV="PATH:CLASSPATH:PWD"}) so users can set
@env{CYGWIN_RUNNER_ENV} in their dotfiles or various wrappers.)


@node    Example usage, Running Daikon, Installing Daikon, Top
@chapter Example usage for Java, C, and Perl

Detecting invariants involves two steps:
@enumerate
@item
Obtain a data trace file by running your program under the control of a
front end (also known as an instrumenter) that records information about
variable values.  You can run your program over an input of your own
choosing, such as regression tests or a typical user input session.

@item
Run the Daikon invariant detector over the data trace files
(@pxref{Running Daikon}).  This detects invariants in the recorded
information.  You can view the invariants textually, or process them
with an additional program.
@end enumerate
@noindent
Often, you can run a single command that performs both steps.

This section briefly describes how to obtain data traces for Java, C,
and Perl programs, and how to run Daikon.  For detailed information about
these and other front ends that are available for Daikon, @ref{Front ends}.

@menu
* Detecting invariants in Java programs::  
* Detecting invariants in C programs::  
* Detecting invariants in Perl programs::  
@end menu

@node    Detecting invariants in Java programs, Detecting invariants in C programs, Example usage, Example usage
@section Detecting invariants in Java programs

In order to detect invariants in a Java program, run the
program using the Chicory front end to create a data trace file, then
run Daikon itself to detect invariants.
With the @option{--daikon} option to Chicory, a single command performs
both steps.

For example, if you usually run
@example
java mypackage.MyClass arg1 arg2 arg3
@end example
@noindent
@noindent
then instead you would run
@example
java daikon.Chicory --daikon mypackage.MyClass arg1 arg2 arg3
@end example


@menu
* Eclipse plug-in::             
* StackAr example::             
* Understanding the invariants::  
@end menu

@node    Eclipse plug-in, StackAr example, Detecting invariants in Java programs, Detecting invariants in Java programs
@subsection Eclipse plug-in
@cindex Eclipse plug-in
@cindex GUI, Eclipse

Daikon is integrated with the 
@uref{http://eclipse.org/, ,
Eclipse} IDE (Integrated Development Environment) for Java.
The Daikon plug-in provides a convenient way to instrument files,
obtain trace information, analyze those traces,
and create appropriately annotated Java source code.
For
details, see the @uref{daikonHelp.html, , Daikon Eclipse plug-in
documentation}.

As of this writing (February 11, 2005), the plug-in only works with 
Daikon 3 (for instance, version 3.1.7), not with Daikon 4.  Support for
Daikon 4 is underway.

For brief troubleshooting information, see @ref{Eclipse plug-in problems}.


@node    StackAr example, Understanding the invariants, Eclipse plug-in, Detecting invariants in Java programs
@subsection StackAr example

The Daikon distribution contains some sample programs that will help
you get practice in running Daikon.

To detect invariants in the StackAr sample program, perform the following steps.

@enumerate
@item
Compile the program with the @option{-g} switch to enable debugging
symbols.  (The program and test suite appear in the
@file{DataStructures} subdirectory directory.)
@example
cd examples/StackAr
javac -g DataStructures/*.java
@end example

@item Run the program under the control of the Chicory front end, in
order to create a @file{StackArTester.dtrace.gz} file.

@example
java daikon.Chicory DataStructures.StackArTester
@end example

@item Run Daikon on the trace file.

@example
java daikon.Daikon StackArTester.dtrace.gz
@end example

Alternately, you can combine this step and the previous one into a
single command:
@example
java daikon.Chicory --daikon DataStructures.StackArTester
@end example

In either case, the invariants are printed to standard output, and a binary
representation of the invariants is written to @file{StackAr.inv.gz}.


@item Examine the invariants.

There are various ways to do this.
@itemize @bullet
@item Examine the output from running Daikon.  (You may find it
convenient to capture the output in a file; add @samp{> StackAr.txt}
to the end of the command that runs Daikon.)

@item Use the PrintInvariants program to display the invariants.

@example
java daikon.PrintInvariants StackAr.inv.gz
@end example

For more options to the PrintInvariants program, @xref{Printing
invariants}.

@item Use the Annotate program to insert the invariants as comments
into the Java source program.

@example
cd ..
java daikon.tools.jtb.Annotate daikon-output/StackAr.inv.gz \
     DataStructures/StackAr.java
@end example

Now examine file @file{DataStructures/StackAr.java-escannotated}.
For more information about the Annotate program, @xref{Annotate}.

@c @item Use the Daikon Tree GUI to browse the invariants.  The Tree GUI
@c contains a tree that hierarchically organizes program points according
@c to their class and method.  Using the GUI, you can look at invariants
@c for only the methods and program points you care about.
@c 
@c @example
@c java daikon.gui.treeGUI.InvariantsGUI StackAr.inv.gz
@c @end example

@c @item Use the Daikon Context GUI to browse the invariants.  As you move
@c the cursor in an editor window, the Context GUI displays the invariants
@c applicable to the current location (class or method).  For details on
@c running the Context GUI, see @ref{Context GUI}.  

@end itemize
@end enumerate


@node    Understanding the invariants,  , StackAr example, Detecting invariants in Java programs
@subsection Understanding the invariants

This section examines some of the invariants for the StackAr example.
For more help interpreting invariants, see @ref{Interpreting output}.

The StackAr example is an array-based stack implementation.  Take a
look at @file{DataStructures/StackAr.java} to get a sense of the
implementation.  Now, look at the first section of Daikon output.

@c   In
@c the Tree GUI, expand the node labeled @command{StackAr}, then select the
@c node labeled @command{StackAr:Object}.
@c 
@c @emph{(Note: The invariants displayed in the Tree GUI may be different than the
@c invariants written to standard out by Daikon.  This is because the
@c invariants are being filtered differently.  We are currently working
@c to resolve this issue.)}

@example
======================================================================
StackAr:::OBJECT
this.theArray != null
this.theArray.class == "java.lang.Object[]"
this.topOfStack >= -1
this.theArray[this.topOfStack+1..] elements == null
this.theArray[0..this.topOfStack] elements != null
this.topOfStack <= size(this.theArray[])-1
======================================================================
@end example

These six annotations describe the representation invariant.  The
array is never null, and its runtime type is @code{Object[]}.  The
@code{topOfStack} index is at least -1 and is less than the length
of the array.  Finally, the elements of the array are non-null if
their index is no more than @code{topOfStack} and are null
otherwise.

Next, look at the invariants for the @code{top()} method.
@c In
@c the Tree GUI, expand the node labeled @command{top()Ljava/lang/Object;}.
@code{top()} has two different exit points, at lines 78 and 79
in the original source.  There is a set of invariants for each exit
point, as well as a set of invariants that hold for all exit points.
Look at the invariants when @code{top()} returns at line 79.
@c In the Tree GUI, select the node labeled @command{EXIT79}.

@example
======================================================================
StackAr.top():::EXIT79
return == this.theArray[this.topOfStack]
this.theArray == orig(this.theArray)
this.theArray[] == orig(this.theArray[])
this.topOfStack == orig(this.topOfStack)
return != null
this.topOfStack >= 0
this.theArray[this.topOfStack+1..] elements == this.theArray[-1]
======================================================================
@end example

The return value is never null, and is equal to the array element at
index @code{topOfStack}.  The top of the stack is at least 0.  The
array, the elements of the array, and @code{topOfStack} are not
modified by this method --- this method is an ``observer''.  The
last invariant is not particularly interesting.




@node    Detecting invariants in C programs, Detecting invariants in Perl programs, Detecting invariants in Java programs, Example usage
@section Detecting invariants in C programs

In order to detect invariants over C programs, you must first install
the C front end Kvasir; see @ref{Installing Kvasir}.

To use the C front end Kvasir with your program, first make sure that
your program has been compiled with DWARF-2 format debugging
information, such as by giving the @option{-gdwarf-2} flag to GCC when
compiling.  Then, run your program as usual, but prepend
@command{kvasir-dtrace} to the command line.

For more information about Kvasir, including more detailed
documentation on its command-line options, see @ref{Kvasir}.


@menu
* C examples::                  
* Dealing with large examples::  
@end menu

@node    C examples, Dealing with large examples, Detecting invariants in C programs, Detecting invariants in C programs
@subsection C examples

The Daikon distribution comes with several example C programs in the
@file{examples/kvasir-examples} directory to enable users to become
familiar with running Daikon on C programs.

@c There are two sets of examples, corresponding to the two supplied C
@c front ends.  Examples intended for use with the binary-based front end
@c Kvasir are in a subdirectory @file{kvasir-examples}; examples for the
@c older source-based front end dfec are in a subdirectory
@c @file{dfec-examples}.  It should be possible to instrument the dfec
@c examples with Kvasir, though we will not give directions here.
@c Instrumenting the Kvasir examples with dfec is not recommended (and is
@c not likely to work).


To detect invariants for a program with Kvasir, you need to perform
two basic tasks:  run the program under Kvasir to create a data trace
file (steps 1--2), and run
Daikon over the data trace file to produce invariants (steps 3--4).
The following instructions are for the wordplay example, which is a
program for finding anagrams.

@enumerate
@item Change to the directory containing the program.
@example
cd $DAIKONDIR/examples/kvasir-examples/wordplay
@end example

@item Compile the program with DWARF-2 debugging information enabled.
@example
gcc -gdwarf-2 wordplay.c -o wordplay
@end example

Kvasir can also be used for programs constructed by compiling a number
of @file{.c} files separately, and then linking them together; in such
a program, specify @option{-gdwarf-2} when compiling each source file
containing code you wish to see invariants about.

@item Run the program just as you normally would, but prepend
@command{kvasir-dtrace} to the command line.
@example
kvasir-dtrace ./wordplay -f words.txt 'daikon dynamic invariant detector'
@end example

Any options to the program can be specified as usual; here, for
instance, we give commands to look for anagrams of the phrase ``Daikon
Dynamic Invariant Detector'' using words from the file @file{words.txt}.

Executing under Kvasir, the program runs normally, but Kvasir will
executes additional checks and collects trace information (for this
reason, the program will run more slowly than usual).  Kvasir creates a
directory named @file{daikon-output} under the current directory, and
creates files @file{wordplay.decls} and @file{wordplay.dtrace} describing
its observations.

Kvasir will also print messages if it observes your program doing
something with undefined effects; these may indicate bugs in your
program, or they may be spurious.  (If they are bugs, they can also be
tracked down by using Valgrind (@uref{http://valgrind.kde.org/})
with its regular memory checking
tool; if they do not appear with that tool, they are probably
spurious).

@item Run Daikon on the trace file.
@example
java daikon.Daikon \
     --config_option daikon.Daikon.disable_derived_variables=true \
     daikon-output/wordplay.decls daikon-output/wordplay.dtrace
@end example

The invariants are printed to standard output, and a binary representation
of the invariants is written to @file{wordplay.inv.gz}.  Note that the
example uses a configuration option to disable the use of derived
variables; it can also run without that option, but takes significantly
longer.

@item Examine the invariants.  As described in @xref{StackAr example},
there are several ways to do this:
@itemize 
@item Examine the output from running Daikon.
@item Use the PrintInvariants program to display the invariants.
@c @item Use the Daikon Tree GUI to browse the invariants.  (Deprecated.)
@end itemize
@noindent
For help understanding the invariants, see @ref{Interpreting output}.

@end enumerate


@node    Dealing with large examples,  , C examples, Detecting invariants in C programs
@subsection Dealing with large examples

Beware that several of the C example programs require significant
resources in terms of memory, CPU time, or disk space.  Therefore they
can also serve as examples of techniques for limiting Daikon's
resource usage.

Since the default memory size used by Java virtual machines varies, we
suggest that Daikon be run on the examples with at least 256 megabytes of
memory, specified for many JVMs by the option @option{-Xmx256m}.
The schedule example uses even more space: we suggest specifying
@option{-Xmx768m}, and avoiding the example altogether unless your
workstation has at least a gigabyte of physical memory.  For more
information about specifying the memory usage for Daikon, see
@ref{Out of memory}.

Most of the C examples shouldn't require more than a minute of
processing time for any single step, but the schedule2 example
requires about 10 minutes, the Rijndael example about 20, and the
schedule example more than an hour, on a relatively modern
workstation.

Most of the C examples require no more than 50 megabytes of disk
space, but the schedule and schedule2 examples require around 200
megabytes each, and the Rijndael example requires about 600
megabytes.  This disk usage can be reduced by recompiling the Daikon
runtime to compress its output dtrace files; see @ref{dfec runtime
customization}.

In some cases, the time and space requirements of the examples can be
reduced by reducing the length of the program run.  For instance, when
the test.sh script contains many invocations of the program, some can
be commented out.  The Rijndael example includes preprocessor
definitions at the top of the @file{rijndaeltest-ref.c} that control
how many iterations are performed.  However, Daikon's running time
depends on both the length of the test run and the size of the program
(especially in its use of global variables and nested data
structures).  For more techniques for using Daikon with large programs
and long program runs, see @ref{Large dtrace files}.




@node    Detecting invariants in Perl programs,  , Detecting invariants in C programs, Example usage
@section Detecting invariants in Perl programs

The Daikon front end for Perl is called dfepl.

Using the Perl front end is a two-pass
process: first you must run the annotated program so that the runtime
system can dynamically infer the kind of data stored in each variable,
and then you must re-annotate and re-run the program with the added
type information.
This is necessary because Perl programs do not contain type declarations. 

dfepl requires version 5.8 or later of Perl.

@menu
* Instrumenting Perl programs::  
* Perl examples::               
@end menu


@node Instrumenting Perl programs, Perl examples, Detecting invariants in Perl programs, Detecting invariants in Perl programs
@subsection Instrumenting Perl programs

Perl programs must be instrumented twice.  First they must be
instrumented without type information.  Then, once the first
instrumented version has been run to produce type information, they
must be instrumented again taking the type information into account.

To instrument a stand-alone Perl program, invoke dfepl with
the name of the program as an argument.

@example
dfepl program.pl
@end example

To instrument a Perl module or a collection of modules, invoke
dfepl either with the name of each module, or with the name
of a directory containing the modules.  To instrument all the modules
in the current directory, give dfepl the argument @file{.}.
For instance, if the current directory contains a module
@code{Acme::Trampoline} in @file{Acme/Trampoline.pm} and another
module @code{Acme::Date} in @file{Acme/Date.pm}, they can be annotated
by either of the following two commands:

@example
dfepl Acme/Trampoline.pm Acme/Date.pm
dfepl .
@end example

Once type information is available, run the instrumentation command
again with the @option{-T} or @option{-t} options added to use the
produced type information.

For more information about dfepl, see @ref{dfepl}.


@node Perl examples,  , Instrumenting Perl programs, Detecting invariants in Perl programs
@subsection Perl examples

The Daikon distribution includes sample Perl programs suitable for use
with Daikon in the @file{examples/perl-examples} directory.

Here are step-by-step instructions for examining a simple module,
@file{Birthday.pm}, as used by a test script @file{test-bday.pl}.

@enumerate
@item Change to the directory containing the @file{Birthday.pm}
module.
@example
cd examples/perl-examples
@end example

@item Instrument the @file{Birthday.pm} file.
@example
dfepl Birthday.pm
@end example

This command creates a directory @file{daikon-untyped}, and puts
the instrumented version of @file{Birthday.pm} into
@file{daikon-untyped/Birthday.pm}.  As the directory name implies, this
instrumented version doesn't contain type information.

@item Run a test suite using the instrumented @file{Birthday.pm}
file.
@example
dtype-perl test_bday.pl 10
@end example

The @file{dtype-perl} is a script that runs Perl with the appropriate
command line options to find the modules used by the Daikon Perl
runtime tracing modules, and to use the instrumented versions of
modules in @file{daikon-untyped} in preference to their original
ones.  The number 10 is an argument to the @file{test_bday.pl} script
telling it to run a relatively short test.

This will also generate a file
@file{daikon-instrumented/Birthday.types} recording the type of each
variable seen during the execution of the instrumented program.

@item Re-annotate the module using the type information.
@example
dfepl -T Birthday.pm
@end example

This step repeats step 2, except that the @option{-T} flag to
dfepl tells it to use the type information generated in the
previous step, and to put the output in the directory
@file{daikon-instrumented}.  dfepl also converts the
type information into a file @file{daikon-output/Birthday.decls}
containing subroutine declarations suitable for Daikon.

@item Run the full test suite with the type-instrumented
@file{Birthday.pm}.
@example
dtrace-perl test_bday.pl 30
@end example

Here we run another test suite, which happens to be the same
@file{test_bday.pl}, but running for longer. (The example will also
work with a smaller number).  The script @command{dtrace-perl} is
similar to @command{dtype-perl} mentioned earlier, but looks for
instrumented source files in @file{daikon-instrumented}.

This creates @file{daikon-output/test_bday-combined.dtrace}, a trace
file containing the values of variables at each invocation. (The
filename is formed from the name of the test program, with
@file{-combined} appended because it contains the trace information
from all the instrumented modules invoked from the program).

@item Change to the @file{daikon-output} directory to analyze the
output.
@example
cd daikon-output
@end example

@item Run Daikon on the trace file
@example
java daikon.Daikon Birthday.decls test_bday-combined.dtrace
@end example

@item Examine the invariants.  They are printed to standard output, and
they are also saved to file @file{Birthday.inv.gz}, which you can
manipulate with the PrintInvariants program and other Daikon tools.
For example:
@example
java daikon.PrintInvariants Birthday.inv.gz
@end example
@c java daikon.gui.treeGUI.InvariantsGUI Birthday.inv.gz

Invariants produced from Perl programs can be examined using the same
tools as other Daikon invariants. 
@end enumerate

In the example above, the script @file{test_bday.pl} was not itself
instrumented; it was only used to test the instrumented code.  The
Perl front end can also be used to instrument stand-alone Perl
programs.  The following sequence of commands, similar to those above,
show how Daikon can be used with the stand-alone program
@file{standalone.pl}, also in the @file{examples/perl-examples}
directory.

@example
dfepl standalone.pl
dtype-perl daikon-untyped/standalone.pl
dfepl -T standalone.pl
dtrace-perl daikon-instrumented/standalone.pl
cd daikon-output
java daikon.Daikon -o standalone.inv standalone-main.decls \
     standalone-combined.dtrace
@end example

Note two differences when running a stand-alone program.  First, the
instrumented versions of the program, in the @file{daikon-untyped} or
@file{daikon-instrumented} directory, are run directly.  Second, the
declarations file is named after the package in which the subroutines
were declared, but since every stand-alone program uses the
@code{main} package, the name of the program is prepended to the
@file{.decls} file name to avoid collisions.


@node    Running Daikon, Daikon output, Example usage, Top
@chapter Running Daikon

Run the Daikon invariant detector via the command
@example
java daikon.Daikon @i{[@var{flags}]} @var{dtrace-files...} @i{[@var{decl-files...}]} @i{[@var{spinfo-files...}]}
@end example

@itemize
@item
The @var{dtrace-files} are data trace (@file{.dtrace}) files containing
variable values from an execution of the target program.

@item
The @var{decl-files} are declaration (@file{.decl}) files containing
program point declarations.  Be sure to include all declaration files
that are needed for the particular data trace file; the simplest way
is to include every declaration file created when instrumenting the
program.

Not all Daikon front ends produce @file{.decl} files, since program point
declarations may also appear in @file{.dtrace} files.  For instance, the 
Chicory front end for Java (@pxref{Chicory}) produces only @file{.dtrace}
files.  If there are no @file{.decl} files, then it is not necessary to
include them on the command line to Daikon.

@item
The @var{spinfo-files} are splitter info (@file{.spinfo}) files that
enable detection of conditional invariants (@pxref{Conditional
invariants}); these are optional and may be created automatically or by hand.

@end itemize
@noindent
The files may appear in any order;
the file type is determined by whether the file name contains
@file{.decls}, @file{.dtrace}, or @file{.spinfo}.
As a special case, a file name of @file{-} means to read data trace
information from standard input.


@cindex command line options for Daikon
@cindex flags for Daikon
The optional flags are described in the sections that follow.

@menu
* Options to control Daikon output::  
* Options to control invariant detection::  
* Processing only part of the trace file::  
* Daikon configuration options::  
* Daikon debugging options::    
@end menu


@node Options to control Daikon output, Options to control invariant detection, Running Daikon, Running Daikon
@section Options to control Daikon output

@c Unfortunately, @option{} adds quotes in the Info and printed output
@c which is not necessary in a table.  However, @t and @code compress
@c the two hyphens to one in Info and HTML output, which is even worse.
@table @option
@item --help
Print usage message.

@item -o @var{inv_file}
Output serialized invariants to the specified file; they can later be
postprocessed, compared, etc.  Default: @file{@var{basename}.inv.gz} in
the current directory, where the first data trace file's basename starts
with @file{@var{basename}.dtrace}.  Default is no serialized output, if
no such data trace file was supplied.  If a data trace file was
supplied, there is currently no way to avoid creating a serialized
invariant file.

@item --no_text_output
Don't print invariants as text output.  This option may be used in
conjunction with the @option{-o} option.

@item --format @var{name}
Produce output in the given format.  For a list of the output formats
supported by Daikon, see @ref{Invariant syntax}.

@item --show_progress
@itemx --no_show_progress
Prints (respectively, suppresses) timing information as major portions of Daikon are executed.

@item --noversion
Suppress the printing of version information

@item --output_num_samples
@cindex samples breakdown output
@cindex mux output
Output numbers of values and samples for invariants and program points;
this is a debugging flag.  (That is, it helps you understand why Daikon
produced the output that it did.)

The ``Samples breakdown'' output indicates how many samples in the
@file{.dtrace} file had a modified value (``m''), had an unmodified
value (``u''), and had a missing value (``x'').  The summary uses a
capital letter if the sample had any of the corresponding type of
variable, and a lower-case letter if it had none.  These types affect
statistical tests that determine whether a particular invariant (that
was true over all the test runs) is printed.

Only variables that appear in both the pre-state and the post-state
(variables that are in scope at both procedure exit and entry) are
eligible to be listed as modified or unmodified.  This is why the list
of all variables is not the union of the modified and unmodified
variables.

@item --files_from @var{filename}
Read a list of @file{.decl}, @file{.dtrace}, or @file{.spinfo} files from the
given text file, one filename per line, as an alternative to providing
them on the command line.

@item --omit_from_output [0rs]
Omit some potentially redundant information from the serialized output
file produced with @option{-o}.
By default, the serialized output contains all of the data structures
produced by Daikon while inferring invariants.
Depending on the use to which the serialized output will later be put,
the file can sometimes be significantly shortened by omitting
information that is no longer needed.
The flag should be followed by one or more characters each representing
a kind of structures the can be omitted.
The following characters are recognized:

@table @option
@item 0 (zero)
Omit information about program points that were declared, but for which
no samples were found in any @file{.dtrace} file.

@item r
Omit ``reflexive'' invariants, those in which a variable appears more
than once.
Usually, such invariants are not interesting, because their meaning is
duplicated by invariants with fewer variables: for instance, @code{x =
x - x} and @code{y = z + z} can be expressed as @code{x = 0} and
@code{y = 2 * z} instead.
However, Daikon generates and uses such invariants internally to
decide what invariants to create when two previously equal variables
turn out to be different.

@item s
Omit invariants that are suppressed by other invariants.
``Suppression'' refers to a particular optimization
in which the processing of an invariant is
postponed as long as certain other invariants that logically imply it
hold.
@end table

For most uses of serialized output in the current version, it is safe
to use the @option{0} and @option{r} omissions, but the @option{s} omission
will cause subtle output changes.
In many cases, the amount of space saved is modest (typically around
10%), but the savings can be more substantial for programs with many
unused program points, or program points with many variables.

@end table

@node Options to control invariant detection, Processing only part of the trace file, Options to control Daikon output, Running Daikon
@section Options to control invariant detection

@table @option
@cindex confidence limit
@item --conf_limit @var{val}
Set the confidence limit for justifying invariants, which is used to filter
invariants which are satisfied purely by chance from Daikon's output.  
@var{val} must be between 0 and 1; the default is .99 (1%).  Larger values 
yield stronger filtering.

@item --list_type @var{classname}
Indicate that the given class implements the @code{java.util.List}
interface.  The preferred mechanism for indicating such information is
the @code{ListImplementors} section of the @file{.decls} file.  
See @ref{ListImplementors declaration}.

@item --nohierarchy
@cindex hierarchy, disabling
@cindex unmatched entries, not ignoring
Avoid connecting program points in a dataflow hierarchy.  For example,
Daikon normally connects the @code{:::ENTER} program points of class methods
with the class's @code{:::CLASS} program point, so that any invariant 
that holds on the @code{:::CLASS} program point is considered to hold 
true on the @code{:::ENTER}
program point.  With no hierarchy, each program point is treated
independently.  This is for using Daikon on applications that do not
have a concept of hierarchy.  It can also be useful when you wish to
process unmatched enter point samples from a trace file thatis missing
some exit point samples.

@item --suppress_redundant
Suppress display of logically redundant invariants, using the Simplify
automatic theorem prover.  Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to take advantage of this option.  Beware that the process of
detecting redundant invariants can sometimes be time-consuming; the
amount of effort Simplify exerts for each invariant can be controlled
using the @option{daikon.simplify.Session.simplify_max_iterations} and
@option{daikon.simplify.Session.simplify_timeout} configuration
options.

@end table

@node Processing only part of the trace file, Daikon configuration options, Options to control invariant detection, Running Daikon
@section Processing only part of the trace file

Using @option{--ppt-select-pattern} and @option{--ppt-omit-pattern} can
save time even if there are no samples for the excluded program points,
as Daikon can skip the declarations and need not initializing data
structures that would be used if samples were encountered.

@table @option
@item --ppt-select-pattern=@var{ppt_regexp}
Only process program points whose names match the regular expression,
which uses Perl syntax.

@item --ppt-omit-pattern=@var{ppt_regexp}
Do not process program points whose names match the regular expression,
which uses Perl syntax.  This takes priority over the
@option{--ppt-select-pattern} argument.

@item --var-select-pattern=@var{ppt_regexp}
Only process variables (whether in the trace file or derived) whose
names match the regular expression, which uses Perl syntax.

@item --var-omit-pattern=@var{var_regexp}
Ignore variables (whether in the trace file or derived) whose names
match the regular expression, which uses Perl syntax.  This takes
priority over the @option{--var-select-pattern} argument.

@end table

@node Daikon configuration options, Daikon debugging options, Processing only part of the trace file, Running Daikon
@section Daikon configuration options

@table @option
@item --config @var{filename}
Load the configuration settings specified in the given file.
@xref{Configuration options}, for details.

@item --config_option @var{name}=@var{value}
Specify a single configuration setting.
@xref{Configuration options}, for details.

@end table

@node Daikon debugging options,  , Daikon configuration options, Running Daikon
@section Daikon debugging options

@table @option
@item --dbg @var{category}
@itemx --debug
@cindex debugging flags
@cindex category, for debugging
@cindex logging, for debugging Daikon
@cindex Logger
These debugging options cause output to be written to a log file (by
default, to the terminal); in other words, they enable a Logger.
The @option{--dbg @var{category}} option
enables debugging output for a specific part of Daikon; it may be
specified multiple times, permitting find-grained control over debugging
output.  The @option{--debug} option turns on all debugging flags.
(This produces a lot of output!)  Most categories are class or
package names in the Daikon implementation, such as @code{daikon.split}
or @code{daikon.derive.binary.SequencesJoin}.  Only classes that check
the appropriate categories are affected by the debug flags; you can
determine this by looking for a call to @samp{Logger.getLogger} in
the specific class.

@item --track @var{class}<@var{var1},@var{var2},@var{var3}>@@@var{ppt}
@cindex debugging flags
@cindex category, for debugging
@cindex logging, for debugging Daikon
@cindex Logger
Turns on debugging information on the specified class, variables, and
program point.  In contrast to the @option{--dbg} option, track logging follows
a particular invariant through Daikon.  Multiple @option{--track} options
can be specified.  Each item (class, variables, and program point) is optional.
Multiple classes can be specified separated by vertical bars (|).  Matching
is a simple substring (not a regular expression) comparison.  Each item
must match in order for a printout to occur.  See the Daikon Developer
Manual for more information.

@item --disc_reason @var{inv_class}<@var{var1},@var{var2},...>@@@var{ppt}
Prints all discarded invariants of class @var{inv_class} at the program point
specified that involve exactly the variables given, as well as a short reason
and discard code explaining why they were not worthy of print.  Any of 
the three parts of the argument may be made a wildcard by excluding it.
For example, @samp{@var{inv_class}} and
@samp{<@var{var1},@var{var2},...>@@@var{ppt}} are valid arguments.
Concrete examples are @samp{Implication<x,y>@@foo():::EXIT},
@samp{Implication<x,y>}, and @samp{<x,y>@@foo():::EXIT}.
To print all discarded invariants, use the argument @samp{all}.

@item --mem_stat
Prints memory usage statistics into a file named @file{stat.out} in the
current directory.

@end table



@node    Daikon output, Enhancing Daikon output, Running Daikon, Top
@chapter Daikon output

Daikon outputs the invariants that it discovers in textual form to your
terminal.  This chapter describes how to interpret those invariants ---
in other words, what do they mean?

Daikon also creates a @file{.inv} file that contains the invariants in
serialized (binary) form.  You can use the @file{.inv} file to print the
invariants (@pxref{Printing invariants}) in a variety of formats, to
insert the invariants in your source code (@pxref{Annotate}), to perform
run-time checking of the invariants (@pxref{Runtime-check instrumenter},
and @pxref{InvariantChecker}), and to do various other operations.  See
@ref{Tools}, for descriptions of such tools.


@menu
* Invariant syntax::            
* Program points::              
* Variable names::              
* Interpreting output::         
* Invariant list::              
* Invariant filters::           
@end menu

@node    Invariant syntax, Program points, Daikon output, Daikon output
@section Invariant syntax

Daikon can produce output in a variety of formats.  Each of the format
names can be specified as an argument to the @option{--format} argument
of Daikon (@pxref{Options to control Daikon output}), PrintInvariants
(@pxref{Printing invariants}), and Annotate (@pxref{Annotate}).
When passed on the command line, the format names are case-insensitive:
@option{--format JML} and @option{--format jml} have the same effect.

@cindex invariant output format
@cindex output format, for invariants

@table @asis

@cindex Daikon output format
@cindex output format, Daikon
@item Daikon format

Daikon's default format is a mix of Java, mathematical logic, and some
additional extensions.

@cindex has only one value, in invariant output

The output @samp{@var{var} has only one value} means that every time that
variable @var{var} was encountered, it had the same value.  However,
that value is not interesting to report.  Typically this means that
@var{var} always referred to the same object.  Users may care that the
variable was never rebound to a different object, but it would not be
helpful to print out what the hashcode or address of that object
happened to be at runtime.  @samp{@var{var} has only one value} differs from
saying that @var{var} is unmodified.  

A variable can have only one value but not be reported as unmodified
because the variable is not a parameter to a procedure --- for instance,
if a routine always returns the same object, or in a class invariant.  A
variable can be reported as unmodified but not have only one value
because the variable is never modified during any execution of the
procedure, but has different values on different invocations of the
procedure.

@cindex DBC output format
@cindex output format, DBC
@cindex Jtest DBC output format
@cindex output format, Jtest DBC
@item DBC format
This format produces output in the design-by-contract (DBC) format
expected by Parasoft's Jtest tool (@uref{http://www.parasoft.com}).

@c This implementation detail is not relevant to users
@c Like the Java output format, this output format makes extensive use of
@c helper methods defined in class @code{daikon.Quant}.

@cindex ESC/Java output format
@cindex output format, ESC/Java
@item ESC/Java format
@itemx ESC format
The Extended Static Checker for Java (ESC/Java) is a programming tool
for finding errors in Java programs by checking annotations that are
inserted in source code; for more details, see
@uref{http://research.compaq.com/SRC/esc/}.  Daikon's ESC/Java format
(which can also be specified as ESC format) is intended for use with the
original ESC/Java tool.  Use Daikon's JML format for use with the
@uref{http://www.sos.cs.kun.nl/sos/research/escjava/index.html, ,ESC/Java2}
tool.


@cindex IOA output format
@cindex output format, IOA
@item IOA format
IOA is a formal language for describing computational processes that are
modeled using I/O automata; for details, see
@uref{http://theory.csail.mit.edu/tds/ioa/}.

@cindex Java output format
@cindex output format, Java
@item Java format
Write output as Java expressions.  This means that each invariant
would be a valid Java expression, if inserted at the correct program
point: right after method entry, for method entry invariants; 
right before method exit, for method exit invariants;, or anywhere in
the code, for object invariants.

There are two exceptions.  Method exit invariants that refer to
prestate, such as @samp{x == old(x) + 1}, are output with the tag
@samp{\old} surrounding the prestate expression (e.g. @samp{x ==
\old(x) + 1}.  Method exit invariants that refer to the return value of
the method, such as @samp{return == x + y}, are output with the tag
@samp{\result} in place of the return value (e.g. @samp{\result == x + y}).
These expression are obviously not valid Java code.

@c This implementation detail not relevant to users
@c The Java output format makes extensive use of helper methods defined
@c in class @code{daikon.Quant}, which provides methods for
@c quantification and set comprehension over Java collections.  For
@c example, @code{daikon.Quant.eltsEqual(int[] seq1, int elt)} checks
@c whether all elements in @code{seq1} are equal to @code{elt}.  For
@c detailed meanings of all methods in the @code{Quant} class, see the
@c Javadoc documentation for the class (or look inside
@c @file{daikon/QuantBody.java}).

@cindex JML output format
@cindex output format, JML
@item JML format
Produces output in JML (Java Modeling Language,
@uref{http://www.jmlspecs.org}); for details, see the
@uref{http://www.cs.iastate.edu/~leavens/JML.html, ,JML Manual}.  JML
format lets you use the various JML tools on Daikon invariants,
including runtime assertion checking and the
@uref{http://www.sos.cs.kun.nl/sos/research/escjava/index.html, ,ESC/Java2}
tool.

@c This implementation detail not relevant to users
@c Like the Java output format, this output format makes extensive use of
@c helper methods defined in class @code{daikon.Quant}.

@cindex Simplify output format
@cindex output format, Simplify
@item Simplify format
Produces output in the format expected by the Simplify automated theorem
prover; for details, see
@uref{http://research.compaq.com/SRC/esc/simplify/InputSyntax.html}.

@cindex repair output format
@cindex output format, repair
@cindex data structure repair output format
@cindex output format, data structure repair
@item repair format
This format is used by automated data structure repair tools.

@end table


@node    Program points, Variable names, Invariant syntax, Daikon output
@section Program points
@cindex program point

A program point is a specific place in the source code, such as
immediately before a particular line of code.  Daikon's output is
organized by program points.

@cindex :::ENTER program point
@cindex ENTER program point
@cindex precondition

For example, @code{foo():::ENTER} is the point at the entry to procedure
@code{foo()}; the invariants at that point are the preconditions for the
@code{foo()} method, properties that are always true when the procedure
is invoked.

@cindex :::EXIT program point
@cindex EXIT program point
@cindex postcondition
@cindex hierarchy of program points
@cindex program point hierarchy

Likewise, @code{foo():::EXIT} is the program point at the procedure
exit, and invariants there are postconditions.  When there are multiple
exit points from a procedure (for instance, because of multiple
@code{return} statements), the different exits are differentiated by
suffixing them with their line numbers; for instance,
@code{StackAr.top():::EXIT79}.  The exit point lacking a line number (in
this example, @code{StackAr.top():::EXIT}) collects the postconditions
that are true at every numbered exit point.  This is an example of a
program point that represents a collection of locations in the program
source rather than a single location.  This concept is referred to as 
@emph{hierarchy}.  

@cindex :::OBJECT program point
@cindex OBJECT program point
@cindex :::CLASS program point
@cindex CLASS program point
@cindex object invariants
@cindex representation invariants
@cindex class invariants

Two other program point tags that have special meaning to Daikon's hierarchy
organization are @code{:::OBJECT} and @code{:::CLASS}.
The former indicates object invariants (sometimes called representation
invariants or class invariants) that always hold for any object of the
given class, from the point of view of a client or user.  These
properties hold at entry to and exit from every public method of the
class (except not the entry to constructors, when fields are not yet
initialized).
The @code{:::CLASS} tag is just like @code{:::OBJECT}, but only
for static variables, which have only one value for all objects.

@cindex private methods

(By contrast, ESC/Java and JML make class invariants hold even at the
entry and exit of private methods.  Their designers believe that most
private methods preserve the class invariant and are called only when
the class invariant holds.  ESC/Java and JML require an explicit
``helper'' annotation to indicate a private method for which the class
invariant does not hold.)

The Java instrumenters Chicory and dfej select names for program
points that include an indication of the argument and return types for
each method.  These signatures are presented in the JVML format: one
character for each primitive type (@samp{B} for byte, @samp{C} for
character, @samp{Z} for boolean (so as not to clash with byte), etc.);
@samp{L@var{classname};} for object types; and a @samp{[}
prefix for each level of array nesting.


@node    Variable names, Interpreting output, Program points, Daikon output
@section Variable names

Here is an incomplete list of the conventions used by Daikon for
variable names.  Some of these conventions are Java-specific; for
information about conventions in C programs, see @ref{Using Kvasir}.

@itemize @bullet
@item
@cindex @code{orig()} variable (pre-state value)
@cindex pre-state variables
@code{orig(x)} refers to the value of formal parameter @code{x} upon
entry to a procedure (because the procedure body might modify the value
of @code{x}).  These variables appear only at @code{:::EXIT} program
points.
@item
@code{a} (for an array, class, or other non-primitive variable
@code{a}) is the identity of @code{a}; think of it as a
comparison over hash codes.
@item
@cindex @code{.class} variable
@code{a.class} is the runtime type of @code{a}, which may
differ from its declared type.
@c "a.class" is omitted for arrays of primitive type
@item
@cindex @code{a[]} variable (array contents)
@code{a[]} is the contents of array @code{a}, namely a sequence of
elements.  @samp{a=b} implies @samp{a[]=b[]}, but @samp{a[]=b[]} does not 
imply @samp{a=b}.
Also, @samp{a=orig(a)} does not imply @samp{a[]=orig(a[])}.
@item
@code{a[].class} is an array of types, representing the run-time classes
of the contents of @code{a}; it is omitted for arrays of primitive type.
@item
@cindex @code{-1} array index (counts from end of array)
@cindex negative array index (counts from end of array)
@code{a[-1]} denotes the last element of array @code{a};
it is syntactic sugar for @code{a[a.length-1]}.
@item
@cindex @code{.toString} variable
@code{s.toString} is the string value of String @code{s}, namely a
sequence of characters.
@item
@cindex @code{::} variable (C global)
@code{::a} is the global variable @code{a}.  It contains the colons to
differentiate it from @code{a} as a procedure parameter, so that
different properties can be reported over the two different variables.
@end itemize

@cindex local variables
@cindex variables, local
Daikon does not produce output for local variables, only for variables
visible from outside a procedure.  Thus, its output forms a
specification (mostly) from the view of a client of a procedure.  A
future version of Daikon may permit output of local variables as a user
option; send mail to @email{daikon-developers@@lists.csail.mit.edu} if
this functionality is important to you.

@menu
* orig variable example::       
@end menu

@node    orig variable example,  , Variable names, Variable names
@subsection orig variable example

@cindex @code{orig()} variable (pre-state value)

This section gives an example of use of @code{orig()} variables and arrays.

Suppose you have initially that
@example
int i = 0;
int[] a = new int[] @{ 22, 23 @};
int[] b = new int[] @{ 46, 47 @};
@end example

@noindent
and then you run the following:
@example
// pre-state values at this point
a[0] = 24;
a[1] = 25
a = b;
a[0] = 48;
a[1] = 49;
i = 1;
// post-state values at this point
@end example

The values of various variables are as follows:

@table @code
@item orig(a[i]) = 22
The value of @code{a[i]} in the pre-state: @{22, 23@}[0]

@item orig(a[])[orig(i)] = 22
This is the same as orig(a[i]):   @{22, 23@}[0].

@item orig(a[])[i] = 23
The value of @code{a[]} (that is, the array object, not the reference
@code{a}) in the pre-state, indexed by the post-state value of i:
@{22, 23@}[1]

@item orig(a)[orig(i)] = 24
@code{orig(a)} is the original value of the reference @code{a}, not
@code{a}'s original elements: @{24, 25@}[0]

@item orig(a)[i] = 25
The original pointer value of a, indexed by the post-state value
of i:  @{24, 25@}[1]

@item a[orig(i)] = 48
In the post-state, @code{a} indexed by the original value of
@code{i}: @{48, 49@}[0]

@item a[i] = 49
The value of @code{a[i]} in the post-state.
@end table

@node    Interpreting output, Invariant list, Variable names, Daikon output
@section Interpreting Daikon output

@cindex @samp{Exiting}, in Daikon output

If nothing gets printed before the @samp{Exiting} line, then Daikon
found no invariants.  You can get a little bit more information by using
the @option{--output_num_samples} flag to Daikon 
(@pxref{Options to control Daikon output}).


By default, Daikon does not display redundant invariants --- those
that are implied by other invariants in the output --- because such
results would merely clutter the output without adding any valuable
information.  For instance, if Daikon reports @samp{x==y}, then it never
also reports @samp{x-1==y-1}.  You can control this behavior to some extent by 
disabling invariant filters; @xref{Invariant filters}.
(You can also print all invariants, even
redundant ones, by saving the invariants to a @file{.inv} file and
then using the PrintInvariants (@pxref{Printing invariants}) or Diff
(@pxref{Invariant Diff}) programs to print the results.)

@menu
* Equal variables::             
@end menu

@node    Equal variables,  , Interpreting output, Interpreting output
@subsection Equal variables

When two or more variables are always equal, any invariant that
is true over one variable is true over all of the variables.  Daikon
prints invariants only over one variable (the leader) from the equal
set. 

An equality invariant is printed for each non-leader in the equal set.
For example, if the variables @code{a}, @code{b}, and @code{c} are all
equal and @code{a} is chosen as the leader, the printed invariants will
include any invariants over @code{a} and the equality invariants @samp{a=b}
and @samp{a=c}.

@node   Invariant list, Invariant filters, Interpreting output, Daikon output
@section Invariant list

The following is a list of all of the invariants that Daikon detects.
Each invariant has a configuration enable switch.  By default most invariants
are enabled.  Any that are not enabled by default are indicated below.
Some invariants also have additional configuration switches that control 
their behavior.  These are indicated below as well. @xref{Configuration 
options}.

@table @asis
@include invariants-doc.texinfo
@end table

@node Invariant filters,  , Invariant list, Daikon output
@section Invariant filters

@cindex invariant filters
@cindex filters

Invariant filters are used to suppress the printing of invariants that
are true, but not considered ``interesting'' --- usually
because the invariants are considered obvious or redundant in a given
context.

The following is a list of the invariant filters that Daikon supports.
Each of these filters has a corresponding configuration enable switch;
by default, all filters are enabled.  @xref{Configuration options},
for details.

@itemize @bullet

@cindex DerivedParameterFilter
@item DerivedParameterFilter:  suppress parameter-derived postcondition invariants

This filter suppresses invariants at procedure exit points that are
uninteresting because they refer to prestate variables derived from
pass-by-value parameters.  For example, suppose that @code{param} is a
parameter to a
Java method.  If @code{param} itself is modified, that change won't be
visible to a caller, so it's uninteresting to print.  If @code{param} points
to an object, and that object is changed, that is visible, but
only if @code{param} hasn't changed; otherwise, the invariant would report a
change in some object other than the one that was passed in.


@cindex ObviousFilter
@item ObviousFilter:  suppress obvious invariants

This filter suppresses invariants because they are obvious from looking
at other invariants.  Some examples are:

@itemize @bullet

@item If @samp{size(args[])==0} is shown, then @samp{size(args[])-1==-1} is
obvious and will not be displayed by default.
@item If @samp{this.topOfStack < size(this.theArray[])-1} is shown, then
@samp{this.topOfStack < size(this.theArray[])} is obvious and will not be
displayed by default.

@end itemize



@cindex OnlyConstantVariablesFilter
@item OnlyConstantVariablesFilter:  suppress invariants containing only constants

This filter suppresses comparison invariants in which all of the
variables being compared were observed to be constant.  In the current
version of Daikon, most such invariants are not even created in the
first place, because constants are detected on an early pass over the
data.  However, Daikon will note that all of the invariants that had
any particular constant value were also equal to each other: such
invariants will be suppressed by this filter.


@cindex ParentFilter
@item ParentFilter:  filter invariants that match a parent program point invariant

A controlled invariant is an invariant that is ``controlled'' --- or
implied --- by a parent program point in the dataflow hierarchy.  
For example, for Java instrumented
code each class is associated with an object program point, which
contain invariants that are found at the entry and exit of all public
methods.  So in addition to the usual program points such as
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, daikon outputs invariants for the
artificial program point @code{StackAr:::OBJECT}.  The invariants for
@code{StackAr:::OBJECT} control the invariants for
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, because the former imply the latter.
Because of this redundancy, controlled invariants are not displayed by
default.  Note that if for some reason, the controlling invariant is not
displayed (for example, because it's unjustified), then the controlled
invariant @emph{will} be displayed.

@cindex SimplifyFilter
@item SimplifyFilter:  eliminate invariants using Simplify

Daikon can use the Simplify theorem-prover to eliminate even more
implied invariants than Daikon's built-in tests are able to eliminate.
Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to take advantage of this filter.

If you don't also specify the @option{--suppress_redundant} command-line 
option to enable Simplify processing, this filter doesn't do anything.

@cindex UnjustifiedFilter
@item UnjustifiedFilter:  suppress unjustified invariants

For every invariant, Daikon estimates the probability of that invariant
happening by chance.  If that probability is less than the limit, then
the invariant is deemed to be an actual invariant, not just a chance
occurrence.  Currently the limit is .01%.  So by default, only invariants
with probabilities of less than .01% are shown.  See the @option{--conf_limit}
option (@pxref{Options to control invariant detection}).


@cindex UnmodifiedVariableEqualityFilter
@item UnmodifiedVariableEqualityFilter:  suppress invariants that merely indicate that a variable was unmodified

This filter is only useful for ESC output.

@end itemize


@node    Enhancing Daikon output, Front ends, Daikon output, Top
@chapter Enhancing Daikon output

@menu
* Configuration options::       
* Conditional invariants::      
* Enhancing conditional invariant detection::  
* Loop invariants::             
@end menu

@node    Configuration options, Conditional invariants, Enhancing Daikon output, Enhancing Daikon output
@section Configuration options

@cindex configuration options
@cindex dkconfig_ variables

Many aspects of Daikon's behavior can be controlled by setting various
configuration parameters.  These configuration parameters control which
invariants are checked and reported, the statistical tests for
invariants, which derived variables are created, and more.

The configuration options are set by creating a configuration file and
supplying it to Daikon on the command line using the @option{--config
@var{filename}} option.  Daikon reads all supplied configuration files
in order, overriding the defaults.  You may wish to use the supplied
example configuration file
@file{daikon/java/daikon/config/example-settings.txt} as an example when
creating your own configuration files.  (If you did not downloaded
Daikon's sources, you will have to extract the example from
@file{daikon.jar} to read it.)

You may also specify a configuration setting directly on the command line,
using the @option{--config_option @var{name}=@var{value}} option.

The configuration options are different from the debugging flags
@option{--debug} and @option{--dbg @var{category}} 
(@pxref{Daikon debugging options}).  
The debugging flags permit Daikon to produce debugging
output, but they do not affect the invariants that Daikon computes.

@menu
* List of configuration options::  
@end menu

@node    List of configuration options,  , Configuration options, Configuration options
@subsection List of configuration options

This is a list of all Daikon configuration options.
The configuration option name contains the
Java classes in which it is defined.  (In the Daikon source code, the
configuration value is stored in a variable whose name contains a
@code{dkconfig_} prefix, but that should be irrelevant to users.)
To learn more about a specific invariant or derived variable, see
its source code.

@c The config options are categorized into sections by pattern-matching
@c their names.  If you are adding new options, you might want to choose
@c names similar to those of similar options.  
@c Currently the categories are:
@c   daikon.inv.filter.*.enabled  -> turn filters on/off
@c   daikon.inv.*.enabled -> turn invariant detection on/off
@c   daikon.inv.* -> other invariant configuration
@c   daikon.derive.* -> turn derived parameters on/off
@c   daikon.simplify.* -> options for Simplify
@c   * -> general options
@c See ParameterDoclet.java for details.

@include config-options.texinfo


@node    Conditional invariants, Enhancing conditional invariant detection, Configuration options, Enhancing Daikon output
@section Conditional invariants and implications
@cindex splitting
@cindex splitting condition
@cindex conditional invariant
@cindex invariant, conditional
@cindex implication invariant
@cindex invariant, implication

Conditional invariants are invariants that are true only part of the time.
For instance, the postcondition for the absolute value procedure is
@example
if arg < 0
  then return == -arg
  else return == arg
@end example
@noindent
The invariant @code{return == -arg} is a conditional invariant because
it depends on the predicate @code{arg < 0} being true.  An
@emph{implication} is a compound invariant that includes both the
predicate and the conditional invariant (also called the consequent).

Daikon must be supplied with the predicate for an implication.  Daikon has
certain built-in predicates that it uses for finding conditional invariants;
examples are which return statement was executed in a procedure and whether a
boolean procedure returns true or false.  Additionally, Daikon can read
predicates from a file called a splitter info (@file{.spinfo}) file and find
implications based on those predicates.  The splitter info file can be produced
automatically, such as by static analysis of the program using the CreateSpinfo
and CreateSpinfoC programs or by cluster analysis of the
traced values in the data trace file.  Details of these techniques and usage
guides can be found in @ref{Enhancing conditional invariant detection}.  Users
can also create splitter info files by hand or manually augment
automatically-created ones.

To detect conditional invariants and implications:
@enumerate
@item
Create the splitter info file, either automatically or by hand.
@item
Run Daikon with the @file{.spinfo} file as one of its arguments.  
(The order of arguments does not matter.)
For example,
@example
java daikon.Daikon Foo.decls Foo.spinfo Foo.dtrace
@end example
@end enumerate

The term ``splitter'' comes from Daikon's technique for detecting
implications and conditional invariants.  For each predicate, Daikon
creates two conditional program points --- one for program executions
that satisfy the condition and one for those that don't --- and splits
the data trace into two parts.  Invariant detection is then performed
on the conditional program points (that is, the parts of the data
trace) separately and any invariants detected are reported as
conditional invariants (as implications).

To be precise, we say that an invariant holds exclusively if it is
discovered on one side of a split, and its negation is discovered on
the opposite side.  Daikon creates conditional invariants whose
predicates are invariants that hold exclusively on one side of a
split, and whose consequents are invariants that hold on that side of
the split but not on the un-split program point.  If Daikon finds
multiple exclusive conditions, it will create biconditional (``if and
only if'') invariants between the equivalent conditions.  Within the
context of the program, each of the exclusive conditions is equivalent
to the splitting condition.  In particular, if both the splitting
condition and its negation are within the grammar of invariants that
Daikon detects, the splitting condition may appear as the predicate of
the generated conditional invariants.  On the other hand, if other
equivalent conditions are found, or if the splitting condition is not
expressible in Daikon's grammar, it might not appear in the generated
implications.

@cindex dummy invariant
@cindex invariant, dummy

In some cases, the default policy of selecting predicates from
Daikon's output may be insufficient.  For instance, Daikon might not
detect any invariant equivalent to the splitting condition, if it is
sufficiently complex or application-specific.  In such situations,
Daikon can also use the splitting condition itself as the predicate of
an implication, as what is called a ``dummy invariant''.  A ``dummy
invariant'' is one whose meaning is not dealt with directly by Daikon;
instead Daikon knows only how to print the invariant in its output.
When a tool or a user writes a splitter info file, the file can
specify a way to print the condition represented by the splitter in
any of Daikon's output formats.  If the use of dummy invariants is
enabled, invariants with the supplied output formats will be used as
the predicates of conditional invariants.

To use dummy invariants, a condition's formatting must be specified in
the splitter info file, and the configuration option
@option{daikon.PptTopLevel.dummy_invariant_level} must be set to a
non-zero value (see @ref{List of configuration options}).

@menu
* Splitter info file::          
* Indiscriminate splitting::    
* Example splitter info file::  
@end menu

@node    Splitter info file, Indiscriminate splitting, Conditional invariants, Conditional invariants
@subsection Splitter info file
@cindex splitter info file
@cindex .spinfo file
@cindex spinfo file

A splitter info file contains the conditions that Daikon should use to
create conditional invariants.  Each section in the @file{.spinfo}
file consists of a sequence of non-blank lines; sections are separated
by blank lines.  There are two types of sections:  program point
sections and replacement sections.
@xref{Example splitter info file}, for an example splitter info file.

@menu
* Program point sections::      
* Replacement sections::        
@end menu

@node    Program point sections, Replacement sections, Splitter info file, Splitter info file
@subsubsection Program point sections

Program point sections have a line specifying a program point name
followed by lines specifying the condition(s) associated with that
program point, each condition on its own line.  Additional information
about a condition may be specified on indented lines.  For example, a
typical entry is

@example
PPT_NAME @var{pptname}
@var{condition1}
@var{condition2}
    DAIKON_FORMAT @var{output string}
    ESC_FORMAT @var{output string}
@var{condition3}
...
@end example
@noindent
@var{pptname} can be any string that matches a part of the desired
program point name as printed in the decls file.  In finding matching
program points, Daikon uses the first program point that matches
@var{pptname}.  Caution is necessary when dealing with method names
that are prefixes of other method names.  For instance, if the class
@code{List} has methods @code{add} and @code{addAll}, specifying
@samp{PPT_NAME List.add} might select either method, depending on
which was encountered first.  Instead writing @samp{PPT_NAME
List.add(} will match only the @code{add} method.

Each condition is a Java expression of boolean type.  All variables
that appear in the condition must also appear in the declaration of
the program point in the @file{.decls} file.  (In other words, all the
variables must be in scope at the program point(s) where the Splitter
is intended to operate.)  The automatically generated Splitter source
code fails to compile (but Daikon proceeds without it) if a variable
name in a condition is not found at the matching program point.

Indented lines beginning with @option{DAIKON_FORMAT},
@option{JAVA_FORMAT}, @option{ESC_FORMAT}, @option{SIMPLIFY_FORMAT},
or @option{IOA_FORMAT} may be used to specify how to represent the
condition specified by the splitter in each of Daikon's output
formats, to allow the splitting condition to be used as a dummy
invariant.

@node    Replacement sections,  , Program point sections, Splitter info file
@subsubsection Replacement sections

Ordinarily, a splitting condition may not invoke user-defined methods,
because when Daikon reads data trace files, it does not have access to the
program source.  A replace section of the splitter info file can specify
the bodies of methods, permitting conditions to invoke those methods.  The
format is as follows:
@example
REPLACE
@var{procedure1}
@var{replacement1}
@var{procedure2}
@var{replacement2}
...
@end example
@noindent
where @var{replacementi} is a Java expression for the body
of @var{procedurei}.  In each condition, Daikon replaces procedure
calls by their replacements.  A replace section may appear anywhere in
the splitter info file.

@node    Indiscriminate splitting, Example splitter info file, Splitter info file, Conditional invariants
@subsection Indiscriminate splitting

Ordinarily, each condition in an @file{.spinfo} file gives rise to
conditional invariants only at the program point in whose section the
condition appears.  Alternately, every condition can be used at every
program point, regardless of where in the @file{.spinfo} file the
condition appeared; this latter approach is called ``indiscriminate
splitting''.

The advantage of indiscriminate splitting is that a condition that is
useful at one program point may also be useful at another --- if the
same variables are in scope or other variables of the same name are in
scope.  The disadvantage of indiscriminate splitting is that often the
condition is not applicable everywhere, and when it is, it may not be
useful at all such locations, so checking for many conditional
invariants may slow down Daikon without a corresponding benefit. 
Indiscriminate splitting can result in Daikon attempting
to use many conditions that are inappropriate at certain program
points, for instance because the program point does not have (in
scope) all the variables that are used in the condition.  For example,
the condition @code{myArray.length == x} is inapplicable at a program
point if either of @code{myArray} and @code{x} is not in scope at that
program point.  In this case, Daikon prints a warning message and
proceeds, using conditions wherever they are valid.

By default, Daikon uses indiscriminate splitting.  To use
non-indiscriminate splitting, place the following line in a file that is
passed to Daikon via the @option{--config} flag 
(@pxref{Daikon configuration options}):
@example
daikon.split.SplitterList.all_splitters = false
@end example


@node    Example splitter info file,  , Indiscriminate splitting, Conditional invariants
@subsection Example splitter info file

Below is an implementation of a simple Queue for positive integers and
a corresponding @file{.spinfo} file.  The splitter info file is like
the one that @command{CreateSpinfo} would create for that class, but
also demonstrates some other features.

@menu
* Example class::               
* Resulting .spinfo file::      
@end menu

@node    Example class, Resulting .spinfo file, Example splitter info file, Example splitter info file
@subsubsection Example class

@smallexample
class simpleStack @{
 
  private int[] myArray;
  private int currentSize;
 
  public simpleStack(int capacity) @{
    myArray = new int[capacity];
    currentSize = 0;
  @}
 
  /** Adds an element to the back of the stack, if the stack is
    * not full.
    * Returns true if this succeeds, false otherwise.  **/
  public String push(int x) @{
    if ( !isFull() && x >= 0) @{
      myArray[currentSize] = x;
      currentSize++;
      return true;
    @} else @{
      return false;
    @}
  @}
 
  /** Returns the most recently inserted stack element.
    * Returns -1 if the stack is empty. **/
  public int pop() @{
    if ( !isEmpty() ) @{
      currentSize--;
      return myArray[currentSize];
    @} else @{
      return -1;
    @}
  @}

 /** Returns true if the stack is empty, false otherwise. **/
  private boolean isEmpty() @{
    return (currentSize == 0);
  @}

  /** Returns true if the stack is full, false otherwise. **/
  private boolean isFull() @{
    return (currentSize == myArray.length);
  @}
@}
@end smallexample

@node    Resulting .spinfo file,  , Example class, Example splitter info file
@subsubsection Resulting .spinfo file

@smallexample
REPLACE
isFull()
currentSize == myArray.length
isEmpty()
currentSize == 0

PPT_NAME  simpleStack.push
!isFull() && x >= 0
    DAIKON_FORMAT !isFull() and x >= 0
    SIMPLIFY_FORMAT (AND (NOT (isFull this)) (>= x 0))

PPT_NAME  simpleStack.pop
!isEmpty()

PPT_NAME  simpleStack.isFull
currentSize == myArray.length - 1

PPT_NAME  simpleStack.isEmpty
currentSize == 0
@end smallexample

@node    Enhancing conditional invariant detection, Loop invariants, Conditional invariants, Enhancing Daikon output
@section Enhancing conditional invariant detection

The built-in mechanisms (@pxref{Conditional invariants}) have
limitations in the invariants they can find.  By supplying splitting
conditions to Daikon via a splitter info file, the user can infer more
conditional invariants.  To ease this task, there are two methods to
automatically create splitter info files for use by Daikon.

@menu
* Static analysis for splitters::  
* Cluster analysis for splitters::  
* Random selection for splitters::  
@end menu

@node   Static analysis for splitters, Cluster analysis for splitters, Enhancing conditional invariant detection, Enhancing conditional invariant detection
@subsection Static analysis for splitters

@cindex splitting conditions, static analysis
@cindex static analysis for splitters
@cindex CreateSpinfo
@cindex CreateSpinfoC

In static analysis, all explicitly stated boolean statements in the program
source are extracted and used as splitting conditions.  The assumption is that
conditions that are explicitly tested in the program are likely to affect the
program's behavior and could lead to useful conditional invariants.  

The CreateSpinfo program takes Java source code as input and creates a
splitter info file for each input file; for instance,
@example
java daikon.tools.jtb.CreateSpinfo Foo.java Bar.java
@end example
@noindent
creates the splitter info files @file{Foo.spinfo} and
@file{Bar.spinfo}.
Given an @option{-o @var{filename}} argument, CreateSpinfo puts all the
splitters in the specified file instead.
The resulting splitter info file(s) contains each
boolean expression that appears in the source code.  The conditional
statements that the programmer used in the source code are likely to
have important semantic properties.  This simple heuristic of using
these conditional statements as predicates for conditional invariant
detection is often quite effective.  

If you get an error such as
@example
jtb.ParseException: Encountered ";" at line 253, column 8.
Was expecting one of: "abstract" ...
@end example
@noindent
then you may have encountered a bug in the JTB library on which
CreateSpinfo is built.  It does not permit empty declarations in a
class body.  Remove the extra semicolon in your Java file (at the
indicated position) and re-rerun CreateSpinfo.

The @command{CreateSpinfoC} program performs the same function, for
C source code.  It can only be run on postprocessed source
files---that is, source files contain no CPP commands.  CPP commands
are lines starting with @samp{#}, such as @samp{#include}.  To
expand CPP commands into legal C, run either @command{cpp -P} or
@command{gcc -P -E}.  For instance, here is how you could use it.
@example
cpp -P foo.c foo.c-expanded
cpp -P bar.c bar.c-expanded
java daikon.tools.jtb.cparser.CreateSpinfoC \
     foo.c-expanded bar.c-expanded
@end example
@noindent

If you get an error such as
@example
... Lexical error at line 5, column 1.
Encountered: "#" (35), after : ""
@end example
@noindent
then you forgot to run CPP before running CreateSpinfoC@.

@node   Cluster analysis for splitters, Random selection for splitters, Static analysis for splitters, Enhancing conditional invariant detection
@subsection Cluster analysis for splitters

@cindex splitting conditions, cluster analysis
@cindex cluster analysis for splitters
@cindex runcluster.pl program

Cluster analysis is a statistical method that finds groups or clusters
in data.  The clusters may indicate conditional properties in the
program.  A conditional property at a program point separates the data
into those that satisfy it and those that do not, and conditional
invariants can be induced by clustering.  Any invariant that is
discovered over one cluster but not over another is a conditional
invariant---the predicate for the conditional invariant being
membership in the cluster in which the invariant was found.  The
cluster analysis mechanism finds clusters in the data trace file,
infers invariants over any clusters that it finds, and writes these
invariants into a splitter info file for conditional invariant
detection.

To find splitting conditions using cluster analysis, run the
@command{runcluster.pl} program (found in the @file{$DAIKONDIR/bin}
directory) in the following way:
@example
runcluster.pl [@var{options}] @var{dtrace_file ...} @var{decls_files ...}
@end example

The @var{options} are:
@table @option

@cindex kmeans cluster analysis
@cindex hierarchical cluster analysis
@cindex xm cluster analysis
@item -a @var{ALG}
@itemx --algorithm @var{ALG}
@var{ALG} specifies a clustering algorithm.
Current options are @samp{km} (for kmeans), @samp{hierarchical},
and @samp{xm} (for xmeans).  The default is @samp{xm}.

@item -k
The number of clusters to use (for algorithms which require
this input, which is everything except xmeans).  The default is 4.

@item --keep    
Don't delete the temporary files created by the clustering
process.  This is a debugging flag.
@end table

The @command{runcluster.pl} script currently supports three clustering
programs.  They are implementations of the kmeans algorithm,
hierarchical clustering and the xmeans algorithm (kmeans algorithm
with efficient discovery of the number of clusters).  The kmeans and
hierarchical clustering tools are provided in the Daikon
distribution.  The xmeans code and executable are publicly available at
@uref{http://www.cs.cmu.edu/~dpelleg/kmeans.html} (fill in the license
form and mail it in).

@node   Random selection for splitters,  , Cluster analysis for splitters, Enhancing conditional invariant detection
@subsection Random selection for splitters

@cindex splitting conditions, random selection
@cindex random selection for splitters
@cindex TraceSelect tool

Random selection can create representative samples of a data set with
the added benefit of finding conditional properties and eliminating
outliers.  Given traced data, the TraceSelect tool creates several
small subsets of the data by randomly selecting parts of the original
trace file.  Any invariant that is discovered in the smaller samples but
not found over the entire data is a conditional invariant.

To find splitting conditions using random selection, run the
@command{daikon.tools.TraceSelect} program in the following way:
@example
java daikon.tools.TraceSelect @var{num_reps} @var{sample_size} [@var{options}] \
    @var{dtrace_file} @var{decls_files ...} [@var{daikon_options}]
@end example

@var{num_reps} is the number of subsets to create, and @var{sample_size} is the
number of invocations to collect for each method.

The @var{daikon_options} are the same options that can be provided to the
daikon.Daikon program.

The @var{options} for TraceSelect are:
@table @option

@item -NOCLEAN
Don't delete the temporary trace samples created by the random
selection process.  This can help for debugging or for using the tool
solely to create trace samples instead of calculating invariants over
the samples.

@item -INCLUDE_UNRETURNED
Allows random selection to choose method invocations that entered the
method successfully but did not exit normally; either from a thrown
Exception or abnormal termination. 

@item -DO_DIFFS
Creates an spinfo file for generating conditional invariants and
implications by reporting the invariants that appear in at least one
of the samples but not over the entire data set.


@end table



@node    Loop invariants,  , Enhancing conditional invariant detection, Enhancing Daikon output
@section Loop invariants

@cindex loop invariants

Daikon does not by default output loop invariants.  Daikon can detect
invariants at any location where it is provided with variable values,
but the front ends do not currently supply Daikon with variable values
at loop heads.

Here is one way to cause Daikon to produce loop invariants.  At the top
of a loop (or at any other location in the program at which you would
like to obtain invariants), insert a call to a dummy procedure that does
not work but returns immediately.  Pass, as arguments to the dummy
procedure, all variables of interest.  Daikon will produce (identical)
preconditions and postconditions for the dummy procedure; these are
properties that held at the call site.



@node    Front ends, Tools, Enhancing Daikon output, Top
@chapter Front ends

@cindex front end

The Daikon invariant detector is a machine learning tool that finds
patterns (invariants) in data.  That data can come from any source, but
Daikon is typically used to find invariants over variable values in
running programs.  A front end is a tool that converts data from some
other format into Daikon's input format; for instance, a front end might
cause a program to output a @file{.dtrace} file that Daikon can process.

This chapter describes several front ends that are part of Daikon.  It
is relatively easy to build your own front end, if these do not serve
your purpose; we are aware of a number of users who have done so.  For
more information about building a new front end, see @ref{New front
ends,,,./developer,Daikon Developer Manual}.


@menu
* Chicory::                     
* Kvasir::                      
* dfepl::                       
* convertcsv.pl::               
* dfej::                        
* dfec::                        
* Other front ends::            
@end menu

@node    Chicory, Kvasir, Front ends, Front ends
@section Java front end Chicory

@cindex front end for Java
@cindex Java front end
@cindex Chicory (Daikon front end for Java)

The Daikon front end for Java, named Chicory, executes Java programs,
creates data trace (@file{.dtrace}) files, and optionally runs Daikon on
them.  Chicory is named after the chicory plant, whose root is sometimes
used as a coffee substitute or flavor enhancer.

To use Chicory, run your program as you normally would, but 
replace the @command{java} command with @command{java daikon.Chicory}.  For
instance, if you usually run
@example
java mypackage.MyClass arg1 arg2 arg3
@end example
@noindent
then instead you would run
@example
java daikon.Chicory mypackage.MyClass arg1 arg2 arg3
@end example
@noindent
This runs your program and creates file @file{MyClass.dtrace} 
in the current directory.
Furthermore, a single command can both create a trace file and run Daikon:
@example
java daikon.Chicory --daikon mypackage.MyClass arg1 arg2 arg3
@end example
@noindent
See below for more options.

That's all there is to it!  Since Chicory instruments class files 
directly as they are loaded into Java,
you do not need to perform separate instrumentation and recompilation steps.
However, you should compile your program with debugging information
enabled (the @option{-g} command-line switch to @command{javac});
otherwise, Chicory uses the names @code{arg0}, @code{arg1}, @dots{} as
the names of method arguments.

Chicory must be run in a version 5.0 JVM, but it is backward-compatible
with older versions of Java code.
Chicory's functionality is very similar to that
of the older dfej Java front end (@pxref{dfej}), and Chicory 
supports most of the same
command-line options.  However, Chicory has three substantial advantages
over dfej: Chicory is much easier to use, dfej only supports Java
1.4 and earlier, and Chicory is platform-independent (and requires no
special action to build) since it is written in Java.

@menu
* Chicory options::             
@end menu

@node    Chicory options,  , Chicory, Chicory
@subsection Chicory options

Chicory is invoked as follows:
@example
java daikon.Chicory @var{classname} @var{args}
@end example
@noindent
where
@example
java @var{classname} @var{args}
@end example
@noindent
is a valid invocation of Java.

This section lists the optional command-line arguments to Chicory, which
appear before the @var{classname} on the Chicory command line.
Unless otherwise noted, all of these options are also accepted by
dfej (@pxref{dfej options}).

@table @option
@item --help
Print a help message.

@item --debug
Produce debugging information.

@item --nesting-depth=@var{n}
Depth to which to examine structure components (default 2).
This parameter determines which variables the front end causes to be output at
runtime.  For instance, suppose that a program contained the following
data structures and variables:
@example
class A @{
  int x;
  B b;
@}
class B @{
  int y;
  int z;
@}
A myA;

class Link @{
  int val;
  Link next;
@}
Link myList;
@end example
@itemize @bullet
@item
If depth=0, only the identities (hashcodes) of @code{myA} and
@code{myList} would be examined; those variables could be determined to
be equal or not equal to other variables.
@item
If depth=1, then also @code{MyA.b}, @code{myList.next}, and the integers
@code{myA.x} and @code{myList.val} would be examined.
@item
If depth=2, then also @code{MyA.b.y}, @code{MyA.b.y},
@code{myList.next.next}, and @code{myList.next.val} would be examined.
@end itemize

Values that do not exist are not examined.  For instance, if @code{myA}
is @code{null} on a particular execution of a program point, then
@code{myA.b} is not accessed on that execution regardless of the depth
parameter.

@item --ppt-select-pattern=@var{regexp}
Only produce trace output for classes/procedures/program points whose
names match the
given regular expression.  This option may be supplied multiple times,
but it cannot be used in conjunction with @option{--ppt-omit-pattern}.  

When this switch is supplied, filtering occurs in the following way:
for each program point, Chicory checks the fully
qualified class name, the method name, and the
the program point name against each @var{regexp} that
was supplied.  If any of these match, then the program point is included
in the instrumentation.

Here are two commands, each of which traces only method @code{bar}
(assuming that @code{bar} is defined only in class @code{C}):

@example
java daikon.Chicory --ppt-select-pattern='bar$' ...
java daikon.Chicory --ppt-select-pattern='C\.bar\(' ...
@end example

The first example matches the method name (in any class), whereas the
second matches the program point name.


@item --ppt-omit-pattern=@var{regexp}
Do not produce data trace output for classes/procedures/program points
whose names match the given regular expression.  This
reduces the size of the data trace file and also may make the
instrumented program run faster, since it need not output those variables.

This option works just like @option{--ppt-select-pattern} does, except
that matching program points are excluded, not included.
 
The @option{--ppt-omit-pattern} argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its fully qualified class, procedure name, or
complete program point name matches one of the omitting criteria.


The @option{--ppt-omit-pattern} argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its fully qualified class, fully qualified procedure name, or
complete program point name exactly matches one of the omitting criteria.
A regular expression matches if it matches any portion of the program
point name.  Note that currently only classes are matched, not each full
program point name.  Thus, either all of a class's methods are traced, 
or none of
them are.

Here are examples of how to avoid detecting invariants over various
parts of your program.

@itemize
@item omit a whole package:
@example
java daikon.Chicory '--ppt-omit-pattern=^junit\.'
@end example
@example
java daikon.Chicory '--ppt-omit-pattern=^daikon\.util\..*' ...
@end example

@item omit a single class:
@example
java daikon.Chicory '--ppt-omit-pattern=HashSetLinear\$HslIterator' ...
@end example

@item omit a single method:
@example
java daikon.Chicory '--ppt-omit-pattern=StackAr.topAndPop()' \
     ...
@end example

@item omit a single program point:
@example
java daikon.Chicory '--ppt-omit-pattern=StackAr.<init>(int):::EXIT33' ...
@end example

@end itemize

@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
@cindex DTRACEAPPEND environment variable
@cindex environment variable DTRACEAPPEND
@cindex trace file name
@cindex dtrace file name
@cindex file name, for dtrace file
@item --dtrace-file=@var{filename}
Specifies the default name for the trace output (@file{.dtrace}) file.
If no explicit trace file name or directory is specified on the command line,
the default is @file{./@var{CLASSNAME}.dtrace}; however,
if the @env{DTRACEFILE}
environment variable is set when the instrumented program is run, it
overrides this default.  Furthermore, if the @env{DTRACEAPPEND} environment
variable is set to any value, the dtrace file will be appended to
instead of overwritten.  Compressed data trace files may not be appended
to.  In some cases you may find a single large data trace file more
convenient; in other cases, a collection of smaller data trace files may
give you more control over which subsets of runs to invoke Daikon on.

@item --output-dir=@var{directory}
Write the trace output (@file{.dtrace}) to this directory.  The default
is the current directory.
(Not supported by dfej, only Chicory.)

@item --daikon
@itemx --daikon=@var{args}
After creating a data trace (@file{.dtrace}) file, run Daikon on it,
passing the specified arguments, if any, to Daikon.
(Not supported by dfej, only Chicory.)

This option supplies Daikon with a single trace from a one execution of
your program.  When Daikon is invoked from the command line, it can be
supplied as many trace files as desired.

@item --premain=@var{path}
Specifies the absolute pathname to the @file{ChicoryPremain.jar} file.
Chicory requires this jar file in order to execute.  By default Chicory
looks for the jar file in the classpath and in @file{$(DAIKONDIR)/java}
(where @file{DAIKONDIR} is an environment variable that points to the
complete installation of Daikon).  

Chicory can also use the @file{daikon.jar} file for this purpose.  If it
doesn't find @file{ChicoryPremain.jar} above, it will use daikon.jar
itself (if a file named 'daikon.jar' appears in the classpath).  If
the daikon jar file is not named @file{daikon.jar}, you can use this
switch to specify its name.  For example:
@example
--premain=C:\lib\daikon-4.1.3.jar
@end example

@item --daikon-online
@itemx --daikon-online=@var{args}
This option produces behavior very similar to @option{--daikon}.  The difference is that with @option{--daikon-online}, Daikon processes the data trace information as Chicory produces it.  Daikon and Chicory use socket communication in this mode.  Thus, there is no intermediate .dtrace file created when using @option{--daikon-online}.

Just like with the @option{--daikon} option, Daikon is only given a single trace from one execution of your program.

@item --purity-file=@var{file}
Specifies a @file{*.pure} file to read.  It may be specified as a full path or just a file name.  If a configuration directory is
specified via @option{--configs=@var{directory}}, then Chicory looks for @var{file} in @var{directory}.  Otherwise, it searches for @var{file}
in the current directory.

Pure methods are defined as methods which do not induce side-effects.  Thus, invoking a pure method at any time in an application should
not change the execution of the rest of the application.  For example, almost all implementations of @code{toString()} methods are pure.
Thus, if we took an existing application and added calls to @code{toString()} on various objects, its input-output relationship should not
change.

Chicory will use this behavior to its advantage, although currently it only supports pure methods which take no parameters (and return
some value).  When appropriate, Chicory will add variables corresponding to the values of pure method invocations.  Here is an example:

@example
class Point
@{
   private int x, y;
   public int radiusSquared() 
   @{ 
       return x*x + y*y;
   @}
@}
@end example

If a user tells Chicory that @code{radiusSquared()} is pure via the @option{--purity-file=@var{file}} switch, then Chicory will
add a @code{radiusSquared()} variable just like it will add @code{x} and @code{y} variables.  Doing so may improve the richness
of Daikon invariants returned.  For instance, if a point is constantly changing but remains on some circle, then Daikon
ought return an invariant that the point's radius remains constant if Chicory knows that @code{radiusSquared()} is a pure method.

The purity file has a simple format: there is exactly one method on each line.  The format of each method is outline clearly in the
Sun JDK API: 
    "The string is formatted as the method access modifiers, if any, followed by the method return type, 
    followed by a space, followed by the class declaring the method, followed by a period, followed by 
    the method name, followed by a parenthesized, comma-separated list of the method's formal parameter 
    types. If the method throws checked exceptions, the parameter list is followed by a space, followed 
    by the word throws followed by a comma-separated list of the thrown exception types. For example:
    @example 
    public boolean java.lang.Object.equals(java.lang.Object)
    @end example
    The access modifiers are placed in canonical order as specified by "The Java Language Specification". 
    This is public, protected or private first, and then other modifiers in the following order: abstract, 
    static, final, synchronized native."

@item --configs=@var{directory}
Chicory will use this location to search for configuartion files.  Currently, this only includes @file{*.pure} files.

@end table




@node Kvasir, dfepl, Chicory, Front ends
@section C front end Kvasir

@cindex Kvasir (binary front end for C)
@cindex front end for C
@cindex C front end

Daikon's front end for C, named Kvasir, executes C (and a reasonable subset 
of C++) programs and creates  
data trace (@file{.dtrace}) files by examining the operation of the binary at
runtime.  Kvasir is named after the Norse god of knowledge and beet juice.

To use Kvasir, first compile your program using the DWARF-2 debugging
format (e.g., supply the @option{-gdwarf-2} option to @command{gcc}).
Then, prefix your command line by @command{kvasir-dtrace}.  For example, 
if you normally run your program with the command 
@example
./program -option input.file
@end example
@noindent
then instead use the command
@example
kvasir-dtrace ./program -option input.file
@end example
@noindent
which creates a data trace file @file{daikon-output/program.dtrace}.
You can also run Daikon without creating an intermediate data trace
file; see @ref{Online execution}.

For information about installing Kvasir, see @ref{Installing Kvasir}.
Kvasir only works under Linux running on an x86 processor; for full
details, see @ref{Kvasir limitations}.
For information about how to create an instrumenter for C that works on
non-Linux or non-386 platforms, see @ref{Instrumenting C
programs,,,./developer,Daikon Developer Manual}.

@menu
* Using Kvasir::                
* Kvasir options::              
* Pointer type disambiguation::  
* Online execution::            
* Installing Kvasir::           
* Kvasir limitations::          
@end menu

@node Using Kvasir, Kvasir options, Kvasir, Kvasir
@subsection Using Kvasir

Before using Kvasir, you must compile your program without optimization,
and with the DWARF-2 format of debugging information.
DWARF-2 is the default format for debugging information in GCC 3, and
otherwise is produced by supplying the
@option{-gdwarf-2} command line option.
Also, remove any optimization flags, such as @option{-O} or @option{-O2},
and any flags that affect calling conventions, such as
@option{-fomit-frame-pointer}.  Except for these changes, you should be
able to compile and link your program normally.

In the second step of using Kvasir, run your program as you normally
would, but prepend the command @command{kvasir-dtrace} to the beginning.
For instance, if you normally run your program with the command 
@example
./program -option input.file
@end example
@noindent
just say
@example
kvasir-dtrace ./program -option input.file
@end example
@noindent
As well as running your program (more slowly than usual), this command
also creates a directory @file{daikon-output} in the current
directory containing a @file{program.dtrace} file suitable as input to Daikon.

A number of options to Kvasir may be supplied on the command line
before the argument that is the name of your program (@pxref{Kvasir options}).

Note that Kvasir uses a different scheme for naming variables than the
Java front ends and the source-based C front end dfec do
(@pxref{Variable names}).  Because C does not have classes, the
``class'' portion of a program point name (before the last period)
instead holds the file in which a function was defined, for
file-static functions, or is simply a single period for global
functions. (Thus, global function names start with two periods, like
@samp{..main():::ENTER}., the first denoting that it is global in
scope and the second denoting the separator between the ``class''
portion of the program point name and its actual name) In variable
names, by contrast, the period is used to represent the field
selection operator, so a slash is used instead as a separator: global
variables are prefixed with a slash (e.g., @samp{/globalVar}), and
file-static variables are prefixed with their filename (with periods
converted into underscores) and then a slash (e.g.,
@samp{Global_c/staticVar} for a file-static variable @code{staticVar}
declared in the file @file{Global.c}).  For static variables which are
declared within functions, an at-sign @samp{@@} separates the filename
and the function name and then a slash separates the function name and
variable name (e.g., @samp{Global_c@@main/funcStaticVar} for a static
variable @code{funcStaticVar} declared within the function @code{main}
in the file @file{Global.c}).  This syntax ensures that each program
point and variable within a C program has a unique name when presented
to Daikon.


@node Kvasir options, Pointer type disambiguation, Using Kvasir, Kvasir
@subsection Kvasir options

@table @option

@item --asserts-aborts
@itemx --no-asserts-aborts

Enable (disable) Kvasir's internal consistency checks.  By default, they
are disabled. 

@item --debug
@itemx --no-debug

Enable (disable) progress messages meant for debugging problems with
Kvasir itself.  By default, they are disabled.  This option is intended
mainly for Kvasir's developers.

@item --decls-file=@var{filename.decls}

Write the @file{.decls} file listing the names of functions and
variables to the specified file name.  This forces Kvasir to generate separate 
@file{.decls} and @file{.dtrace} files instead of outputting everything to the 
@file{.dtrace} file, which is the default behavior.

@item --decls-only

Exit after writing the @file{.decls} file; don't run the program or
generate trace information.  Since the @file{.decls} file is the same for
any run of a program, it can be generated once and then reused on later
runs, as long as no new program points are added and each program point
has the same set of variables.

@item --with-dyncomp

Run Kvasir with the DynComp dynamic
comparability analysis tool to generate .decls files with variable
comparability information in the format specified in the @ref{Program
point declarations} section.  Variable comparability information can
speed up the performance of Daikon and allow it to generate a more
focused and relevant set of invariants.  This option may be used
concurrently with @option{--decls-only} to only generate a .decls file
without .dtrace.

@item --no-dyncomp-gc

By default, DynComp runs with a garbage collector for the tag metadata
that it uses, but this can cause your program to slow down if it runs
too often.  This option turns off the garbage collector.

@item --gc-num-tags=@var{N}

The DynComp garbage collector runs once after every 5,000,000 tags have
been assigned.  This option tells the garbage collector to run once
after every @var{N} tags have been assigned.  Making the value of
@var{N} larger allows your program to run faster (because the garbage
collector runs less frequently), but may cause your program to run out
of memory faster as well.

@item --dyncomp-fast-mode

This option applies an approximation for handling literal values which
greatly speeds up the performance of DynComp and drastically lowers its
memory usage, but at the expense of a slight loss in precision of the
generated comparability sets.  If you cannot get DynComp to successfully
run on a large program, try turning on this option.

@item --dtrace-append

Append new trace information to the end of an existing @file{.dtrace}
file.  The default is to overwrite a pre-existing @file{.dtrace} file.

@item --dtrace-file=@var{filename.dtrace}

Write the @file{.dtrace} trace file giving the values of variables to
the specified file name.  The default is
@file{daikon-output/@var{programname}.dtrace}, where @var{programname}
is the name of the program.  A filename of @file{-} may be used to
specify the standard output; in this case, the regular standard output
of the program will be redirected back to the terminal, to avoid
intermixing it with the trace output.  If the given filename ends in
@file{.gz}, then @option{--dtrace-gzip} is enabled and the
@file{.dtrace} file will be compressed.

@item --dtrace-gzip

Compress trace information with the gzip program before writing
it to the @file{.dtrace} file.  You must have the gzip program
available.

@item --dump-ppt-file=@var{filename}
@itemx --dump-var-file=@var{filename}

Print a list of all the program points (respectively all the variables)
in the program to the specified file.  An edited version of this file can
then be used with the @option{--ppt-list-file} (respectively
@option{--var-list-file}) option.

@item --ignore-globals

Omit any global or static variables from the @file{.decls} and
@file{.dtrace} files.  Leaving these out can significantly improve Kvasir
and Daikon's performance, at the expense of missing properties involving
them.  The default is to generate trace information for 
global and static variables.

@item --ignore-static-vars

Omit any static variables but generate trace information for 
global variables in the  @file{.decls} and @file{.dtrace} files.

@item --limit-static-vars

Limits the output of static variables in the @file{.decls} and
@file{.dtrace} files.  File-static variables are only observed at
program points for functions which belong to the same file as the
variable.  Static variables declared within a particular function are
only observed at program points for that function.  This is a
heuristic to reduce the amount of Kvasir output without greatly
reducing the amount of useful output.

@item --bit-level-precision

When activated, forces more stringent checking of value validity on the
bit-level, which in some cases could result in more accurate output at
the expense of speed.  This is useful when your program performs
lots of bit-level operations, but is unnecessary for most programs.
(Note: If you have trouble getting floating point values to print out
properly, try this option.  It seems to work well in practice.)
This option is fairly untested at the moment.

@item --nesting-depth=@var{N}

For recursively-defined structures (structs or classes with members that
are structs or classes or pointers to structs or classes of @emph{any} type), 
@var{N} (an integer between 0 and 100) specifies approximately how many levels
of pointers to dereference.  This is useful for controlling the output
of complex data structures with many references to other structures.
The default is 2.

@item --struct-depth=@var{N}

For recursively-defined structures (structs or classes with members that
are pointers to the @emph{same} type of struct or class),
@var{N} (an integer between 
0 and 100) specifies approximately how many levels of pointers to dereference. 
This is useful for controlling the output of linked lists and trees. 
The default is 2.

@item --output-fifo

Create the output @file{.decls} and @file{.dtrace} files as FIFOs (also
known as ``named pipes'').  Kvasir will then open first the @file{.decls}
FIFO and then the @file{.dtrace} FIFO, blocking until another program
(such as Daikon) reads from them.  Using FIFOs for the output of Kvasir
avoids the need for large trace files, but FIFOs are not supported by
some file systems, including AFS@.

@item --ppt-list-file=@var{filename}
@itemx --var-list-file=@var{filename}

Trace only the program points (respectively, variables) listed in the
given file.  Other program points (respectively variables) will be
omitted from the @file{.decls} and @file{.dtrace} files.  A convenient
way to produce such files is by editing the output produced by the
@option{--dump-ppt-file} (respectively, @option{--dump-var-file}) option
described above.

@item --program-stdout=@var{filename}
@itemx --program-stderr=@var{filename}

Redirect the standard output (respectively, standard error) stream of the
program being traced to the specified path.  By default, the standard
output and standard error streams will be left pointing to the same
locations specified by the shell, except that if @option{--dtrace-file=-}
is specified, then the default behavior is as if
@option{--program-stdout=/dev/tty} were specified, since mixing the
program's output and Kvasir's trace output is not advisable.
If the same filename is given for both options, the streams will be
interleaved in the same way as if by the Bourne shell construction
@code{2>&1}.

Also, as in the shell, @var{filename} can be an ampersand followed by an
integer, to redirect to a numbered file descriptor.  For instance, to
redirect the program's standard output and error, and Kvasir's standard
error, to a single file, you can say @option{--program-stdout='&2'
--program-stderr='&2' 2>@var{filename}}.

@item --disambig-file=@var{filename}
Specifies the name of the pointer type disambiguation file 
(@pxref{Pointer type disambiguation}).
If this file exists, Kvasir uses it to make decisions about how 
to output the referents of pointer variables.  If the file does not exist, 
then Kvasir creates it, inferring whether pointers should output as one 
element or an array of elements.  
This file may then be edited and used on subsequent runs.

@item --disambig
Tells Kvasir to create or read pointer type disambiguation 
(@pxref{Pointer type disambiguation}) with the default filename, 
which is @file{@var{myprog}.disambig} in the same
directory as the target program, where @var{myprog} is the name of the 
target program. This is equivalent to 
@samp{--disambig-file=@file{@var{myprog}.disambig}}.

@end table

@node    Pointer type disambiguation, Online execution, Kvasir options, Kvasir
@subsection Pointer type disambiguation

@cindex pointer type disambiguation
@cindex disambiguation of pointer types

Kvasir permits users (or external analyses) to specify whether pointers
refer to arrays or to single values.  For example, in
@example
void sum(int * array, int * result) @{ ... @}  // definition of "sum"
...
int a[40];
int total;
...
sum(a, &total);        // use of "sum"
@end example
@noindent
the first pointer parameter refers to an array while the second refers to
a single value.  Kvasir (and Daikon) should treat these values
differently.  For instance, @code{*array} is better printed as @code{array[]}, 
an array of integers, and @code{result[]} isn't a sensible array 
at all, even though in C @code{result[0]} is semantically identical to 
@code{*result}.
By default, Kvasir treats all pointers as referencing arrays.  For
instance, it would print @code{result[]} rather than @code{*result}
and would indicate that the length of array @code{result[]} is always 1.
In order to improve the formatting of Daikon's output (and to speed it
up), you can indicate to Daikon that certain pointers refer to single
elements rather than to arrays.
For an example, see @ref{Pointer type disambiguation example}).

Information about whether each pointer refers to an array or a single
element can be specified in a ``disambig file'' that resides in the
same directory as the target program (by default).  The @option{--disambig} 
option instructs Kvasir to read this file if it exists.  (If it does not exist, 
Kvasir produces the file automatically and heuristically infers whether each 
pointer variable refers to single or multiple elements. Thus, users can
edit this file for use on subsequent runs rather than having to create it 
from scratch.)  The disambig file lists all the program points and user-defined 
types, and under each, a list of all the relevant variables along with their 
custom disambiguation types as shown below.  
The list of disambiguation options is:

@enumerate
@item
For variables of type @code{char} and @code{unsigned char}:
@enumerate
@item
'I': an integer, signed for @code{char} and unsigned for @code{unsigned char}. (Default)
@item
'C': a single character, output as a string.
@end enumerate
@item
For pointers to (or arrays of) @code{char} and @code{unsigned char}:
@enumerate
@item
'S': a string, possibly zero-terminated. (Default)
@item
'C': a single character, output as a string.
@item
'A': an array of integers.
@item
'P': a single integer.
@end enumerate
@item 
For pointers to (or arrays of) all other variable types (Kvasir automatically infers a default 'A' or 'P' for each variable during the generation of a @file{.disambig} file):
@enumerate
@item
'A': an array.  (For an array of structs, an array will be output for each scalar field of the struct.  Aggregate children (arrays, other structs) will not be output.)
@item
'P': a pointer to a single element.  (For a pointer to a struct, each field will be output as a single instance, and child aggregate types will be output recursively. This extra information obtained from struct pointers is a powerful consequence of pointer type disambiguation.)
@end enumerate
@end enumerate

The disambig file that Kvasir creates contains an entry for each program
point, which can be used to disambiguate parameter variables visible at
that program point.  It also contains an entry for every user-defined
struct, which can be used to disambiguate member variables of
that struct.  Disambiguation information entered here will apply to all
instances of a struct or class of that type, at all program points.
There is also an entry called ``globals'', which disambiguates global
variables which are output at every program point.  The entries in the
disambig file may appear in any order, and whole entries or individual
variables within an entry may be omitted.  In this case, Kvasir will
retain their default values.


@menu
* Pointer type disambiguation example::  
@end menu

@node    Pointer type disambiguation example,  , Pointer type disambiguation, Pointer type disambiguation
@subsubsection Pointer type disambiguation example

This example demonstrates the power of pointer type disambiguation in creating 
more accurate Daikon output.  Consider this file:

@example
struct record @{
  char* name;     // Initialize to: "Daikon User"
  int numbers[5]; // Initialize to: @{5, 4, 3, 2, 1@}
@};

void foo(struct record* bar) @{
  int i;
  for (i = 0; i < 5; i++) @{
    bar->numbers[i] = (5 - i);
  @}
@}
     
int main() @{
  char* myName = "Daikon User";
  struct record baz;
  baz.name = myName;
  foo(&baz);
@}
@end example

In @code{foo()}, @code{bar} is a @code{struct record *}.  By inspection, it is 
evident that in this program, @code{bar} only refers to one element: @code{&baz} 
within @code{main}.  However, by default, Kvasir assumes that @code{bar} is an 
array of @code{record} structs since a C pointer contains no information about 
how many elements it refers to.  Because Kvasir must output @code{bar} as an 
array and @w{@code{bar->numbers}} is an array of integers, it ``flattens'' 
@w{@code{bar->numbers}} into 5 separate arrays named @w{@code{bar->numbers[0]}}
through @w{@code{bar->numbers[4]}} 
and creates fairly verbose output.  This is a direct 
consequence of the fact that Daikon can only handle one layer of sequences 
(it cannot handle arrays within arrays, i.e., multi-dimensional arrays).  

Here is part of the Daikon output for this program:

@example
===========================================================================
..foo():::ENTER
bar has only one value
bar[] contains no nulls and has only one value, of length 1
bar[] elements has only one value
bar[].name == [Daikon User]
bar[].name elements == "Daikon User"
size(bar[]) == 1
===========================================================================
..foo():::EXIT
bar[] == orig(bar[])
size(bar[].numbers[0][]) == orig(size(bar[]))
size(bar[].numbers[1][]) == orig(size(bar[]))
size(bar[].numbers[2][]) == orig(size(bar[]))
size(bar[].numbers[3][]) == orig(size(bar[]))
size(bar[].numbers[4][]) == orig(size(bar[]))
bar[] contains no nulls and has only one value, of length 1
bar[] elements has only one value
bar[].name == [Daikon User]
bar[].name elements == "Daikon User"
bar[].numbers[0] has only one value
bar[].numbers[0][] == [5]
bar[].numbers[0][] elements == 5
bar[].numbers[1] has only one value
bar[].numbers[1][] == [4]
bar[].numbers[1][] elements == 4
bar[].numbers[2] has only one value
bar[].numbers[2][] == [3]
bar[].numbers[2][] elements == 3
bar[].numbers[3] has only one value
bar[].numbers[3][] == [2]
bar[].numbers[3][] elements == 2
bar[].numbers[4] has only one value
bar[].numbers[4][] == [1]
bar[].numbers[4][] elements == 1
bar[].numbers[4][] elements == orig(size(bar[]))
orig(size(bar[])) in bar[].numbers[4][]
@end example

This is a bit wordy due to the fact that Kvasir treats @code{bar} like an array 
by default when it actually only points to one element.  However, by running 
Kvasir with the @option{--disambig} option, we create the 
@file{@var{myprog}.disambig} file, which we can then edit and feed back to 
Kvasir to change how the pointer is output.  (We run Kvasir twice on the same
program, but we edit the @file{.disambig} file in between the runs.)
@example
kvasir-dtrace @var{...options...} --disambig @var{myprog}.c
@end example

This creates the @file{@var{myprog}.disambig} file.  It contains, at the top:

@example
--------ENTRY--------
..foo():::ENTER
bar
P

--------ENTRY--------
..foo():::EXIT0
bar
P
@end example

This means that at the two program points corresponding to the entry and
exit of @code{foo()}, the variable @code{bar} is treated as a
@samp{P}ointer type. 
Kvasir automatically inferred Pointer instead of Array for @code{bar} 
because it observed that @code{bar} only pointed to one element during the 
execution of the target program which generated the @file{.disambig} file. 
This heuristic allows users to use 
@file{.disambig} files more effectively with less manual editing.

Then, running Kvasir again with the @option{--disambig}
option causes Kvasir to open the existing
@file{@var{myprog}.disambig} file, read the definitions, and alter 
the output accordingly:
@example
kvasir-dtrace @var{...options...} --disambig @var{myprog}.c
@end example

This tells Kvasir to output @code{bar} as a @samp{P}ointer to a single
element, which in turn causes Daikon to generate much cleaner
invariants. Notice that @w{@code{bar->numbers}} no longer has to be
``flattened'' because @code{bar} is now a pointer to one struct, so
Daikon can recognize @w{@code{bar->numbers}} as a single-dimensional
array.

@example
===========================================================================
..foo():::ENTER
bar has only one value
*bar has only one value
bar.name == "Daikon User"
===========================================================================
..foo():::EXIT
*bar == orig(*bar)
*bar has only one value
bar.name == "Daikon User"
bar.numbers has only one value
bar.numbers[] == [5, 4, 3, 2, 1]
size(bar.numbers[]) == 5
bar.name == orig(bar.name)
size(bar.numbers[]) in bar.numbers[]
size(bar.numbers[])-1 in bar.numbers[]
@end example


@node Online execution, Installing Kvasir, Pointer type disambiguation, Kvasir
@subsection Online execution

@cindex online execution, for C programs
@cindex on-the-fly execution, for C programs

The term ``online execution'' refers to running Daikon at the same time
as the target program, without writing any information to a file.  This
can avoid some I/O overhead, it prevents filling up your disk with
files, and in the future Daikon may be able to produce partial results
as the target program is executing.

@cindex pipe, as data trace file

To use regular pipes in lieu of a disk file, simply use @file{-} as the
name of the @file{.dtrace} file, and run the target program and Daikon
in a Unix pipeline.

@example
kvasir-dtrace --dtrace-file=- ./bzip2 --help | $DAIKON -
@end example

Of course, you could also replace @option{--help} with @option{-vv1
file.txt} to compress a text file (but start with a small one first).

@noindent
(This example assumes that you have compiled the bzip2 example (in
@file{$DAIKONDIR/examples/kvasir-examples/bzip2} of the distribution) by
saying @command{gcc -gdwarf-2 bzip2.c -o bzip2}, and that
@command{$DAIKON} stands for the command that invokes Daikon, for
instance @command{java -Xmx512m daikon.Daikon --config_option
daikon.Daikon.disable_derived_variables=true}.)

@cindex named pipe, as data trace file
@cindex FIFO, as data trace file

Instead of a regular pipe, you can use a named pipe, also known as a
FIFO, which is a special kind of file supported by most Unix-compatible
systems.  When one process tries to open a FIFO
for reading, it blocks, waiting for another process to open it for
writing (or vice-versa).  When both a reader and a writer are ready, the
FIFO connects the reader to the writer like a regular Unix pipe.

The @option{--output-fifo} option causes Kvasir to create its output
@file{.dtrace} file as a named pipes.  When Kvasir is
run with this option, Daikon needs to be run at the same time to read
from the FIFOs, such as from another terminal or using the shell's
@code{&} operator.

For instance, the following two commands have the same effect as the
pipeline above that used ordinary pipes.  The FIFO is named
@file{bzip2.dtrace}.

@example
kvasir-dtrace --output-fifo ./bzip2 --help &
$DAIKON bzip2.dtrace
@end example

The two commands (before and after the ampersand) could also be run in
two different terminals.

When running Kvasir with DynComp (using the @file{--with-dyncomp}
option), Kvasir generates the .decls file after it generates the .dtrace
file, so it is not possible to perform online execution using one run.
The recommended way to perform online execution with DynComp is to run
it once and only generate a .decls file with comparability information,
then run Kvasir again without DynComp and pipe the .dtrace data directly
into Daikon while using the .decls file generated from the previous run:

@example
kvasir-dtrace --with-dyncomp --decls-only ./foo
@end example

This should generate a .decls file with comparability information
named @file{daikon-output/foo.decls}.

@example
kvasir-dtrace --decls-file=/dev/null --dtrace-file=- ./foo | java daikon.Daikon daikon-output/foo.decls -
@end example

When you run Kvasir the second time, you don't need to run DynComp
again since you are only interested in the .dtrace file.  Notice that
the .decls output is directed to @file{/dev/null} and the .dtrace output
is directed to standard out (@file{--dtrace-file=-}).  You can simply
pipe that .dtrace output out to Daikon, which is invoked using the
.decls file (with comparability information) generated during your
previous run.

A general warning about online execution: If your program outputs text
to standard output and the .dtrace data is also redirected to standard
output, then the two may conflict and confuse Daikon.

@node    Installing Kvasir, Kvasir limitations, Online execution, Kvasir
@subsection Installing Kvasir

@cindex installing Kvasir
@cindex Kvasir installation

@c Kvasir is the recommended C front end for use on Linux/x86.
The source
code for Kvasir is included in the main Daikon distribution, and is
compiled by default on Linux/x86 based systems.

To compile and install Kvasir, give the command @command{make kvasir}
from the top-level Daikon directory:

@example
cd $DAIKONDIR
make kvasir
@end example

This will check that you have the appropriate prerequisites (such as
GCC), configure Kvasir for your machine, compile it, and install
it in the directory @file{kvasir/inst}.

Once Kvasir has been installed, it can be used via the
@file{kvasir-dtrace} script in the @file{$DAIKONDIR/bin} directory; if
you have set up the Daikon environment according to the instructions
above, it should already be in your @env{PATH}.  For instructions on using
Kvasir, see @ref{Kvasir}.


@node Kvasir limitations,  , Installing Kvasir, Kvasir
@subsection Kvasir implementation and limitations

Kvasir is based on the Valgrind dynamic program supervision framework
(which is best known for its memory error detection tool).  Using
Valgrind allows Kvasir to interrupt your program's execution, read its
variables, and examine its memory usage, all transparently to the
program.  Also, rather than using your program's source code to find
the names and types of functions and variables, Kvasir obtains them
from debugging information included in the executable in a standard
format.  These differences should make Kvasir both much easier to use and
more robust than the source-rewriting-based dfec front end (@pxref{dfec}).

However, Kvasir has some limitations of its own.  Because Kvasir uses
Valgrind, it shares Valgrind's limitation of working only under the
Linux operating system, and only on Intel 386-compatible processors
(the so-called IA-32 architecture) such as the Intel Pentium and the
AMD Athlon.  Furthermore, Kvasir requires that your program have debugging
information available in the DWARF-2 format, as produced by recent
versions of GCC@.  Furthermore, the programs used by Kvasir should be
compiled without optimization.

This subsection lists some of the known limitations of the
current Kvasir release; if you encounter any problems other than listed
here, please report them as bugs (@pxref{Reporting bugs}).  The
limitations are listed roughly in decreasing order of severity.

@itemize @bullet

@item
Kvasir-traced programs take a while to start (often a good fraction of a
second).  When tracing short-lived programs, this overhead can
dominate Kvasir's per-instruction runtime overhead.  In order to make Kvasir 
run faster, try the @option{--ignore-globals} or @option{--limit-static-vars} 
options in order to limit the amount of generated output.
However, please keep in mind that, when running simultaneously with
Daikon using the @option{--output-fifo} option (see @ref{Online execution}), Kvasir can generate
output data much faster than Daikon can process it.  Thus, it is not the
performance bottleneck in the entire invariant detection system.

@item
Kvasir currently has rudimentary support for C++.  It outputs C++ classes
like C structs, generates @code{:::OBJECT} and @code{:::CLASS} invariants 
(@pxref{Program points}), treats member functions like regular
functions with an extra @code{this} pointer parameter, and
correctly outputs static class member variables.  However, 
it cannot print out the contents of classes which are defined in external 
libraries rather than in the 
user's program (e.g., it can properly output a C-string represented as 
@code{char*} but not the contents of the C++ @code{string} class).
Kvasir can only recognize classes which have member function
definitions located outside of the class body like in typical C++ style
instead of inside the class body like in Java style.  
If further support for more C++ features is important to you,
please send email to @email{daikon-developers@@lists.csail.mit.edu},
so that we can increase its priority on our to-do list.

@item
Kvasir always prints the contents of structures according to their
compile-time type.  Programs that use generic pointers and structural
equivalence to simulate object-orientation will have derived-class
fields missing when a structure is passed via a base-class pointer.

@item
Kvasir's support for outputting arrays is not yet complete. 
It still does not have the functionality to print out multidimensional 
arrays with all of their elements or the option to flatten 
multidimensional arrays into multiple single-dimensional arrays.

@item
Kvasir behaves somewhat differently with different versions of GCC@.
We have had the best results with GCC versions 3.3 (which we use for
testing) and 3.4.  If feasible, we recommend that you use
Kvasir with such a relatively recent version of GCC@.  Incompatibilities
between Kvasir and the debugging information produced by older GCC
versions can lead to incorrect output and, in some cases for version
2.95, can cause Kvasir to crash.

@item
On some platforms (including, as of December 2004, recent versions of
Debian), Kvasir crashes if run on statically-linked binaries.  To avoid
this problem, do not use the @option{-static} flag when linking programs
for use Kvasir.  If you want to link statically with a particular
library, supply the path to its static version (@file{libfoo.a})
directly to GCC instead.

@item
Not all of the options of the source-based C front end dfec are supported.
Of the environment variables obeyed by dfec,
only @env{DTRACEAPPEND} is recognized by Kvasir.

@item
Kvasir is incompatible with some compiler optimizations.  It is
definitely incompatible with the @option{-fomit-frame-pointer}
optimization, and it may have trouble with other optimizations as
well.  We recommend that you compile programs for Kvasir without
optimization.

@end itemize


@node dfepl, convertcsv.pl, Kvasir, Front ends
@section Perl front end dfepl

@cindex front end for Perl
@cindex Perl front end
@cindex dfepl (Daikon front end for Perl)

This section contains details about dfepl, the Daikon front end for
Perl.  For a brief introduction to dfepl, see @ref{Perl examples} and
@ref{Instrumenting Perl programs}.

dfepl works with Perl versions 5.8 and later. (To be precise, Perl
programs instrumented with dfepl can also be run with Perl 5.6, but
the instrumentation engine, which is itself written in Perl, requires
version 5.8).  dfepl reads the source code for Perl modules or
programs, and writes out instrumented versions of that code that
keep track of function parameters, and make calls to routines in the
@file{daikon_runtime} package whenever an instrumented subroutine is
entered or exited.

The instrumentation engine recognizes parameters as those variables
that are declared with @code{my(...)} or @code{local(...)} and, in the
same expression, assigned to from a value related to the argument
array @code{@@_}, but only among the first contiguous series of such
assignments in the body of a subroutine.  This will capture the most
common assignment idioms, such as @code{my $self = shift;} (where
@code{shift} is short for @code{shift @@_}), @code{my $x = $_[0];}, and
@code{my($x, $y, @@a) = @@_;}, but the arguments to subroutines which
access them only directly through @code{@@_}, or that perform other
operations before reading their arguments, will not be recognized.

If the uninstrumented code requested warnings via the @code{use
warnings} pragma or by adding the @option{-w} flag on the @code{#!}
line, the instrumented code will also request warnings.  In this case,
or if @option{-w} is specified on the command line when running it, the
instrumented code may produce warnings that the original code did
not.  There are several situations in which the instrumented code
produced by dfepl, while functionally equivalent to the original,
generates more warnings.  The most common such problem, which arises
from code that captures the scalar-context return value of a
subroutine that returns a list, has been avoided in the current
version by disabling the warning in question.  Other warnings which
are known to be produced innocuously in this way include
@samp{Ambiguous call resolved as CORE::foo(), qualify as such or use
&} (caused by code that uses @code{CORE::} to distinguish a built-in
function from a user subroutine of the same name), and @samp{Constant
subroutine foo redefined} (caused by loading both instrumented and
uninstrumented versions of a file).  Though some such warnings
represent deficiencies in the instrumentation engine, they can be
safely ignored when they occur.

Because Perl programs do not contain static type information to
distinguish, for instance, between strings and numbers, the Perl
front end incorporates an additional dynamic analysis to infer these
types.  This type guessing, which occurs as a first pass before the
program can be instrumented to produce output for Daikon, operates in
a manner somewhat analogous to Daikon itself: watching the execution
of a program, the runtime system chooses the most restrictive type for
a variable that is not contradicted during that execution.  These
types indicate, for instance, whether a scalar value always holds an
integer, a possibly fractional numeric value, or a reference to
another object.  It should not be necessary to examine or modify this
type information directly, but for the curious, the syntax of the type
information is described in comments in the @file{Daikon::PerlType}
module.

The safest course is to infer types for variables using exactly the
same program executions (e.g., test cases) which will later be used to
generate traces for Daikon, as this guarantees that the type
information will match the actual data written to the trace file.
However, because the type-guessing-instrumented versions of programs
run fairly slowly in the current version, you may be tempted to use a
subset of the input data for type guessing.  Doing so is possible, but
it will only work correctly if the smaller tests exercise all of the
instrumented subroutines and exit points with all the types of data
they will later be used with.  If the trace runtime tries to output a
data value that doesn't match the inferred type, the value may
silently be converted according to Perl's usual conventions (for
instance, a non-numeric string may be treated as the number zero), or
it may cause an error during tracing (for instance, trying to
dereference a supposed array reference that isn't).  Also, if a
subroutine exit point is traced but was never encountered during type
guessing, the generated @file{.decls} and @file{.dtrace} files will be
incompatible in a way that will cause Daikon to abort with an error
message of the form @samp{Program point foo():::EXIT22 appears in dtrace
file but not in any decl file}.

@float Figure,dfepl-flow
@center @image{images/dfepl-flow,4in,}
@caption{Workflow of instrumenting Perl code with dfepl.}
@end float

dfepl works by reading one or more Perl programs
or modules, and writing out new versions of those files, instrumented
to capture information about their execution, by default to another
directory.  dfepl is used in two passes: first, before type
information is available, instrumented versions are written to a
directory @file{daikon-untyped}.  These untyped programs, when run,
will write
files containing dynamically inferred type information (with the
extension @file{.types}), by default to the @file{daikon-instrumented}
directory.  When dfepl is rerun with this type information, it
produces type-aware instrumented code in the
@file{daikon-instrumented} directory, which when run produces
execution traces in files with the extension @file{.dtrace} in the a
directory @file{daikon-output}.

@menu
* dfepl options::               
@end menu

@node dfepl options,  , dfepl, dfepl
@subsection dfepl options

@table @option
@item --absolute
@itemx --no-absolute
@option{--absolute} stores the absolute path to the output directories
(by default named @file{daikon-untyped}, @file{daikon-instrumented} or
@file{daikon-output}) in the instrumented programs, so that no matter
where the instrumented program is run, the output will go to a fixed
location.  Even if these directories are given as relative paths (as is
the default), @option{--absolute} specifies that they should always be
taken as relative to the directory that was the working directory when
dfepl was run.

@option{--no-absolute} specifies the opposite, causing the output paths
to be interpreted relative to the current working directory each time
the instrumented program is invoked.  The default, when neither option
is specified, is for @file{.types} files to use an absolute path, but
all others to use relative path, so that the @file{.types} files will
always be in the same place as the instrumented source files that
generated them, but the @file{daikon-output} directory will be created
in the current directory when the program runs.

@item --accessor-depth=@var{num}
Controls the number of nested invocations of object accessor methods
to examine.  For instance, suppose that the @code{Person} class has a
method @code{mother()} that returns another person (and has been
specified to dfepl as an accessor), and that @code{$me} is
an instrumented variable.  If the accessor depth is 1, only
@code{$me->mother()} will be examined.  If the depth is 2,
@code{$me->mother()->mother()} will also be examined.  Specifying large
accessor depths is generally not advisable, especially with many
accessor methods, as the number of variables examined can be too many
for Daikon to process efficiently.

By default, the Daikon Perl trace runtime will examine at most a
single level of accessors.

@item -A
@itemx --accessors-dir=@var{directory}
Look for files containing accessor lists in @var{directory}, or the
current directory if @var{directory} is omitted.  For a class
@code{Acme::Foo}, accessors are methods that return information about
an object but do not modify it.  dfepl cannot determine on
its own which methods are accessors, but when a list of them is
provided, it can call an object's accessors when examining a variable
of that class to obtain more information about the object.  To tell
dfepl about the accessors for @code{Acme::Foo}, make a file
listing the names of each accessor method, one per line with no other
punctuation, named @file{Acme/Foo.accessors} in the same directory as
@file{Acme/Foo.pm}.

@item --decls-dir=@var{directory}
Put generated declaration files in @var{directory} and its
subdirectories.  The default is @file{daikon-output}.

@item --decls-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}.  A style of @option{combined} specifies that the
declarations for all packages should be merged, in a file named
@file{prog-combined.decls} where @file{prog} is the name of the
program.  A style of @option{flat} specifies that the declarations for
each package should be in a separate file named after the package, but
that these files should go in a single directory; for instance, the
declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.decls} and @file{Acme::Skates::Rocket.decls}.  A
style of @option{tree} specifies that each package should have its own
declarations file, and that those files should be arranged in
directories whose structure matches the structure of their package
names; in the example above, the files would be
@file{Acme/Trampoline.decls} and @file{Acme/Skates/Rocket.decls}.

The default is @option{tree}.  Note that @option{--decls-style} and
@option{--types-style} are currently constrained to be the same; if
one is specified, the other will use the same value.

@item --dtrace-append
@itemx --no-dtrace-append
When @option{--dtrace-append} is specified, the instrumented program
will append trace information to the appropriate
@file{.dtrace} file each time it runs.  When
@option{--no-dtrace-append} is specified, it will overwrite the file
instead. 

The default behavior is to overwrite.  This choice can also be
overridden, when the program is run, to always append by setting the
environment variable @env{DTRACEAPPEND} to 1.

When appending to a @file{.dtrace} file, no declaration information is
ever produced, because it would be redundant to do so and Daikon does
not permit re-declarations of program points.

@item --dtrace-dir=@var{directory}
Put generated trace files in @var{directory} and its
subdirectories.  The default is @file{daikon-output}.

@item --dtrace-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}.  A style of @option{combined} specifies that the traces
for all packages should be merged, in a file named
@file{prog-combined.dtrace}, where @file{prog} is the name of the
program.  A style of @option{flat} specifies that the
traces for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.dtrace} and
@file{Acme::Skates::Rocket.dtrace}.  A style of @option{tree} specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be @file{Acme/Trampoline.dtrace} and
@file{Acme/Skates/Rocket.dtrace}.

The default is @option{combined}.

@item --help
Print a short options summary.

@item --instr-dir=@var{directory}
@c dfec option -- do not rename (yet)
@itemx --instrsourcedir=@var{directory}
Put instrumented source files in @var{directory} and its
subdirectories.  The default is @file{daikon-untyped}, or
@file{daikon-instrumented} if type information is available.

@item --list-depth=@var{DEPTH}
Consider as many as @var{DEPTH} of the first elements of a list to be
distinct entities, for the purpose of guessing their types.  When
subroutines return a list of values, each value may have a distinct
meaning, or the list may be homogeneous.  When trying to assign types
to the elements of a list, the Daikon Perl trace runtime will try
making separate guesses about the types of the elements of a short
list, but it would be inefficient to make retain this distinction for
many elements.  This parameter controls how many elements of a list
will be examined individually; all the others will be treated
uniformly.

The default is 3.

@item --output-dir=@var{directory}
Put all of the files that are the output of the tracing process (and
therefore input to the Daikon invariant detection engine) in
@var{directory} and its subdirectories.  This option is a shorthand
equivalent to setting both @option{--decls-dir} and
@option{--dtrace-dir} to the same value.

The default behavior is as if @option{--output-dir=daikon-output} had
been specified.

@item --perl=@var{path}
Use @var{path} as the location of Perl when calling the annotation
back end (a module named @code{B::DeparseDaikon}), rather than the
version of Perl under which @command{dfepl} itself is running, which
is probably the first @command{perl} that occurs on your path.  For
instance, if the first version of @command{perl} on your path isn't
version 5.8 or later, you should this option to specify another
@command{perl} program that is.

@item --nesting-depth=@var{num}
When examining nested data structures, traverse as many as @var{num}
nested references.  For instance, suppose that @code{@@a} is the array

@example
@@a = (@{1 => [2, 3]@}, @{5 => [4, 2]@})
@end example

If the depth is 0, then when examining @code{@@a}, Daikon's Perl trace
runtime will consider it to be an array whose elements are references,
but it won't examine what those references point to.  If the depth is
1, it will consider it to be an array of references to hashes whose
keys are integers and whose values are references, but it won't
examine what @emph{those} references point to.  Finally, if the depth
is 2 or more, it will consider @code{@@a} to be an array of references
to hashes whose keys are integers and whose values are references to
arrays of integers.

The default nesting depth is 3.

When referenced objects have accessor methods, or when accessors
return references, the @option{--accessor-depth} and
@option{--nesting-depth} options interact.  Specifically, if these
depths are A and R, the behavior is as if the runtime has a budget of
1 unit, which it can use either on accessors which cost 1/A or
references which cost 1/R@.  It may thus sometimes be useful to specify
fractional values for @option{--accessor-depth} and
@option{--nesting-depth}; in fact, the default accessor depth is
1.5.

@item --types-append
@itemx --no-types-append
When @option{--types-append} is specified, the instrumented program
will append type information to the appropriate
@file{.types} file each time it runs.  When
@option{--no-types-append} is specified, it will overwrite the file
instead. 

The default behavior is to append.  If @option{--no-types-append} is
specified, however, this choice can also be overridden, when the
program is run, to append by setting the environment variable
@env{TYPESAPPEND} to 1.  There is no way to use environment variables
to force the runtime to overwrite a types file, but an equivalent
effect can be obtained by simply removing the previous types file
before each run.

@item -T
@itemx --types-dir=@var{directory}
Look for @file{.types} files in @var{directory}, or
@file{daikon-instrumented} if @var{directory} is omitted.  When
instrumenting a module @code{Acme::Trampoline}, used in a program
@file{coyote.pl},  dfepl will look for
files named @file{coyote-combined.types}, @file{Acme::Trampoline.types}, and
@file{Acme/Trampoline.types}, corresponding to the possible choices of
@option{--types-style}.  Once discovered, the files are used in the
same way as for @option{-t}.

@item --types-file=@var{file}
@itemx -t @var{file}
Include type information from @var{file} when instrumenting programs
or modules.  Since Daikon needs to know the types of variables when
they are declared, useful @file{.decls} and @file{.dtrace} files can
only be produced by source code instrumented with type
information.  Since Perl programs don't include this information to
begin with, and it would be cumbersome to produce by hand, type
information must usually be produced by running a version of the
program that has itself been annotated, but without type
information.  The Daikon Perl trace runtime will automatically decide
whether to output types, or declarations and traces, depending on
whether the source was instrumented without or with types.  This option
may occur multiple times, to read information from multiple types
files (irrelevant type information will be ignored).

@item --types-basedir=@var{directory}
Put files containing type information in @var{directory} and its
subdirectories.  By default, this is whatever @option{--instr-dir}
is, usually @file{daikon-instrumented}.

@item --types-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}.  A style of @option{combined} specifies that the types
for all packages should be merged, in a file named
@file{prog-combined.types}, where @file{prog} is the name of the
program.  A style of @option{flat} specifies that the
types for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.types} and
@file{Acme::Skates::Rocket.types}.  A style of @option{tree} specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be @file{Acme/Trampoline.types} and
@file{Acme/Skates/Rocket.types}.

The default is @option{tree}.  Note that @option{--types-style} and
@option{--decls-style} are currently constrained to be the same; if
one is specified, the other will use the same value.

@item --verbose
@itemx -v
Print additional information about what dfepl is doing,
including external commands invoked.
@end table


@node convertcsv.pl, dfej, dfepl, Front ends
@section Comma-separated-value front end convertcsv.pl

@cindex csv files
@cindex comma-delimited files
@cindex comma-separated-value files
@cindex tab-separated files
@cindex Excel files
@cindex spreadsheet files

Daikon can process data from spreadsheets such as Excel.  In order to
use such files, first save them in comma-separated-value, also known
as csv or comma-delimited, format.
Then, convert the @file{.csv} file into a @file{.dtrace} file (and a
@file{.decls} file) to be used by Daikon by running the
@command{convertcsv.pl} program found in the @file{$DAIKONDIR/bin}
directory.  For example,
@example
convertcsv.pl myfile.csv
@end example
@noindent
produces files @file{myfile.decls} and @file{myfile.dtrace}.  Run
@command{convertcsv.pl} without any arguments in order to see a usage
message.


@node    dfej, dfec, convertcsv.pl, Front ends
@section Source-based Java front end dfej

@cindex front end for Java, source-based
@cindex Java front end, source-based
@cindex dfej (Daikon front end for Java)

This section contains details about dfej, the source-based Daikon front
end for Java.

For brief information about running dfej, see @ref{Instrumenting Java programs}.
For information about installing dfej, see @ref{Installing dfej}.
The @command{dfej} usage message also contains some usage information;
run @command{dfej --help} to see it.

dfej works on Java code that corresponds to versions 1.0--1.4
of the Java language.  dfej does not work on Java 5.0.

The Chicory front end for Java (@pxref{Chicory}) works on
all versions of the Java language, including Java 5.0.
Another advantage of Chicory is that Chicory is much easier to use.
Finally, Chicory is platform-independent (and requires no special action to
build), since it is written in Java.  
Thus, we recommend the use of Chicory over dfej in most circumstances.
For more details on Chicory, see @ref{Chicory}.

@menu
* Instrumenting Java programs::  
* dfej options::                
* Run dfej Java::               
* Scope of instrumentation::    
* Refined runtime types::       
* Installing dfej::             
* All-in-one script::           
@end menu


@node    Instrumenting Java programs, dfej options, dfej, dfej
@subsection Instrumenting Java programs

To instrument Java source programs, simply invoke @command{dfej}, the
Daikon front end for Java, on them:
@example
dfej @var{filename1}.java @var{filename2}.java @var{...}
@end example


Instrumentation with dfej performs two actions:
@itemize @bullet
@item
Instrumentation adds instructions to the target program so that, in
addition to performing its original task, it also writes variable values
to a data trace file.  The changes are made to a copy of the target
program; your original version is not modified.
dfej writes instrumented versions of the files to a
@file{daikon-instrumented/} directory.

@item
Instrumentation creates declaration files that describe the format of
the data trace files.  For instance, these declaration files describe
the names of procedures and variables that appear in the data trace file.
dfej creates declaration files named @file{@var{filename1}.decls}, etc.@
in a @file{daikon-output/} directory.
@end itemize

After running dfej, compile the instrumented version of the code, which
by default appears in the @file{daikon-instrumented/} directory.

@menu
* StackAr example with dfej::   
* Summary of Daikon use with dfej::  
* Automating the process::      
* Second Java example::         
@end menu

@node    StackAr example with dfej, Summary of Daikon use with dfej, Instrumenting Java programs, Instrumenting Java programs
@subsubsection StackAr example with dfej

@c We recommend you run Daikon on Unix, but it can also be run on Windows.

You need to perform three basic tasks:  instrument the target program
(steps 1-4), run the instrumented program to create a data trace file
(steps 5-7), and run Daikon over the data trace file to produce
invariants (steps 8-9).

You must first install Daikon if you haven't done so already; see
@ref{Installing Daikon}.  If you have any trouble with these
instructions, see @ref{Troubleshooting}, or try the @ref{Index}.


@enumerate
@item Change to the directory containing the StackAr program.  (The
directory contains the @file{DataStructures} directory.)
@example
cd examples/StackAr
@end example

@item Compile the original version of the program.  You must use the
@option{-g} flag to include debugging information in the compiled classfiles.
You may compile with any Java compiler you like (such as javac), but
your code must be compilable with the @command{jikes} Java compiler (see
@uref{http://www.ibm.com/developerworks/oss/jikes/}).
@example
javac -g DataStructures/*.java
@end example


@item Instrument the @file{StackAr.java} file.
@example
dfej DataStructures/StackAr.java
@end example
@noindent
(These instructions assume you have the current working directory (@file{.})
in your @env{CLASSPATH}@.  If that is not the case, then run @command{dfej
-ajaxap=.} instead of @command{dfej}.)

We instrument only this one file because we are only interested in the
invariants of the StackAr class, not the other classes in the program.

This command creates two directories, @file{daikon-instrumented} and
@file{daikon-output}.  It creates an instrumented version of
@file{StackAr.java} at @file{daikon-instrumented/DataStructures/StackAr.java}.
It creates a declaration file at
@file{daikon-output/DataStructures/StackAr.decls}.

@item Compile the instrumented version of StackAr.java.
@c I think this comment about "." on the classpath is correct.  -MDE 8/26/01
(This step requires @file{.} to be on your classpath.)

@example
javac daikon-instrumented/DataStructures/StackAr.java
@end example

@item Run the StackAr test suite, using the instrumented
@file{StackAr.class} class file instead of the original (but the
original version of all other files):

@example
java -classpath "daikon-instrumented:$CLASSPATH" \
     DataStructures.StackArTester
@end example

(On Windows, use @samp{;%CLASSPATH%} instead of @samp{:$CLASSPATH}.)

This will generate a trace file at
@file{daikon-output/StackAr.dtrace}.  This could take anywhere from
a few seconds to a few minutes, depending on the speed of your
computer.

@item Change to the @file{daikon-output} directory to analyze
the output.

@example
cd daikon-output
@end example

@item Run Daikon on the trace file.

@example
java daikon.Daikon DataStructures/StackAr.decls StackAr.dtrace
@end example

The invariants are printed to standard output, and a binary
representation of the invariants is written to
@file{StackAr.inv.gz}.

@item Examine the invariants; for a
description of how to do this, @xref{StackAr example}.

@end enumerate

@node    Summary of Daikon use with dfej, Automating the process, StackAr example with dfej, Instrumenting Java programs
@subsubsection Summary of Daikon use with dfej

The steps above can be divided into three stages:

@itemize @bullet
@item Instrumentation (steps 1-4)
@example
cd examples/StackAr
javac -g DataStructures/*.java
dfej DataStructures/StackAr.java
javac daikon-instrumented/DataStructures/StackAr.java
@end example

@c @item Trace file generation (steps 5-7)

@item Trace file generation (step 5)
@example
java -classpath "daikon-instrumented:$CLASSPATH" \
     DataStructures.StackArTester
@end example

(On Windows, use ``;'' as the path separator.)

@item Invariant detection (steps 6-8)
@example
cd daikon-output
java daikon.Daikon DataStructures/StackAr.decls StackAr.dtrace
@end example

@end itemize


@node    Automating the process, Second Java example, Summary of Daikon use with dfej, Instrumenting Java programs
@subsubsection Automating the process

The script @command{daikon.pl} automates all steps of the invariant
detection process.

@example
cd examples/StackAr
daikon.pl DataStructures.StackArTester
@end example

This command instruments your program, generates a trace file, and
displays the invariants in the (deprecated) Tree GUI@.  Currently, this
script only works on Unix.  For more details, @xref{All-in-one script}.


@node    Second Java example,  , Automating the process, Instrumenting Java programs
@subsubsection A second Java example

A second example is located in the @file{examples/QueueAr} subdirectory.
Run this sample using the following steps:

@itemize @bullet
@item Instrumentation (steps 1-4)
@example
cd examples/QueueAr
javac -g DataStructures/*.java
dfej DataStructures/QueueAr.java
javac daikon-instrumented/DataStructures/QueueAr.java
@end example

@c @item Trace file generation (steps 5-7)
@item Trace file generation (step 5)
@example
java -classpath "daikon-instrumented:$CLASSPATH" \
     DataStructures.QueueArTester
@end example

(On Windows, use ``;'' as the path separator.)

@item Invariant detection (steps 6-8)
@example
cd daikon-output
java daikon.Daikon DataStructures/QueueAr.decls \
     QueueAr.dtrace
@end example

@end itemize

@node    dfej options, Run dfej Java, Instrumenting Java programs, dfej
@subsection dfej options

The simplest way to invoke dfej is simply to supply it with a list of
Java files:
@example
dfej @var{filename1}.java @var{filename2}.java @var{...}
@end example

dfej options should be provided before the first Java file name.  dfej
accepts most Chicory arguments (@pxref{Chicory options}), and also the
following additional options.
@c
@c The options can be divided into the following
@c categories:
@c @table @b
@c @item where (in what directory) to produce output
@c 
@c @end table
@c
@c Details of the options are as follows.  
When conflicting options are specified, the last one
takes precedence.


@table @option
@c @item +daikon_loops
@c Produce data trace output for loop invariants.
@c @emph{This option has no effect:  loop invariants are not currently supported.}
@c 
@c @item -daikon_loops
@c Do not produce data trace output for loop invariants (default).

@item --instrument
Produce tracing output (default).

@item --no-instrument
Do not produce tracing output.

@item --linked-lists
Render linked lists as vectors (default).

Suppose you have a class one of whose fields is of the class's own type,
such as
@example
class Link @{
  Object value;
  Link next;
@}
@end example
Then if the @option{--linked-list} option is set, the Daikon front end
will output a list consisting of all the elements reachable via
@code{next} pointers.

@item --no-linked-lists
Do not render linked lists as vectors.

@item +daikon_context
Produce context sensitive output.

@item -daikon_context
Do not produce context sensitive output (default).

@item --exceptions
Produce data trace output for exceptions.

@item --no-exceptions
Do not produce data trace output for exceptions (default).

@item +daikon_classhier
Produce class hierarchy data.

@item -daikon_classhier
Do not produce class hierarchy data (default).


@item --decls-dir=@var{decldir}
Specifies the directory in which to create
@file{@var{PACKAGES}/@var{CLASSNAME}.decls} (default
@file{daikon-output}, unless @option{--decls-flat} is
specified).  @file{@var{PACKAGES}} is the relative path from the current
directory to the source file; that is, the relative path from
@var{decldir} to the @file{.decls} file is the same as the relative
path from the current directory to the source file.  The directory
structure of the @file{.decls} files mirrors the directory structure of
the source files.

@item --decls-flat
Specifies to create @file{@var{CLASSNAME}.decls} in a single directory,
not in a directory hierarchy.

@item --instr-dir=@var{instrdir}
Specifies the directory in which to write instrumented source files
(default @file{daikon-instrumented/}).  The instrumented files have the
same names and directory structure as the original input files.

@c not yet implemented for dfej as of 6/13/2001
@c If the value of this field is @samp{.} (i.e., a single period), then
@c instrumented files replace the original versions in the original
@c directories, but the original source files are backed up by appending
@c @file{.uninst}.  More specifically,
@c @enumerate
@c @item each instrumented file is copied from @file{filename} to
@c @file{filename.uninst}, unless filename @file{filename.uninst} already
@c exists, in which case no copying occurs
@c @item the system reads from @file{filename.uninst} and writes to
@c @file{filename}.
@c @end enumerate
@c This behavior permits in-place instrumentation, which may be desirable
@c to ease compiling the instrumented code.  (This feature is probably more
@c important for C than for Java programs.)  Running the instrumenter a
@c second time reads the original source code rather than inserting an
@c additional set of instrumentation into the already-instrumented source
@c code files.

Note for Java:

If you do not override the default value of this variable (and possibly
even if you do, if you do not set it to @samp{.}), then you should run
dfej from a directory in your classpath.  For example, if
directory @file{parent/} is in your classpath and you want to instrument
@file{parent/foo/Bar.java}, you should run @samp{dfej foo/Bar.java} from
directory @file{parent/}.  This will create a file
@file{parent/daikon-instrumented/foo/Bar.java}.  You must add directory
@file{parent/daikon-instrumented} to your classpath.

(The reason for running dfej from a directory in your
classpath is that it allows the directory structure to remain consistent
with the package structure.  If @file{Bar.java} specifies its package, it
does so with a line like @samp{package foo;}.  If you run dfej
from the @file{parent/foo} directory, the instrumented version of
@file{Bar.java} will go in @file{parent/foo/daikon-instrumented/Bar.java}; this
is not consistent with the package structure.)

@item --no-ajax
@cindex AJAX_DIR environment variable
@cindex environment variable AJAX_DIR
Do not use Ajax.  Ordinarily, the Ajax module
@code{ComparablePairsDescFileReader} updates the variable comparability
information in the @file{.decls} file.  The comparability information
can indicate which variables should not be compared to one another.
(For instance, the number of people that a recipe serves should not be
compared to the page number in a cookbook where the recipe is found,
even if both are integers.)  Use of Ajax to update this information is
entirely optional; its effect is to suppress invariants over incomparable
variables.  These comparisons are usually nonsensical, so using Ajax makes
Daikon report fewer irrelevant invariants.

Use of Ajax requires environment variable @env{AJAX_DIR} to be set to a
directory containing various Ajax helper files (such as
@file{main-harness.csal}, @file{tweaked-classes.zip}, etc.).  The proper
directory is @file{java/ajax-ship} in the Daikon distribution and is set
by the provided @file{daikon.cshrc} and @file{daikon.bashrc}
initialization files.

@item -ajaxap=@var{apdir}
This is the directory in which the Ajax comparability module looks
for @file{.class} files for the current application.  (It is a classpath
entry, so the @file{.class} files might appear in a subdirectory named
for the appropriate package.  If this option is not supplied, the
@option{-classpath} argument is used.  A sensible value is required for
code that (for example) calls libraries that do not appear under the
current directory.

@item -ajaxcp=@var{cpdir}
Classpath to give to Ajax in its @option{-cp} flag, similar to @option{-ajaxap}.

@item -ajax_runnable=@var{class}
This is a Java class, in dot-delimited form (e.g., @samp{foo.bar.Baz}), that
contains a @samp{public static void main(String[])} method.  This class
need not be one of the instrumented ones.  If it is not supplied, the
first instrumented class with such a @samp{main} method is used instead.

@c @item -ajax_runnables=@var{classes}
@c This is a whitespace-separated list of Java classes, in dot-delimited
@c form (e.g., "foo.bar.Baz"), that contain @samp{public static void
@c main(String[])} methods.  Those Java classes need not be among the
@c instrumented ones.  In addition, all such @samp{main} methods in the
@c instrumented classes are also used as entry points.  In order to run,
@c Ajax requires the name of at least one runnable class.
@c (Actually, Ajax requires the name of exactly one runnable class.)
@c 
@c @item -ajax_all_runnables=@var{classes}
@c Just like @option{-ajax_runnables}, except that no @samp{main} methods
@c in the instrumented classes are used as entry points.

@item -ajaxdumpdir=@var{dumpdir}
This is the directory in which the Ajax comparability module writes its
log file, named @file{ajax.log}.  By default, @file{ajax.log} is written
to the current directory.

@end table


@cindex trace file size, limiting
@cindex limiting trace file size
The following two environment variables can control the size of your
trace file.  (There aren't currently dfej command-line arguments to
set these, but there probably should be.)

@cindex DTRACELIMIT environment variable
@cindex environment variable DTRACELIMIT
@cindex DTRACELIMITTERMINATE environment variable
@cindex environment variable DTRACELIMITTERMINATE
Environment variable @env{DTRACELIMIT} is a number of records (that is,
program point executions), after which the instrumented program will
continue to run but will close the @file{.dtrace} and produce no more
output to it.  If environment variable @env{DTRACELIMITTERMINATE} is set to
true, then when the specified number of records is output, the
instrumentation throws a TerminationMessage (an unchecked Java error) in
an attempt to halt the program.

Note that recent versions of the JDK do not allow Java programs to
inspect environment variables.  So if you're generating a
@file{.dtrace} from a Java class, you may need to pass the environment
variable directly as an argument to Java.  For example:

@example
java -classpath daikon-instrumented:$CLASSPATH \
    -DDTRACELIMIT=10000 -DDTRACELIMITTERMINATE=true Foo
@end example


@node    Run dfej Java, Scope of instrumentation, dfej options, dfej
@subsection Details on running dfej-instrumented Java programs

After instrumentation, there are two versions of your Java program:
the original version, which is unmodified, and the instrumented
version, which appears in the @file{daikon-instrumented/} directory.
Make sure that the @file{daikon-instrumented/} directory appears on
your class path before the directory containing the original Java
code.  You can do this by running the program from that directory, if
@file{.} (the current directory) appears early on your class path, or
you can add the @file{daikon-instrumented/} directory to your class
path explicitly.  (To be able to run the instrumented program from a
directory other than the parent of the @file{daikon-instrumented/}
directory, an absolute path to the @file{daikon-instrumented/} should
be used).


@menu
* Java applets::                
@end menu

@node    Java applets,  , Run dfej Java, Run dfej Java
@subsubsection Java applets

In order to run an applet, you must take two additional steps.

@enumerate
@item
Copy or link all class files, jar files, input files, and html files
that your applet needs to the @file{daikon-instrumented/} directory.  This
includes the @file{daikon/java} directory itself.  For example, to
create a link to the @file{daikon/java} directory, type (while in the
@file{daikon-instrumented/} directory):
@example
ln -s $DAIKONDIR/java/daikon .
@end example

@item
By default, the Java 2 applet security model does not allow applets to
write files.  To get around this so that Daikon can write its @file{.dtrace}
files, create a file named @file{javaPolicy} in the @file{daikon-instrumented/}
directory that contains the text
@example
grant @{
    permission java.io.FilePermission
      "<<ALL FILES>>", "read, write, delete, execute";
@};
@end example
@noindent
Do not use this policy file with untrusted applets.

@item
Finally, run the applet:
@example
appletviewer -J-Djava.security.policy=javaPolicy @var{html-file}
@end example
@end enumerate


@node    Scope of instrumentation, Refined runtime types, Run dfej Java, dfej
@subsection Controlling what classes are instrumented

Only the specified Java files are instrumented; other files are
run uninstrumented.  This permits you to control the scope of invariant
detection.

In any of the specified files, all classes defined in any of those
files are instrumented.  For instance, after
@example
dfej Foo.java Bar.java
@end example
@noindent
the instrumented versions of @file{Foo.java} and @file{Bar.java} output
information about all @code{Foo} objects (including @code{Foo} objects that are
components of @code{Bar} objects, that are arguments to @code{Bar} 
procedures, etc.), and likewise for @code{Bar} objects.

After
@example
dfej Foo.java
dfej Bar.java
@end example
@noindent
the same procedures (all those in the @code{Foo} and @code{Bar} classes)
are instrumented, but in @code{Foo} procedures, no detail is provided
about the structure of any @code{Bar} objects that might appear.  In other
words, the instrumenter assumes that the only classes instrumented (and
about which information is desired) are those presented to it on the
command line.  One way to determine all the @file{.java} files that are
included in a specified program is to run the following commands:
@example
find . -name '*.class' -print | xargs rm -f
javac MyProgram.java
find . -name '*.class' -print
@end example

dfej tracks all modifications of instrumented classes; if you
do not instrument all users of a class, then modifications in
uninstrumented classes may not be detected.  This can affect Daikon's
statistical tests, but in practice usually has little impact.  The program 
makes approximations to the missing modification information.


@node    Refined runtime types, Installing dfej, Scope of instrumentation, dfej
@subsection Refined runtime types

Daikon uses the declared types of variables to determine what fields
those variables have and what methods may be legally applied to those
variables.  However, sometimes the declared type is excessively general:
the runtime value may be guaranteed to be of a more specific type.  This
often results from use of polymorphic datatypes or methods.  For
instance, a Java variable may be declared as @code{Object} even though
it always holds an @code{Integer}.  In that case, methods such as
@code{intValue} may be safely called on the object, even though it is
not applicable to arbitrary @code{Object}s.

You can indicate the runtime type of a variable to dfej by inserting a
@example
/*refined_type: Integer*/ 
@end example
@noindent
comment immediately before the declared type (but after any modifiers like
@code{public} or @code{static}).  For example, a list element that only 
contains @code{Integer}s might be annotated as follows:
@example
class ListNode @{
  /*refined_type: Integer*/ Object element;
  ListNode next;

  ListNode( /*refined_type: Integer*/ Object theElement ) @{ ... @}
  ListNode( /*refined_type: Integer*/ Object theElement,
            ListNode n ) @{ ... @}
@}
@end example


@node    Installing dfej, All-in-one script, Refined runtime types, dfej
@subsection Installing dfej, the Daikon front end for Java

@cindex installing dfej
@cindex dfej installation

This manual section is optional; if you ran @command{make} from
@file{$DAIKONDIR} (@pxref{Installing Daikon}), you can skip it.

If you wish to use the dfej source-based front end for Java, you need to
obtain or build an executable for dfej.

@itemize @bullet
@item
You can download a precompiled version of
dfej from @uref{http://pag.csail.mit.edu/daikon/download/}.
Place that executable in directory
@file{$DAIKONDIR/front-end/java/src} (or, alternately, elsewhere on
your path), then run @command{rehash}.  Now you are ready to run dfej.
(If no executable is available for your architecture, send mail to
@email{daikon-developers@@lists.csail.mit.edu} and we may be able to produce an
executable for you.)

@item
You can build dfej from the sources, which are included in
the Daikon source distribution.  
(dfej is written in C++, so you need a C++ compiler such as
@uref{http://gcc.gnu.org/,, gcc}.)
After building, file @file{src/dfej} (on Windows, @file{src/dfej.exe}) is
the dfej executable.  If you followed the installation instructions
(@pxref{Installing Daikon}), it is already on your path.

@itemize
@item
The easiest way to do this is to type @command{make dfej} from the top
level of your Daikon distribution.

@item
Alternatively, see file @file{INSTALL} in the dfej sources.  In
summary, you should be able to build dfej by running the following
commands:
@example
cd daikon/front-end/java
./configure
make
rehash
@end example
@noindent
@end itemize
@noindent

If you modify the source code for dfej (which is not recommended
unless you know what you are doing), just run @command{make} again to
build a new binary.

@c Because it uses some obsolescent C++ features, dfej cannot be compiled
@c using gcc/g++ 3.2; dfej can be compiled with gcc 2.95.3 (and possibly
@c other versions).
@c 
@c @b{Cygwin note:}  Cygwin uses gcc 3.2 by default; there is also an
@c option to install gcc 2.95.3.  After installing gcc 2.95.3, you can
@c make it the default in the following way:
@c @example
@c      cd /usr/bin
@c      mv gcc.exe gcc-3.exe
@c      mv g++.exe g++-3.exe
@c      cp gcc-2.exe gcc.exe
@c      cp g++-2.exe g++.exe
@c @end example

@b{Cygwin note:}If you wish to
build dfej under Cygwin, you must use GCC 2.95.3.

@b{Solaris note:}
If you are running under Solaris, you may need to edit
@file{Makefile} to indicate use of the @file{libw} library; change
@example
LDFLAGS=-L. -o $(EXECUTABLE)
@end example
@noindent
to
@example
LDFLAGS=-L. -lw -o $(EXECUTABLE)
@end example


@end itemize


@node    All-in-one script,  , Installing dfej, dfej
@subsection All-in-one script daikon.pl

The @command{daikon.pl} script automates all steps of the invariant
detection process:  instrumentation, trace file generation, and
invariant display.  However, it has several limitations: it only works
with programs written in Java, it doesn't allow all of the optional
features of Daikon to be controlled, and it depends on external
programs that may not be present on non-Unix systems.  It is not
the preferred way to run Daikon, but some users may find it helpful
for quick testing, or for use from automated scripts.

Running @command{daikon.pl} without without any arguments will display usage information:
@example
% daikon.pl
Usage: daikon.pl [OPTIONS] MAIN_CLASS [MAIN_ARGUMENTS]
Options:
  -o, --output FILE   Save invariants in FILE.inv
  ...
@end example

You must supply at least the name of a ``main'' class that provides
the method @code{public static void main(String[] args)}.
@command{daikon.pl} runs this class to exercise your program.

@menu
* daikon.pl arguments::         
@end menu

@node    daikon.pl arguments,  , All-in-one script, All-in-one script
@subsubsection Command line options for daikon.pl

@table @option
@item -i @var{file}
@itemx --instrument @var{file}
Only instrument @var{file}@.  Can be specified multiple times.
Otherwise, all files that are used by the main file are instrumented.

@item -o @var{file}
@itemx --output @var{file}
Save invariants in @file{@var{file}.inv} and source in
@file{@var{file}.src.tar.gz}.  If no name 
is given, a name is automatically generated and used.

@item -t
@itemx --textfile
Save a textual listing of invariants to a @file{.txt} file.

@item -n
@itemx --nogui
Create the invariants file (and @file{.txt} file,
if @option{-t} is given), but do not start the Tree GUI@.

@item --daikonarg @var{arg}
Supply additional argument to Daikon proper.
Can be specified multiple times, in order to supply multiple arguments to
Daikon.
Warning:  be careful with quoting, as the argument is supplied directly
to the shell and may be viewed as multiple arguments or reinterpreted
(which may or may not be what you want).

@item -v
@itemx --verbose
Display progress messages while running.

@item -c
@itemx --cleanup
Remove files left over from an interrupted session before starting.
Should be used only when @command{daikon.pl} detects left-over files and instructs
you to use this option.

@item --nocleanup
Do not remove temporary files when exiting.
This option is intended for debugging.

@item -s
@itemx --src
Make an archive of the source code for later reference.  All the code
that is instrumented will be recorded in the compressed tarfile
@file{@var{file}.src.tar.gz}, where @var{file} is the name that was
supplied via the @option{-o} or @option{--output} arguments.

@item -d
@itemx --debug
Print extra debugging information.
@end table


@node    dfec, Other front ends, dfej, Front ends
@section Source-based C front end dfec

@cindex dfec (Daikon front end for C)
@cindex front end for C
@cindex C front end

This section describes dfec, the Daikon source-based front end for C@.
For information about installing dfec, see @ref{Installing dfec}.

There are two ways to instrument C programs.  Compiled programs
originally written in C can be instrumented on the fly using the
Kvasir tool, or C programs in source code form can be instrumented
with the dfec tool.  We recommend use of Kvasir instead of dfec.
Kvasir can only be used on Linux/x86, but it is
usually easier to use and more reliable.


Dynamic invariant detection over a C program using dfec requires
three steps:
@enumerate
@item
Run dfec, creating an instrumented version of the program and a
declaration file.
@item
Run the instrumented program, creating data trace files.
@item
Run Daikon on the declaration files and data trace files.
@end enumerate

This section discusses the steps in more detail, with an emphasis on the
first step.  If you have trouble, see @ref{dfec requirements}.

@c The three crucial files are @command{dfec}, 
@c @file{daikon_runtime.h}, and 
@c @file{daikon_runtime.o}.

Instrumentation with dfec performs two actions:
@itemize @bullet
@item
Instrumentation adds instructions to the target program so that, in
addition to performing its original task, it also writes variable values
to a data trace file.  The changes are made to a copy of the target
program; your original version is not modified.
@item
Instrumentation creates declaration files that describe the format of
the data trace files.  For instance, these declaration files describe
the names of procedures and variables that appear in the data trace file.
@end itemize

To instrument a C file, run dfec on it.  dfec produces
instrumented source as well as a @file{.decls} file.  dfec
must be run on all source files, including any header files that
contain code or definitions to be instrumented (header files typically
end in @file{.h}).  All files to be included in a single executable
must be instrumented simultaneously; for example,
@example
dfec file1.c file2.c file1.h file2.h
@end example

Even if you do not wish to detect invariants in one of the files, it
must be run through dfec so it can correctly interact with the
instrumented versions of the other files.  @xref{dfec command-line
arguments}, for instructions on how to exclude files from
instrumentation.

Running @command{dfec @var{arguments} myprog.c} creates
a file named @file{myprog.cc} in the @file{daikon-instrumented/}
directory.  (The instrumented file has a @file{.cc} extension, regardless of 
the extension of the original file.)  
It also creates a file named @file{myprog.decls}, which
is placed in the @file{daikon-output/} directory by default.  To change
these defaults, see @ref{dfec command-line arguments}.


@c Before compiling the instrumented program, either copy or link
@c @file{daikon_runtime.h} and @file{daikon_runtime.o} from
@c @file{daikon/front-end/c/} to the current directory.  (See
@c @ref{Installing dfec}, for details on creating @file{daikon_runtime.o}.)
@c @example
@c   cp -p $DFECDIR/daikon_runtime.h $DFECDIR/daikon_runtime.o .
@c @end example

Compile the instrumented program in the usual way, except that the link
step should include @file{daikon_runtime.o}, and the compiler should be
G++, since the instrumented files are C++ files.
For instance,
@example
gcc -g -o @var{exefile} myprog.c
@end example
@noindent
would become
@example
g++ -g -o @var{exefile} daikon-instrumented/myprog.cc\
     $DFECDIR/daikon_runtime.o
@end example

@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
@c dfec option -- do not rename (yet)
Now you can run your executable in the usual way.  Running the
executable creates a @file{myprog.dtrace} file.  By default, this file
is placed in @file{daikon-output/}, and subsequent runs overwrite that
file.  This default can be overridden via the @option{--tracefilename}
argument to dfec or the @env{DTRACEFILE} environment variable at runtime.

Given the @file{myprog.decls} file that dfec created and the
@file{myprog.dtrace} file that running the instrumented program created,
you can run Daikon:
@example
java daikon.Daikon daikon-output/myprog.decls \
     daikon-output/myprog.dtrace
@end example

@menu
* Instrumenting C programs with dfec::  
* dfec examples::               
* dfec command-line arguments::  
* dfec runtime customization::  
* Instrumentation scope::       
* dfec requirements::           
* Installing dfec::             
@end menu


@node    Instrumenting C programs with dfec, dfec examples, dfec, dfec
@subsection Instrumenting C programs with dfec

To instrument C source, invoke @command{dfec} on all the source and
header files at once:
@example
dfec @var{...options...} @var{myprog}.c
@end example
@strong{Important:}  dfec may only be run on programs written in 
ANSI/ISO C, not on K&R C
or other dialects (@pxref{C program requirements})

You may want to specify one or more command-line options;
see @ref{dfec command-line arguments}.

After dfec is run, you must compile the instrumented source, linking
it with the object file for the Daikon runtime library and the stdc++
library.  By default, dfec places instrumented source in the
@file{daikon-instrumented/} directory.
@example
g++ -g -o @var{myprog} daikon-instrumented/@var{myprog}.cc \
    $DFECDIR/daikon_runtime.o
@end example
@noindent
In addition, you may want to specify the @option{-w} flag to G++, to
suppress warnings.  dfec's output is valid C++ but may cause G++ to
issue warnings.

The Daikon front end for C has three effects:
@itemize @bullet
@item
dfec writes instrumented versions of the files to a
@file{daikon-instrumented/} directory 
@item
dfec creates declaration files named
@file{@var{myprog}.decls}, etc.@: in a
@file{daikon-output/} directory.
@item
optionally, dfec may create a pointer
type disambiguation file named
@file{@var{myprog}.disambig} in the
same directory as the @file{@var{myprog}.decls}
file.
@end itemize

For more information about dfec, including more detailed documentation
on its command-line options, see @ref{dfec}.


@node    dfec examples, dfec command-line arguments, Instrumenting C programs with dfec, dfec
@subsection dfec examples

To detect invariants for a program with dfec, you need to perform three basic
tasks: instrument the target program (steps 1-3), run the instrumented
program to create a data trace file (step 4), and run Daikon over the
data trace file to produce invariants (steps 5-6).  The following
instructions are for the print_tokens example.  The other examples can
be run in exactly the same manner.

@enumerate
@item Change to the directory containing the print_tokens program.
@example
cd $DAIKONDIR/examples/dfec-examples/print_tokens
@end example

@item Instrument the program using dfec, the C front end.
Run the front end over all the C source files and
the user-created header files they depend on.
@example
dfec print_tokens.c stream.h tokens.h
@end example
@noindent
This command creates two directories, @file{daikon-instrumented}
and @file{daikon-output}.  It creates an instrumented and preprocessed
version of @file{print_tokens.c} at
@file{daikon-instrumented/print_tokens.cc}.  It 
creates a declaration file at @file{daikon-output/print_tokens.decls}.

@quotation
Note for Windows users:
Under Windows, you must insert in the source file a gcc-specific
@samp{__attribute__} for the @samp{_ctype_} variable, which is used in
our test suite.  Run the following commands:
@example
alias fix="sed -f $DFECDIR/fix.sed"
(cd daikon-instrumented; \
  fix print_tokens.cc > fixed.cc;
  mv fixed.cc print_tokens.cc)
@end example
@end quotation

@item Compile and link the instrumented program to create the
executable @file{print_tokens} in the current directory.

@example
g++ -g -w -o print_tokens.exe \
    daikon-instrumented/print_tokens.cc \
    $DFECDIR/daikon_runtime.o
@end example

@item Run the print_tokens test suite.  First set the @env{DTRACEAPPEND}
environment variable, so that a final @file{.dtrace} file contains
information from all runs, rather than each run overwriting the file
so that it contains only information from the last run.  (For more
details about the @env{DTRACEAPPEND} environment variable, see @ref{dfej
options} and @ref{dfec command-line arguments}.)

If you use the bash shell, run the following commands:
@example
export DTRACEAPPEND=1
sh tests.sh
@end example

If you use the csh or tcsh shell, run the following commands:
@example
setenv DTRACEAPPEND 1
sh tests.sh
@end example

These commands create a data trace file at
@file{daikon-output/print_tokens.dtrace}.

@item Run Daikon on the trace file.
@example
java -Xmx256m daikon.Daikon \
     daikon-output/print_tokens.decls \
     daikon-output/print_tokens.dtrace
@end example
@noindent
The invariants are printed to standard output, and a binary representation
of the invariants is written to @file{print_tokens.inv.gz}.

@item Examine the invariants.  You can do this in one of the following
ways:
@itemize 
@item Examine the output from running Daikon.
@item Use the PrintInvariants program (@pxref{Printing invariants}) 
to display the invariants.
@c @item Use the Daikon Tree GUI to browse the invariants.
@item Use the Daikon Context GUI to browse the invariants.
@end itemize
@noindent
For help understanding the invariants, see @ref{Daikon output}.

@end enumerate

@menu
* Dfec C examples summary::     
@end menu

@node    Dfec C examples summary,  , dfec examples, dfec examples
@subsubsection Dfec C examples summary

The above steps can be divided into three stages:

Instrumentation (Steps 1-3)
@example
cd $DAIKONDIR/examples/dfec-examples/print_tokens
dfec print_tokens.c stream.h tokens.h
g++ -g -w -o print_tokens daikon-instrumented/print_tokens.cc \
    $DFECDIR/daikon_runtime.o
@end example

Trace File Generation (Step 4)
@example
export DTRACEAPPEND=1
sh tests.sh
@end example

Invariant Detection (Step 5)
@example
java -Xmx256m daikon.Daikon \
     daikon-output/print_tokens.decls \
     daikon-output/print_tokens.dtrace
@end example



@node    dfec command-line arguments, dfec runtime customization, dfec examples, dfec
@subsection dfec command-line arguments

@c dfec option -- do not rename (yet)
This section describes dfec's command-line options.
When conflicting options are specified (for instance, both
@option{--declsfiledir} and @option{--declsfiledirflat}), the last one
takes precedence.

@table @option

@item -I@var{path}
Adds @var{path} to the end of the system include path.  The system
include path that @command{gcc} uses is automatically detected by dfec,
so you should not have to use the @option{-I} option unless you wish to
use additional include
paths or @command{gcc} defaults to using header files
that cannot be processed by @command{dfec}.
For example,
@example
dfec -I/usr/local/.../2.95.3/include myprog.c
@end example
@c  @noindent
@c  To determine your system include path, run
@c  @example
@c  touch searchpath.cc; gcc -v -E searchpath.cc > /dev/null; rm searchpath.cc
@c  @end example
@c  @noindent
@c  and look for what follows "@samp{#include <...> search starts here:}".


@c [this is deprecated - we want the c++ searchpath only.]
@c For instance, on
@c Unix run one of these commands, depending on whether you want the C or
@c C++ search path:
@c @example
@c touch searchpath.c; gcc -v -E searchpath.c > /dev/null; rm searchpath.c
@c touch searchpath.cc; gcc -v -E searchpath.cc > /dev/null; rm searchpath.cc
@c @end example


@item -D@var{macro}=@var{value}
Defines the preprocessor macro @var{macro} to be @var{value}.
@c    For example,
@c  to get dfec to correctly traverse the include files on our system, we use
@c  @example
@c    dfec @var{...includepath...} -D__GNUG__=1 -D__null=0
@c  @end example


@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
@cindex DTRACEAPPEND environment variable
@cindex environment variable DTRACEAPPEND
@cindex trace file name
@cindex dtrace file name
@cindex file name, for dtrace file
@c dfec option -- do not rename (yet)
@item --tracefilename=@var{filename}
Specifies the default name for the trace output (@file{.dtrace}) file (default
@file{daikon-output/@var{myprog}.dtrace}, where @file{@var{myprog}.c} is
the instrumented program file that contains the main() procedure).
A relative filename is interpreted with respect
to the current directory at runtime, not at compile time.
If the @env{DTRACEFILE} environment
variable is set (to a file name) when the instrumented program is run,
it overrides the default specified by this flag.  Furthermore, if the
@env{DTRACEAPPEND} environment
variable is set to any value at runtime, the dtrace file is appended to
instead of overwritten, which can be handy if you wish to run
the instrumented program multiple times.

@c dfec option -- do not rename (yet)
@item --declsfiledir=@var{decldir}
Specifies the directory in which to create
@file{@var{PATH}/@var{myprog}.decls} (default
@c dfec option -- do not rename (yet)
@file{daikon-output/}, unless @option{--declsfiledirflat} is
specified).  @var{PATH} is the relative path from the current
directory to the source file; that is, the relative path from
@var{decldir} to the @file{.decls} file is the same as the relative
path from the current directory to the source file.  The directory
structure of the @file{.decls} files mirrors the directory structure of
the source files.

@c dfec option -- do not rename (yet)
@item --declsfiledirflat=@var{decldir}
Specifies the directory in which to create @file{@var{myprog}.decls}
(no default).  All @file{.decls} files appear in the same directory.

@c dfec option -- do not rename (yet)
@item --instrsourcedir=@var{instrdir}
Specifies the directory in which to write instrumented source files
(default @file{daikon-instrumented/}).  The instrumented files have the
same names and directory structure as the original input @file{.c} files, with the
slight exception that the file suffix is always set to @file{.cc}, so if you
instrument @file{@var{myprog}.c}, you will end up with
@file{daikon-instrumented/@var{myprog}.cc}.  
Header files (files with a @file{.h} extension) are textually 
substituted into the instrumented @file{.cc} files, so they do not appear 
in the instrumented source directory.  If @var{instrdir} is @file{.},
then instrumentation is performed in place, first copying the source
file @file{myprog.c} to @file{myprog.c.uninst}, then overwriting
@file{myprog.c} with instrumented source.  If @file{myprog.c.uninst}
already exists, it is left in place:  the copy step is not performed.
This is useful in situations with Makefiles that you don't want to
change, or when compiling a system requires many files to be in place.


@item --disambigfilename=@var{filename}
Specifies the filename for the pointer type disambiguation file
(@pxref{Pointer type disambiguation}), which must be given relative to
the @file{daikon-output} directory.  If this file exists, dfec uses it
to make decisions about how to output the referents of pointer
variables.  If the file does not exist, dfec creates it,
specifying default instrumentation behavior for all
pointer types.  It may then be edited and used on subsequent runs. 
Note: The dfec version of pointer type disambiguation differs slightly 
in both syntax and functionality from the Kvasir version.

@item --disambig
Tells dfec to create or read pointer type disambiguation with the
default filename, which is @file{@var{myprog}.disambig} in the same
directory as the @file{.decls} file.  For more information, see
@ref{Pointer type disambiguation}.

@item --flatten-mdas
Ensures that each multi-dimensional array in the instrumented program will be
allocated as a single contiguous block of memory.  A multi-dimensional array
is a variable declared with multiple sets of square brackets after it, e.g.:
@example
int foo[5][10];
@end example
@noindent
This is necessary if the program under analysis performs operations that
assume that its sub-arrays appear in contiguous blocks of memory (that
is, that @code{foo[3][0]} appears immediately after  @code{foo[2][9]});
examples of such operations are clearing the entire array with
@code{memset()}, manually calculating addresses of elements
in the array using memory offsets from the first element, etc.
Use of the @option{--flatten-mdas} removes padding at the beginnings
and ends of subarrays and diminishes the ability of the runtime
library to report array overflow errors, so this option should only be
specified if necessary.

@item --help
Displays a usage message.

@item -l
Indicates that the next file (only) should not produce @file{.dtrace}
file output (@pxref{Instrumentation scope}).
For instance, if you have two source files, @file{file1.c} and @file{file2.c},
and each has its own header file, but you don't want to instrument the
procedures defined in @file{file2.c}, you would instrument as follows:
@example
dfec file1.c -l file2.c file1.h file2.h
@end example
@noindent
This is the only command-line switch that can be used in the midst of the
list of filenames; it may be specified multiple times.

@item --no-lackwit
@cindex LACKWIT_HOME environment variable
@cindex --no-lackwit flag to dfec
@cindex Lackwit, runs slowly
Turns off Lackwit postprocessing of the @file{.decls} file.  
Lackwit is a variable comparability analysis package; it can make
invariant detection in Daikon more accurate and efficient.  However,
Lackwit processing itself can be very slow, especially on large programs.
You can also turn off Lackwit postprocessing by unsetting the 
@env{LACKWIT_HOME} environment variable.  

@item --struct-depth=@var{N}
For nested or recursive types (structs or classes that have members that
are also structs or classes), this argument specifies how deep to instrument.
For example, suppose you have a simple linked list structure as follows:
@example
struct node @{
  struct node *next;
  int val;
@} list;
@end example
@noindent
Setting the struct instrumentation depth to 1 would cause the runtime
library to output @code{node.val} and @code{node.next}.  Setting the
struct instrumentation depth to 2 would cause the runtime library to
output @code{node.val}, @code{node.next}, @w{@code{node.next->val}}, and
@w{@code{node.next->next}}.  The default instrumentation depth is 3, which
allows Daikon to capture invariants about nonadjacent nodes, but results
in larger dtrace files than smaller values do.

@item --pcc-array-addresses
In ANSI/ISO C, the address operator applied to an ``array of T''
yields a ``pointer to array of T,'' whereas some compilers (such as
pcc) treat @samp{&a} the same as @samp{a} --- that is, as a pointer to
the first element of @samp{a}.  If you have code that uses the latter
interpretation, your best bet is to rewrite @samp{&a} as the simpler,
clearer, and correct @samp{a}.  Failing that, you can supply the
@option{--pcc-array-addresses} option to dfec to make it treat all
address-of-array operations in the older, pcc-style manner.

@end table


@node    dfec runtime customization, Instrumentation scope, dfec command-line arguments, dfec
@subsection dfec runtime customization

@cindex dfec customizations
@cindex Daikon C runtime customizations
@cindex daikon_runtime.h file
Many customization options for the dfec front end appear in the
file @file{$DAIKONDIR/front-end/c/daikon_runtime.h}.
Each option in the file has a comment explaining its function and how
to enable it.
Some examples of the options are:

@itemize @bullet
@item
The instrumented program can have the capability to produce gzipped
(compressed) @file{.dtrace} files.  (This option requires zlib to be
available on your system.)
@item
You can allocate extra space at the ends of arrays, so that your
program can continue despite (some) memory errors.  You can customize
what error code is returned if your program contains a memory error
and is terminated by the dfec runtime.  You can (dangerously) tell
the dfec runtime not to check for specific memory errors.
@item
You can turn specific dfec warnings on and off.
@end itemize


@node    Instrumentation scope, dfec requirements, dfec runtime customization, dfec
@subsection Instrumentation scope

@cindex instrumentation scope
@cindex scope of instrumentation
@cindex uninstrumented libraries
@cindex libraries, uninstrumented

When you run a C program that has been instrumented with dfec to 
produce a @file{.dtrace}
file, the executable may contain three varieties of code:  fully
instrumented code that produces @file{.dtrace} file output (and also
tracks memory), partially instrumented code that only tracks memory,
and entirely uninstrumented code.  The default level of
instrumentation is full instrumentation.  The @option{-l} command-line
argument to dfec (@pxref{dfec command-line arguments})
specifies partial instrumentation for a
file.  Uninstrumented code is only included by being linked from a
library that was not processed with dfec --- for instance, system
libraries.  You should not intentionally leave part of your program
entirely uninstrumented, because dfec's memory tracking is important
both for improved output and for correctness.
If you must link your program against uninstrumented libraries, you need
to make some small changes to your program.

@enumerate
@item
If there are calls from instrumented code to uninstrumented code, then
memory tracking will not occur in the uninstrumented code.  To correct
this problem, see @ref{Memory tracking in libraries}.

@item
If there are calls from uninstrumented code to instrumented code, your
program will not link, because the instrumented code is C++ and the
uninstrumented code is C@.  If certain procedures are called from
uninstrumented code (an example is @code{usage} in @file{wc.c}), then
you can place
@example
#ifdef DAIKON_RUNTIME_H
extern "C"
#endif
@end example
@noindent
in front of the procedure definition (and declaration).
This will not affect calls from within the file, nor will it affect
compilation of the program, but it will enable dfec to process it.
@end enumerate


@menu
* Memory tracking details::     
* Memory tracking in libraries::  
@end menu

@node    Memory tracking details, Memory tracking in libraries, Instrumentation scope, Instrumentation scope
@subsubsection Memory tracking details

Here are some details about dfec's operation, to help you understand
linker errors or other problems.

Instrumented
programs perform memory tracking, which checks and records the
program's memory accesses.  This has many benefits.  It tracks whether
pointers are valid, so dfec's runtime does not attempt to dereference
uninitialized or deallocated pointers.  It tracks how many elements of
memory have been initialized, so the runtime does not output garbage
values.  It catches memory errors in user programs.  It protects
dfec's runtime data structures from program memory errors that would
otherwise corrupt them (and which would then appear to the user as
dfec errors).

Memory tracking is implemented by converting all pointers and arrays
in the program to ``smart pointers'' and ``smart arrays'', implemented
as the classes DaikonSmartPointer and DaikonSmartArray.
Additionally, dfec outputs C++, whereas the original user program is
written in C@.

@node    Memory tracking in libraries,  , Memory tracking details, Instrumentation scope
@subsubsection Memory tracking in libraries

The C front end keeps track of the maximum read or written element
of each array.  This enables it to avoid outputting (meaningless)
uninitialized elements.  For example, consider the following code:
@example
char * mystring = malloc(100);
strcpy(mystring, "hello");
@end example
@noindent
Even though @code{mystring} has 100 elements, only the first six of them are
valid.  dfec will only communicate those first six elements to
Daikon.  After a subsequent operation:
@example
strcat(mystring, ", world");
@end example
@noindent
dfec would communicate 13 elements to Daikon.

dfec tracks all array accesses in the instrumented program, and dfec
also contains special-case handling for certain library routines,
including all the stdc library functions found in @file{string.h}.
However, array accesses in files not supplied to dfec (for instance,
in other library functions) might not be recorded, causing too little
of the array to be output to Daikon.

The rest of this section describes how to add 
other functions to dfec's list of special-case functions.
Suppose system header file @file{<bar.h>} contains a function with signature
@example
int foo(char *arg1, char *arg2)
@end example
@noindent
Then you would need to do these things:

@enumerate
@item
Add a @code{#include} directive for @file{<bar.h>} to @file{daikon_runtime.cc},
in the section with the other overloaded functions.
That section starts with this text:
@example
/* functions to overload with DAIKON_* implementations: */
#include <string.h>
@end example

@item
Add an instrumented implementation to @file{daikon_runtime.cc}.  This requires
knowledge of how smartpointers and the basemap work.  Typically, the
instrumented implementation calls the normal library function, then
manually adjusts the max_seen pointers in the basemap to their correct values,
based on semantic knowledge about the function itself.  For examples, see
the implementations provided for @file{string.h}.
The signature of the function must be changed in two ways:  the name should
have @code{DAIKON_} 
prepended to it, to avoid namespace pollution (the calls are
resolved through a macro definition explained below), and the argument and
return value types must be changed as well to reflect the use of
smartpointers.  In this example, @code{foo()} as above would be declared as
@example
int DAIKON_foo(DaikonSmartPointer<char> arg1,
               DaikonSmartPointer<char> arg2);
@end example

@item
Add a macro definition and a function declaration to @file{daikon_runtime.h}.
There is a large section of these near the end of the file.  In the case of
@code{foo()} above, we would need to insert:
@example
extern int DAIKON_foo(DaikonSmartPointer<char> arg1,
                      DaikonSmartPointer<char> arg2);
#define foo DAIKON_foo
@end example
@noindent
You can find the section to add this in by searching for
@example
/* add other user-overloaded functions here */
@end example
@noindent
Be sure to place the declaration and macro definition before the @code{#endif}
signifying the end of the @code{!COMPILING_DAIKON_RUNTIME} block.  If you put the
macro definition outside this block, then the runtime library will fail to
compile.

@end enumerate


@node    dfec requirements, Installing dfec, Instrumentation scope, dfec
@subsection dfec requirements

If you have trouble with dfec, you should first ensure that
the input to dfec (the program being instrumented) is
proper, according to the requirements set out in this section.
dfec sometimes issues obscure error messages when provided
invalid input.
For additional help troubleshooting dfec, see @ref{dfec problems}.

@menu
* C program requirements::      
* Header file dependencies::    
* gcc version::                 
@end menu

@node    C program requirements, Header file dependencies, dfec requirements, dfec requirements
@subsubsection C program requirements

dfec only instruments ANSI/ISO C programs.  (More
specifically, dfec only instruments programs that are both
legal C and legal C++.  This is essentially the same as C, but
avoiding C++ keywords.)  dfec does not support K&R C or
other non-ANSI/ISO C dialects.  Before running dfec, you
should ensure that your code is legal ANSI/ISO C (and legal ANSI/ISO
C++) and that it compiles cleanly.

@cindex ANSI C
@cindex ISO C
@cindex C89 standard
@cindex C99 standard
@cindex K&R C

Running your code through a C compiler is necessary, but not
sufficient, to verify that your program is valid C; GCC and
other compilers accept a number of erroneous or nonstandard 
C constructs for which dfec issues warnings.  You should remove all
warnings produced by @command{gcc -g -Wall -ansi -pedantic}.  (Lack of
errors from that command does not guarantee your code is ANSI/ISO C,
or that your code is acceptable to dfec.  However, errors from that
command do indicate that your code is not ANSI/ISO C@.)  Likewise,
your code should compile
@c and link??
using @command{g++} (instead of @command{gcc}) as the compiler.

Here are some steps you may find necessary in converting code from C
to the intersection of ANSI/ISO C and ANSI/ISO C++.

@table @asis

@item prototypes
@cindex C prototypes
@cindex prototypes, C
@cindex protoize tool
@cindex function declarations, C
@cindex procedure declarations, C
@cindex declaration formats, of C functions
You must convert any K&R function prototypes to ANSI/ISO form.  In K&R
function declarations, parameters may be omitted entirely, and in K&R
function definitions, variable types may appear as variable
declarations between the ``)'' that ends the signature and the ``@{''
that starts the body.  In ANSI/ISO C, variable types always appear in
the function signature.  Furthermore, signatures must match
@b{exactly} between declarations and definitions.
(C library functions needn't be declared at all, since they should
appear in header files; a fallback would be to make the declarations
@samp{extern "C"}.)

@c Stephen McCamant says:
@c When debugging linking problems, I usually find it helpful to compile
@c everything to .o files.  This will let the linker give you a sensible
@c file name to tell where the unsatisfied usages are, and let you see
@c for yourself which symbols are needed or provided, using nm.

The best way to convert prototypes is to use the @command{protoize}
program.  Even if you believe your code to be ANSI/ISO C, you should
check that @command{protoize} has no effect.  Protoize is distributed
with gcc, among other places; you can find documentation at
@uref{http://gcc.gnu.org/onlinedocs/gcc/Running-Protoize.html}.

After running @command{protoize}, you may need to perform additional
fixups by hand.  A common problem is function declarations of the form
@code{f()} that specify no parameters.  In K&R C, the corresponding
definition was allowed to have any number of arguments, but such
declarations are obsolescent under the ANSI/ISO C standard, and in C++
they always denote a function that takes no arguments.  To specify a
prototype in ANSI/ISO C for a function that takes no arguments, write
@code{f(void)}.

@item type checking, casts, and const
C++ is stricter about type checking than C is.  Some C compilers permit
function prototypes to differ slightly from function definitions.
Whereas C silently inserts conversions,
C++ requires types to match or explicit casts to be inserted.
Therefore, your program may need to have variable types refined or
changed.

Furthermore, certain functions have different types in the C and C++
standard libraries.  In particular, more functions have parameters
annotated as @code{const} in the C++ library, and in more modern C
libraries, than in older C libraries. 
In order to satisfy the type checker, you may need to change the types
of variables, for instance by adding @code{const} the types of variables
that are assigned string literals, or assigned the results of functions
that return @code{const} pointers.
Alternatively, you can add casts every time a value of type @code{char *}
(for instance) must be converted to a value of type @code{const char *}.
Adding such casts is only safe if your program never actually modifies
the value pointed to.
In some cases, changing the declaration of a variable may be easier,
since only the declaration, and not each use, must be changed.
In others, adding casts will require fewer changes, because when
variable becomes const, other variables that receive its value may
also need to be declared const, causing a cascade of required
changes.

@item reserved words
@cindex string, use in C programs

C++ reserves the following keywords that are not reserved words in C:
@example
asm catch class const_cast delete dynamic_cast explicit
export friend inline mutable namespace new operator
private protected public reinterpret_cast static_cast
template this throw try typeid typename using virtual

and and_eq bitand bitor bool compl false not not_eq
or or_eq true wchar_t xor xor_eq
@end example
@noindent
(Those in the second group are defined as macros in the 1999 ISO C
standard).
Additionally, the C++ standard libraries define certain other
identifiers, such as @code{string}.
Any use of these words as identifiers must be changed.

@item daikon_runtime.h file
The easiest solution is to rewrite the program so that it uses a
different name for that typedef, say @samp{STRING} instead of
@samp{string}.  Another workaround for @samp{string} is to change
@file{daikon_runtime.h} so that it never mentions an identifier
@samp{string}.  See the file for a commented-out (unportable,
inelegant) way to do this.


@item nested enums
@cindex template-argument uses local type error
In C, enums that appear inside structs have global scope and can be
accessed anywhere in the program.  When converting to C++, you will
have to raise the enum to top level or else use a qualified name,
which may not work with your C compiler.
The error message @samp{template-argument `...' 
uses local type `...'} may indicate this problem.

@end table


dfec does not accept every legal program in the intersection
of ANSI/ISO C and ANSI/ISO C++.  Here are the exceptions.
@enumerate

@item 
dfec does not output the contents of C unions.

@item
If G++ gives an error message while compiling the instrumented code,
then first try compiling the uninstrumented code with G++,
and remove any errors that G++ issues.  For instance, C++ requires
declaration of prototypes, whereas C can sometimes guess the types for
missing prototypes.

@item 
Instrumented programs must not redeclare functions defined in system
headers; for instance, do not do the following:
@example
#include <stdlib.h>
...
char *getenv(const char *name);
@end example

The reason is that dfec expects every C file to contain either only
code and declarations that are instrumented (with respect to smart
pointer tracking), or no code that is instrumented (with respect to
smart pointer tracking).  User code is instrumented, but library
functions are not, so you should use the declaration in
@file{stdlib.h} rather than repeating it in your own code.

@item
dfec redefines certain functions defined in system headers.
Your program must not define these as macros or otherwise use them
in a non-standard way.

@item
Instrumented programs must not use nested structures or enums that are
declared inside procedures.
You should raise all nested structures to
the top level (and after raising them, remove any
@code{static} modifier, which is not relevant to top-level definitions).

You should also separate all declarations from uses.  For example, change
@example
enum @{ make, user @} current_access;
@end example
to
@example
enum current_access_type @{ make, user @};
current_access_type current_access;
@end example

@item
dfec does not deal properly with bitfields (declared like
@samp{unsigned int env:1} for a single bit).  Change any bitfield
variables to full-width variables.

@item
@cindex realloc, use in C programs
The @code{realloc} function of standard C, used to change the size of
a memory block allocated with @code{malloc}, is not supported by the dfec
runtime.  Calls to @code{realloc} will instrument and compile without
errors, but if @code{realloc} is called, the runtime will not notice
that the amount of accessible memory has increased after the call, and
so spurious array overflow errors will occur.  If you know the old
size of the allocated region, or if it is null terminated, a call to
@code{realloc} can be replaced by a @code{malloc}, a @code{memcpy} or
@code{strcpy} respectively, and a @code{free}.

@end enumerate


@node    Header file dependencies, gcc version, C program requirements, dfec requirements
@subsubsection Header file dependencies

Some programs contain dependences on header files that make code that
is legal C but not legal C++.  dfec's input must be both legal C and
legal C++ (@pxref{C program requirements}).  This section shows how to
work around such problems by modifying the header files.

For example, the GNU @command{wc} program
(@uref{http://www.gnu.org/software/textutils/}; download from
@uref{ftp://ftp.gnu.org/pub/gnu/textutils/textutils-2.0.tar.gz})
contains the following test on line 179 (in textutils version 2.0):
@example
(current_pos = lseek (fd, (off_t) 0, SEEK_CUR)) != -1
@end example
@noindent
However, Linux's header files define @code{off_t} as @code{__quad_t},
and @file{bits/types.h} in turn defines @code{__quad_t} as
follows:
@example
#ifdef __GNUC__
__extension__ typedef long long int __quad_t;
#else
typedef struct
  @{
    long int __val[2];
  @} __quad_t;
#endif
@end example

dfec uses the non-@code{__GNUC__} branch.  (Many non-standard
extensions are enabled when @code{__GNUC__} is defined, and dfec can
understand many but not all of them.)  In C, it is legal to cast the
number 0 to a struct.  Such a cast is not legal in C++.  Because
dfec's input must be both legal C and legal C++, dfec issues an error
message for line 179 of @file{wc.c}.

To work around the problem, execute the following two lines to create
a local copy of @file{bits/types.h}:
@example
mkdir -p $DFECDIR/bits
cp -p /usr/include/bits/types.h $DFECDIR/bits/types.h
@end example
@noindent
and then edit @file{$DFECDIR/bits/types.h} to remove all but the
second line of the above snippet.  This will define @code{__quad_t} as
@code{long long int} instead of as a struct.  dfec uses files found
under @file{$DFECDIR} in preference to other system headers, so
@file{wc.c} will compile.

You may need to make similar changes to other header files in order to
ensure that your code is both legal C and legal C++, or to work around
other problems.


@node    gcc version,  , Header file dependencies, dfec requirements
@subsubsection gcc version


@cindex gcc version for use with dfec
@cindex gcc 3, does not work with dfec
@cindex gcc 2.96

dfec works with GCC 2.95.3 or 2.95.2, so long as you do not
include both C's @file{math.h} and C++'s @file{complex.h}.
dfec also works with GCC 2.96; this is not an official GCC
release, but it does appear in some Linux distributions, such as Red Hat's.
dfec does not currently work with other
compilers or other versions of GCC.  In particular, GCC 3 does not
work, nor does the pre-release version labeled ``GCC 2.95.4'' that
appears in some Linux distributions (including some versions of
Debian).


@cindex gcc 2.95.3, installing
@cindex installing gcc 2.95.3

You can download GCC 2.95.3, which is the last official release in the
GCC 2.x series, from @uref{http://gcc.gnu.org/releases.html}.

GCC is easy to install; see the @uref{http://gcc.gnu.org/install/, ,
GCC installations instructions}.  If you do not wish to read them,
then the following commands may work for you.  They do not require
that you have superuser privileges on your machine.  They create
directory @file{/tmp/build-gcc-2.95.3}, then build GCC and install
GCC under directory @file{/tmp/build-gcc-2.95.3/gcc-installation}.
You may wish to adjust those directory names.

@example
cd /tmp
mkdir build-gcc-2.95.3
cd build-gcc-2.95.3
wget ftp://prep.ai.mit.edu/pub/gnu/gcc/gcc-2.95.3.tar.gz
gunzip gcc-2.95.3.tar.gz
tar xf gcc-2.95.3.tar
mkdir gcc-2.95.3-build
cd gcc-2.95.3-build
../gcc-2.95.3/configure --prefix=/tmp/build-gcc-2.95.3/gcc-installation
make bootstrap
make install
@end example

To test the installation, do the following:
@example
which gcc
gcc -v
set path = (/tmp/build-gcc-2.95.3/gcc-installation $path)
which gcc
gcc -v
@end example

Now you can just use it; @command{gcc} refers to the new version.  You should
also add the @command{set path} command to your @file{.cshrc} file.  
If you use sh or
bash rather than csh, then add the following to your @file{.bashrc} or
equivalent file.
@example
export PATH=/tmp/build-gcc-2.95.3/gcc-installation:$PATH
@end example

@node    Installing dfec,  , dfec requirements, dfec
@subsection Installing dfec, the source-based Daikon front end for C

@cindex installing dfec
@cindex dfec installation

dfec is distributed separately from Daikon itself.
If you wish to use dfec, first perform the following installation
steps.

@enumerate
@item
Download the dfec distribution from
@uref{http://pag.csail.mit.edu/daikon/download/}; choose the version for
your architecture and operating system.  The distribution includes
both the dfec executable and Lackwit.  Lackwit is a variable
comparability analysis package; its use is optional, but it can make
invariant detection more accurate and efficient.
@item
Unpack the tarfile.
@example
cd $DAIKONDIR/front-end
tar zxvf dfec-linux-x86.tar.gz
@end example
@item
Compile the dfec C runtime library.
@example
cd $DAIKONDIR/front-end/c
make
@end example
@noindent
This creates the file @file{daikon_runtime.o}; you will use it (and
@file{daikon_runtime.h}, which also appears in @file{front-end/c})
when compiling C and C++ programs in which you wish to detect invariants.
@end enumerate

For information about customizing the behavior of your instrumented
programs, @pxref{dfec runtime customization}.

@menu
* dfec EDG sources::            
@end menu

@node    dfec EDG sources,  , Installing dfec, Installing dfec
@subsubsection Installing dfec from EDG sources

@cindex EDG C front end
@cindex Edison Design Group C front end

License restrictions prohibit us from distributing the source for dfec,
except to other parties who hold a license to the EDG (Edison Design
Group) C front end.  If you hold such a license, send mail to
@email{daikon-developers@@lists.csail.mit.edu} to obtain a patch to the
EDG front end.  To build dfec for yourself, perform the following steps:
@enumerate
@item Unpack your EDG source code (which you obtained from EDG).
@example
tar zxf edgcpfe_3.0.tar.gz
@end example
@item cd into the EDG source directory
@example
cd release_3.0
@end example
@item Apply the patch (which you received from the Daikon group) with
@option{-p1}; this adds the dfec source modifications.
@example
patch -p1 < edg-3.0_to_dfec.patch
@end example
@item Compile the software, creating the dfec executable
@file{release_3.0/bin/dfec}.
@example
make
@end example
@end enumerate

(A different patch is available for EDG version 2.45; substitute
@file{2.45} for @file{3.0} in the above instructions.  However, we
recommend the use of EDG version 3.0, because the version of dfec built
using EDG 2.45 contains some known bugs that are corrected in the
version of dfec that is built using EDG 3.0.)

@node    Other front ends,  , dfec, Front ends
@section Other front ends

@cindex front end for IOA
@cindex IOA front end
@cindex front end for Lisp
@cindex Lisp front end

A front end for the IOA programming language is distributed separately
(see @uref{http://theory.csail.mit.edu/tds/ioa.html}).
An earlier version of Daikon included a Lisp front end, but it is no
longer supported.


@node    Tools, Troubleshooting, Front ends, Top
@chapter Tools for use with Daikon

This chapter describes various tools that are included with the Daikon
distribution.
@menu
* Tools for manipulating invariants::  
* DtraceDiff utility::          
@end menu

@node Tools for manipulating invariants, DtraceDiff utility, Tools, Tools
@section Tools for manipulating invariants

@cindex .inv files, tools for manipulating
@cindex inv files, tools for manipulating

This section gives information about tools that manipulate invariants
(in the form of @file{.inv} files).


@menu
* Printing invariants::         
* Invariant Diff::              
* Annotate::                    
* Runtime-check instrumenter::  
* InvariantChecker::            
* LogicalCompare::              
@end menu


@node    Printing invariants, Invariant Diff, Tools for manipulating invariants, Tools for manipulating invariants
@subsection Printing invariants

@cindex printing invariants
@cindex PrintInvariants program

Daikon provides many options for controlling how invariants are printed.
Often, you may want to print the same set of invariants several
different ways.  However, you only want to run Daikon once, since it may
be very time consuming.  The PrintInvariants utility prints a set of
invariants from a @file{.inv} file.

PrintInvariants is invoked as follows:
@example
java daikon.PrintInvariants @i{[@var{flags}]} @var{inv-file}
@end example

PrintInvariants shares many flags with Daikon:

@table @option
@item --help
Print usage message.

@item --format @var{name}
Produce output in the given format.  See @ref{Invariant syntax}.

@item --output_num_samples
Output numbers of values and samples for invariants and program points;
for debugging.

@item --config @var{filename}
Load the configuration settings specified in the given file.
@xref{Configuration options}, for details.

@item --config_option @var{name}=@var{value}
Specify a single configuration setting.
@xref{Configuration options}, for details.

@item --dbg @var{category}
@itemx --debug
Enable debug loggers.

@item --track @var{class}<@var{var1},@var{var2},@var{var3}>@@@var{ppt}
Track information on specified invariant class, variables and program point.

@end table

@node    Invariant Diff, Annotate, Printing invariants, Tools for manipulating invariants
@subsection Invariant Diff

@cindex invariant diff
@cindex diff, over invariants
@cindex comparing invariants

The invariant diff utility is designed to output the differences between
two sets of invariants.  This is useful, for example, if you want to
compare the invariants generated by two versions of the same program.

Invariant diff is invoked as follows:
@example
java daikon.diff.Diff @i{[@var{flags}]...} @var{file1} [@var{file2}] 
@end example

@var{file1} and @var{file2} are files containing serialized invariants 
produced by running Daikon or Diff
with the @option{-o} flag.  If @var{file2} is not specified,
@var{file1} is compared with the empty set of invariants.

This section describes the optional flags.

@table @option
@item --help
Print usage message.

@item -d
Display the tree of differing invariants (default).  Invariants that are
the same in @var{file1} and @var{file2} are not printed.  At least one of the
invariants must be justified.  Does not print ``uninteresting'' invariants
(currently some OneOf and Bound invariants).

@item -u
Include ``uninteresting'' invariants in the tree of differing invariants.

@item -y
@itemx --ignore_unjustified
Include (statistically) unjustified invariants. 

@item -a
Display the tree of all invariants.  Includes invariants that are the
same in file1 and file2, and unjustified invariants.

@item -s
For internal use only.  Display the statistics between two sets of
invariants.  The pairs of invariants are placed in bins according to the
type of the invariant and the type of the difference.

@item -t
For internal use only.  Display the same statistics as @option{-s}, but as a
tab-separated list.

@item -m
Compute (@var{file1} - @var{file2}).  This is all the invariants that appear in
@var{file1} but not @var{file2}.  Unjustified invariants are treated as if they
don't exist.  Output is written as a serialized InvMap to the file
specified with the @option{-o} option.  To view the contents of the serialized
InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -x
Compute (@var{file1} XOR @var{file2}).  
This is all the invariants that appear in
one file but not the other.  Unjustified invariants are treated as if
they don't exist.  Output is written as a serialized InvMap to the file
specified with the @option{-o} option.  To view the contents of the serialized
InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -n
Compute (@var{file1} UNION @var{file2}).  
This is all the invariants that appear in
either file.  If the same invariant appears in both files, the one with
the better justification is chosen.  Output is written as a serialized
InvMap to the file specified with the @option{-o} option.  To view the contents
of the serialized InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -o @var{inv_file}
Used in combination with the @option{-m} or @option{-x} option.  Writes
the output as a serialized InvMap to the specified file.

@item -j
For internal use only.  Treat justification as a continuous value when
gathering statistics.  By default, justification is treated as
a binary value --- an invariant is either justified or it is not.  For
example, assume invariant I1 has a probability of .01, and I2 has a
probability of .5.  By default, this will be a difference of 1,
since I1 is justified but I2 is not.  With this option, this will be a
difference of .49, the difference in the probabilities.  This only
applies when one invariant is justified, and the other is unjustified.

@item -p
Examine all program points.  By default, only procedure entries and
combined procedure exits are examined.  This option also causes
conditional program points to be examined.

@item -e
Print empty program points.  By default, program points are not printed
if they contain no differences.

@item -v
Verbose output.  Invariants are printed using the @code{repr()} method, instead
of the @code{format()} method.

@item -l
For debugging use only.  Prints logging information describing the state
of the program as it runs.

@item --invSortComparator1 @var{classname}
@itemx --invSortComparator2 @var{classname}
@itemx --invPairComparator @var{classname}
Use the specified class as a custom comparator.  A custom comparator can
be used for any of 3 operations: sorting the first set of invariants,
sorting the second set of invariants, and combining the two sets into
the pair tree.  The specified class must implement the Comparator
interface, and accept objects of type Invariant.

@end table

@c @node    GUIs, Front ends, Daikon output, Top
@c @chapter GUIs for displaying invariants
@c 
@c By default, Daikon outputs a textual list of invariants; this list may
@c be very long.  Daikon's graphical user interfaces (GUIs) are designed to
@c make the task of browsing invariants easier.  However, we recommend
@c viewing the textual output or using one of the other Daikon tools
@c (@pxref{Tools}) rather than using one of the GUIs.
@c @c There are two GUIs to choose from.  The Tree GUI that lets users browse
@c @c the hierarchy of invariants directly.
@c The Context GUI lets users browse
@c the code in a text editor; the Context GUI concurrently displays the
@c invariants for the browsed code.
@c 
@c The Eclipse plug-in is not a GUI per se; rather, it helps to automate
@c various Daikon-related tasks such as instrumenting programs, running
@c them, and inserting invariants into source code as comments.
@c 
@c 
@c @menu
@c * Eclipse plug-in::             
@c * Context GUI::                 
@c @end menu


@c @node    Tree GUI, Context GUI, Eclipse plug-in, GUIs
@c @section Tree-structured invariant browser
@c @cindex Tree GUI
@c @cindex GUI, tree
@c 
@c The Tree GUI contains a tree that
@c hierarchically organizes program points according to their class and
@c method.  Using the Tree GUI, you can look at invariants for only the methods
@c and program points you care about.  You can also sort invariants by a
@c property (e.g., probability) or filter invariants (e.g., only look at
@c invariants containing a certain variable).
@c 
@c This invariant browser consists of two windows.  The main window is the
@c Invariants Display, which gives a tree-structured view of program
@c points; you can navigate through the program points and view invariants.
@c The other window is the Filter Control Panel, where you can control
@c which invariants from each program point are displayed in the Invariants
@c Display.
@c 
@c @menu
@c * Invoking Tree GUI::           
@c * Invariants Display::          
@c * Control panel::               
@c @end menu
@c 
@c @node    Invoking Tree GUI, Invariants Display, Tree GUI, Tree GUI
@c @subsection Starting the invariant browser
@c 
@c To use the Tree GUI, first make a @file{.inv} file by invoking Daikon with
@c the @option{-o} option; for instance, to create @file{foo.inv}, run
@c @example
@c java daikon.Daikon -o foo.inv @var{decl-files...} @var{trace-files...}
@c @end example
@c 
@c Then, run the Tree GUI with the @file{.inv} file as an argument:
@c @example
@c java daikon.gui.treeGUI.InvariantsGUI foo.inv
@c @end example
@c 
@c If you run the Tree GUI with no arguments, it presents a file browser that
@c asks you to choose a @file{.inv} file for viewing.
@c 
@c 
@c @node    Invariants Display, Control panel, Invoking Tree GUI, Tree GUI
@c @subsection Invariants Display
@c 
@c @ifnotinfo
@c @image{images/gui-InvariantsDisplay-small,3in,}
@c @end ifnotinfo
@c 
@c @table @strong
@c @item File menu
@c 
@c The @command{Load file} menu option brings up a file browser that you
@c can use to select another @file{.inv} file.  The @command{Quit} menu
@c options lets you quit the Tree GUI@.
@c 
@c @item Program point tree
@c The top part of the Invariants Display consists of the Program point
@c tree --- a hierarchy of program points broken down by class and method.
@c Click on various program points in the tree to see tables of invariants
@c for those program points.  You may use the @key{Ctrl} and @key{Shift}
@c keys to make an arbitrary selection of program points.  Selecting a
@c class or method automatically selects all the program points
@c associated with that method or class.
@c 
@c @item Invariant tables
@c Invariant tables that display the actual invariants appear at the bottom
@c of the Invariants Display.
@c 
@c @itemize @bullet
@c @item
@c Use @key{Alt} along with the @key{up} or @key{down} arrow keys to scroll
@c by a table at a time.
@c @item
@c Sort a column in a table by clicking on the column header.  Shift-click
@c to sort the column in reverse order.
@c @end itemize
@c 
@c @end table
@c 
@c @node    Control panel,  , Invariants Display, Tree GUI
@c @subsection Control panel
@c 
@c The Control Panel determines which invariants are displayed.
@c @c As of 2/2002
@c (This picture of the Control Panel is slightly out of date; it needs to
@c be updated.)
@c 
@c @c Force a paragraph break so the image is on its own line.
@c @*
@c 
@c @ifnotinfo
@c @image{images/gui-ControlPanel,3in,}
@c @end ifnotinfo
@c 
@c 
@c @menu
@c * Property filters::            
@c * Variable filters::            
@c @end menu
@c 
@c @node    Property filters, Variable filters, Control panel, Control panel
@c @subsubsection Property filters
@c @cindex property filters
@c 
@c Property filters narrow down the list of invariants that are displayed.
@c You can adjust which Property filters are being applied.  By default,
@c all Property filters are enabled.
@c 
@c For information about property filters, see @ref{Invariant filters}.
@c 
@c @node    Variable filters,  , Property filters, Control panel
@c @subsubsection Variable filters
@c @cindex variable filters
@c 
@c Variable filters let you display only the invariants that contain
@c certain variables.  The left-hand box displays the variables that you
@c are interested in.  By default, the box is empty and invariants containing
@c any variables are displayed.  There are two ways to add variables to the
@c variables list:
@c @enumerate
@c @item 
@c Type the name of the variable into the @command{Add variable}
@c text field, and click the @command{Add variable} button (or just press
@c @key{enter}).
@c @item
@c Each Invariant table in the Invariants Display has a @command{Show
@c variables} button.  Click on that button to see a list of variables for
@c that program point.  Select any set of variables and click the
@c @command{Filter on selected variables} button.
@c @end enumerate
@c 
@c To remove variables from the variables list, select the variables in
@c question and click on the @command{Remove selected
@c variables} button.
@c 
@c If you click on the @command{any variable} checkbox,
@c invariants are displayed if they contain any of the variables in the
@c variables list.  If you click on the @command{all
@c variables} checkbox, invariants are displayed if they contain all
@c of the variables in the variables list.



@c @node    Context GUI,  , Eclipse plug-in, GUIs
@c @section Context GUI
@c @cindex Context GUI
@c @cindex GUI, context
@c 
@c The Daikon Context GUI displays invariants for the Java or C code displayed
@c in a text editor or code browser; as the cursor moves, the invariant
@c display is updated.
@c (Before using the Context GUI, you must follow the installation
@c instructions; @pxref{Installing the Context GUI}.)
@c 
@c @c Force a paragraph break so the image is on its own line.
@c @*
@c 
@c @ifnotinfo
@c @image{images/context-gui,5in,}
@c @end ifnotinfo
@c 
@c Currently, the Context GUI is integrated with the Emacs text editor.
@c However, users can extend it to other Java or C editors.  The Context GUI can
@c also be run stand-alone.  This provides the user the ability to browse
@c the invariants without having to load up the text editor in case the
@c user wants to do a quick lookup on invariants.
@c 
@c @menu
@c * Context GUI with Emacs::      
@c * Installing the Context GUI::  
@c @end menu
@c 
@c @node    Context GUI with Emacs, Installing the Context GUI, Context GUI, Context GUI
@c @subsection Running the Context GUI with Emacs
@c @cindex Emacs, with Context GUI
@c 
@c In order to use the Context GUI, perform the following steps:
@c @enumerate
@c @item
@c Use the Daikon invariant detector to create a @file{.inv} file containing the
@c invariants.
@c @example
@c   java daikon.Daikon -o foo.inv decl-files... trace-files...
@c @end example
@c 
@c 
@c 
@c @item
@c 
@c Start the Context GUI by typing @kbd{M-x daikon-context-gui}
@c while visiting a Java or C file in Emacs.  When prompted, select the
@c appropriate @file{.inv} file, containing the invariants.
@c 
@c @item
@c Stop the Context GUI by typing @kbd{M-x daikon-context-gui-end}
@c 
@c @end enumerate
@c 
@c 
@c 
@c @node    Installing the Context GUI,  , Context GUI with Emacs, Context GUI
@c @subsection Installing the Context GUI
@c 
@c If you wish to run the Daikon Context GUI (@pxref{Context GUI}), perform
@c the following two steps:
@c 
@c @enumerate
@c @item
@c If you wish to use the Context GUI with Java code, then
@c download and install JDE, the Java Development Environment for Emacs,
@c from @uref{http://jdee.sunsite.dk/}.
@c If you wish to use the Context GUI with C code, no extra packages are needed.
@c @item
@c Add the Emacs Lisp code for the Daikon Context GUI to your Emacs load
@c path.  Add the following to your @file{.emacs} or @file{prj.el} file:
@c @example
@c   ;; Daikon Context GUI
@c   (add-to-list 'load-path
@c                (substitute-in-file-name "$DAIKONDIR/emacs"))
@c   (autoload 'daikon-context-gui "daikon-context-gui"
@c             "Daikon Context GUI" t)
@c   (custom-set-variables '(jde-global-classpath '("$CLASSPATH")))
@c @end example
@c @end enumerate


@menu
* Annotate::                    
* Runtime-check instrumenter::  
* InvariantChecker::            
* LogicalCompare::              
@end menu

@node    Annotate, Runtime-check instrumenter, Invariant Diff, Tools for manipulating invariants
@subsection Annotate

@cindex Annotate tool
@cindex MergeESC tool, see Annotate tool

The Annotate program inserts Daikon-generated invariants into Java
source code as  annotations in  DBC, ESC, Java or JML format.
These annotations are comments that can be automatically verified or
otherwise manipulated by other tools.

Invoke Annotate like this:
@example
java daikon.tools.jtb.Annotate Myprog.inv Myprog.java Myprog2.java ...
@end example

The first argument is a Daikon @file{.inv} or @file{.inv.gz} file 
produced by running
Daikon with the @option{-o} command-line argument.  All subsequent
arguments are @file{.java} files.  The original @file{.java} files are left
unmodified, but Annotate produces new versions of the @file{.java} files
(with names suffixed as @file{-escannotated}, @file{-jmlannotated}, or 
@file{-dbcannotated}) that include the Daikon invariants as comments.

The options are:
@table @option

@item --format @var{name}
Produce output in the given format.  See @ref{Invariant syntax}.

@item --no_reflection
Do not use reflection to find information about the classes being
instrumented.  This allows Annnotate to run without having access
to the class files.  Since the class files are necessary to generate ``also''
tags, those tags will be left out when this option is chosen.

@item --max_invariants_pp @var{count}
Output at most @var{count} invariants per program point (which ones are chosen
is not specified).

@item --wrap_xml
Each invariant is printed using the given format (ESC, JML or DBC),
but the invariant expression is wrapped inside XML tags, along with other
information about the invariant.

For example, if this switch is set, the output format is ESC,
and an invariant for method @code{foo(int x)} normally prints as

@example
/*@ requires x != 0; */
@end example

Then the resulting output will look something like this (all
in one line; we break it up here for clarity):

@example
/*@ requires <INVINFO>
<INV> x != 0 </INV>
<SAMPLES> 100 </SAMPLES> 
<DAIKON> x != 0 </DAIKON>
<DAIKONCLASS> daikon.inv.unary.scalar.NonZero </DAIKONCLASS>
<METHOD> foo() </METHOD>
</INVINFO> ; */
@end example

Note that the comment will no longer be a legal ESC/JML/DBC
comment.  To make it legal again, you must replace the XML tags with
the string between the <INV> tag.

Also note the extra information printed with the invariant: the number
of samples from which the invariant was inferred, the Daikon
representation (i.e., the Daikon output format), the Java class that
the invariant corresponds to, and the method that the invariant
belongs to (@code{null} for object invariants).

@end table

@strong{Known bug (logical shift in Java).}
Daikon's Java parser (adopted from javacc and JTB) accepts Java 1.5 syntax.
An error in the new parser
may produce illegal Java in the annotated file, if the source file to be
annotated includes logical shift operators. @xref{Known bugs}.


@node    Runtime-check instrumenter, InvariantChecker, Annotate, Tools for manipulating invariants
@subsection Runtime-check instrumenter (runtimechecker)

@cindex runtime-check instrumenter
@cindex runtimechecker instrumenter

The runtimechecker instrumenter inserts, into a Java file,
instrumentation code that checks invariants as the program executes.
For a full list of options, run:

@example
java daikon.tools.runtimechecker.Main help
@end example

The @code{instrument} command to runtimechecker creates a new directory
@file{instrumented-classes} containing a new version of the
user-specified Java files, instrumented to check invariants at runtime
and to record a list of invariant violations in a Java data structure.

Note that the instrumented program does not do anything with the list of
violations; it merely creates the list.  You will need to write your own
code to process that list; see @ref{Accessing violations}.


Here is an example of use of the runtime-check instrumenter.
To create a version of file
@file{ubs/BoundedStack.java} that checks the invariants in 
invariant file @file{BoundedStack.inv.gz}, do:
@example
java daikon.tools.runtimechecker.Main instrument BoundedStack.inv.gz \
    ubs/BoundedStack.java
@end example
@noindent
The instrumented Java code references classes in the
@code{daikon.tools.runtimechecker} package, so those classes must be
present in the classpath when the instrumented classes are compiled and
executed.

Invariants are evaluated at the program points at which they should
hold. Three things can happen when evaluating an
invariant:

@itemize @bullet
@item
It evaluates to true, which means that the invariant holds.
Program execution continues normally.

@item
It evaluates to false, which means that the invariant doesn't
hold. In this case the corresponding
@code{daikon.tools.runtimechecker.Property} is added to a list in the
class @code{daikon.tools.runtimechecker.Runtime}. A programmer can
obtain the growing list of violated invariants through the method
@code{daikon.tools.runtimechecker.Runtime.getViolations()}. (See
that class for other useful methods.)

@item
A @code{Throwable} (exception) is thrown when evaluating the
invariant.  In this case, the throwable is added to the list
@code{daikon.tools.runtimechecker.Runtime.internalInvariantEvaluationErrors}.
The throwable is not rethrown.

@end itemize


@menu
* Accessing violations::        
@end menu

@node    Accessing violations,  , Runtime-check instrumenter, Runtime-check instrumenter
@subsubsection Accessing violations

The instrumented class handles violations silently:
it simply adds them to a list in the class
@code{daikon.tools.runtimechecker.Runtime.}  
No ``invariant violation'' exceptions are thrown, and the violated
invariants can only be obtained dynamically from class
@code{daikon.tools.runtimechecker.Runtime}.

A future release of Daikon will provide tools that process the list in
the following ways:
@enumerate
@cindex WriteViolationFile tool
@item To write a file of all the violations for a program execution.
A prototype of such a tool is provided in the Daikon distribution, as
program @code{daikon.tools.runtimechecker.WriteViolationFile}.  If you
would ordinarily run your program as @samp{java MyProg arg1 arg2},
then running @samp{java daikon.tools.runtimechecker.WriteViolationFile
MyProg arg1 arg2} creates a file called @file{violations.txt} in the
current directory.  If the program under test calls
@code{System.exit}, then no @file{violations.txt} file is created.
@item Throw an exception when any violation occurs.
@end enumerate


The following code snippet contains a method @code{callMethod()} which
presumably calls one of the methods in the instrumented class.
The code detects if any violations occurred, and if so, prints 
a message.

@example
daikon.tools.runtimechecker.Runtime.resetViolations();
daikon.tools.runtimechecker.Runtime.resetErrors();

callMethod();

List<Violation> vs = daikon.tools.runtimechecker.Runtime.getViolations();

if (!vs.isEmpty())
  System.out.println("Violations occurred.");
@end example

In addition, the instrumenter adds the following two methods to the
instrumented class:

@itemize @bullet
@item
@code{isDaikonInstrumented()}.  Returns true (you could calling
this method to see if the class has been instrumented).

@item
@code{getDaikonInvariants()}.  Returns the array of properties being checked.
@end itemize

@strong{Known bug (logical shift in Java).}
Daikon's Java parser (adopted from javacc and JTB) accepts Java 1.5 syntax.
An error in the new parser
may produce illegal Java in the instrumented file, if the source file to
be instrumented includes logical shift operators. @xref{Known bugs}.

@node    InvariantChecker, LogicalCompare, Runtime-check instrumenter, Tools for manipulating invariants
@subsection InvariantChecker

@cindex InvariantChecker tool

The InvariantChecker program takes a set of invariants found by Daikon
and a set of data trace files.  It checks each sample in the data trace
files against each of the invariants.  Any sample that violates an invariant
is noted, via a message printed to standard output or to a specified
output file.

InvariantChecker is invoked as follows:
@example
java daikon.tools.InvariantChecker [@var{options}] @var{invariant-file} @var{dtrace-files} 
@end example

The @var{invariant-files} are invariant files (@file{.inv}) created by
running Daikon.  The @var{dtrace-files} are data trace (@file{.dtrace})
files created by running the instrumented program.  The files may appear
in any order; the file type is determined by whether the file name
contains @file{.dtrace}, or @file{.inv}.

The options are:
@table @option

@item --help
Print usage message.

@item --output @var{output-file}
Write any violations to the specified file.

@item --config_option @var{name}=@var{value}
@itemx --dbg @var{category}
@itemx --track @var{class}<@var{var1},@var{var2},@var{var3}>@@@var{ppt}
These switches are the same as for Daikon.  They are described in
@ref{Running Daikon}.

@end table

@node LogicalCompare,  , InvariantChecker, Tools for manipulating invariants
@subsection LogicalCompare

@cindex LogicalCompare tool
@cindex implication checking tool
@cindex comparison tool, logical

Given two sets of invariants describing the operation of a software
module, or describing two implementations of a module with the same
interface, we can define one set of invariants to be ``stronger'' than
another roughly if in any situation where the ``stronger'' invariants
hold, the ``weaker'' invariants also hold.  The LogicalCompare tool
examines two sets of invariants, and checks using the Simplify
automatic theorem prover whether they satisfy a precise version of
this relationship.

Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to use this program.

The LogicalCompare program takes two mandatory arguments, which are
@file{.inv} files containing invariants; the invariants will be
checked to verify if the invariants in the first file are weaker
(implied by) the invariants in the second file, and exceptions to this
implication are printed.  If no other regular arguments are supplied,
all the method or function program points that exist in both files
will be compared, with a exception message reported for each method
that exists in the ``weaker'' set but not the ``stronger''.
Alternatively, one or two additional arguments may be supplied, which name an 
@code{:::ENTER} program point and an @code{:::EXIT} program point to examine
(if only an @code{:::ENTER} program point is supplied,
the corresponding combined @code{:::EXIT} point
is selected automatically).  To be precise, for each
pair of program points representing a single method or function,
LogicalCompare will check that each precondition (@code{:::ENTER} point
invariant) in the ``stronger'' invariant set is implied by some
combination of invariants in the ``weaker'' invariant set, and that
each postcondition (@code{:::EXIT} point invariant) in the ``weaker'' invariant
set is implied by some combination of postconditions in the
``stronger'' set and preconditions in the ``weaker'' set.  In summary,
the syntax of an invocation of LogicalCompare will have the following
form:

@example
java daikon.tools.compare.LogicalCompare [@var{options}] \
      @var{weak-invs} @var{strong-invs} [@var{enter-ppt} [@var{exit-ppt}]]
@end example

LogicalCompare accepts the following options:

@table @option
@item --assume @var{file}
Read additional assumptions about the behavior of compared routines
from the file @var{file}.  The assumptions file should consist of lines
starting with @samp{PPT_NAME}, followed by the complete name of an
@code{:::ENTER} program point, followed by lines each consisting of a Simplify
formula, optionally followed by a @code{#} and a human-readable
annotation.  Blank lines and lines beginning with a @code{#} are
ignored.  The assumption properties will be used as if they were
invariants true at the strong @code{:::EXIT} point when checking 
weak @code{:::EXIT} point invariants.

@item --cfg @var{option}=@var{value}
Specify a single configuration setting.  The available settings are the
same as can be passed to Daikon's @option{--config_option} option,
though because the invariants have already been generated, some will
have no effect.  For a list of
available options, @xref{Configuration options}.

@item --config-file=@var{file}
Read configuration options from the file @var{file}.  This file should
have the same format as one passed to Daikon's @option{--config}
option, though because the invariants have already been generated,
some will have no effect.

@item --debug-all
@itemx --dbg @var{category}
These options have the same effect as the @option{--debug} and
@option{--dbg} options to Daikon, causing debugging logs to be
printed.

@item --filters=[bBoOmjpi]
Control which invariants are removed from consideration before
implications are checked.  Note that except as controlled by this
option, LogicalCompare does not perform any of the filters that
normally control whether invariants are printed by Daikon.  Also,
invariants that cannot be formatted for the Simplify automatic theorem
prover will be discarded in any case, as there would be no other way
to process them.  Each letter controls a filter: an invariant is reject
if it is reject by any filter (or, equivalently, kept only if it
passes through every filter).

@table @option
@item b
Discard upper-bound and lower-bound invariants
(such as ``x <= c'' and ``x >= c'' for a
constant c), when Daikon considers the constant to be uninteresting.
Currently, Daikon has a configurable range of interesting constant: by
default, -1, 0, 1, and 2 are interesting, and no other numbers are.

@item B
Discard all bound invariants, whether or not the constants in them are
considered interesting.

@item o
Discard ``one-of'' invariants (which signify that a variable always
had one of a small set of values at runtime), when the values that the
variable took are considered uninteresting by Daikon.

@item O
Discard all ``one-of'' invariants, whether or not the values involved
are interesting.

@item m
Discard invariants for which it was never the case that all the
variables involved in the invariant were present at the same time.

@item j
Discard invariants that Daikon determines to be statistically
unjustified, according to its tests.

@item p
Discard invariants that refer to the values of pass-by-value
parameters in the postcondition, or to the values of objects pointed
to by parameters in postconditions, when the pointer is not
necessarily the same as at the entrance to the method or function.
Usually such invariants reflect implementation details that would not
be visible to the caller of a method.

@item i
Discard implication invariants when they appear in @code{:::ENTER} program
points.
@end table

The default set of filters corresponds to the letters @option{ijmp}.

@item --help
Print a brief summary of available command-line options.

@item --no-post-after-pre-failure
If implication is not verified between two invariant sets after
examining the preconditions, do not continue to check the implication
involving postconditions.  Because the postconditions aren't formally
meaningful outside the domain specified by the preconditions, this is
the safest behavior, but in practice trivial precondition mismatches
may prevent an otherwise meaningful postcondition comparison.  See also
@option{--post-after-pre-failure}.

@item --proofs
For each implication among invariants that is verified, print a
minimal set of conditions that establish the truth of the conclusion.
The set is minimal, in the sense that if any condition were removed,
the conclusion would no longer logically follow according to Simplify,
but it is not the least such set: there may exist a smaller set of
conditions that establish the conclusion, if that set is not a subset
of the set printed.  Beware that because this option uses a naive
search technique, it may significantly slow down output.

@item --post-after-pre-failure
Even if implication is not verified between two invariant sets after
examining the preconditions, continue to check the implication
involving postconditions.  This is somewhat dangerous, in that if the
implication does not hold between the preconditions, the invariant
sets may be inconsistent, in which case reasoning about the
postconditions is formally nonsensical, but the tool will attempt to
ignore the contradiction and carry on in this case.  This is now the
default behavior, so the option has no effect, but it is retained for
backward compatibility.  See also @option{--no-post-after-pre-failure}.

@item --show-count
Print a count of the number of invariants checked for implication.

@item --show-formulas
For each invariant, show how it is represented as a logical formula
passed to Simplify.

@item --show-sets
Rather than testing implications among invariants, simply print the
sets of weak and strong @code{:::ENTER} and @code{:::EXIT} point invariants that would
normally be compared.  The invariants are selected and filtered as
implied by other options.

@item --show-valid
Print invariants that are verified to be implied (``valid''), as well
as those for which the implication could not be verified (``invalid''
invariants, which are always printed).

@item --timing
For each set of invariants checked, print the total time required for
the check.  This time includes both processing done by LogicalCompare
directly, and time spent waiting for processing done by Simplify, but
does not include time spent de-serializing the @file{.inv} input
files.

@end table


@node  DtraceDiff utility,  , Tools for manipulating invariants, Tools
@section DtraceDiff utility

DtraceDiff is a utility for comparing data trace (@file{.dtrace}) files.
It checks that the same program points are visited in the same order in
both files, and that the number, names, types, and values of variables
at each program point are the same.  The differences are found using a
content-based, rather than text-based, comparison of the two files.

DtraceDiff stops by signalling an error when it finds a difference
between the two data trace files.  (Once execution paths have
diverged, continuing to emit record-by-record differences is likely to
produce output that is far too voluminous to be useful.)  It also
signals an error when it detects incompatible program point
declarations or when one file is shorter than the other.

DtraceDiff is invoked as follows:
@example
java daikon.tools.DtraceDiff [@var{flags}] \
   [@var{declsfiles1}] @var{dtracefile1}  [@var{declsfiles2}] @var{dtracefile2}
@end example

Corresponding declarations (@file{.decls}) files can optionally be
specified on the command line before each of the two @file{.dtrace}
files.  Multiple @file{.decls} files can be specified.  If no
@file{.decls} file is specified, DtraceDiff assumes that the
declarations are included in the @file{.dtrace} file instead.

DtraceDiff supports the following Daikon command-line flags:

@table @option
@item --help
Print usage message.

@item --config @var{filename}
Load the configuration settings specified in the given file.
@xref{Configuration options}, for details.

@item --config_option @var{name}=@var{value}
Specify a single configuration setting.
@xref{Configuration options}, for details.

@item --ppt-select-pattern=@var{ppt_regexp}
Only process program points whose names match the regular expression,
which uses Perl syntax.

@item --ppt-omit-pattern=@var{ppt_regexp}
Do not process program points whose names match the regular expression,
which uses Perl syntax.  This takes priority over the
@option{--ppt-select-pattern} argument.

@item --var-select-pattern=@var{ppt_regexp}
Only process variables (whether in the trace file or derived) whose
names match the regular expression, which uses Perl syntax.

@item --var-omit-pattern=@var{var_regexp}
Ignore variables (whether in the trace file or derived) whose names
match the regular expression, which uses Perl syntax.  This takes
priority over the @option{--var-select-pattern} argument.

@end table

DtraceDiff uses appropriate comparisons for the type of the variables in
each program point being compared.  In particular:

@itemize @bullet
@item Hashcode (pointer or address) values may differ from one run of
the same program to the next, and there may not be a one-to-one mapping
of hashcode values between different program executions, so the
comparison function only looks for null versus non-null pointer values.

@item Floating-point values are subject to roundoff error from printing and
reading, so they are compared with a ``fuzzy'' rather than exact equality test.
@end itemize

@node    Troubleshooting, Details, Tools, Top
@chapter Troubleshooting

@cindex troubleshooting
@cindex warning messages
@cindex error messages

This chapter gives solutions for certain problems you might have with
Daikon; it also tells you how to report bugs in a useful manner.


@menu
* Daikon problems::             
* Large dtrace files::          
* Parsing Java 5.0 code::       
* Chicory problems::            
* dfej problems::               
* Eclipse plug-in problems::    
* dfec problems::               
* Reporting bugs::              
* Known bugs::                  
* Further reading::             
@end menu


@node    Daikon problems, Large dtrace files, Troubleshooting, Troubleshooting
@section Problems running Daikon

You may find the debugging flags @option{--debug} and @option{--dbg
@var{category}} useful if you wish to track down bugs or better
understand Daikon's operation; @xref{Daikon debugging options}.
@xref{Configuration options}, for another way to adjust Daikon's output.


@menu
* Too much output::             
* No samples::                  
* No return from procedure::    
* Unsupported class version::   
* Out of memory::               
* Simplify errors::             
* Contradictory invariants::    
* Method needs to be implemented::  
* Daikon runs slowly::          
@end menu


@node    Too much output, No samples, Daikon problems, Daikon problems
@subsection Too much output

@cindex too much output from Daikon

Sometimes, Daikon may produce a very large number of seemingly
irrelevant properties that obscure the facts that you were hoping to
see.  Usually, such output indicates a deficiency in your test suite:
your test suite is so small that many arbitrary properties hold over it.
This happens when the test suite does not execute the code with a broad
distribution of values, but only executes the code with a few specific
values.  This problem disappears if you augment your test suite so that
it exercises the code with more different values.

Each property that Daikon produces is a true fact about how the target
program behaved.  However, some of these facts would be true for any
execution of the target program, and others are accidents of the
particular executions that Daikon observed.  Both types of facts are
useful:  the former tell you about your program, and the latter tell you
about your test suite (and how to improve it!).


@node    No samples, No return from procedure, Too much output, Daikon problems
@subsection No samples and no output

@cindex no output from Daikon

When Daikon produces no output, that is usually a result of it having no
samples from which to generalize.  Use the @option{--output_num_samples}
flag to Daikon to find out how many samples it is observing.  This
section tells you how to debug your problem if the
answer is 0, but you believe that there are samples in the file you are
feeding to Daikon.

Daikon processes only @code{:::ENTER} program points that have a 
matching @code{:::EXIT}
program point.  (You can disable this behavior with the
@option{--nohierarchy} switch to Daikon; 
see @xref{Options to control invariant detection}.)  
If no @code{:::EXIT} program points are present (perhaps every
execution threw an exception, or you filtered out all the 
@code{:::EXIT} program points), 
then Daikon will not process any of the @code{:::ENTER} program points.
You can make Daikon print information about unmatched procedure entries
via the @samp{daikon.FileIO.unmatched_procedure_entries_quiet}
configuration option (@pxref{General configuration options}).


@node    No return from procedure, Unsupported class version, No samples, Daikon problems
@subsection No return from procedure

@cindex no return from procedure, warning
@cindex return from procedure, warning

Daikon sometimes issues a warning that a procedure in the target program
was entered but never exited (that is, the target program abnormally
terminated).  In other words, the @file{.dtrace} file contains more
entry records
than exit records for the given procedure.  Some procedures that were
entered were never recorded to have exited: either they threw an
exception, skipping the instrumentation code that would have recorded
normal termination, or the target program's run was interrupted.
When this happens, the entry sample is ignored; the rationale is that
the particular values seen led to exception exit, were probably
illegal, and so should not be factored into the method preconditions.

@cindex invocation nonce
@cindex nonce, invocation
@cindex this_invocation_nonce

In some cases, exceptional exit from a procedure can cause procedure
entries and exits (in the trace file) to be incorrectly matched up; if
they are incorrectly matched, then the @code{orig(@var{x})} values may
be incorrect.  Daikon has two techniques for associate procedure exits
with entries --- the nonce technique and the stack technique.  If a
@file{.dtrace} file uses the nonce technique, @code{orig(@var{x})}
values are guaranteed to be correct.  If a @file{.dtrace} file uses
the stack technique, then incorrect @code{orig(@var{x})} values are
likely to occur.  You can tell which technique Daikon will use by
examining the @file{.dtrace} file.  If the second line of each entry
in the @file{.dtrace} file is @samp{this_invocation_nonce}, then Daikon
uses the nonce technique.  Otherwise, it uses the stack technique.
Which technique is used is determined by the front end, which creates
the @file{.dtrace} file, and typically cannot be controlled by the
user.


@node    Unsupported class version, Out of memory, No return from procedure, Daikon problems
@subsection Unsupported class version

@cindex UnsupportedClassVersionError
@cindex java.lang.UnsupportedClassVersionError
@cindex major.minor version error

Daikon requires a Java 5 JVM (@pxref{Requirements}).
An error such as 
@example
Exception in thread "main" java.lang.UnsupportedClassVersionError:
daikon/Daikon (Unsupported major.minor version 49.0)
@end example
@noindent
indicates that you are trying to run Daikon on an older JVM.  You need to
install a newer version of Java in order to run Daikon.


@node    Out of memory, Simplify errors, Unsupported class version, Daikon problems
@subsection Out of memory

@cindex out of memory error
@cindex java.lang.OutOfMemoryError
@cindex memory exhaustion
@cindex HotSpot JVM
@cindex JVM memory management
@cindex permanent generation (in HotSpot JVM)

If Daikon runs out of memory, generating a message like
@example
Exception in thread "main" java.lang.OutOfMemoryError
        <<no stack trace available>>
@end example
@noindent
then it is likely that it has created more invariants than will fit
in memory.  The number of invariants created depends on the number of
program points and the number of variables at each program point.
In addition to the solutions discussed in @ref{Reducing program points}, 
you can try increasing the amount of memory available to Java
with the @option{-mx} argument to @command{java}.  (This flag is
JVM-specific; see your JVM documentation for details.  For instance,
its correct name in JDK versions 1.3 and later is @option{-Xmx}.)
However, the value you use should be less your system's total amount
of physical memory.  
The default may be 64 megabytes or less; to permit use of up to 256
megabytes, you would run Java like so:
@example
java -mx256m ...
@end example

When using the Java HotSpot JVM, an additional parameter may need to
be increased.  HotSpot uses a separately-limited memory region, called
the ``permanent generation'', for several special kinds of allocation,
one of which (interned strings) Daikon sometimes uses heavily.  It may
be necessary to increase this limit as well, with the
@option{-XX:MaxPermSize=} option.  For instance, to use 512 megabytes,
of which at most 256 can be used for the permanent generation, you
would run Java like so:
@example
java -Xmx512m -XX:MaxPermSize=256m
@end example

Another possible problem is the creation of too many derived variables.
If you supply the @option{--output_num_samples} option to Daikon
(@pxref{Options to control Daikon output}), then it will list all
variables at each program point.  If some of these are of no interest,
you may wish to suppress their creation.  For information on how to do that,
see @ref{Options to enable/disable derived variables}.  Also see 
@ref{Reducing variables} for other techniques.

Any output generated before the out-of-memory error is perfectly valid.


@node    Simplify errors, Contradictory invariants, Out of memory, Daikon problems
@subsection Simplify errors

@cindex Simplify, could not utilize

The warning ``Could not utilize Simplify'' indicates that the Simplify
theorem-prover could not be run; this usually indicates that the
Simplify binary was not found on the user's path.
Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed.

If Simplify is not used, certain redundant (logically implied)
invariants may appear in Daikon's output.  The output is
correct, but more verbose than it would be if you used Simplify.

@node Contradictory invariants, Method needs to be implemented, Simplify errors, Daikon problems
@subsection Contradictory invariants

@cindex contradictory invariants
@cindex inconsistent invariants
@cindex invariants, inconsistent
@cindex invariants, contradictory

The invariants Daikon produces are all true statements about the
supplied program executions, so they should be mutually consistent.
Sometimes, however, because of a bug or a limitation in Daikon,
contradictory invariants are produced.

One known problem involves object invariants.  Daikon infers object
invariants by observing the state of an object when its public methods
are called.  However, if an object has publicly accessible fields that
are changed by code outside the class, after which no public methods
are called, invariants about the state of the object as seen by other
code can contradict the class's object invariants.  A workaround is to
allow changes to an object's state from outside the class only by
way of public methods.

Besides confusing the user, contradictory invariants also cause
trouble for the Simplify theorem prover that implements the
@option{--suppress_redundant} option.  When the invariants at a
particular program point contradict each other or background
information (such as the types of objects), Simplify becomes unable to
distinguish redundant invariants from non-redundant ones.

The best solution in such cases is to fix the underlying cause of the
contradictory invariants, but since that is sometimes not possible,
Daikon will try to work around the problem by avoiding the invariants
that cause a contradiction.  Daikon will attempt to find a small subset
of the invariants that aren't mutually consistent, and remove one,
repeating this process until the remaining invariants are consistent.
(Note that the invariants are removed only for the purposes of
processing by Simplify; this does not affect whether they will be
printed in the final output).  While this technique can allow
redundant invariants to be found when they otherwise wouldn't be, it
has some drawbacks: the choice of which invariant to remove is
somewhat arbitrary, and the process of finding contradictory subsets
can be time consuming.  The removal process can be disabled with the
@option{daikon.simplify.LemmaStack.remove_contradictions}
configuration option.

@node    Method needs to be implemented, Daikon runs slowly, Contradictory invariants, Daikon problems
@subsection Method needs to be implemented

@cindex method needs to be implemented warning
@cindex needs to be implemented warning

Daikon may produce output like the following (but all on one line):
@example
method daikon.inv.binary.twoSequence.SubSequence.format_esc()
needs to be implemented:
this.theArray[0..this.topOfStack] is a subsequence of
orig(this.theArray[0..this.topOfStack])
@end example
@noindent
This indicates that a particular invariant (shown on the last two lines
above) cannot be formatted using the current formatting.  In this example,
the invariant can be formatted using Daikon's default
formatting (which is how it is shown above), but (as of April 2002)
Daikon cannot output it in ESC format, so Daikon prints the above
message instead.  The message also shows exactly what Java method needs
to be implemented to correct the problem.  You can ignore such messages,
or else use an output formatting that can handle those invariants.
Annotate (@pxref{Annotate}) automatically ignores unformattable invariants.


@node    Daikon runs slowly,  , Method needs to be implemented, Daikon problems
@subsection Daikon runs slowly

@cindex slow operation, of Daikon
@cindex runtime, of Daikon

Daikon's runtime and space depend on the particular data that it analyzes.
Informally, invariant detection time can be characterized as 
@example
O((@var{vars}^3 * @var{falsetime} + @var{trueinvs} * @var{testsuite}) * @var{procedures})
@end example
@noindent
where @var{vars} is the number of variables @emph{at a program point}, 
@var{falsetime} is the (small constant) 
time to falsify a potential invariant, 
@var{trueinvs} is the (small) number of
true invariants at a program point, 
@var{testsuite} is the size of the test
suite, and
@var{procedures} is the number of instrumented program points.  The first
two products multiply a number of invariants by the time to test each
invariant.

If there are many true invariants over an input, then Daikon continues
to check them all over the entire input.  By contrast, if not many
invariants are true, then Daikon need no longer check them once they
are falsified (which in practice happens quickly).  Daikon processes
each procedure independently.

Another important factor affecting Daikon's runtime is the number of
variables.  Because invariants involve up to three variables each, the
number of invariants to check is cubic in the number of variables at a
single program point.  Derived variables (such as @code{a[i]},
introduced whenever there is both an array @code{a} and an integer
@code{i}) can increase the number of variables substantially.
The @option{daikon.Daikon.disable_derived_variables} and individual
@option{daikon.derive.*.*.enabled} configuration variables 
(@pxref{Options to enable/disable derived variables}) may be used
to disable derived variables altogether or selectively, at the cost of
detecting fewer invariants, especially over sequences.

For details on improving Daikon's performance, see @ref{Out of
memory}, and @ref{Large dtrace files}.

@node    Large dtrace files, Parsing Java 5.0 code, Daikon problems, Troubleshooting
@section Large data trace (.dtrace) files


@cindex data trace files, too large
@cindex large data trace files

Running instrumented code can create very large @file{.dtrace} files.
This can be a problem because writing the large files can slow the
target programs substantially, or because the large files may fill up
your disk.  The solution is to create smaller data trace files, by 
computing invariants over fewer program
points (procedures), computing invariants over fewer variables, or
computing invariants over fewer samples (executions).

It is usually possible to create an @file{.inv} file equivalent to
the one that Daikon would have computed, had Daikon been able to
process your entire program over its full test suite.  First, use the
techniques below (@pxref{Reducing program points}) to split your
@file{.dtrace} file into parts.  Next, run Daikon on each resulting
@file{.dtrace} file.  Finally, use the union function of @ref{Invariant
Diff} to combine the resulting @file{.inv} files into one.
@c A more correct way to merge the resulting .inv files would be with
@c the MergeInvariants tool, but it is not yet documented,

Independently from the above techniques, you can run Daikon online.  
The term ``online execution'' refers to running Daikon at the same time
as the target program, without writing any information to a file.  This
can avoid some I/O overhead, it prevents filling up your disk with
files, and in the future Daikon may be able to produce partial results
as the target program is executing.
@c The Chicory front end supports online execution via use of the
@c @option{--daikon} flag.
The Kvasir front end supports online execution via use of (normal or
named) Unix pipes (@pxref{Online execution}).

@menu
* Reducing program points::     
* Reducing variables::          
* Reducing executions::         
@end menu


@node    Reducing program points, Reducing variables, Large dtrace files, Large dtrace files
@subsection Reducing program points (functions)

Here are ways to compute invariants over a subset of the program
points (functions) in your program.
@enumerate
@item 
You can make Daikon ignore some program points.  With the
@option{--ppt-select-pattern=@var{ppt_regexp}}
flag (@pxref{Processing only part of the trace file}), 
only program points matching
the regular expression are processed.  Likewise, the
@option{--ppt-omit-pattern=@var{ppt_omit_regexp}} option causes program points
matching the regular expression to be ignored.

Also, the configuration variable @option{daikon.Daikon.ppt_perc}
allows a percentage of the program points to be processed. 
@xref{General configuration options}, for details.

@item 
@cindex trace-purge-fns.pl script
You can remove some program points (functions) from your
@file{.dtrace} file.  The @command{trace-purge-fns.pl} script takes as
arguments a (Perl) regular expression and a list of files.  It
modifies each file in place, removing every program point (function)
whose name matches the regular expression.  The @option{-v} flag means
to retain rather than discard matching program points.  For instance,
to create two subparts of a @file{.dtrace} file --- one containing the
getters and setters, and the other containing all other functions ---
use the following commands:
@example
cp myprog.dtrace myprog-setters.dtrace
trace-purge-fns.pl -v 'set|get' myprog-setters.dtrace
cp myprog.dtrace myprog-non-setters.dtrace
trace-purge-fns.pl 'set|get' myprog-non-setters.dtrace
@end example

@item 
You can instrument fewer methods, creating smaller @file{.dtrace}
files in the first place (rather than cutting the @file{.dtrace} files
down afterward).
@itemize
@item With Chicory or dfej, use the @option{--ppt-omit-pattern} or
@option{--ppt-select-pattern} options (@pxref{Processing only part of
the trace file}, @pxref{Chicory options}) to
restrict which program points are traced.  Running the
instrumented program will result in a smaller @file{.dtrace} file that
contains fewer records.
@item With Kvasir, use the @option{-ppt-list-file} option to specify a list
of program points that should be traced.
@item With dfec, split your program into multiple files, then
instrument only some of them (see below).
@end itemize

@item
If you are using a source-based front end, you can instrument fewer files.
@itemize
@item With dfej, only supply it the files you wish to instrument.
@item With dfec, use the @option{-l} command (@pxref{dfec command-line
arguments}) on the command line immediately before any file you wish
not to instrument.
@end itemize

@end enumerate

@node    Reducing variables, Reducing executions, Reducing program points, Large dtrace files
@subsection Reducing variables

Here are ways to compute invariants over a subset of the variables in
your program.  This changes the resulting invariants, because
invariants over the missing variables (including any relationship
between a missing variable and a retained variable) are not detected
or reported.  For instance, you might remove uninteresting variables
(or ones that shouldn't be compared to certain others) or variables
that use a lot of memory (such as some arrays).

@enumerate
@item
You can make Daikon ignore certain variables rather than modifying
the @file{.dtrace} file directly.  Analogously with the
@option{--ppt-select-pattern} and @option{--ppt-omit-pattern} flags, the
@option{--var-select-pattern} and @option{--var-omit-pattern} flags
restrict which variables Daikon processes
(@pxref{Processing only part of
the trace file}, @pxref{Chicory options}).

@item
You can reduce the number of variables that are output by instrumented
code --- for instance, output @samp{a} and @samp{a.b} but not
@samp{a.b.c}.  Do this by reducing the class/structure instrumentation
depth.
@itemize
@item With Chicory, use the @option{--nesting-depth=@var{N}} option.
@item With dfej, use the @option{--nesting-depth=@var{N}} option.
@item With Kvasir, use the @option{--struct-depth=@var{N}} or the 
@option{--nesting-depth=@var{N}} option.
@item With dfec, use the @option{--struct-depth=@var{N}} option.
@end itemize

@item 
You can pare down an existing @file{.dtrace} file using the
@command{trace-purge-vars.pl} script.  Analogously to the 
@command{trace-purge-fns.pl} script, it removes certain variables from
all program points in a function (or retains them, with the
@option{-v} flag).  After running this command, you will need
to edit the corresponding @file{.decls} file by hand to remove the
same variables.

@end enumerate

@node    Reducing executions,  , Reducing variables, Large dtrace files
@subsection Reducing executions

Here are ways to run Daikon over fewer executions of each program
point.  (You cannot combine the resulting invariants in order to
obtain the same result as running Daikon over all the executions.)

@enumerate
@item
If you have multiple @file{.dtrace} files (perhaps resulting from 
multiple program runs), you can run Daikon on just some of them.

@item 
@cindex trace-untruncate program
You can terminate the instrumented program when it has created a
sufficiently large @file{.dtrace} file.  If you interrupt the program
while it is in the middle of writing a record to the @file{.dtrace}
file, the last record may be only partially written.  Use the
@command{daikon/bin/trace-untruncate} program to remove the last,
possibly partial, record from the file:
@example
trace-untruncate myfile.dtrace
@end example
@noindent
modifies @file{myfile.dtrace} in place to remove the last record.

Alternately, you can use the
@command{daikon/bin/trace-untruncate-fast} program.  It operates much
faster on very large files.  In order to use
@command{trace-untruncate-fast}, you must have already compiled it
(@pxref{Installing Daikon}).

@end enumerate


@node    Parsing Java 5.0 code, Chicory problems, Large dtrace files, Troubleshooting
@section Parsing Java 5.0 code

The Annotate (@pxref{Annotate}) and runtimechecker (@pxref{Runtime-check
instrumenter}) tools use an external library (JTB,
@uref{http://compilers.cs.ucla.edu/jtb/}) for parsing Java code.  That
external library has an error in parsing logical shift operators such as
@code{x << y} or @code{x >> y}.  Therefore, such invariants (along with
a few other invariants that cannot be properly formatted as Java code)
are suppressed from the output of these tools.  (Annotate inserts them
as comments, and runtimechecker silently ignores them.)


@c @node    Tree GUI font errors, Reporting bugs, Parsing Java 5.0 code, Troubleshooting
@c @section Tree GUI font errors
@c 
@c @cindex font not found
@c 
@c When running the Tree GUI on Linux, you may get font errors such as the following:
@c 
@c @example
@c Font specified in font.properties not found
@c   [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
@c @end example
@c 
@c These errors are harmless; the Tree GUI will still run correctly.  To
@c prevent these errors from appearing in the future, take the following
@c steps:
@c 
@c @itemize @bullet
@c @item
@c Find out where your JDK root directory is.  In general, the JDK root directory
@c is where you run java from: @file{@var{JDK_ROOT}/bin/java}.
@c @item
@c Edit @file{@var{JDK_ROOT}/jre/lib/font.properties}, and comment out all lines
@c with the offending fonts.  For example, to eliminate the error messages
@c shown above, one would comment out all lines containing "fontspecific".
@c @end itemize
@c 
@c If you don't have permission to edit @file{font.properties}, ask
@c your system administrator to do so.


@node    Chicory problems, dfej problems, Parsing Java 5.0 code, Troubleshooting
@section Problems with Chicory

Before reporting or investigating a problem with Chicory, always check
that the program executes properly when not being run under Chicory's
control.

For example, if a command such as 
@example
java daikon.Chicory DataStructures.StackArTester
@end example
@noindent
fails with an error, then first try
@example
java DataStructures.StackArTester
@end example
@noindent
which is likely to fail with the same error.

If the latter command also fails, the problem is not with Chicory.
First solve your Java problem, then once again attempt to use Chicory.

If the latter command does not fail, then you have found a bug in
Chicory; please report it if it is not already explained in this manual.


@menu
* VerifyError constant pool index error::  
@end menu

@node    VerifyError constant pool index error,  , Chicory problems, Chicory problems
@subsection VerifyError constant pool index error

@cindex VerifyError, when running Chicory
@cindex java.lang.VerifyError, when running Chicory
@cindex illegal constant pool index error, when running Chicory
@cindex constant pool index error, when running Chicory

If Chicory throws an error such as the following:
@example
Exception in thread "main" java.lang.VerifyError: 
  (class: ps1/PublicTest, method: <init> signature: (Ljava/lang/String;)V)
  Illegal constant pool index
@end example
@noindent
then the problem is most likely that your classpath contains a version
of the BCEL library (@file{bcel.jar}) that is not compatible with Java
5.  You should either remove that version of BCEL from your classpath,
or you should ensure that it appears after @file{daikon.jar}.  (If you
are running Daikon from sources rather than from @file{daikon.jar}, then
ensure that @file{$DAIKONDIR/java/lib/bcel.jar} is the first version of
BCEL on your classpath.)


@node    dfej problems, Eclipse plug-in problems, Chicory problems, Troubleshooting
@section Problems with dfej

@menu
* dfej installation problems::  
* dfej invocation problems::    
* dfej javac problems::         
* JVM initialization error::    
@end menu

@node    dfej installation problems, dfej invocation problems, dfej problems, dfej problems
@subsection Problems installing dfej

GCC 2.95.2 on Linux raises an internal error when compiling
@file{stream.cpp} using the @option{-Wall} flag.  You can simply compile
that file without the @option{-Wall} flag.

@cindex cannot convert `const char **' to `char **'

If you get an error like
@example
stream.cpp: In method `void LexStream::ProcessInputUnicode
                                       (const char *, long int)':
stream.cpp:901: cannot convert `const char **' to `char **' for
argument `2' to `iconv (void *, char **, size_t *, char **, size_t *)'
@end example
@noindent
then
@c undefine preprocessor macro @code{HAVE_ICONV_H}
define preprocessor macro @code{HAVE_ERROR_CALL_ICONV_CONST}
and try compiling again --- that is, run the command that failed, but
add the @option{-DHAVE_ERROR_CALL_ICONV_CONST} command-line argument.
(This has been reported on Red Hat Linux 7.@i{x}.)

@c reported 12/19/2001 by Tao Xie
Also reported on Red Hat Linux 7.0 is the following error:
@example
daikon-context.cpp:466: no matching function for call to `pair<Ast *, 
Ast *>::pair (Ast *&, void *)'
@end example
@noindent
We do not yet have a fix, but if you find one, please let us know.


@node    dfej invocation problems, dfej javac problems, dfej installation problems, dfej problems
@subsection Problems running dfej

@cindex dfej, runs slowly

You may find that dfej runs very slowly, even on small programs.  dfej
itself finishes quite quickly, but it calls the external Ajax program,
which is extremely slow.  If you disable Ajax with the
@option{--no-ajax} argument to dfej, then Daikon may output slightly
more irrelevant invariants, but dfej will run much faster.

@cindex could not find package named, dfej error
@cindex dfej error, could not find package named

If you get an error like
@example
% dfej MyProg.java
MyProg.java:0:0:0:0: Error: Could not find package named: 
                ./java/util
MyProg.java:0:0:0:0: Error: Could not find package named: 
                ./java/lang
@end example
@noindent
then you need to add @file{rt.jar} to your
@env{CLASSPATH}@.  This should be automatic, if you are using the
@file{daikon.bashrc} or @file{daikon.cshrc} file and have set the
@env{JDKDIR} environment variable correctly.  Also see @ref{Installing dfej}.

@cindex zip file, invalid

If you get an error like
@example
MyProg.java:0:0:0:0: Error: Could not find package named:
                MyProg.MyPackage
@end example
@noindent
then the root of your packages in not in your classpath.  For example,
if you have a package @code{A} in directory @file{src/A} 
and a class @code{A.B}, then you
have to add the superdirectory of @code{A} (@file{src}) to your classpath so that
dfej can find package @code{A}@.  For example,
@example
dfej -classpath src:$CLASSPATH src/A/B.java
@end example
@noindent
Note that this behavior is identical to that of jikes, but differs
from javac.

If you get a warning like
@example
*** Warning: the file "/cygdrive/c/jswdk-1.0.1/jspengine.jar"
    is not a valid zip file.
@end example
@noindent
then you have set your @env{CLASSPATH} incorrectly:  it names a nonexistent
file or a file that is not a @file{.jar} Java archive.  You should adjust
your @env{CLASSPATH} to remove the offending file.  This warning has no effect
on the operation of dfej, however.

@cindex SOURCEPATH environment variable
@cindex environment variable SOURCEPATH

The behavior of dfej is controlled by many environment variables;
unexpected behavior may result from your settings for these
environment variables.  For example, if @env{SOURCEPATH} is set, then dfej
searches the indicated path for source files (ignoring class files in
those directories); this may cause processing of files that you had
not intended dfej to examine.

@cindex dfej option, invalid
@cindex decls-dir= option (to dfej) invalid
@cindex instr-dir= option (to dfej) invalid
@cindex dtrace-file= option (to dfej) invalid
@cindex --decls-dir= option (to dfej) invalid
@cindex --instr-dir= option (to dfej) invalid
@cindex --dtrace-file= option (to dfej) invalid
@cindex Eclipse plug-in, with wrong version of dfej
@cindex dfej, wrong version for Eclipse plug-in

If you get a warning like
@example
Warning: "--decls-dir=../DaikonInstrumented/output" is an invalid option
@end example
@noindent
then you are running dfej version 3, but you are trying to supply
arguments that are recognized by dfej version 4.  (For instance, perhaps
you are using the Eclipse plug-in with an out-of-date version of dfej.)
To fix the problem, download or build a current version of dfej.

@menu
* Ajax errors::                 
@end menu

@node    Ajax errors,  , dfej invocation problems, dfej invocation problems
@subsubsection Ajax errors

@cindex Ajax, problem with

The warning 
@example
Problem with Ajax; using original .decls files instead
@end example
@noindent
indicates that the Ajax variable comparator could not run.

Ajax
indicates which variables are comparable to which other variables.  This
information can reduce the amount of spurious output from Daikon by
preventing it from making spurious comparisons and reporting irrelevant
output.  For example, two integer variables that never appear together
in an expression (and that don't appear with variables that appear
together, etc.)@ should not be compared to one another, because those
variables are likely to be entirely unrelated and any properties over
them are incidental and uninformative.

Use of Ajax is optional and can be disabled via the
@option{--no-ajax} argument to dfej (@pxref{dfej options}).
If Ajax cannot be run, then a more primitive method of determining
comparability is used instead.  Even if Ajax cannot be run, Daikon
proceeds without error.

@cindex No such method in call, Ajax error
@cindex ajax.jbc.InvalidClassDataError
@cindex InvalidClassDataError, Ajax

Ajax cannot deal with binary @file{.class} files of version later that 1.1.
Thus, before running ajax, compile all your code using 
@command{javac -target 1.1} 
to create correct format @file{.class} files.  Note that all the
@file{.jar} files and other class files in your classpath used by the code
also need to be compiled using @command{javac -target 1.1} in order
for ajax to be able to execute.

As of July 2002, Ajax cannot deal with JDK 1.2 (or later) libraries.
For instance, Ajax issues the error 
@example
ajax.jbc.InvalidClassDataError: No such method in call
@end example
@noindent
for methods such as
@code{java.lang.Math.toDegrees(Double)} that do not appear in JDK 1.1.

@cindex Invalid class loading, Ajax warning

Ajax may produce the warning message ``Invalid class loading ...'';
you will notice this if environment variable @env{DFEJ_VERBOSE} is set.
You may safely ignore this message if Ajax does not produce any
further warnings or errors.  The message results from Ajax's inability
to handle JDK 1.2 libraries.

@cindex classpath cycles
@cindex Too many levels of symbolic links, Ajax exception

Due to a bug in Java 1.3,
Ajax may throw a RuntimeException with a message stating
``Too many levels of symbolic links''.  This can be caused
by cycles in the classpath (for example, a link from a directory to
itself).  To locate the problem link, rerun the the the failing command
as before, but prefixed by @samp{strace}.  If the original command had
been @samp{wc ~/.emacs}, then you would instead run 
@samp{strace wc ~/.emacs}.
Search the resulting output for the exception stack trace, containing
the message, ``Too many levels of symbolic links''.  On the line just
before the stack trace begins should appear the name of the link being
processed.  For example,
@example
lstat("a/sources/sources", st_mode=S_IFLNK|0777, st_size=53, ...) = 0
@end example
@noindent
Removing the link identified, in this case @file{.../sources/sources},
should solve the problem.



@node    dfej javac problems, JVM initialization error, dfej invocation problems, dfej problems
@subsection Problems compiling dfej output

@cindex javac errors on dfej output

@cindex duplicate definition, in instrumented Java file

While compiling files instrumented by dfej, if you get an error like
@example
Duplicate declaration of local variable "this_invocation_nonce".
Duplicate declaration of method "daikonPrintArrayMissing"
    in type "StackAr".
@end example
@noindent
then you have instrumented an already-instrumented file.  Remove the
instrumented version and re-run dfej on the original version.  (If you
are using the Daikon regression tests, run @command{make clean}.)

@cindex package and variable with same name
@cindex variable and package with same name

You should avoid giving a package and a variable the same name,
because of a problem with the standard javac compiler that is exposed
when dfej instruments inner classes.  Suppose that a package and a
variable are both named @code{link}.  When the compiler sees
@code{link.foo}, it doesn't know whether to interpret that as field
@code{foo} of the variable @code{link}, or as class @code{foo} of the
package @code{link}.  The compiler should just try both, but it
doesn't:  it only tries the variable.

In the future, we plan to make dfej to work around this javac problem.  
In the meanwhile, you can avoid the problem by not using the same name for a
package and a variable.  Reusing such names is considered bad style anyway,
because the name @code{link.foo} is ambiguous to people as well as to the
compiler.


@node    JVM initialization error,  , dfej javac problems, dfej problems
@subsection JVM initialization error

@cindex JVM initialization error
@cindex initialization error, JVM
@cindex Vector, dfej cannot instrument

Instrumenting @code{java.util.Vector} with dfej prevents the Java
Virtual Machine from initializing
properly, because instrumented classes attempt to use the JVM's
facilities when they are loaded, but the JVM loads Vector during its own
initialization.  The same problem may be true for other classes used
internally by the JVM@.  Users can create a new class MyVector, replace
uses of Vector by MyVector, and then instrument MyVector.


@node    Eclipse plug-in problems, dfec problems, dfej problems, Troubleshooting
@section Problems with dfec

@cindex Eclipse plug-in, troubleshooting

If you have trouble with the Eclipse plug-in, one good way to debug the
difficulty is to run the command-line tools (because the plug-in does
nothing more than run those tools for you).  If the command-line
versions work properly, then you have isolated the bug to the plug-in.
If the command-line versions do not work properly, then you can submit a
more specific bug report that is easier for the developers to reproduce
and correct.


@node    dfec problems, Reporting bugs, Eclipse plug-in problems, Troubleshooting
@section Problems with dfec

If you have trouble while instrumenting a C program, or while
compiling the instrumented program, first make sure that the program
being instrumented satisfies dfec's requirements: @xref{C program requirements}.

Problems with dfec can be divided into those encountered when running
dfec; those encountered when compiling and linking the instrumented code; and
those encountered when running the instrumented code.

@menu
* dfec instrumentation problems::  
* Compilation and linking of instrumented code problems::  
* Running instrumented code problems::  
@end menu


@node    dfec instrumentation problems, Compilation and linking of instrumented code problems, dfec problems, dfec problems
@subsection Problems running dfec

dfec errors in system files, such as
@file{.../gcc-3.2.1/include/c++/3.2.1/cstdlib}, or in the Daikon C
runtime, @file{daikon_runtime.h}, are likely to indicate that you are
using an unsupported version of GCC.  In particular, when you run
dfec, the version of GCC on your path should be 2.95.2, 2.95.3, or
2.96; @xref{gcc version}.

@cindex ?: operator, types of operands

dfec is sometimes confused by the conditional expression (@samp{?:})
operator, saying that the two sides are of different types.  If either
of the reported types involve ``DaikonSmartPointer'', then the problem
may be that the compiler could interconvert the two different types in
the original code, but after dfec instrumented those types, the
resulting ones were no longer interconvertible.  You have
two options.  The first option is to
rewrite the expression using a conditional statement (@samp{if
... else}).
@c Take care, because in C it is illegal to insert statements in the middle
@c of a list of declarations.
The second option is to add an appropriate cast to give the two
arms of the conditional expression the same type.  For example, change
the second line of
@example
char * mystring = ...;
foo ? "literal" : mystring;
@end example
@noindent
to
@example
foo ? (char *)"literal" : mystring;
@end example
@noindent
or perhaps to
@example
foo ? strdup("literal") : mystring;
@end example
@noindent
(though the latter introduces a small memory leak).

@menu
* Lackwit problems::            
@end menu

@node    Lackwit problems,  , dfec instrumentation problems, dfec instrumentation problems
@subsubsection Lackwit problems

@cindex Lackwit error, identifier undefined
@cindex identifier undefined, Lackwit error
@cindex undefined identifier, Lackwit error

By default, dfec runs the Lackwit variable comparability analysis
package.  Use of Lackwit is optional, but it can make invariant
detection more accurate and efficient.  Lackwit errors are non-fatal
to dfec, which can continue even if Lackwit fails.  (Lackwit is
pickier than dfec, so it may fail when dfec does not.)

If Lackwit (but not dfec proper) gives errors of the form
``identifier "strcat" is undefined'', then you have failed to include
the proper header file.  In this case, you should add @samp{#include
<string.h>} to the program to make the program valid ANSI C@.  dfec
does not produce this particular error, because it includes
@file{daikon_runtime.h}, which itself includes @file{string.h}.

@cindex lwpp-init.pl error

If Lackwit gives an error of the form
@example
sh: lwpp-init.pl: not found
@end example
@noindent
then you have not correctly installed the dfec distribution
(@pxref{Installing dfec}).  The @file{lwpp-init.pl} file should appear
in the directory referred to by environment variable @env{DFECDIR}@.  (That
directory is placed on your path by the standard Daikon dotfiles.)

Note, Lackwit may have different preprocessor parameters set than
GCC or G++ (and dfec) do.  As a result,
you may get errors about undefined function definitions with
Lackwit, but not with dfec proper.  Check if the
preprocessor is following the wrong branch, and adjust your code to
follow the right branch.  

@node    Compilation and linking of instrumented code problems, Running instrumented code problems, dfec instrumentation problems, dfec problems
@subsection Problems compiling and linking instrumented programs

This section discusses errors encountered when compiling instrumented
code (with G++) and linking the resulting compiled files.  (In some
cases, compiling and linking may be performed by a single command line
invocation, but the two steps are still logically distinct.)

  In Emacs, run this command from the @file{.cc} file
buffer to comment out the @samp{#line} directives:
@example
(replace-regexp "^\\(#line.*\\)$" "/* \\1 */" nil nil nil)
@end example


@menu
* Compiler problems::           
* Linker problems::             
@end menu

@node    Compiler problems, Linker problems, Compilation and linking of instrumented code problems, Compilation and linking of instrumented code problems
@subsubsection Compiler problems

When compiling the instrumented code (e.g., @samp{g++ myfile.cc},
where @file{myfile.cc} was created by dfec from @file{myfile.c}), G++
produces error messages referring to lines of the original file
@file{myfile.c}.  Often this indicates the problem, but in other
cases, you may wish to know which line in the @file{.cc} file is the
wrong one.  In that case, remove or comment out all the @samp{#line}
directives from the @file{.cc} file and re-compile.  For example, run
this command in the @file{daikon-instrumented} directory:
@example
perl -pi -e 's|^(#line.*)$|/* $1 */|' myfile.cc
@end example


@cindex DaikonSmartPointer errors in compilation of instrumented code
@cindex function not defined errors in compilation of instrumented code

@c Can this happen, if the original g++ compilation worked?
A ``function not defined'' error may indicate a type mismatch in the
original code.  Code should not declare a parameter but omit the
corresponding argument at the function call.  The solution is to make
the function declaration consistent with the use.

@cindex template-argument uses local type errors
@cindex local type in template-argument error

An error of the form ``template-argument ... uses local type'' is
probably due to use of a nested (local) structure declaration; raise
the declaration to top level in your C program.

An error of the form ``__T142459136' was not declared in this scope''
likely means that you simultaneously declared and used an enum
or other type.  Separate the declaration from the use.


@node    Linker problems,  , Compiler problems, Compilation and linking of instrumented code problems
@subsubsection Linker problems

This section discusses problems that may occur when linking files that
have been instrumented by dfec.  For more details,
@xref{Instrumentation scope}.

@cindex undefined symbol error
@cindex error, undefined symbol
@cindex ld error
@cindex symbol referencing errors
@cindex DaikonSmartPointer link errors

A linker error involving DaikonSmartPointer, such as
@example
Undefined                       first referenced
 symbol                             in file
foo(DaikonSmartPointer<Bar>)/var/tmp/ccPtoCZc.o
ld: fatal: Symbol referencing errors. No output written to MyProgram
@end example
@noindent
means that
instrumented (or partially instrumented) code contains a declaration
of @code{foo(bar *)}, but the definition appears in uninstrumented
code.  The instrumented version uses smart pointers, but the
uninstrumented version does not.  You should supply the @file{.c} file
containing the definition to dfec (preceded by @option{-l}
if you do not wish to fully instrument the file).

If you cannot specify the @file{.c} containing the definition of
@code{foo()} to dfec (for instance, if it appears in a pre-compiled
library), then no code supplied to dfec should contain a declaration
for @code{foo()}.   The declaration should occur in a @file{.h} file
that your code @code{#include}s, but that is not specified on the dfec
command line.

Other linker problems may indicate a mismatch between part of
your code that was compiled with GCC and part of it that was compiled
with G++.  GCC creates files using ``C linkage'', and G++ creates
files using ``C++ linkage''; the two are not compatible.  (It is
possible to direct G++ to use C linkage in certain circumstances;
@xref{Instrumentation scope}.)
While G++ can compile and link in the same step,
you should never provide the link step (the one that creates an
executable) with uninstrumented C code.  You should only provide the
link invocation of G++ with either
@itemize @bullet
@item
@file{.cc} files (or their @file{.o} versions) that were output
by dfec, or
@item
@file{.o} or @file{.a} files for (completely) uninstrumented code;
these files should be created by compiling with GCC, never
G++.
@end itemize


@node    Running instrumented code problems,  , Compilation and linking of instrumented code problems, dfec problems
@subsection Problems running instrumented code

@cindex daikon_runtime error
@cindex error, daikon_runtime
@cindex attempted to access index error
@cindex error, attempted to access index

A program instrumented by dfec may produce a message such as
@example
daikon_runtime: attempted to access index 5 of a 4-length array!
@end example
@noindent
Such a message indicates that there is an error in your program.  Your
program attempts to read or write memory beyond the end of an array.
You should fix this error before proceeding to try to detect
invariants.  If you do not do so, then the program's results cannot be
relied on, because the erroneous array access might corrupt (or access
meaningless values from) other variables, the dfec runtime data
structures, or your program's stack.  When this occurs, the dfec
runtime immediately halts your program to let you know where the error
occurred and to prevent memory corruption.  The dfec runtime's
discovery of these errors, while not directly related to invariant
detection, is a pleasant side effect of using dfec.  You also might
want to consider using the Valgrind tool for Linux on x86 processors
(@uref{http://valgrind.kde.org/}), which can help you correct
memory errors; this reduces the number of warnings/errors produced by
the dfec runtime, and it also improves your code.

@cindex daikon_runtime.h file
@cindex customizing the Daikon C runtime

The dfec runtime's behavior when a program
contains a memory error is customizable.
For instance, it can halt immediately; it
can allocate extra buffer space around arrays (but cannot do so around
dynamically allocated (malloced) blocks, because the type is not known
at the time of the malloc call) and only halt if the program goes
beyond those bounds; or the checking can be turned off entirely, which
is extremely dangerous.  These and many other customizations for the
dfec C runtime library are described in the @file{daikon_runtime.h}
file.


@node    Reporting bugs, Known bugs, dfec problems, Troubleshooting
@section Reporting bugs

@cindex reporting bugs
@cindex bugs, reporting

If you have any questions, can suggest ways to improve the
documentation, find bugs in the system, or have suggestions for its
improvement, please send email to
@email{daikon-developers@@lists.csail.mit.edu}.  (If you can't figure
out how to do something or do not understand why Daikon works the way it
does, that is a bug, too --- in the Daikon documentation.  Please report
those as well.)
We will try to assist you and to correct any
problems, so please don't hesitate to ask for help or report
difficulties.  Additionally, if you can contribute enhancements or bug
fixes, those will be gratefully accepted.

In order for us to assist you, please provide a complete and useful bug
report.  Your bug report must provide all the information that is
required in order to replicate the bug and verify that our fix corrects
the problem.  If you do not provide complete information, we will not be
able to assist you.

Your bug report should include:
@itemize @bullet
@item
the version of Daikon, which appears in the file @file{daikon/README}
and is also printed when you run Daikon.
@c ; also, whether you are running
@c from the @file{.class} files or from the @file{.jar} file.
If you are not using the most recent version, download a newer version
from @uref{http://pag.csail.mit.edu/daikon/} to see whether your problem
has already been corrected.
If you are using a modified version of Daikon, you should verify that
the problem exists in Daikon as distributed.
@item
a description of exactly what you did (in sufficient detail for others
to reproduce the problem), exactly what happened, and what
you expected to happen instead.
For instance, a transcript of your commands and the system's output
may provide this information.  (A transcript is @strong{much} more
useful than a vague description; don't just give English when you can
give a more precise specification instead.)
It is crucial that you not omit steps in your report.  Do not force the
developers to speculate about what you did; that is a waste of their
time, since you already have the knowledge.
@item
input files that permit the problem to be replicated (by following the
detailed steps in your bug report).  The
most important thing is the original, uninstrumented source files.
It is also helpful to include instrumented source files,
@file{.decl} files, and @file{.dtrace} files.
@item
any other information that you consider relevant.
@end itemize

When users provide an inadequate bug report, 
it is frequently more difficult for us to reproduce an error than to correct
it.  If you make it easy for us to reproduce and verify the problem, then it is
much more likely to be corrected.

You may also wish to take advantage of the Daikon mailing lists
(@pxref{Mailing lists}).


@node    Known bugs, Further reading, Reporting bugs, Troubleshooting
@section Known bugs

@c @c Use the following if there are no known problems.
@c There are no outstanding user-reported problems at this time.

@c The following problems are already known.  (You may report them again,
@c to encourage us to fix them faster, if the problems are important to you.)

@itemize @bullet
@item
This problem affects @ref{Annotate} and the @ref{Runtime-check
instrumenter}, which output Java source code. If
the java file to be annotated/instrumented uses logical
shift operators (@code{>>}, @code{<<}, and @code{>>>}), the 
annotated/instrumented java may contain extra brackets in these
operators. For example, the expression @code{x << y} in the input source
file may erroneously be translated as @code{x <<<<<< y} in the
annotated/instrumented file.

This error's presence will be immediately apparent if you try to compile
the annotated/instrumented file and it fails to compile because the
extra brackets make it syntactically illegal. In this case, the best
solution we can recommend is that you manually fix the occurrence of the
logical shift operator.

This error is caused by a bug in the parser generator that generates
Daikon's Java parser. We expect it will be fixed by the next release.
@end itemize

@node    Further reading,  , Known bugs, Troubleshooting
@section Further reading

More information on Daikon can be found in the Daikon Developer Manual
(@pxref{Top,,,./developer,Daikon Developer Manual}).
For instance, the Daikon Developer Manual indicates how to extend
Daikon with new invariants, new derived variables, and front ends for
new languages.  It also contains information about the implementation
and about how to debug.

You may find discussions on the mailing lists (@pxref{Mailing lists})
helpful.  The mailing list archives may contain helpful information, but
we strive to incorporate that information in this manual so that you
don't have to search the archives as well.

For further reading, see the list of publications at the 
Daikon homepage, @uref{http://pag.csail.mit.edu/daikon/pubs/}.


@node    Details, File formats, Troubleshooting, Top
@chapter Details

The Daikon invariant detector is named after an Asian radish.
``Daikon'' is pronounced like the combination of the two one-syllable
English words ``die-con''.

More information on Daikon can be found in the Daikon Developer Manual
(@pxref{Top,,,./developer,Daikon Developer Manual}).
For instance, the Daikon Developer Manual indicates how to extend
Daikon with new invariants, new derived variables, and front ends for
new languages.  It also contains information about the implementation
and about debugging flags.


@menu
* History::                     
* License::                     
* Mailing lists reminder::      
* Credits::                     
@end menu

@node    History, License, Details, Details
@section History
@cindex history of Daikon

This manual describes Daikon version 4.1.3, released July 1, 2005.
A more detailed list of revisions since mid-2001 can be found in file
@file{daikon/doc/CHANGES} in the distribution; this section gives a
high-level view of the package's history.

There have been four major releases of Daikon, with different features
and capabilities.  User experiences and technical papers should be
judged based on the version of Daikon current at the time of use.

@cindex Lisp front end
@cindex front end for Lisp
@c @cindex loop heads, instrumenting
@c @cindex instrumenting loop heads
@cindex Python implementation of Daikon
@cindex Daikon 1

Daikon 1 was written in the Python programming language in 1998.  It included
front ends for C, Java, and Lisp.  The C front end was extremely limited
and failed to operate correctly on all C programs:  sometimes it
suffered a segmentation fault while instrumenting a target program, and even
when that did not happen, sometimes the instrumented program
segmentation-faulted while running.  The Lisp front end operated
correctly on all Lisp programs, but only instrumented certain common
constructs, leaving other language features uninstrumented.  The Java front
end was reasonably reliable.  The Lisp front end instrumented procedure
entries, exits, and loop heads; the C front ends instrumented only
procedure entries and exits; and the Java front end instrumented program
points for object invariants as well as procedure entries and exits.

Daikon 2 was a complete rewrite in the Java programming language and was
the first version to contain a substantive manual.  Daikon 2 uses the
same source-based Java front end as did Daikon 1, though with certain
enhancements.  Its C front end was rewritten from scratch; it
instruments only procedure entries and exits.  A front end also exists
for the IOA programming language, but is not included in the Daikon
distribution.

Daikon 3 is a redesign of the invariant detection engine to work
incrementally --- that is, to examine each sample (execution of a
program point) once, then discard it.  By contrast, Daikon 1 and
Daikon 2 made multiple passes over the data.  This simplified their
algorithms but required storing all the data in memory at once, which
was prohibitive, particularly since data trace files may be gigabytes
in size.  Daikon 3 also introduces the idea of a @emph{dataflow
hierarchy}, a way to relate and connect program points based on their
variables.

Daikon 4 includes new binary front ends for Java and for C.  These front
ends make Daikon much easier to use.  Daikon 4 makes @file{.decls} files
optional; program point declarations are permitted to appear in
@file{.dtrace} files.  Daikon 4 is released under more liberal licensing
conditions that place no restrictions on use.


@node    License, Mailing lists reminder, History, Details
@section License

@cindex license

Copyright @copyright{} 1998-2005 Massachusetts Institute of Technology

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

The names and trademarks of copyright holders may not be used in
advertising or publicity pertaining to the software without specific prior
permission. Title to copyright in this software and any associated
documentation will at all times remain with the copyright holders.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT@.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE@.


@c As a condition of use, you agree to promptly communicate any changes,
@c improvements, or enhancements to the authors for inclusion in a
@c future release, and to promptly report any errors, problems, or
@c bugs. 
@c Other licensing terms are available;
@c send mail to @email{mernst@@csail.mit.edu}.

@sp 1

Daikon uses the Java port of the GNU getopt library, which is
copyright 1998 Aaron M.@: Renn.  The getopt library is free software, and
may be redistributed or modified under the terms of the GNU Library
General Public License version 2.  A copy of this license is included
with the Daikon distribution as the file
@file{java/gnu/getopt/COPYING.LIB}.

Daikon's unit tests use the JUnit testing framework, which is governed
by the Common Public License, version 1.0.  JUnit is provided on an
``as is'' basis, without warranties or conditions of any kind, either
express or implied including, without limitation, any warranties or
conditions of title, non-infringement, merchantability or fitness for
a particular purpose.  Neither the Daikon developers nor the authors of
the JUnit framework shall have any liability for any direct, indirect,
incidental, special, exemplary, or consequential damages (including
without limitation lost profits), however caused and on any theory of
liability, whether in contract, strict liability, or tort (including
negligence or otherwise) arising in any way out of the use or
distribution of JUnit or the exercise of any rights granted in
the Common Public License, even if advised of the possibility of such
damages.  Those portions of JUnit that appear in the Daikon
distribution may be redistributed under the same terms as Daikon
itself; this offer is made by the Daikon developers exclusively and
not by any other party.  The Common Public License is included with the
Daikon distribution as the file @file{java/junit/cpl-v10.html}.

Note that the front ends discussed in this manual are separate
programs, and some are made available under different licenses.
@c All
@c of the software in the main Daikon distribution is made available
@c under the same license as the Daikon tool proper, or a less
@c restrictive license.  However, 
Because the front ends are separate
programs not derived from the Daikon invariant detection tool, you are
neither required nor entitled to use the Daikon invariant detector
itself under these other licenses.

The Daikon Perl front end dfepl may be used and distributed under the
regular Daikon license or, at your option, either the GNU General
Public License or the Perl Artistic License (that is, under the same
terms as Perl itself).

The Daikon dynamic C front end Kvasir is based in part on the Valgrind
dynamic program supervision framework, copyright 2000-2004 Julian
Seward, the Sparrow Valgrind tool, copyright 2002 Nicholas Nethercote,
the MemCheck Valgrind tool, copyright 2000-2004 Julian Seward, and the
readelf program of the GNU Binutils, copyright 1998-2003 the Free
Software Foundation, Inc.  Kvasir is free software; you can
redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
Kvasir is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE@.  See the GNU General Public License
for more details.  You should have received a copy of the GNU General
Public License along with Kvasir, in a file kvasir/COPYING;
if not, write to the Free
Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA@.


@node    Mailing lists reminder, Credits, License, Details
@section Mailing lists reminder

If you use Daikon, please subscribe to the daikon-announce and
daikon-discuss mailing lists (@pxref{Mailing lists}).  The
daikon-announce list will inform you of new versions, enhancements,
and bug fixes.  On the daikon-discuss mailing list, you can obtain
help from, and offer help to, other users.  We would also appreciate a
brief description of how you are using Daikon, sent to
@email{daikon-developers@@lists.csail.mit.edu}.  We are curious about how
users exploit Daikon, and we are eager for anecdotes about its
successes and failures, so that we can make Daikon more effective for
its users.


@node    Credits,  , Mailing lists reminder, Details
@section Credits

@cindex contributors to Daikon

The following individuals have contributed to Daikon:
Yuriy Brun,
Jake Cockrell,
David Cok,
Adam Czeisler,
Brian Demsky,
Alan Donovan,
Nii Dodoo,
Alan Dunn,
Michael Ernst,
Eric Fellheimer,
William Griswold,
Philip Guo,
Melissa Hao,
Michael Harder,
Lee Lin,
Greg Jay,
Josh Kataoka,
Sandra Loosemore,
Vikash Mansinghka,
Stephen McCamant,
Samir Meghani,
Benjamin Morse,
Jelani Nelson,
Ryan Newton,
Jeremy Nimmer,
Toh Ne@w{ }Win,
David Notkin,
Carlos Pacheco,
Kathryn Shih,
Matthew Tschantz,
Iuliu Vasilescu,
Chen Xiao,
Tao Xie.

Craig Kaplan carved the Daikon logo.

The feedback of Daikon users has been very valuable.  We are
particularly grateful to
B. Thomas Adler,
Rich Angros,
Tadashi Araragi,
Seung Mo Cho,
Christoph Csallner,
Dorothy Curtis,
Diego Garbervetsky,
Madeline Hardojo,
Engelbert Hubbers,
Scott McMaster,
Alex Orso,
Manos Renieris,
Rosie Wacha.
Many others have also been generous with their feedback, for which we
are also grateful.

If your name has been inadvertently omitted from this section, please
let us know so we can correct the oversight.

Financial support has been provided by:
National Science Foundation (NSF),
Defense Advanced Research Projects Agency (DARPA),
Edison Design Group,
IBM,
NTT,
MIT Oxygen Project,
Raytheon,
Toshiba.


@node     File formats, Index, Details, Top
@appendix File formats

@cindex file formats

This chapter contains information about the file format of Daikon's input
files.  It is of most information to those who
wish to write a front end (@pxref{Front ends}), enabling Daikon to
detect invariants in another programming language.

Daikon's input is conventionally one or more @file{.dtrace} data trace
files.  There are two basic types of records that can appear in Daikon's
input:  program point declarations, and trace records.

A declaration describes the structure of the trace records.  One
declaration is required for each instrumented program point --- that is,
each program point for which a trace record may appear.  Each
declaration names a program point and lists the variables at that
program point.

A data trace record (also known as a ``sample'')
represents one execution of a program point.  The
record names the program point and gives the runtime values of each
variable.  The list of variables in the data trace record must be
identical to that in the corresponding declaration.  The program point
declaration must precede the first data trace record for the program
point, but it is not required that all the program point declarations
appear before any of the data trace records.  Each program point may be
declared only once; re-declarations (even identical ones) are not
currently permitted.

Instead of placing both declarations and data trace records in a single
file, it is permitted to place the declarations in one or more
@file{.decls} ``declaration files'' while leaving the data trace records
in the @file{.dtrace} file.  This can be convenient for tools that
perform a separate instrumentation step, such as dfepl (@pxref{dfepl}),
dfej (@pxref{dfej}), and dfec (@pxref{dfec}).  Such a tool takes as
input a target program to be analyzed, and produces two outputs:  a
@file{.decls} file and an instrumented program.  Executing the
instrumented program produces a @file{.dtrace} file containing data
trace records for all the program points that appear in the
@file{.dtrace} file.  This approach works fine and is easier to
implement in certain situations, but has a few disadvantages.  It
requires the user to perform at least two steps --- instrumentation and
execution --- and the existence of two versions of the program
(instrumented and uninstrumented) can lead to confusion or extra work.
It is also more convenient to have a single file that contains all
information about a program, rather than multiple @file{.decls} files
that must be associated with the @file{.dtrace} file.


@menu
* Conventions::                 
* Declarations::                
* Data trace records::          
* Example files::               
@end menu

@node    Conventions, Declarations, File formats, File formats
@section File format conventions


Daikon files are textual, to permit easier viewing and editing by humans.
Each record is separated by one or more blank lines.
To permit easier parsing by programs, each piece of information in a record
appears on a separate line.

Outside a record, any line starting with a pound sign (#) is ignored as
a comment.  Comments are not permitted inside a record.


@node    Declarations, Data trace records, Conventions, File formats
@section Declarations

@cindex declaration format
@cindex .decls file

A declarations file can contain program point declarations,
@code{VarComparability} declarations, and @code{ListImplementors declarations}.

@menu
* Program point declarations::  
* pptname format::              
* VarComparability declaration::  
* ListImplementors declaration::  
@end menu

@node    Program point declarations, pptname format, Declarations, Declarations
@subsection Program point declarations

The format of a program point declaration is:
@example
DECLARE
program-point-name
varname1
declared-type1 [# auxiliary-information1]
representation-type1 [= constant-value1]
comparable1
varname2
declared-type2 [# auxiliary-information2]
representation-type2 [= constant-value2]
comparable2
...
@end example

Program point information includes:
@itemize @bullet
@item
name (``tag'') of this program point, an arbitrary string containing no
tab or newline characters.  This name contains information such as the
class name or method name; what information is contained depends on
which instrumenter is being used.  @xref{pptname format}, for a full
specification of the naming format.

By convention, the entry and exit points for a function have names of
a special form so that they can be associated with one another.
(Currently, those names end with @code{:::ENTER} and @code{:::EXIT}.)  This
convention permits Daikon to generate pre-state variables 
(@pxref{Variable names}) automatically at procedure exit points, so 
front ends need not output them explicitly.  When there
are multiple exit points, then each one should be suffixed by a number
(such as a line number, for example, @code{foo::EXIT22}).  Daikon produces
the main (non-numbered) @code{:::EXIT} point automatically.  All the
numbered exits should contain the same set of variables; in general,
this means that local variables are not included at exit points.
Daikon currently requires that declarations for @code{:::ENTER} program
points appear before any declarations for matching @code{:::EXIT} program
points.

Another convention is to have another program point whose name ends
with @code{:::OBJECT} for the representation invariant of an object or
class.  This program point is not created automatically, because
there isn't a way to know whether a particular method is a private
helper method or not --- that is, whether the representation
invariants should hold on entry to and exit from it.

@item
for each variable:
@itemize @bullet
@item
name: a string containing no tabs or newlines.  For the most part,
the variable name can be any string, except that the period character,
square brackets, and parentheses have special meanings.  (The exact
requirement is that the VarInfoName @code{parse} method must be able
to parse the name).   A pair of empty square brackets (@samp{[]}) represents
an array-valued variable.  For instance, @samp{a} might stand for the array
object itself (appearing in the trace file as a unique ID or
hashcode), and @samp{a[]} would stand for the array contents (appearing in
the trace file as a sequence of values).  Otherwise, square brackets
represent selecting an element of a sequence (as in the C or Java
array access operator); the index should not itself contain square
brackets.  A period character represents field access, and any field
name is allowed, except for the restrictions above and the special
case that a field named @samp{class} represents the type of a value.
Parentheses once had a special meaning to Daikon, but now should not be used.

@item
declared type: this is what the programmer used in the declaration of
the variable.  Array types must be suffixed by the proper number of
@samp{[]} to indicate their dimensionality.  Names for standard types
should use Java's names (e.g., @code{int}, @code{boolean}, etc.), but names for
user-defined or language-specific types can be arbitrary strings.

@item
auxiliary information: optionally, Daikon can be given information
about the meaning of the variable to help it better interpret the
values it later sees.  Information is provided as a comma-separated
list of items, with each item in the form of @samp{key = value}.  Unrecognized
keys are silently ignored.  All values are
either @samp{true} or @samp{false}.  Mainly, this information is used for
collections, which are presented to Daikon as arrays.  Valid keys are:

@table @code

@item hasDuplicates 
Whether a collection can contain duplicates.  If it
cannot, Daikon does not check for some invariants that only have
meaning for collections that can contain duplicate elements.

@item hasOrder
Whether order has meaning for a collection.  If order does
not have meaning in a collection, then Daikon does not check for
element-wise comparisons between it and other collections.  

@item hasNull 
Whether zero has the special meaning null for the variable or
collection.  If it does, then Daikon checks for whether a value or the
elements in a collection are null.

@item nullTerminated
Whether a collection has a value (usually null) that
ends its representation.  If it does, then Daikon looks at the
collection's size and at the collection's size-1 as ``interesting''
values.  If it does not, then Daikon only looks at the collection's
size.

@item isParam
Whether a given variable is a parameter to a method.  If a
variable is a parameter, Daikon avoids printing some information that
would be considered uninteresting for parameters.  First, invariants
that use the parameter variable @code{p} in its post-state form are not
printed.  Second, invariants that use fields of @code{p} (such as @code{p.x}) 
are printed only if @code{p} has not changed.  Lastly, some immutable
characteristics, such as the size of arrays and data types are not
printed (both can be changed if @code{p} is changed, but then, @code{p} 
would no longer be interesting).

@end table

@item
representation type:  this describes what will appear in the data
trace file.  For instance, the declared type might be @code{char[]} but
the representation type might be @code{java.lang.String}.  Or, the declared
type might be @code{Object} but the representation type might be
@code{hashcode}, if the address of the object is written to the data trace
file.

The representation type should be one of @code{boolean}, @code{int},
@code{hashcode}, @code{double}, or @code{java.lang.String}; or an
array of one of those (indicated by a @code{[]} suffix, as in Java).
Hashcodes are treated like integers, except that their actual values
are considered uninteresting for the purposes of output; they are
intended for unique object identifiers like memory addresses or the
return value of Java's @code{Object.hashCode} method.

The representation type may optionally be followed by an equals
sign and a value; in that case, the variable is known to have a
compile-time constant value and should be omitted from the data
trace file.
@end itemize
@item
@cindex comparability, for variables
@cindex variable comparability
comparable variables.  These indicate
which other variables are comparable to this one, which is typically
obtained via type-inference based analysis.

A comparability for a non-array type is a signed integer.  Two variables
at the same program point
are considered comparable if both integers are the same, or if either
integer is negative.are 
A comparability for an array type may contain an
integer for each index and for the contents; for instance, @samp{5[22][17]}
for a two-dimensional array.  Comparisons succeed if comparisons over
each component succeed.

Variables at different program points are never compared to one another.
Use of the same number at different program points does not indicate any
relationship between the variables, and a given variable may have a
different comparability integer at different program points.

If no comparability information is supplied (i.e., this line is blank), then
the variable is considered comparable to all other variables of the same type.

As an example, in the following code:
@example
int sum(int len, int[] a) @{
  int sum=0;
  for (int i=0; i++; i<len)
    sum += a[i];
  return sum;
@}
@end example
variables @code{i} and @code{len} are comparable to one another (and
to indices of array @code{a}).  Furthermore, the result is comparable
to the elements of array @code{a}.  A declaration file for these
variables might look like
@example
len
int
int
5
a
int[]
int[]
8[5]
return
int
int
8
@end example

@end itemize

@c Future enhancements may include:
@c @itemize @bullet
@c @item
@c permit variables to be omitted if they haven't changed (but always
@c outputting the bit permits us to write a sanity checker)
@c @item
@c permit variables to appear in any order (not sure this is so worthwhile)
@c @item
@c specify which @file{.decl} files should be used (including their pathnames
@c and/or MD5 hashes)
@c @end itemize

@node    pptname format, VarComparability declaration, Program point declarations, Declarations
@subsection Program point name format specification

Instrumenting code creates a @file{.decls} file that contains program
point names such as:

@example
DataStructures.StackAr.push(java.lang.Object):::ENTER
DataStructures.StackAr.push(java.lang.Object):::EXIT99
PolyCalc.RatNum.RatNum(int, int):::ENTER
PolyCalc.RatNum.RatNum(int, int):::EXIT55
PolyCalc.RatNum.RatNum(int, int):::EXIT67
@end example

This section describes the format of these program point names.  Someone
writing an instrumenter for a new language must be sure to follow this
format specification.

A program point name is a string with no tabs or newlines in it.  The basic
format is @samp{@var{topLevel}.@var{bottomLevel}:::@var{pptInfo}}.
For the first example given above, the top level of the hierarchy would
be @code{StackAr}, the bottom level would be @code{makeEmpty()V}, and the
program point information would be @code{EXIT54}.

@var{topLevel} and @var{bottomLevel} can represent anything.  Currently,
for Java, @var{topLevel} consists of the class name while
@var{bottomLevel} consists of the method name and method signature.  For
C, @var{topLevel} could consist of a filename and @var{bottomLevel}
could consist of a method name and signature.  For IOA, @var{topLevel}
could consist of an Automaton name and @var{bottomLevel} could consist of
information for a transition state.

@var{topLevel} may contain any number of periods (@samp{.}). @var{bottomLevel}
and @var{pptInfo} may not contain any periods.  The string @samp{:::} may only
appear once.

@var{topLevel} and @var{pptInfo} are required (i.e., they must be non-empty),
as are the period to the right of @var{topLevel} and the colons to the
left of @var{pptInfo}.  However, @var{bottomLevel} is optional.  For
example, the Java instrumenter creates an artificial object program point
which contains invariants that are true for all of an object's methods,
rather than for just one method:

@example
StackAr:::OBJECT
@end example


@node VarComparability declaration, ListImplementors declaration, pptname format, Declarations
@subsection VarComparability declaration

There is a special @code{VarComparability} declaration that controls how
the comparability field in program point declarations is interpreted.
The default @code{VarComparability} is @code{implicit}, which means
ordinary comparability as described in @ref{Program point declarations}.
(The name @code{implicit} is retained for historical reasons.)
You can override it as
follows:
@example
VarComparability
none
@end example
@noindent
As with all records in Daikon input files, a
blank line is required between this record and the next one.

@node ListImplementors declaration,  , VarComparability declaration, Declarations
@subsection ListImplementors declaration

This declaration can be used to indicate classes that implement the
@code{java.util.List} interface, and should be treated as sequences
for the purposes of invariant detection.  The syntax is as follows:

@example
ListImplementors
classname1
classname2
...
@end example

The @samp{--list_type} command-line option to Daikon can also be used to
specify classes which implement lists; see
@ref{Options to control invariant detection}, for information.


@node    Data trace records, Example files, Declarations, File formats
@section Data trace records

@cindex data trace format
@cindex .dtrace file

The format of the value information in a data trace record (also known
as a ``sample'') is:
@example
program-point-name
varname1
var-value-1
var-modified-1
varname2
var-value-2
var-modified-2
...
@end example

Value information includes:
@itemize @bullet
@item name of the program point

@item for each variable:
@itemize @bullet
@item name
@item value
@itemize @bullet
@item    integer: sequence of digits, optionally preceded by a minus sign.
Boolean values are written as the number 0 (for false) or the number 1
(for true).
@item    string: characters surrounded by double-quotes; internal
double-quotes and backslashes are escaped by a backslash; newlines and
carriage returns are represented as @samp{\n} and @samp{\r}, respectively
@item    array: elements are listed on one line, separated by spaces.
The entire array contents are in square brackets.  (Also, the array name
should end in @samp{[]}; use @samp{a[]} for array contents, 
but @samp{a} for the identity of the array itself.)
@end itemize

@cindex nonsensical values for variables
The value may also be the string @code{nonsensical}.
That means that the variable does not have a value because
the expression that computes it cannot be evaluated.  For instance, if
variable @code{a} has value @code{null}, then variable @code{a.b} would
have value @code{nonsensical}.  When the value is @code{nonsensical}, the
modified field should be 2.

@item modified? (0, 1, or 2).
@cindex modified bit
This value is 0 if the variable has not been assigned to since the
last time this program point was executed, and 1 if the variable has
been assigned to since then.  It is safe for an implementation to
always set it to 1.  It is also safe to always set it to 0, because
Daikon corrects obviously incorrect modification bits (such as 0 for a
never-before-seen value).

The special value 2 should be used only (and always) when the value
field is @code{nonsensical}.

@end itemize

The variables should appear in the same order as they did in the
declaration of the program point, without omissions or additions.
@end itemize

@cindex nonce, invocation
@cindex this_invocation_nonce

As a special case, the first variable in a record may be
@code{this_invocation_nonce}, in which case there is no modification
information, only a value.  The nonce is used to match up procedure entries
(whose names end with @code{:::ENTER}) with procedure exits (whose names end
with @code{:::EXIT}); this is necessary in concurrent systems because there may
be several invocations of a procedure active at once and they do not
necessarily follow a stack discipline, being exited in the reverse order of
entry.  For non-concurrent systems, this nonce is not necessary and may be
omitted.


@node    Example files,  , Data trace records, File formats
@section Example files

Here are portions of two files @file{StackAr.decls} and
@file{StackAr.dtrace}, for a Java class that implements a stack of
integers using an array as the underlying data structure.  You can see
many more examples by simply running an existing front end on some Java,
C, or Perl programs and viewing the resulting files.

@menu
* Example declaration file::    
* Example data trace file::     
@end menu


@node    Example declaration file, Example data trace file, Example files, Example files
@subsection Example declaration file

This is part of the file @file{StackAr.decls}, a declaration file for
the @file{StackAr.java} program (@pxref{StackAr example}).

@example
DECLARE
StackAr.push(java.lang.Object):::ENTER
x
Object
int
1
x.class
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr.push(java.lang.Object):::EXIT96
x
Object
int
1
x.class
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr:::OBJECT
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0
@end example


@node    Example data trace file,  , Example declaration file, Example files
@subsection Example data trace file

This is part of file @file{StackAr.dtrace}, which you can create by
running the instrumented @file{StackAr.java} program (@pxref{StackAr
example}).  This excerpt contains only the first two calls to
@code{push} and the first return from @code{push}, along with the
associated object program point records; omitted records are indicated
by ellipses.


@example
...

StackAr.push(java.lang.Object):::ENTER
this_invocation_nonce
55
x
1217030
1
x.class
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.class
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.class
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

...

StackAr.push(java.lang.Object):::EXIT96
this_invocation_nonce
55
x
1217030
1
x.class
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.class
"java.lang.Object[]"
1
this.theArray[]
[1217030]
1
this.theArray[].class
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.class
"java.lang.Object[]"
1
this.theArray[]
[1217030]
1
this.theArray[].class
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

...

StackAr.push(java.lang.Object):::ENTER
this_invocation_nonce
94
x
1482257
1
x.class
"DataStructures.StackAr"
1
this.theArray
350965
1
this.theArray.class
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
350965
1
this.theArray.class
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

...
@end example



@node     Index,  , File formats, Top
@unnumbered Index

@printindex cp


@bye

@c  LocalWords:  texinfo setfilename daikon settitle MDE texi html daikonurl sp
@c  LocalWords:  inlined makeinfo daikonemail setchapternewpage ifinfo hboxes
@c  LocalWords:  finalout titlepage titlefont eps pdf txt png jpg vskip pt img
@c  LocalWords:  filll src alt ifnothtml dir ifnottex GUIs ifhtml detailmenu pl
@c  LocalWords:  Cygwin StackAr Diff orig dfepl CSV convertcsv dfej dfec gcc cd
@c  LocalWords:  applets EDG spinfo InvariantChecker LogicalCompare dtrace inv
@c  LocalWords:  runtimechecker javac Lackwit pptname uref abs lst treenode IOA
@c  LocalWords:  myArray PathFinder pxref cindex samp classpath xref var wget
@c  LocalWords:  daikonparent zxvf noindent csh tcsh cshrc setenv zxf DAIKONDIR
@c  LocalWords:  DAIKONCLASS bashrc java cpp daikonenv HKEY AutoRun pathlists
@c  LocalWords:  CompletionChar PathCompletionChar subsubsection MYDOCU ENV arg
@c  LocalWords:  DataStructures dotfiles ActiveState mypackage MyClass emph Xmx
@c  LocalWords:  StackArTester PrintInvariants theArray topOfStack Ljava gdwarf
@c  LocalWords:  kvasir decls Valgrind config Rijndael rijndaeltest perl bday
@c  LocalWords:  dtype standalone decl asis noversion num conf nohierarchy ppt
@c  LocalWords:  dbg mem stat postprocessed itemx mux pre val classname regexp
@c  LocalWords:  ListImplementors dataflow getLogger JML jml hashcode DBC Jtest
@c  LocalWords:  Parasoft's Quant ESC prestate int seq elt Javadoc JVML param
@c  LocalWords:  DerivedParameterFilter ObviousFilter args ParentFilter isEmpty
@c  LocalWords:  OnlyConstantVariablesFilter SimplifyFilter UnjustifiedFilter
@c  LocalWords:  UnmodifiedVariableEqualityFilter diff OneOf InvMap repr gui td
@c  LocalWords:  invSortComparator invPairComparator daikonHelp ifnotinfo gif
@c  LocalWords:  InvariantsDisplay Ctrl ControlPanel checkbox kbd JDE prj jde
@c  LocalWords:  autoload myA myList hashcodes MyA HashSetLinear HslIterator IA
@c  LocalWords:  topAndPop init util DTRACEFILE DTRACEAPPEND Valgrind's AMD gz
@c  LocalWords:  Athlon fomit Kvasir's programname vars gzip fifo FIFOs AFS csv
@c  LocalWords:  stdout stderr disambig myprog Debian libfoo inst pragma prog
@c  LocalWords:  workflow accessor instr instrsourcedir TYPESAPPEND basedir cp
@c  LocalWords:  myfile dfej's classfiles jikes ajaxap QueueAr QueueArTester ln
@c  LocalWords:  classhier decldir instrdir uninst ajax csal apdir ajaxcp cpdir
@c  LocalWords:  ComparablePairsDescFileReader runnables ajaxdumpdir dumpdir rm
@c  LocalWords:  DTRACELIMIT DTRACELIMITTERMINATE DDTRACELIMIT applet xargs mv
@c  LocalWords:  DDTRACELIMITTERMINATE javaPolicy appletviewer MyProgram exe lw
@c  LocalWords:  datatypes intValue ListNode theElement precompiled Solaris cc
@c  LocalWords:  libw LDFLAGS xname textfile nogui daikonarg nocleanup tarfile
@c  LocalWords:  TODO DFECDIR exefile tracefilename stdc dfec's preprocessed wc
@c  LocalWords:  ctype sed declsfiledir declsfiledirflat searchpath includepath
@c  LocalWords:  GNUG disambigfilename mdas memset subarrays lackwit unsetting
@c  LocalWords:  postprocessing structs pcc gzipped zlib baz ints std min rray
@c  LocalWords:  ointer ifdef endif DaikonSmartPointer DaikonSmartArray malloc
@c  LocalWords:  mystring strcpy strcat smartpointers basemap namespace ansi eq
@c  LocalWords:  protoize fallback fixups const asm inline typeid typename bool
@c  LocalWords:  bitand bitor compl wchar xor unportable enums enum stdlib env
@c  LocalWords:  getenv bitfields bitfield realloc memcpy textutils pos lseek
@c  LocalWords:  fd Linux's GNUC mkdir tmp gunzip xf li dkconfig CreateSpinfo
@c  LocalWords:  ParameterDoclet CreateSpinfoC un biconditional addAll isFull
@c  LocalWords:  smallexample simpleStack currentSize jtb ParseException kmeans
@c  LocalWords:  runcluster xm ALG xmeans TraceSelect NOCLEAN DIFFS MergeESC pp
@c  LocalWords:  escannotated jmlannotated dbcannotated Annnotate xml INVINFO
@c  LocalWords:  ubs Throwable throwable rethrown WriteViolationFile MyProg cfg
@c  LocalWords:  callMethod isDaikonInstrumented getDaikonInvariants INVS ijmp
@c  LocalWords:  bBoOmjpi de iconv undefine DHAVE Xie Ast rt JDKDIR MyPackage
@c  LocalWords:  superdirectory SOURCEPATH InvalidClassDataError strace lstat
@c  LocalWords:  RuntimeException IFLNK interconvert interconvertible strdup ld
@c  LocalWords:  lwpp ine runtime's malloced MaxPermSize JVM's MyVector perc vv
@c  LocalWords:  falsetime trueinvs testsuite MergeInvariants fns untruncate mx
@c  LocalWords:  subsubheading bzip fontspecific sublicense NONINFRINGEMENT Cok
@c  LocalWords:  getopt Renn Nethercote MemCheck readelf Binutils Yuriy Brun ps
@c  LocalWords:  Cockrell Czeisler Demsky Nii Dodoo Fellheimer Griswold Guo Hao
@c  LocalWords:  Kataoka Loosemore Vikash Mansinghka Samir Meghani Jelani Toh
@c  LocalWords:  Nimmer Shih Iuliu Vasilescu Xiao Kaplan Angros Tadashi Araragi
@c  LocalWords:  Seung Cho Hardojo Engelbert Hubbers McMaster Orso Manos Wacha
@c  LocalWords:  Renieris NTT varname VarInfoName hasDuplicates hasOrder len
@c  LocalWords:  hasNull nullTerminated isParam hashCode VarComparability IDE
@c  LocalWords:  makeEmpty topLevel bottomLevel pptInfo MyInteger printindex
@c  LocalWords:  cygwin basename globalVar staticVar funcStaticVar myName foo
@c  LocalWords:  TerminationMessage HotSpot daikonPrintArrayMissing javacc invs
@c  LocalWords:  sourcing toString struct uninstrumented Garbervetsky classfile
@c  LocalWords:  UnsupportedClassVersionError DtraceDiff VerifyError procedurei
@c  LocalWords:  replacementi junit declsfiles dtracefile PublicTest BCEL bcel
