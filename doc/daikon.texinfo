\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename daikon.info
@settitle The Daikon Invariant Detector User Manual
@c %**end of header

@c To update all the nodes and menus all at once:   C-u C-c C-u m
@c You shouldn't need to do that, though; the Makefile does it for you.

@c I can't get this to work, don't know why.  MDE 4/2001.
@c @alias directory = file

@c texi2html doesn't work if I use this macro
@c @macro daikonurl{}
@c http://pag.lcs.mit.edu/daikon/
@c @end macro

@c Problem: with texinfo 4.0, the HTML formatting leaves the "{}" after
@c uses of the macro.  (Formatting seems fine for info, for printing, etc.)
@c So for now, I have inlined all instances of the macro.  Yuck.
@c Another solution would be to use "makeinfo -E" (then process the
@c resulting file with "makeinfo --html").
@macro daikonemail{}
@email{daikon-developers@@pag.lcs.mit.edu}
@end macro

@c @setchapternewpage odd

@c @ifinfo
@c This is a short example of a complete Texinfo file.
@c 
@c Copyright 1990 Free Software Foundation, Inc.
@c @end ifinfo

@c avoid black boxes marking overfull hboxes in TeX output
@finalout

@titlepage
@sp 10
@c Could also use @title, @subtitle, @author here.
@center @titlefont{Daikon Invariant Detector User Manual}

@sp 2
@center Daikon version 2.5.3

@sp 1
@c Daikon version 2.5.3 date
@center October 1, 2003

@sp 5
@c reads daikon-logo.{eps,pdf} (not .txt, .png, or .jpg, because info
@c and HTML don't get the title page)
@image{images/daikon-logo,4in,}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998-2003
@c Copyright @copyright{} 1998-2001 Michael Ernst
@end titlepage

@html
<img src="images/daikon-logo.gif" alt="Daikon logo">
@end html
@c Why is this here? It duplicates the stuff further down.
@c @html
@c <h1>Daikon Invariant Detector User Manual</h1>
@c
@c This is the user manual for the Daikon invariant detector.
@c It describes Daikon version 2.5.3, released October 1, 2003.
@c @end html

@c Putting this lower in the HTML version looks a little bit strange,
@c but it's acceptable. 
@ifnothtml
@contents
@end ifnothtml

@node    Top, Introduction, (dir), (dir)
@comment node-name, next,          previous, up

@ifnottex
@c Unfortunately, the Daikon logo doesn't look good in ASCII.
@c @ifinfo
@c @image{images/daikon-logo,4in,}
@c 
@c @end ifinfo
This is the user manual for the Daikon invariant detector.
It describes Daikon version 2.5.3, released October 1, 2003.
@end ifnottex

@menu
* Introduction::                
* Installing Daikon::           
* Example use::                 
* Detecting invariants::        
* Daikon output::               
* GUIs::                        
* Front ends::                  
* Enhancing Daikon output::     
* Tools::                       
* Troubleshooting::             
* Details::                     
* File formats::                
* Index::

@ifhtml
@contents
@end ifhtml
@ifnothtml

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Mailing lists::               

Installing Daikon

* Installing dfej::             
* Installing dfec::             
* Installing the Context GUI::  
* Requirements::                

Installing dfec, the Daikon front end for C

* dfec EDG sources::            

Requirements for running Daikon

* Windows requirements::        

Windows requirements for running Daikon

* Cygwin environment variables::  

Example use of Daikon

* Step-by-step instructions::   
* Summary of Daikon use::       
* Automating the process::      
* Understanding the invariants::  
* Second Java example::         
* C examples::                  
* Perl examples::               

C examples

* C examples summary::          
* Rijndael example::            

Using Daikon to detect invariants

* Instrumentation::             
* Run the instrumented program::  
* Detect invariants::           
* All-in-one script::           

Instrumentation

* Instrumenting Java programs::  
* Instrumenting C programs::    
* Instrumenting Perl programs::  

Run the instrumented program

* Run Java::                    

Details on running instrumented Java programs

* Java applets::                

Detect invariants in the data trace files

* Command line options::        

All-in-one script daikon.pl

* daikon.pl arguments::         

Daikon output

* Interpreting output::         
* Printing invariants::         
* Invariant Diff::              

Interpreting Daikon output

* Program points::              
* Variable names::              
* Invariant syntax::            
* Invariant list::              

Variable names

* orig variable example::       

GUIs for displaying invariants

* Tree GUI::                    
* Context GUI::                 

Tree-structured invariant browser

* Invoking Tree GUI::           
* Invariants Display::          
* Control panel::               

Control panel

* Property filters::            
* Variable filters::            

Context GUI

* Context GUI with Emacs::      

Front ends

* Java front end dfej::         
* C front end dfec::            
* Perl front end dfepl::        
* CSV front end convertcsv.pl::  

Java front end dfej

* dfej options::                
* Scope of instrumentation::    
* Refined runtime types::       

C front end dfec

* dfec command-line arguments::  
* Daikon runtime customization::  
* Pointer type disambiguation::  
* Instrumentation scope::       
* dfec requirements::           

Pointer type disambiguation

* Pointer type disambiguation example::  

Instrumentation scope

* Memory tracking details::     
* Memory tracking in libraries::  

dfec requirements

* C program requirements::      
* Header file dependencies::    
* gcc version::                 

Perl front end dfepl

* dfepl options::               

Enhancing Daikon output

* Configuration options::       
* Conditional invariants::      
* Enhancing conditional invariant detection::  

Configuration options

* List of configuration options::  

Conditional invariants and implications

* Splitter info file::          
* Indiscriminate splitting::    
* Example splitter info file::  

Splitter info file

* Program point sections::      
* Replacement sections::        

Example splitter info file

* Example class::               
* Resulting .spinfo file::      

Enhancing conditional invariant detection

* Static analysis for splitters::  
* Cluster analysis for splitters::  

Tools

* MergeESC::                    
* MakeInvariantChecker::        
* LogicalCompare::              

Troubleshooting

* Installation problems::       
* dfej problems::               
* dfec problems::               
* Daikon problems::             
* Large dtrace files::          
* Other problems::              
* Reporting bugs::              
* Known bugs::                  
* Further reading::             

Problems with dfej

* dfej installation problems::  
* dfej invocation problems::    

Problems running dfej

* Ajax errors::                 

Problems with dfec

* dfec instrumentation problems::  
* Compilation and linking of instrumented code problems::  
* Running instrumented code problems::  

Problems running dfec

* Lackwit problems::            

Problems compiling and linking instrumented programs

* Compiler problems::           
* Linker problems::             

Problems running Daikon

* No return from procedure::    
* Out of memory::               
* Simplify errors::             
* Contradictory invariants::    
* Method needs to be implemented::  
* JVM initialization error::    
* Daikon runs slowly::          

Large data trace (.dtrace) files

* Reducing program points::     
* Reducing variables::          
* Reducing executions::         

Other problems

* Tree GUI font errors::        

Details

* History::                     
* License::                     
* Credits::                     

File formats

* Conventions::                 
* Declaration files::           
* Data trace files::            
* Examples::                    

Declaration files

* pptname format::              

Examples

* Example declaration file::    
* Example data trace file::     

@end detailmenu
@end ifnothtml
@end menu

@node    Introduction, Installing Daikon, Top, Top
@chapter Introduction

The @uref{http://pag.lcs.mit.edu/daikon, ,Daikon invariant detector}
reports likely program invariants.  An invariants is a property that
holds a a certain point or points in a program; these are often seen
in assert statements, documentation, and formal specifications.
Examples include arithmetic equations such as "x > abs(y)", "x = 3*y +
4*z - 7", or "x = 0 (mod 4)", and properties over arrays and other
collections, including those accessed via pointers.  Daikon also
reports implications (invariants whose truth depends on some other
property), such as "p != null => p.content in collection".

Invariants can be useful in program understanding and a host of other
applications.  Daikon operates by running the program and examining
the values it computes, looking for patterns and relationships among
those values.  Front ends (@pxref{Instrumentation}) exist for the
Java, C, C++, @uref{http://theory.lcs.mit.edu/tds/ioa/, ,IOA}, and
Perl languages.  Front ends also exist for other applications, such as
the @uref{http://ase.arc.nasa.gov/visser/jpf/, , Java PathFinder model
checker}.  It is easy to extend Daikon to other applications.

Daikon is freely available for most uses; for details, see
@ref{License}.

More information on Daikon can be found in the Daikon Developer
Manual.  For instance, the Daikon Developer Manual indicates how to
extend Daikon with new invariants, new derived variables, and front
ends for new languages.  It also contains information about the
implementation and about debugging flags.

@menu
* Mailing lists::               
@end menu

@node    Mailing lists,  , Introduction, Introduction
@section Mailing lists
@cindex mailing lists
@cindex daikon-announce mailing list
@cindex daikon-discuss mailing list
@cindex daikon-developers mailing list

The following mailing lists (and their archives) are available:
@table @samp
@item daikon-announce@@pag.lcs.mit.edu
A low-volume, announcement-only list.  For example,
announcements of new releases are sent to this list.
To subscribe, visit @uref{http://pag.lcs.mit.edu/daikon/download/} or
@uref{http://pag.lcs.mit.edu/mailman/listinfo/daikon-announce}.
@item daikon-discuss@@pag.lcs.mit.edu
A moderated list for the community of Daikon users.  Use it to share
tips and successes, and to get help with questions or problems (after
checking the documentation).  To subscribe, visit
@uref{http://pag.lcs.mit.edu/daikon/download/} or
@uref{http://pag.lcs.mit.edu/mailman/listinfo/daikon-discuss}.
@item daikon-developers@@pag.lcs.mit.edu
This list goes to the Daikon maintainers.  Use it for bug reports,
suggestions, and the like.  If you are an active contributor to Daikon,
you may send mail to the list asking to be added.
@end table


@node    Installing Daikon, Example use, Introduction, Top
@chapter Installing Daikon
@cindex installing Daikon

In order to install Daikon, perform the following steps.
@xref{Requirements}, for a few additional requirements running Daikon
(in short, you must be able to run Java programs, because Daikon is
written in Java).  Differences between various versions of Daikon appear
in the file @file{doc/CHANGES} in the distribution.

@enumerate
@item
Download Daikon.  It is available as a tar file from
@uref{http://pag.lcs.mit.edu/daikon/download/daikon.tar.gz}.
or as a zip file from
@uref{http://pag.lcs.mit.edu/daikon/download/daikon.zip}.
The two files contain the same information; you only need one of them.
One way to obtain Daikon is to use one of the following command lines:
@example
wget http://pag.lcs.mit.edu/daikon/download/daikon.tar.gz
@end example
@noindent
or
@example
wget http://pag.lcs.mit.edu/daikon/download/daikon.zip
@end example

@cindex anonymous CVS access to Daikon sources
Daikon is also available via anonymous CVS@.  If you desire such
access, send email to the
@email{daikon-developers@@pag.lcs.mit.edu} mailing list.

You may wish to subscribe to one of the mailing lists (@pxref{Mailing
lists}), in order to be notified of new releases or join discussions
with other Daikon users and developers.

@cindex @var{daikonparent} directory
@item
In the directory where you want to install Daikon (we'll call this
the @var{daikonparent} directory), unpack the distribution; for example:
@example
tar zxvf daikon-source.tar.gz
@end example
@noindent
or
@example
unzip daikon-source.zip
@end example
@noindent
This creates a @file{@var{daikonparent}/daikon/} subdirectory.

@item
Set up your environment.
@enumerate
@item Make your shell initialization file source the appropriate
Daikon environment file.
@itemize 
@item
@cindex C shell
@cindex csh shell
@cindex tcsh shell
If you use the csh or tcsh shell, add the
following to your @file{.cshrc} file:
@example
source @var{daikonparent}/daikon/bin/daikon.cshrc
@end example
@noindent
@item
@cindex Bourne shell
@cindex bash shell
If you use the bash shell, add the following to your
@file{.bash_profile} file:
@example
source @var{daikonparent}/daikon/bin/daikon.bashrc
@end example
@end itemize

@item
Also, you must edit the @file{daikon.cshrc} or @file{daikon.bashrc} file
to indicate the @var{daikonparent} directory and to perform any desired
customizations.  (Alternately, you may place such customizations in your
own @file{.cshrc} or @file{.bash_profile} file, just before and/or
after the @samp{source ... daikon.cshrc} or @samp{source
... daikon.bashrc} line.)
@end enumerate

@item
Execute the @command{source} command you placed in your shell
initialization file, or else log out and log back in to achieve the
same effect.

@item
Build various executables used by Daikon.  (This step is optional; you
can look in the Makefile to see what will get made.)
@example
cd $DAIKONDIR
make
@end example

@c @item
@c @cindex DAIKONCLASS_SOURCES environment variable
@c @cindex environment variable DAIKONCLASS_SOURCES
@c @cindex @file{daikon.jar}, running from
@c @cindex @file{.class} files, running from
@c If you set the environment variable DAIKONCLASS_SOURCES in
@c @file{daikon.cshrc} or @file{daikon.bashrc}, indicating that you wish to
@c compile the Daikon sources yourself, then you must now compile them.
@c @example
@c cd $DAIKONDIR/java
@c make
@c @end example

@end enumerate

@menu
* Installing dfej::             
* Installing dfec::             
* Installing the Context GUI::  
* Requirements::                
@end menu

@node    Installing dfej, Installing dfec, Installing Daikon, Installing Daikon
@section Installing dfej, the Daikon front end for Java

@cindex installing dfej
@cindex dfej installation

This manual section is optional; if you ran @command{make} from
$DAIKONDIR (@pxref{Installing Daikon}), you can skip it.

If you wish to detect invariants in Java programs, you need to obtain
or build an executable for dfej, the Daikon front end for Java.


@itemize @bullet
@item
The easiest approach is to download a precompiled version of
@command{dfej} from @uref{http://pag.lcs.mit.edu/daikon/download/}.
Place that executable in directory
@file{$DAIKONDIR/front-end/java/src} (or, alternately, elsewhere on
your path), then run @command{rehash}.  Now you are ready to run dfej.
(If no executable is available for your architecture, send mail to
@email{daikon-developers@@pag.lcs.mit.edu} and we may be able to produce an
executable for you.)

@item
Alternately, you can build dfej from the sources, which are included in
the Daikon source distribution.  
To build dfej, see file @file{INSTALL} in the dfej sources.  In
summary, you should be able to build dfej by running the following
commands:
@example
cd daikon/front-end/java
./configure
make
rehash
@end example
@noindent
after which file @file{src/dfej} (on Windows, @file{src/dfej.exe}) is
the dfej executable.  It is already on your path.

If you modify the source code for dfej (which is not recommended
unless you know what you are doing), just run @command{make} again to
build a new binary.

Because it uses some obsolescent C++ features, dfej cannot be compiled
using gcc/g++ 3.2; dfej can be compiled with gcc 2.95.3 (and possibly
other versions).

@b{Cygwin note:}  Cygwin uses gcc 3.2 by default; there is also an
option to install gcc 2.95.3.  After installing gcc 2.95.3, you can
make it the default in the following way:
@example
	cd /usr/bin
	mv gcc.exe gcc-3.exe
	mv g++.exe g++-3.exe
	cp gcc-2.exe gcc.exe
	cp g++-2.exe g++.exe
@end example

@b{Solaris note:}
If you are running under Solaris, you may need to edit
@file{Makefile} to indicate use of the @file{libw} library; change
@example
LDFLAGS=-L. -o $(EXECUTABLE)
@end example
@noindent
to
@example
LDFLAGS=-L. -lw -o $(EXECUTABLE)
@end example


@end itemize

@node    Installing dfec, Installing the Context GUI, Installing dfej, Installing Daikon
@section Installing dfec, the Daikon front end for C

@cindex installing dfec
@cindex dfec installation

For instructions on detecting invariants in C programs, @xref{C
front end dfec}.  If you wish to detect invariants in C programs,
first perform the following installation steps.

@enumerate
@item
Download the dfec distribution from
@uref{http://pag.lcs.mit.edu/daikon/download}; choose the version for
your architecture and operating system.  The distribution includes
both the dfec executable and Lackwit.  Lackwit is a variable
comparability analysis package; its use is optional, but it can make
invariant detection more accurate and efficient.
@item
Unpack the tarfile.
@example
cd $DAIKONDIR/front-end
tar zxvf dfec-linux-x86.tar.gz
@end example
@item
Compile the Daikon C runtime library.
@example
cd $DAIKONDIR/front-end/c
make
@end example
@noindent
This creates the file @file{daikon_runtime.o}; you will use it (and
@file{daikon_runtime.h}, which also appears in @file{front-end/c})
when compiling C and C++ programs in which you wish to detect invariants.
@end enumerate

For information about customizing the behavior of your instrumented
programs, @pxref{Daikon runtime customization}.

@menu
* dfec EDG sources::            
@end menu

@node    dfec EDG sources,  , Installing dfec, Installing dfec
@subsection Installing dfec from EDG sources

@cindex EDG C front end
@cindex Edison Design Group C front end

License restrictions prohibit us from distributing the source for dfec,
except to other parties who hold a license to the EDG (Edison Design
Group) C front end.  If you hold such a license, send mail to
@email{daikon-developers@@pag.lcs.mit.edu} to obtain a patch to the
EDG front end.  To build dfec for yourself, perform the following steps:
@enumerate
@item Unpack your EDG source code (which you obtained from EDG).
@example
    tar zxf edgcpfe_3.0.tar.gz
@end example
@item cd into the EDG source directory
@example
    cd release_3.0
@end example
@item Apply the patch (which you received from the Daikon group) with
@option{-p1}; this adds the dfec source modifications.
@example
    patch -p1 < edg-3.0_to_dfec.patch
@end example
@item Compile the software, creating the dfec executable
@file{release_3.0/bin/dfec}.
@example
    make
@end example
@end enumerate

(A different patch is available for EDG version 2.45; substitute
@file{2.45} for @file{3.0} in the above instructions.  However, we
recommend the use of EDG version 3.0, because the version of dfec built
using EDG 2.45 contains some known bugs that are corrected in the
version of dfec that is built using EDG 3.0.)

@c how to put something on your path:
@c 	      <li>copy or link the @command{dfej} program to a directory on
@c 	          your path, or
@c 	      <li>add the @file{java-front-end/src} directory to your path;
@c 		  for instance, in csh place the following in your
@c 		  @file{.cshrc} file:<br>
@c 		  <tt>set path = (<em>daikonparent</em>/daikon/java-front-end/src $path)</tt><br>

@node    Installing the Context GUI, Requirements, Installing dfec, Installing Daikon
@section Installing the Context GUI

If you wish to run the Daikon Context GUI (@pxref{Context GUI}), perform
the following two steps:

@enumerate
@item
If you wish to use the Context GUI with Java code, then
download and install JDE, the Java Development Environment for Emacs,
from @uref{http://jdee.sunsite.dk/}.
If you wish to use the Context GUI with C code, no extra packages are needed.
@item
Add the Emacs Lisp code for the Daikon Context GUI to your Emacs load
path.  Add the following to your @file{.emacs} or @file{prj.el} file:
@example
  ;; Daikon Context GUI
  (add-to-list 'load-path
               (substitute-in-file-name "$DAIKONDIR/emacs"))
  (autoload 'daikon-context-gui "daikon-context-gui"
            "Daikon Context GUI" t)
  (custom-set-variables '(jde-global-classpath '("$CLASSPATH")))
@end example
@end enumerate

@node    Requirements,  , Installing the Context GUI, Installing Daikon
@section Requirements for running Daikon

In order to run Daikon, you must have a Java 1.4 (or later) JVM
(@uref{http://java.sun.com,, Java Virtual Machine}).

If you wish to re-compile Daikon from scratch, you will need the C
preprocessor, @command{cpp}.  If you have a C compiler, you almost
certainly have @command{cpp}.  (Alternately, you can use @command{gcc -E}.)

You also need a compiler for whatever language your target programs are
written in.  For instance, if you wish to analyze Java programs, you
need a Java compiler such as @command{javac} or @command{jikes}.  If you
wish to analyze C or C++ programs, you need a C or C++ compiler such as
@command{gcc}.  (In fact, @command{dfec} requires that @command{gcc} is
installed.)

If you wish to build the Daikon front end for Java (dfej) yourself,
rather than using a precompiled binary provided at
@uref{http://pag.lcs.mit.edu/daikon/}, you need a C++ compiler such as
@uref{http://gcc.gnu.org/,, gcc}.  (The dfej front end, which permits you to
detect invariants in Java programs, is written in C++, and sources are
distributed with Daikon.)

@menu
* Windows requirements::        
@end menu

@node    Windows requirements,  , Requirements, Requirements
@subsection Windows requirements for running Daikon

@cindex Windows
@cindex Microsoft Windows
@cindex Cygwin toolset

If you are running Daikon under Microsoft Windows, you have two
options:  using native Windows utilities and using the Cygwin
environment.  These are described below.

(Daikon and most of its related programs, such as dfej, run under
Windows as command-line applications.  You should invoke them from a
command shell --- either an Windows command shell or a cygwin command
shell --- rather than by double-clicking their icons.  In any event,
double-clicking would not supply the proper arguments to the program.)

The first option is to run Daikon using native Windows utilities.
Before running Daikon, you must invoke the @file{daikonenv.bat} batch
file (once) in the Windows command shell to set up the environment
properly.  To automatically run something (such as a batch file) every
time the Windows command shell is started, set the value of this
registry key to the program you want to run:
@example
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\AutoRun
@end example
@noindent
You may also wish to set two registry entries to enable automatic completion:
@example
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\CompletionChar
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\PathCompletionChar
@end example
@noindent
The values for these registry entries are ASCII key codes.  Tab is 9.



The second option is to run Daikon using the Cygwin toolset
(available at @uref{http://sources.redhat.com/cygwin/}), which
contains everything you need to compile and run Unix programs under
Windows.  You can install Cygwin by simply running the program found
at @uref{http://sources.redhat.com/cygwin/setup.exe}.  If you use
Cygwin, @pxref{Cygwin environment variables}.  (If you wish to build
dfej under Cygwin, you must use gcc 2.95.3; @pxref{Installing dfej}.)


@menu
* Cygwin environment variables::  
@end menu

@node    Cygwin environment variables,  , Windows requirements, Windows requirements
@subsubsection Cygwin environment variables

There is an incompatibility between Cygwin and programs compiled for
Windows.  (The incompatibility does not exist if the program was
compiled for Cygwin).  The incompatibility is that Windows programs
use the semicolon (@samp{;}) as their path separator (for instance,
for CLASSPATH), but Unix and Cygwin programs use the colon (@samp{:})
as their path separator.  The dfej executable compiled on Cygwin seems
to accept both Windows-style and Cygwin/Unix-style paths.

The @file{cygwin-runner.pl} script in the @file{bin/} directory may
help you run windows-native Java tools from within the Cygwin
environment.  It translates Unix @samp{:}-separated pathlists to
Windows @samp{;}-separated pathlists, changes filenames to their 8.3
``old style'' name (e.g., @file{My Documents} to @file{MYDOCU~1}),
changes forward slashes to backslashes, and translates paths with
Cygwin mount points to simple @file{C:\}-like paths.

For now, @file{cygwin-runner.pl} doesn't touch environment variables,
but you can still use it for classpath by getting your CLASSPATH onto
the command line explicitly:
@example
  $ dfej -classpath $CLASSPATH DataStructures/StackAr.java
@end example
(It would be nice to patch cygwin-runner to translate
environment variables, too.  For example, always translate CLASSPATH, or
always translate anything listed in CYGWIN_RUNNER_ENV (e.g.
CYGWIN_RUNNER_ENV="PATH:CLASSPATH:PWD") so users can set CYGWIN_RUNNER_ENV
in their dotfiles or various wrappers.)


@c ** Commented out with the elimination of the need for modbit-munge
@c You may also need to install
@c @uref{http://www.activestate.com/ASPN,ActiveState Perl} in order to run
@c the @command{modbit-munge.pl} script.  A user reports that Cygwin perl
@c does not deal properly with files whose lines are separated by
@c "@samp{\r\n}", which is the DOS default.  It deals fine with files whose
@c lines are separated with "@samp{\n}", which is the Unix default.  By
@c contrast, ActiveState Perl deals properly with both varieties.  You can
@c download ActiveState Perl from
@c @uref{http://www.activestate.com/ASPN/Downloads/ActivePerl/index/}.


@node    Example use, Detecting invariants, Installing Daikon, Top
@chapter Example use of Daikon
@cindex example use of Daikon

This chapter gives step-by-step instructions for running Daikon on a
sample Java program, @file{StackAr.java}.  @xref{Second Java example}, for
another Java example.  @xref{C examples}, for C examples.
@xref{Detecting invariants}, for complete details about running
Daikon.


@menu
* Step-by-step instructions::   
* Summary of Daikon use::       
* Automating the process::      
* Understanding the invariants::  
* Second Java example::         
* C examples::                  
* Perl examples::               
@end menu

@node    Step-by-step instructions, Summary of Daikon use, Example use, Example use
@section Step-by-step instructions

@c We recommend you run Daikon on Unix, but it can also be run on Windows.

You need to perform three basic tasks:  instrument the target program
(steps 1-4), run the instrumented program to create a data trace file
(steps 5-7), and run Daikon over the data trace file to produce
invariants (steps 8-9).

You must first install Daikon if you haven't done so already; see
@ref{Installing Daikon}.  If you have any trouble with these
instructions, see @ref{Troubleshooting}, or try the @ref{Index}.


@enumerate
@item Change to the directory containing the StackAr program.  (The
directory contains the @file{DataStructures} directory.)
@example
cd examples/StackAr
@end example

@item Compile the original version of the program.  You must use the
@option{-g} flag to include debugging information in the compiled classfiles.
@example
javac -g DataStructures/*.java
@end example


@item Instrument the @file{StackAr.java} file.
@example
dfej DataStructures/StackAr.java
@end example
@noindent
(These instructions assume you have the current working directory (".")
in your CLASSPATH@.  If that is not the case, then run @command{dfej
-ajaxap=.}  instead of @command{dfej}.)

We instrument only this one file because we are only interested in the
invariants of the StackAr class, not the other classes in the program.

This command creates two directories, @file{daikon-instrumented} and
@file{daikon-output}.  It creates an instrumented version of
@file{StackAr.java} at @file{daikon-instrumented/DataStructures/StackAr.java}.
It creates a declaration file at
@file{daikon-output/DataStructures/StackAr.decls}.

@item Compile the instrumented version of StackAr.java.
@c I think this comment about "." on the classpath is correct.  -MDE 8/26/01
(This step requires "." to be on your classpath.)

@example
javac daikon-instrumented/DataStructures/StackAr.java
@end example

@item Run the StackAr test suite, using the instrumented
@file{StackAr.class} class file instead of the original (but the
original version of all other files):

@example
java -classpath "daikon-instrumented:$CLASSPATH" \
     DataStructures.StackArTester
@end example

(On Windows, use @samp{;%CLASSPATH%} instead of @samp{:$CLASSPATH}.)

This will generate a trace file at
@file{daikon-output/StackAr.dtrace}.  This could take anywhere from
a few seconds to a few minutes, depending on the speed of your
computer.

@item Change to the @file{daikon-output} directory to analyze
the output.

@example
cd daikon-output
@end example

@c @item Due to a bug in the Java front end, there can be problems in the
@c trace file.  Run the @command{modbit-munge} script to fix these problems:
@c @table @r
@c @item Unix
@c @t{modbit-munge.pl StackAr.dtrace}
@c @item Windows
@c @t{modbit-munge.bat StackAr.dtrace}
@c @end table

@item Run Daikon on the trace file.

@example
java daikon.Daikon -o StackAr.inv DataStructures/StackAr.decls \
     StackAr.dtrace
@end example

The invariants are printed to standard output, and a binary
representation of the invariants is written to
@file{StackAr.inv}.

@item Examine the invariants.  There are five ways to do this.
@itemize @bullet
@item Examine the output from running Daikon.  (You may find it
convenient to capture the output in a file; add @command{> StackAr.txt}
to the end of the command that runs Daikon.)

@item Use the PrintInvariants program to display the invariants.

@example
java daikon.PrintInvariants StackAr.inv
@end example

For more options to the PrintInvariants program, @xref{Printing
invariants}.

@item Use the MergeESC program to insert the invariants as comments
into the Java source program.

@example
cd ..
java daikon.tools.jtb.MergeESC daikon-output/StackAr.inv \
     DataStructures/StackAr.java
@end example

Now examine file @file{DataStructures/StackAr.java-escannotated}.
For more information about the MergeESC program, @xref{MergeESC}.

@item Use the Daikon Tree GUI to browse the invariants.  The Tree GUI
contains a tree that hierarchically organizes program points according
to their class and method.  Using the GUI, you can look at invariants
for only the methods and program points you care about.

@example
java daikon.gui.treeGUI.InvariantsGUI StackAr.inv
@end example

@item Use the Daikon Context GUI to browse the invariants.  As you move
the cursor in an editor window, the Context GUI displays the invariants
applicable to the current location (class or method).  For details on
running the Context GUI, see @ref{Context GUI}.  

@end itemize

@end enumerate

@node    Summary of Daikon use, Automating the process, Step-by-step instructions, Example use
@section Summary of Daikon use

The steps above can be divided into three stages:

@itemize @bullet
@item Instrumentation (steps 1-4)
@example
cd examples/StackAr
javac -g DataStructures/*.java
dfej DataStructures/StackAr.java
javac daikon-instrumented/DataStructures/StackAr.java
@end example

@c @item Trace file generation (steps 5-7)

@item Trace file generation (step 5)
@example
java -classpath "daikon-instrumented:$CLASSPATH" \
     DataStructures.StackArTester
@end example

(On Windows, use ``;'' as the path separator.)

@c cd daikon-output
@c modbit-munge.pl StackAr.dtrace
@c @end example

@item Invariant detection (steps 6-8)
@example
cd daikon-output
java daikon.Daikon -o StackAr.inv DataStructures/StackAr.decls \
     StackAr.dtrace
java daikon.gui.treeGUI.InvariantsGUI StackAr.inv
@end example

@end itemize

@node    Automating the process, Understanding the invariants, Summary of Daikon use, Example use
@section Automating the process

The script @command{daikon.pl} automates all steps of the invariant
detection process.

@example
cd examples/StackAr
daikon.pl DataStructures.StackArTester
@end example

This command instruments your program, generates a trace file, and
displays the invariants in the Tree GUI@.  Currently, this script only works
on Unix.  For more details, @xref{All-in-one script}.


@node    Understanding the invariants, Second Java example, Automating the process, Example use
@section Understanding the invariants

This section examines some of the invariants for the StackAr example.
For more help interpreting invariants, see @ref{Interpreting output}.

The StackAr example is an array-based stack implementation.  Take a
look at @file{DataStructures/StackAr.java} to get a sense of the
implementation.  Now, look at the first section of Daikon output. In
the Tree GUI, expand the node labeled @command{StackAr}, then select the
node labeled @command{StackAr:Object}.

@emph{(Note: The invariants displayed in the Tree GUI may be different than the
invariants written to standard out by Daikon.  This is because the
invariants are being filtered differently.  We are currently working
to resolve this issue.)}

@example
======================================================================
StackAr:::OBJECT
this.theArray != null
this.theArray.class == "[Ljava.lang.Object;"
this.topOfStack >= -1
this.theArray[this.topOfStack+1..] elements == null
this.theArray[0..this.topOfStack] elements != null
this.topOfStack <= size(this.theArray[])-1
======================================================================
@end example

These six annotations describe the representation invariant.  The
array is never null, and its runtime type is @code{Object[]}.  The
@code{topOfStack} index is at least -1 and is less than the length
of the array.  Finally, the elements of the array are non-null if
their index is no more than @code{topOfStack} and are null
otherwise.

Next, look at the invariants for the @code{top()} method.  In
the Tree GUI, expand the node labeled @command{top()Ljava/lang/Object;}.
@code{top()} has two different exit points, at lines 78 and 79
in the original source.  There is a set of invariants for each exit
point, as well as a set of invariants that hold for all exit points.
Look at the invariants when @code{top()} returns at line 79.  In
the Tree GUI, select the node labeled @command{EXIT79}.

@example
======================================================================
StackAr.top():::EXIT79
return == this.theArray[this.topOfStack]
this.theArray == orig(this.theArray)
this.theArray[] == orig(this.theArray[])
this.topOfStack == orig(this.topOfStack)
return != null
this.topOfStack >= 0
this.theArray[this.topOfStack+1..] elements == this.theArray[-1]
======================================================================
@end example

The return value is never null, and is equal to the array element at
index @code{topOfStack}.  The top of the stack is at least 0.  The
array, the elements of the array, and @code{topOfStack} are not
modified by this method --- this method is an "observer".  The
last invariant is not particularly interesting.

@node    Second Java example, C examples, Understanding the invariants, Example use
@section A second Java example

A second example is located in the @file{examples/QueueAr} subdirectory.
Run this sample using the following steps:

@itemize @bullet
@item Instrumentation (steps 1-4)
@example
cd examples/QueueAr
javac -g DataStructures/*.java
dfej DataStructures/QueueAr.java
javac daikon-instrumented/DataStructures/QueueAr.java
@end example

@c @item Trace file generation (steps 5-7)
@item Trace file generation (step 5)
@example
java -classpath "daikon-instrumented:$CLASSPATH" \
     DataStructures.QueueArTester
@c cd daikon-output
@c modbit-munge.pl QueueAr.dtrace
@end example

(On Windows, use ``;'' as the path separator.)

@item Invariant detection (steps 6-8)
@example
cd daikon-output
java daikon.Daikon -o QueueAr.inv DataStructures/QueueAr.decls \
     QueueAr.dtrace
java daikon.gui.treeGUI.InvariantsGUI QueueAr.inv
@end example

@end itemize

@node    C examples, Perl examples, Second Java example, Example use
@section C examples

The Daikon distribution comes with several example C programs in the
@file{examples/c-examples} directory to enable users to become familiar
with Daikon.

In order to detect invariants over C programs, you must
install dfec, the Daikon front end for C; see @ref{Installing dfec}.


To detect invariants for a program, you need to perform three basic
tasks: instrument the target program (steps 1-3), run the instrumented
program to create a data trace file (step 4), and run Daikon over the
data trace file to produce invariants (steps 5-6).  The following
instructions are for the print_tokens example.  The other examples can
be run in exactly the same manner.

@enumerate
@item Change to the directory containing the print_tokens program.
@example
cd $DAIKONDIR/examples/c-examples/print_tokens
@end example

@item Instrument the program using dfec, the C front end.
Run the front end over all the C source files and
the user-created header files they depend on.
@example
dfec print_tokens.c stream.h tokens.h
@end example
@noindent
This command creates two directories, @file{daikon-instrumented}
and @file{daikon-output}.  It creates an instrumented and preprocessed
version of @file{print_tokens.c} at
@file{daikon-instrumented/print_tokens.cc}.  It 
creates a declaration file at @file{daikon-output/print_tokens.decls}.

@quotation
Note for Windows users:
Under Windows, you must insert in the source file a gcc-specific
@samp{__attribute__} for the @samp{_ctype_} variable, which is used in
our test suite.  Run the following commands:
@example
alias fix="sed -f $DFECDIR/fix.sed"
(cd daikon-instrumented; fix print_tokens.cc \
                         > print_tokens_fixed.cc)
@end example
@end quotation

@item Compile and link the instrumented program to create the
executable @file{print_tokens} in the current directory.

@example
g++ -g -w -o print_tokens \
    daikon-instrumented/print_tokens_fixed.cc \
    $DFECDIR/daikon_runtime.o
@end example
@quotation
Note for Windows users:  Name the executable @file{print_tokens.exe}, not
@file{print_tokens}:
@example
g++ -g -w -o print_tokens.exe \
    daikon-instrumented/print_tokens_fixed.cc \
    $DFECDIR/daikon_runtime.o
@end example
@end quotation

@item Run the print_tokens test suite.  First set the DTRACEAPPEND
environment variable, so that a final @file{.dtrace} file contains
information from all runs, rather than each run overwriting the file
so that it contains only information from the last run.  (For more
details about the DTRACEAPPEND environment variable, see @ref{dfej
options} and @ref{dfec command-line arguments}.)

If you use the bash shell, run the following commands:
@example
export DTRACEAPPEND=1
sh tests.sh
@end example

If you use the csh or tcsh shell, run the following commands:
@example
setenv DTRACEAPPEND 1
sh tests.sh
@end example

These commands create a data trace file at
@file{daikon-output/print_tokens.dtrace}.

@item Run Daikon on the trace file.
@example
java -Xmx256m daikon.Daikon -o print_tokens.inv \
     daikon-output/print_tokens.decls \
     daikon-output/print_tokens.dtrace
@end example
@noindent
The invariants are printed to standard out, and a binary representation
of the invariants is written to @file{print_tokens.inv}.

@item Examine the invariants.  As described in the Daikon manual, there are
several ways to do this:
@itemize 
@item Examine the output from running Daikon.
@item Use the PrintInvariants program to display the invariants.
@item Use the Daikon Tree GUI to browse the invariants.
@item Use the Daikon Context GUI to browse the invariants.
@end itemize
@noindent
For help understanding the invariants, see @ref{Interpreting output}.

@end enumerate

@menu
* C examples summary::          
* Rijndael example::            
@end menu

@node    C examples summary, Rijndael example, C examples, C examples
@subsection C examples summary

The above steps can be divided into three stages:

Instrumentation (Steps 1-3)
@example
cd $DAIKONDIR/examples/c-examples/print_tokens
dfec print_tokens.c stream.h tokens.h
g++ -g -w -o print_tokens daikon-instrumented/print_tokens_fixed.cc \
    $DFECDIR/daikon_runtime.o
@end example

Trace File Generation (Step 4)
@example
export DTRACEAPPEND=1
sh tests.sh
@end example

Invariant Detection (Step 5)
@example
java -Xmx256m daikon.Daikon -o print_tokens.inv \
     daikon-output/print_tokens.decls \
     daikon-output/print_tokens.dtrace
@end example


@node    Rijndael example,  , C examples summary, C examples
@subsection Rijndael example

The Rijndael program requires some special instructions, due to the
size of its data trace file.  The data trace file is over 1GB in size
when first created, so make sure you have adequate disk space.

First, you should set the TRACE_KAT_MCT variable when you run the C
front end; this causes the Rijndael program to produce output when
running the test suite.  Replace the dfec command in step 2 above by
this one:
@example
dfec -DTRACE_KAT_MCT rijndael.c rijndael-alg-ref.h rijndael-api-ref.h
@end example

Second, you will need to manually reduce the size of the dtrace file.
Run these commands after step 4 above.
@example
head -1000000 daikon-output/rijndael.dtrace > \
      daikon-output/rijndael.truncated.dtrace
trace-untruncate daikon-output/rijndael.truncated.dtrace
@end example
@noindent
The first command selects the first million lines of the file, and the
second command cleans up the end of the file, in case we truncate in
the middle of a data structure.

Finally, run Daikon using the truncated trace file (step 5).
@example
java -Xmx256m daikon.Daikon -o rijndael.inv \
     daikon-output/rijndael.decls \
     daikon-output/rijndael.truncated.dtrace
@end example

@node Perl examples,  , C examples, Example use
@section Perl examples

The Daikon distribution includes sample Perl programs suitable for use
with Daikon in the @file{examples/perl-examples} directory.

To use the Daikon Perl front end, you need to have installed Daikon
(see @ref{Installing Daikon}), and you need version 5.8 or later of
Perl.

The Perl front end requires a few extra steps to run compared with the
Java and C front ends, because Perl programs don't pre-specify the
types of their variables. Using the Perl front end is a two-pass
process: first you must run the annotated program so that the runtime
system can dynamically infer the kind of data stored in each variable,
and then you must re-annotate and re-run the program with the added
type information. 

Here are step-by-step instructions for examining a simple module,
@file{Birthday.pm}, as used by a test script @file{test-bday.pl}.

@enumerate
@item Change to the directory containing the @file{Birthday.pm}
module.
@example
cd examples/perl-examples
@end example

@item Instrument the @file{Birthday.pm} file.
@example
dfepl Birthday.pm
@end example

This command creates a directory @file{daikon-untyped}, and puts
the instrumented version of @file{Birthday.pm} into
@file{daikon-untyped/Birthday.pm}. As the directory name implies, this
instrumented version doesn't contain type information.

@item Run a test suite using the instrumented @file{Birthday.pm}
file.
@example
dtype-perl test_bday.pl 10
@end example

The @file{dtype-perl} is a script that runs Perl with the appropriate
command line options to find the modules used by the Daikon Perl
runtime tracing modules, and to use the instrumented versions of
modules in @file{daikon-untyped} in preference to their original
ones. The number 10 is an argument to the @file{test_bday.pl} script
telling it to run a relatively short test.

This will also generate a file
@file{daikon-instrumented/Birthday.types} recording the type of each
variable seen during the execution of the instrumented program.

@item Re-annotate the module using the type information.
@example
dfepl -T Birthday.pm
@end example

This step repeats step 2, except that the @option{-T} flag to
@command{dfepl} tells it to use the type information generated in the
previous step, and to put the output in the directory
@file{daikon-instrumented}. @command{dfepl} also uses converts the
type information into a file @file{daikon-output/Birthday.decls}
suitable for containing subroutine declarations suitable for Daikon.

@item Run the full test suite with the type-instrumented
@file{Birthday.pm}.
@example
dtrace-perl test_bday.pl 30
@end example

Here we run another test suite, which happens to be the same
@file{test_bday.pl}, but running for longer. (The example will also
work with a smaller number). The script @command{dtrace-perl} is
similar to @command{dtype-perl} mentioned earlier, but looks for
instrumented source files in @command{daikon-instrumented}.

This creates @file{daikon-output/test_bday-combined.dtrace}, a trace
file containing the values of variables at each invocation. (The
filename is formed from the name of the test program, with
@file{-combined} appended because it contains the trace information
from all the instrumented modules invoked from the program).

@item Change to the @file{daikon-output} directory to analyze the
output.
@example
cd daikon-output
@end example

@item Run Daikon on the trace file
@example
java daikon.Daikon -o Birthday.inv Birthday.decls \
     test_bday-combined.dtrace
@end example

The invariants are printed to the standard output, and a binary
representation of them is also written in the @file{Birthday.inv}
file.

@item Examine the invariants.
@example
java daikon.gui.treeGUI.InvariantsGUI Birthday.inv
@end example

Invariants produced from Perl programs can be examined using the same
tools as other Daikon invariants. 
@end enumerate

In the example above, the script @file{test_bday.pl} was not itself
instrumented; it was only used to test the instrumented code.  The
Perl front-end can also be used to instrument stand-alone Perl
programs. The following sequence of commands, similar to those above,
show how Daikon can be used with the stand-alone program
@file{standalone.pl}, also in the @file{examples/perl-examples}
directory.

@example
dfepl standalone.pl
dtype-perl daikon-untyped/standalone.pl
dfepl -T standalone.pl
dtrace-perl daikon-instrumented/standalone.pl
cd daikon-output
java daikon.Daikon -o standalone.inv standalone-main.decls \
     standalone-combined.dtrace
@end example

Note two differences when running a stand-alone program.  First, the
instrumented versions of the program, in the @file{daikon-untyped} or
@file{daikon-instrumented} directory, are run directly.  Second, the
declarations file is named after the package in which the subroutines
were declared, but since every stand-alone program uses the
@code{main} package, the name of the program is prepended to the
@file{.decls} file name to avoid collisions.

@node    Detecting invariants, Daikon output, Example use, Top
@chapter Using Daikon to detect invariants

Detecting invariants involves three steps:
@enumerate
@item
Run @command{dfej}, @command{dfec}, or @command{dfepl} to instrument
the target program
(@pxref{Instrumentation}).
This modifies a copy of the target program so that, in addition to
performing its original task, it also writes variable values to a data
trace file.

@item
Run the instrumented program in the usual way, probably using a test
suite (@pxref{Run the instrumented program}).  This creates data trace
files.

@item
Run the Daikon invariant detector over the data trace files
(@pxref{Detect invariants}).  This detects invariants in the data trace
files.  You can display the invariants textually or via a graphical user
interface.
@end enumerate



@menu
* Instrumentation::             
* Run the instrumented program::  
* Detect invariants::           
* All-in-one script::           
@end menu

@node    Instrumentation, Run the instrumented program, Detecting invariants, Detecting invariants
@section Instrumentation

Instrumentation performs two actions:
@itemize @bullet
@item
Instrumentation adds instructions to the target program so that, in
addition to performing its original task, it also writes variable values
to a data trace file.  The changes are made to a copy of the target
program; your original version is not modified.
@item
Instrumentation creates declaration files that describe the format of
the data trace files.  For instance, these declaration files describe
the names of procedures and variables that appear in the data trace file.
@end itemize

Three instrumenters are part of Daikon:  @command{dfej} for Java programs,
@command{dfec} for C and C++, and @command{dfepl} for Perl. The
letters @command{dfe} in the names stand for ``Daikon front-end'', and
@command{j}, @command{c}, and @command{pl} abbreviate ``Java'',
``C'', and ``Perl''. The Java front end is robust; the C front end
is moderately robust, and the C++ and Perl front ends are experimental.

A front end for the IOA programming language is distributed separately
(see @uref{http://theory.lcs.mit.edu/tds/ioa.html}).
An earlier version of Daikon included a Lisp front end, but it is no
longer supported.

@menu
* Instrumenting Java programs::  
* Instrumenting C programs::    
* Instrumenting Perl programs::  
@end menu

@node    Instrumenting Java programs, Instrumenting C programs, Instrumentation, Instrumentation
@subsection Instrumenting Java programs

To instrument Java source programs, simply invoke @command{dfej}, the
Daikon front end for Java, on them:
@example
      dfej @var{filename1}.java @var{filename2}.java @var{...}
@end example

After running dfej, compile the instrumented version of the code, which
by default appears in the @file{daikon-instrumented/} directory.

The Daikon front end for Java has two effects:
@itemize @bullet
@item
dfej writes instrumented versions of the files to a
@file{daikon-instrumented/} directory.
@item
dfej creates declaration files named @file{@var{filename1}.decls}, etc.@
in a @file{daikon-output/} directory.
@end itemize

For more information about dfej, see @ref{Java front end dfej}.


@node    Instrumenting C programs, Instrumenting Perl programs, Instrumenting Java programs, Instrumentation
@subsection Instrumenting C programs

To instrument C source, invoke @command{dfec} on all the source and
header files at once:
@example
dfec @var{...options...} @var{myprog}.c
@end example
@strong{Important:}  dfec may only be run on ANSI/ISO C, not on K&R C
or other dialects (@pxref{C program requirements})

You may want to specify one or more command-line options;
see @ref{dfec command-line arguments}.

After dfec is run, you must compile the instrumented source, linking
it with the object file for the Daikon runtime library and the stdc++
library.  By default, dfec places instrumented source in the
@file{daikon-instrumented/} directory.
@example
g++ -g -o @var{myprog} daikon-instrumented/@var{myprog}.cc \
    $DFECDIR/daikon_runtime.o
@end example
@noindent
In addition, you may want to specify the @option{-w} flag to g++, to
suppress warnings.  dfec's output is valid C++ but may cause g++ to
issue warnings.

The Daikon front end for C has three effects:
@itemize @bullet
@item
dfec writes instrumented versions of the files to a
@file{daikon-instrumented/} directory 
@item
dfec creates declaration files named
@file{@var{myprog}.decls}, etc.@: in a
@file{daikon-output/} directory.
@item
optionally, dfec may create a pointer
type disambiguation file named
@file{@var{myprog}.disambig} in the
same directory as the @file{@var{myprog}.decls}
file.
@end itemize

For more information about dfec, including more detailed documentation
on its command-line options, see @ref{C front end dfec}.


@c <ol>
@c      <tt>dfec</tt> is written in Perl.  If Perl is not available, you may
@c      instead use <tt>dfec.sh</tt>, which is written in sh shell script.<p>
@c 
@c      The Daikon C front end:
@c      <ol>
@c        <li>copies your original files to @file{<i>myprog1.c</i>.uninst},
@c 	   etc.<br>
@c        <li>overwrites the original files with instrumented versions
@c        <li>creates declaration files named @file{<i>myprog1.c</i>.decls}, etc.
@c      </ol>
@c      You may wish to perform this operation with a copy of your program,
@c      to safeguard your original source code.<p>
@c 
@c      If you supply the @option{-d <i>directory</i>} argument (before
@c      the file names), then the instrumented source files are placed in the
@c      specified directory instead (and no backup files need be made).
@c  <li>Create or modify a @file{Makefile}.  Either:
@c    <ul>
@c      <li>If you have no @file{Makefile}, copy @file{Makefile-sample}
@c          to @file{Makefile} and add the names of your source files to its
@c          <tt>OBJS</tt>, and edit its <tt>EXEC</tt> executable name.
@c      <li>If you have a @file{Makefile}, add @file{dump_trace.o} to the
@c          list of object files that need to be created (and linked to create
@c          your executable).
@c    </ul>
@c  <li>Create an instrumented executable by building your program in the
@c      usual way (perhaps by running <tt>make</tt> or <tt>cc</tt> or <tt>gcc</tt>).
@c </ol>

@node Instrumenting Perl programs,  , Instrumenting C programs, Instrumentation
@subsection Instrumenting Perl programs

Perl programs must be instrumented twice. First they must be
instrumented without type information.  Then, once the first
instrumented version has been run to produce type information, they
must be instrumented again taking the type information into account.

To instrument a stand-alone Perl program, invoke @command{dfepl} with
the name of the program as an argument.

@example
dfepl program.pl
@end example

To instrument a Perl module or a collection of modules, invoke
@command{dfepl} either with the name of each module, or with the name
of a directory containing the modules. To instrument all the modules
in the current directory, give @command{dfepl} the argument @file{.}.
For instance, if the current directory contains a module
@code{Acme::Trampoline} in @file{Acme/Trampoline.pm} and another
module @code{Acme::Date} in @file{Acme/Date.pm}, they can be annotated
by either of the following two commands:

@example
dfepl Acme/Trampoline.pm Acme/Date.pm
dfepl .
@end example

Once type information is available, run the instrumentation command
again with the @option{-T} or @option{-t} options added to use the
produced type information.

For more information about dfepl, see @ref{Perl front end dfepl}.

@node    Run the instrumented program, Detect invariants, Instrumentation, Detecting invariants
@section Run the instrumented program

To create data trace files, run the instrumented program over some test
suite of your own choosing, such as regression tests or a typical user
input session.  You can run the instrumented program in just the same
way you did before; the only behavioral change is writing a
@file{.dtrace} file.  Only one @file{.dtrace} file is created, even
though multiple @file{.decls} files might have been created (one for
each source file) when the program was instrumented.

By default, the instrumented Java or C program creates its @file{.dtrace}
file in the @file{daikon-output/} subdirectory of the current directory,
and it defaults to overwriting any previously existing @file{.dtrace} file.

@c    For C
@c  programs, however, you can set the DTRACEAPPEND environmental variable,
@c  which will cause each subsequent run of the program to append to the
@c  @file{.dtrace} file, which is useful if your test suite requires multiple
@c  invocations of the program.

Environment variables DTRACEFILE and DTRACEAPPEND can override the
default behaviors.  For details, see @ref{dfej options} and @ref{dfec
command-line arguments}.

@c After running your program, run @command{bin/modbit-munge.pl} on the
@c resulting @file{.dtrace} files:
@c @example
@c modbit-munge.pl @var{myprog}.dtrace
@c @end example
@c @noindent
@c This step fixes up some potential problems that may appear in the
@c @file{.dtrace} file.


@menu
* Run Java::                    
@end menu

@node    Run Java,  , Run the instrumented program, Run the instrumented program
@subsection Details on running instrumented Java programs

After instrumentation, there are two versions of your Java program:
the original version, which is unmodified, and the instrumented
version, which appears in the @file{daikon-instrumented/} directory.
Make sure that the @file{daikon-instrumented/} directory appears on
your class path before the directory containing the original Java
code.  You can do this by running the program from that directory, if
@file{.} (the current directory) appears early on your class path, or
you can add the @file{daikon-instrumented/} directory to your class
path explicitly.  (To be able to run the instrumented program from a
directory other than the parent of the @file{daikon-instrumented/}
directory, an absolute path to the @file{daikon-instrumented/} should
be used).


@menu
* Java applets::                
@end menu

@node    Java applets,  , Run Java, Run Java
@subsubsection Java applets

In order to run an applet, you must take two additional steps.

@enumerate
@item
Copy or link all class files, jar files, input files, and html files
that your applet needs to the @file{daikon-instrumented/} directory.  This
includes the @file{daikon/java} directory itself.  For example, to
create a link to the @file{daikon/java} directory, type (while in the
@file{daikon-instrumented/} directory):
@example
ln -s $DAIKONDIR/java/daikon .
@end example

@item
By default, the Java 2 applet security model does not allow applets to
write files.  To get around this so that Daikon can write its @file{.dtrace}
files, create a file named @file{javaPolicy} in the @file{daikon-instrumented/}
directory that contains the text
@example
grant @{
    permission java.io.FilePermission
      "<<ALL FILES>>", "read, write, delete, execute";
@};
@end example
@noindent
Do not use this policy file with untrusted applets.

@item
Finally, run the applet:
@example
       appletviewer -J-Djava.security.policy=javaPolicy @var{html-file}
@end example
@end enumerate


@node    Detect invariants, All-in-one script, Run the instrumented program, Detecting invariants
@section Detect invariants in the data trace files

Run the Daikon invariant detector via the command
@example
    java daikon.Daikon @i{[@var{flags}]} @var{decl-files...} @var{dtrace-files...} @var{spinfo-files...}
@end example
@noindent
(For help in interpreting the output, @xref{Interpreting output}.)

The @var{decl-files} are declaration (@file{.decl}) files created at
instrumentation time.
The @var{dtrace-files} are data trace (@file{.dtrace}) files created by
running the instrumented program.
The @var{spinfo-files} are splitter info (@file{.spinfo}) files created
automatically or by hand.
The files may appear in any order;
the file type is determined by whether the file name contains
@file{.decls}, @file{.dtrace}, or @file{.spinfo}.

Be sure to include all declaration files that are needed for the particular
data trace file; the simplest way is to include every the declaration file
created when instrumenting the program.

The optional flags are described in @ref{Command line options}.

@menu
* Command line options::        
@end menu

@node    Command line options,  , Detect invariants, Detect invariants
@subsection Command line options for Daikon
@cindex command line options for Daikon
@cindex flags for Daikon

The Daikon invariant detector is invoked as follows:
@example
    java daikon.Daikon @i{[@var{flags}]} @var{decl-files...} @var{dtrace-files...} @var{spinfo-files...}
@end example

This section describes the optional flags.


@c Unfortunately, @option{} adds quotes in the Info and printed output
@c which is not necessary in a table.  However, @t and @code compress
@c the two hyphens to 1 in Info and HTML output, which is even worse.
@table @option
@item -h
@item --help
Print usage message.

@item --ppt @var{ppt_regexp}
Only process program points whose names match the regular expression,
which uses Perl syntax.

@item --ppt_omit @var{ppt_regexp}
Do not process program points whose names match the regular expression,
which uses Perl syntax.  This takes priority over the
@option{--ppt} argument.

@item --var_omit @var{var_regexp}
Ignore variables (whether in the trace file or derived) whose names
match the regular expression, which uses Perl syntax.

@item -o @var{inv_file}
Serialize invariants to the specified file; they can later be
postprocessed, compared, etc.

@item --config @var{filename}
Load the configuration settings specified in the given file.
@xref{Configuration options}, for details.

@item --config_option @var{name}=@var{value}
Specify a single configuration setting.
@xref{Configuration options}, for details.

@item --files_from @var{filename}
Read a list of @var{decl}, @var{dtrace}, or @var{spinfo} files from the
given text file, one filename per line, as an alternative to providing
them on the command line.

@item --no_text_output
Don't print invariants as text output.  This option may be used in
conjunction with the @option{-o} option.

@item --suppress_cont
Suppress display of implied invariants (by controlling program
point). This is now the default behavior, so this option has no
effect, but exists for backward compatibility.

@item --no_suppress_cont
Do not suppress the display of implied invariants (based on
controlling program points). This will reduce the time needed to print
the invariants, possibly at the expense of printing additional
redundant invariants.

@item --suppress_post
Suppress display of obvious postconditions on prestate.

@item --suppress_redundant
Suppress display of logically redundant invariants, using the Simplify
automatic theorem prover.  Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to take advantage of this option. Beware that the process of
detecting redundant invariants can sometimes be time-consuming; the
amount of effort Simplify exerts for each invariant can be controlled
using the @option{daikon.simplify.Session.simplify_max_iterations} and
@option{daikon.simplify.Session.simplify_timeout} configuration
options.

@item --disc_reason @var{inv_class}<@var{var1},@var{var2},...>@@@var{ppt}
Prints all discarded invariants of class @var{inv_class} at the ppt
specified that involve exactly the vars given, as well as a short reason
and discard code explaining why they were not worthy of print.  Any of 
the three parts of the optarg may be made a wildcard by excluding it.
For example, @samp{@var{inv_class}} and
@samp{<@var{var1},@var{var2},...>@@@var{ppt}} are valid arguments.
Concrete examples are @samp{Implication<x,y>@@foo():::EXIT},
@samp{Implication<x,y>}, and @samp{<x,y>@@foo():::EXIT}.
To print all discarded invariants, use the argument "all".

@item --prob_limit @var{val}
Set the probability limit for justifying invariants.  @var{val} must be
between 0 and 1; the default is .01 (1%).  Smaller values yield stronger
filtering.

@item --conf_limit @var{val}
Set the confidence limit for justifying invariants.  @var{val} must be
between 0 and 1; the default is .99 (1%).  Larger values yield stronger
filtering.

@item --nohierarchy
Avoid connecting program points in a dataflow hierarchy.  For example,
Daikon normally connects the ENTER program points of a class with the
class's CLASS program point, so that any invariant that holds on the
CLASS program point is considered to hold true on the ENTER program
point.  With no hierarchy, each program point is treated
independently.  This is for using Daikon on applications that do not
have a concept of hierarchy.  Note that this switch applies only to V3
of daikon.

@item --esc_output
Write output in ESC-like format.

@item --simplify_output
Write output in Simplify format.

@item --ioa_output
Write output in IOA format.

@item --java_output
Write output as Java expressions.

@item --output_num_samples
@cindex samples breakdown output
@cindex mux output
Output numbers of values and samples for invariants and program points;
this is a debugging flag.  (That is, it helps you understand why Daikon
produced the output that it did.)

The ``Samples breakdown'' output indicates how many samples in the
@file{.dtrace} file had a modified value (``m''), had an unmodified
value (``u''), and had a missing value (``x'').  The summary uses a
capital letter if the sample had any of the corresponding type of
variable, and a lower-case letter if it had none.  These types affect
statistical tests that determine whether a particular invariant (that
was true over all the test runs) is printed.

Only variables that appear in both the pre-state and the post-state
(variables that are in scope at both procedure exit and entry) are
eligible to be listed as modified or unmodified.  This is why the list
of all variables is not the union of the modified and unmodified
variables.

@item --dbg @var{category}
@item --debug
@cindex debugging flags
@cindex category, for debugging
@cindex logging, for debugging Daikon
@cindex Logger
These debugging options cause output to be written to a log file (by
default, to the terminal); in other words, they enable a Logger.
The @option{--dbg @var{category}} option
enables debugging output for a specific part of Daikon; it may be
specified multiple times, permitting find-grained control over debugging
output.  The @option{--debug} option turns on all debugging flags.
(This produces a lot of output!)  Most @var{category}s are class or
package names in the Daikon implementation, such as @code{daikon.split}
or @code{daikon.derive.binary.SequencesJoin}.  Only classes that check
the appropriate categories are affected by the debug flags; you can
determine this by looking for a call to @samp{Logger.getLogger} in
the specific class.

@end table


@node    All-in-one script,  , Detect invariants, Detecting invariants
@section All-in-one script daikon.pl

The @command{daikon.pl} script automates all steps of the invariant
detection process:  instrumentation, trace file generation, and
invariant display.  However, it has several limitations: it only works
with programs written in Java, it doesn't allow all of the optional
features of Daikon to be controlled, and it depends on external
programs that may not be present on non-Unix systems. It is not
the preferred way to run Daikon, but some users may find it helpful
for quick testing, or for use from automated scripts.

Running @command{daikon.pl} without without any arguments will display usage information:
@example
% daikon.pl
Usage: daikon.pl [OPTIONS] MAIN_CLASS [MAIN_ARGUMENTS]
Options:
  -o, --output FILE   Save invariants in FILE.inv
  ...
@end example

You must supply at least the name of a "main" class that provides
the method @code{public static void main(String[] args)}.
@command{daikon.pl} runs this class to exercise your program.

@c <!--
@c <h2><a xname="example">Example</a></h2>
@c 
@c You can try an example provided by the staff:
@c <pre>
@c   athena% cd ~/6.170
@c   athena% mkdir daikon-testing; cd daikon-testing
@c   athena% cp -rp /mit/6.170/handouts/daikon/example .
@c   athena% daikon --verbose xxx
@c </pre>
@c This will run <tt>xxx</tt>, detect invariants for the program, and
@c display the daikon Tree GUI to browse the results.  See the <a
@c href="#interpret-output">interpreting the output</a> section below for
@c details on the meaning of the invariants.
@c 
@c <p>Each run of daikon creates two files: an <tt>.inv</tt> file that
@c contains the invariants in a special format, and a
@c <tt>.src.tar.gz</tt> file that contains a snapshot of the program
@c source.  You may specify names for these files using the <tt>--output
@c <i>file</i></tt> parameter to daikon.  For example <tt>--output
@c mytest</tt> will create <tt>mytest.inv</tt> and
@c <tt>mytest.src.tar.gz</tt>.
@c 
@c <p>If your main class requires arguments, you may place them after the
@c class name, just as if you were running <tt>java</tt> instead of
@c <tt>daikon</tt>.
@c -->

@menu
* daikon.pl arguments::         
@end menu

@node    daikon.pl arguments,  , All-in-one script, All-in-one script
@subsection Command line options for daikon.pl

@table @option
@item -i @var{file}
@item --instrument @var{file}
Only instrument FILE@.  Can be specified multiple times.
Otherwise, all files that are used by the main file are instrumented.

@item -o @var{file}
@item --output @var{file}
Save invariants in @file{@var{file}.inv} and source in
@file{@var{file}.src.tar.gz}.  If no name 
is given, a name is automatically generated and used.

@item -t
@item --textfile
Save a textual listing of invariants to a @file{.txt} file.

@item -n
@item --nogui
Create the invariants file (and @file{.txt} file,
if @option{-t} is given), but do not start the Tree GUI@.

@item --daikonarg @var{arg}
Supply additional argument(s) to Daikon proper.
Can be specified multiple times.
Warning:  be careful with quoting, as the argument is supplied directly
to the shell and may be viewed as multiple arguments or reinterpreted
(which may or may not be what you want).

@item -v
@item --verbose
Display progress messages while running.

@item -c
@item --cleanup
Remove files left over from an interrupted session before starting.
Should be used only when @code{daikon.pl} detects left-over files and instructs
you to use this option.

@item --nocleanup
Do not remove temporary files when exiting.
This option is intended for debugging.

@item -s
@item --src
Make an archive of the source code for later reference.  All the code
that is instrumented will be recorded in the compressed tarfile
@file{@var{file}.src.tar.gz}, where @var{file} is the name that was
supplied via the @option{-o} or @option{--output} arguments.

@item -d
@item --debug
Print extra debugging information.
@end table



@node    Daikon output, GUIs, Detecting invariants, Top
@chapter Daikon output


@menu
* Interpreting output::         
* Printing invariants::         
* Invariant Diff::              
@end menu

@node    Interpreting output, Printing invariants, Daikon output, Daikon output
@section Interpreting Daikon output

@cindex @samp{Exiting}, in Daikon output

If nothing gets printed before the @samp{Exiting} line, then Daikon
found no invariants.  You can get a little bit more information by using
the @option{--output_num_samples} flag to Daikon (@pxref{Command line
options}).

Daikon does not display redundant invariants --- those that are implied
by other invariants in the output --- because such results would merely
clutter the output without adding any valuable information.  For
instance, if Daikon reports ``x==y'', then it never also reports
``x-1==y-1''.  (You can print all invariants, even redundant ones, by
saving the invariants to a @file{.inv} file and then using the
PrintInvariants (@pxref{Printing invariants}) or Diff (@pxref{Invariant
Diff}) programs to print the results.)

@menu
* Program points::              
* Variable names::              
* Invariant syntax::            
* Invariant list::              
@end menu

@node    Program points, Variable names, Interpreting output, Interpreting output
@subsection Program points
@cindex program point

A program point is a specific place in the source code, such as
immediately before a particular line of code.  Daikon's output is
organized by program points, both in the textual output and in the GUIs.

@cindex :::ENTER program point
@cindex ENTER program point
@cindex precondition

For example, @code{foo():::ENTER} is the point at the entry to procedure
@code{foo()}; the invariants at that point are the preconditions for the
@code{foo()} method, properties that are always true when the procedure
is invoked.

@cindex :::EXIT program point
@cindex EXIT program point
@cindex postcondition

Likewise, @code{foo():::EXIT} is the program point at the procedure
exit, and invariants there are postconditions.  When there are multiple
exit points from a procedure (for instance, because of multiple
@code{return} statements), the different exits are differentiated by
suffixing them with their line numbers; for instance,
@code{StackAr.top():::EXIT79}.  The exit point lacking a line number (in
this example, @code{StackAr.top():::EXIT}) collects the postconditions
that are true at every numbered exit point.  This is an example of a
program point that represents a collection of locations in the program
source rather than a single location.

@cindex :::OBJECT program point
@cindex OBJECT program point
@cindex :::CLASS program point
@cindex CLASS program point
@cindex object invariants
@cindex representation invariants
@cindex class invariants

Two other program point tags are @code{:::OBJECT} and @code{:::CLASS}.
The former indicates object invariants (sometimes called representation
invariants or class invariants) that always hold for any object of the
given class, from the point of view of a client or user.  These
properties hold at entry to and exit from every public method of the
class (except not the entry to constructors, when fields are not yet
initialized).
The @code{:::CLASS} tag is just like @code{:::OBJECT}, but only
for static variables, which have only one value for all objects.

@cindex private methods

(By contrast, ESC/Java and JML make class invariants hold even at the
entry and exit of private methods.  Their designers believe that most
private methods preserve the class invariant and are called only when
the class invariant holds.  ESC/Java and JML require an explicit
"helper" annotation to indicate a private method for which the class
invariant does not hold.)

The Java instrumenter dfej selects names for program points that include
an indication of the argument and return types for each method.  These
signatures are presented in the JVML format:  one character for each
primitive type (@samp{B} for byte, @samp{C} for character, @samp{Z} for
boolean (so as not to clash with byte), etc.);
@samp{L}@var{classname}@samp{;} for object types; and a @samp{[} prefix
for each level of array nesting.


@node    Variable names, Invariant syntax, Program points, Interpreting output
@subsection Variable names

Here is an incomplete list of the conventions used by Daikon for
variable names.

@itemize @bullet
@item
@cindex @code{orig()} variable (pre-state value)
@code{orig(x)} refers to the value of formal parameter @code{x} upon
entry to a procedure (because the procedure body might modify the value
of @code{x}).  These variables appear only at @code{:::EXIT} program
points.
@item
@code{a} (for an array, class, or other non-primitive variable
@code{a}) is the identity of @code{a} --- think of it as a
comparison over hash codes
@item
@cindex @code{.class} variable
@code{a.class} is the runtime type of @code{a}, which may
differ from its declared type
@c "a.class" is omitted for arrays of primitive type
@item
@cindex @code{a[]} variable (array contents)
@code{a[]} is the contents of array @code{a}, namely a sequence of
elements.  "a=b" implies "a[]=b[]", but "a[]=b[]" does not imply "a=b".
Also, "a=orig(a)" does not imply "a[]=orig(a[])".
@item
@code{a[].class} is an array of types, representing the run-time classes
of the contents of @code{a}; it is omitted for arrays of primitive type
@item
@cindex @code{-1} array index (counts from end of array)
@cindex negative array index (counts from end of array)
@code{a[-1]} denotes the last element of array @code{a};
it is syntactic sugar for @code{a[a.length-1]}.
@item
@cindex @code{.toString} variable
@code{s.toString} is the string value of String @code{s}, namely a
sequence of characters
@item
@cindex @code{::} variable (C global)
@code{::a} is the global variable @code{a}.  It contains the colons to
differentiate it from @code{a} as a procedure parameter, so that
different properties can be reported over the two different variables.
@end itemize

@cindex local variables
@cindex variables, local
Daikon does not produce output for local variables, only for variables
visible from outside a procedure.  Thus, its output forms a
specification (mostly) from the view of a client of a procedure.  A
future version of Daikon may permit output of local variables as a user
option.

@menu
* orig variable example::       
@end menu

@node    orig variable example,  , Variable names, Variable names
@subsubsection orig variable example

@cindex @code{orig()} variable (pre-state value)

This section gives an example of use of @code{orig()} variables and arrays.

Suppose you have initially that
@example
  int i = 0;
  int[] a = new int[] @{ 22, 23 @};
  int[] b = new int[] @{ 46, 47 @};
@end example

and then you run the following:
@example
  // pre-state values at this point
  a[0] = 24;
  a[1] = 25
  a = b;
  a[0] = 48;
  a[1] = 49;
  i = 1;
  // post-state values at this point
@end example

The values of various variables are as follows:

@table @code
@item orig(a[i]) = 22
The value of @code{a[i]} in the pre-state: @{22, 23@}[0]

@item orig(a[])[orig(i)] = 22
This is the same as orig(a[i]):   @{22, 23@}[0].

@item orig(a[])[i] = 23
The value of @code{a[]} (that is, the array object, not the reference
@code{a}) in the pre-state, indexed by the post-state value of i:
@{22, 23@}[1]

@item orig(a)[orig(i)] = 24
orig(a) is the original value of the reference @code{a}, not
@code{a}'s original elements: @{24, 25@}[0]

@item orig(a)[i] = 25
The original pointer value of a, indexed by the post-state value
of i:  @{24, 25@}[1]

@item a[orig(i)] = 48
In the post-state, @code{a} indexed by the original value of
@code{i}: @{48, 49@}[0]

@item a[i] = 49
The value of @code{a[i]} in the post-state.
@end table


@node    Invariant syntax, Invariant list, Variable names, Interpreting output
@subsection Invariant syntax

Daikon's default format is a mix of Java, mathematical logic, and some
additional extensions.
(In the future, Daikon will produce output in JML format; when
that is the case, this section of the manual will simply refer the
reader to the @uref{http://www.cs.iastate.edu/~leavens/JML.html, ,JML
Manual}.  Daikon's current ESC output format is a variant of JML format.)


@cindex has only one value, in invariant output

The output "@var{var} has only one value" means that every time that
variable @var{var} was encountered, it had the same value.  However,
that value is not interesting to report.  Typically this means that
@var{var} always referred to the same object.  Users may care that the
variable was never rebound to a different object, but it would not be
helpful to print out what the hashcode or address of that object
happened to be at runtime.  "@var{var} has only one value" differs from
saying that var is unmodified.  

A variable can have only one value but not be reported as unmodified
because the variable is not a parameter to a procedure --- for instance,
if a routine always returns the same object, or in a class invariant.  A
variable can be reported as unmodified but not have only one value
because the variable is never modified during any execution of the
procedure, but has different values on different invocations of the
procedure.

@node   Invariant list,  , Invariant syntax, Interpreting output
@subsection Invariant list

The following is a list of all of the invariants that Daikon detects.
Each invariant has a configuration enable switch.  By default most invariants
are enabled.  Any that are not enabled by default are indicated below.
Some invariants also have additional configuration switches that control 
their behavior.  These are indicated below as well. @xref{Configuration 
options}.

@table @asis
@include invariants-doc.texinfo
@end table


@node    Printing invariants, Invariant Diff, Interpreting output, Daikon output
@section Printing invariants

@cindex printing invariants
@cindex PrintInvariants program

Daikon provides many options for controlling how invariants are printed.
Often, you may want to print the same set of invariants several
different ways.  However, you only want to run Daikon once, since it may
be very time consuming.  The PrintInvariants utility prints a set of
invariants from a @file{.inv} file.

PrintInvariants is invoked as follows:
@example
    java daikon.PrintInvariants @i{[@var{flags}]} @var{inv-file}
@end example

PrintInvariants shares many flags with Daikon:

@table @option
@item -h
@item --help
Print usage message.

@item --suppress_cont
Suppress display of implied invariants (by controlling program point).
This is now the default behavior, so this option has no effect, but
exists for backward compatibility.

@item --no_suppress_cont
Do not suppress the display of implied invariants (based on
controlling program points). This will reduce the time needed to print
the invariants, possibly at the expense of printing additional
redundant invariants.

@item --suppress_post
Suppress display of obvious postconditions on prestate.

@item --suppress_redundant
Suppress display of logically redundant invariants, using the Simplify
automatic theorem prover.  Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to take advantage of this option.

@item --esc_output
Write output in ESC-like format.

@item --simplify_output
Write output in Simplify format.

@item --ioa_output
Write output in IOA format.

@item --java_output
Write output as Java expressions.

@item --output_num_samples
Output numbers of values and samples for invariants and program points;
for debugging.
@end table


@node    Invariant Diff,  , Printing invariants, Daikon output
@section Invariant Diff

@cindex invariant diff
@cindex diff, over invariants
@cindex comparing invariants

The invariant diff utility is designed to output the differences between
two sets of invariants.  This is useful, for example, if you want to
compare the invariants generated by two versions of the same program.

Invariant diff is invoked as follows:
@example
    java daikon.diff.Diff @i{[@var{flags}]...} @var{file1} [@var{file2}] 
@end example

file1 and file2 are serialized invariants produced by running Daikon or Diff
with the "-o" flag.  If @file{file2} is not specified,
@file{file1} is compared with the empty set of invariants.

This section describes the optional flags.

@table @option
@item -h
Print usage message.

@item -d
Display the tree of differing invariants (default).  Invariants that are
the same in file1 and file2 are not printed.  At least one of the
invariants must be justified.  Does not print "uninteresting" invariants
(currently some OneOf and Bound invariants).

@item -u
Include "uninteresting" invariants in the tree of differing invariants.

@item -y
@item --ignore_unjustified
Include (statistically) unjustified invariants. 

@item -a
Display the tree of all invariants.  Includes invariants that are the
same in file1 and file2, and unjustified invariants.

@item -s
For internal use only.  Display the statistics between two sets of
invariants.  The pairs of invariants are placed in bins according to the
type of the invariant and the type of the difference.

@item -t
For internal use only.  Display the same statistics as @option{-s}, but as a
tab-separated list.

@item -m
Compute (file1 - file2).  This is all the invariants that appear in
file1 but not file2.  Unjustified invariants are treated as if they
don't exist.  Output is written as a serialized InvMap to the file
specified with the -o option.  To view the contents of the serialized
InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -x
Compute (file1 XOR file2).  This is all the invariants that appear in
one file but not the other.  Unjustified invariants are treated as if
they don't exist.  Output is written as a serialized InvMap to the file
specified with the -o option.  To view the contents of the serialized
InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -n
Compute (file1 UNION file2).  This is all the invariants that appear in
either file.  If the same invariant appears in both files, the one with
the better justification is chosen.  Output is written as a serialized
InvMap to the file specified with the -o option.  To view the contents
of the serialized InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -o @var{inv_file}
Used in combination with the -m or -x option.  Writes the output as a
serialized InvMap to the specified file.

@item -j
For internal use only.  Treat justification as a continuous value when
gathering statistics.  By default, justification is treated as
a binary value -- an invariant is either justified or it is not.  For
example, assume invariant I1 has a probability of .01, and I2 has a
probability of .5.  By default, this will be a difference of 1,
since I1 is justified but I2 is not.  With this option, this will be a
difference of .49, the difference in the probabilities.  This only
applies when one invariant is justified, and the other is unjustified.

@item -p
Examine all program points.  By default, only procedure entries and
combined procedure exits are examined.  This option also causes
conditional program points to be examined.

@item -e
Print empty program points. By default, program points are not printed
if they contain no differences.

@item -v
Verbose output.  Invariants are printed using the repr() method, instead
of the format() method.

@item -l
For debugging use only.  Prints logging information describing the state
of the program as it runs.

@item --invSortComparator1 @var{classname}
@item --invSortComparator2 @var{classname}
@item --invPairComparator @var{classname}
Use the specified class as a custom comparator.  A custom comparator can
be used for any of 3 operations: sorting the first set of invariants,
sorting the second set of invariants, and combining the two sets into
the pair tree.  The specified class must implement the Comparator
interface, and accept objects of type Invariant.

@end table


@node    GUIs, Front ends, Daikon output, Top
@chapter GUIs for displaying invariants

By default, Daikon outputs a textual list of invariants; this list may
be very long.  Daikon's graphical user interfaces (GUIs) are designed to
make the task of browsing invariants easier.

There are two GUIs to choose from.  The Tree GUI that lets users browse
the hierarchy of invariants directly.  The Context GUI lets users browse
the code in a text editor; the Context GUI concurrently displays the
invariants for the browsed code.


@menu
* Tree GUI::                    
* Context GUI::                 
@end menu

@node    Tree GUI, Context GUI, GUIs, GUIs
@section Tree-structured invariant browser
@cindex Tree GUI
@cindex GUI, tree

The Tree GUI contains a tree that
hierarchically organizes program points according to their class and
method.  Using the Tree GUI, you can look at invariants for only the methods
and program points you care about.  You can also sort invariants by a
property (e.g., probability) or filter invariants (e.g., only look at
invariants containing a certain variable).

This invariant browser consists of two windows.  The main window is the
Invariants Display, which gives a tree-structured view of program
points; you can navigate through the program points and view invariants.
The other window is the Filter Control Panel, where you can control
which invariants from each program point are displayed in the Invariants
Display.

@menu
* Invoking Tree GUI::           
* Invariants Display::          
* Control panel::               
@end menu

@node    Invoking Tree GUI, Invariants Display, Tree GUI, Tree GUI
@subsection Starting the invariant browser

To use the Tree GUI, first make a @file{.inv} file by invoking Daikon with
the @option{-o} option; for instance, to create @file{foo.inv}, run
@example
java daikon.Daikon -o foo.inv @var{decl-files...} @var{trace-files...}
@end example

Then, run the Tree GUI with the @file{.inv} file as an argument:
@example
java daikon.gui.treeGUI.InvariantsGUI foo.inv
@end example

If you run the Tree GUI with no arguments, it presents a file browser that
asks you to choose a @file{.inv} file for viewing.


@node    Invariants Display, Control panel, Invoking Tree GUI, Tree GUI
@subsection Invariants Display

@ifnotinfo
@image{images/gui-InvariantsDisplay-small,3in,}
@c </td>
@c <td width=20></td>
@c <td><img src="gui-InvariantsDisplay-small.gif" width=298 height=348></td>
@c </tr></table>
@end ifnotinfo

@table @strong
@item File menu

The @command{Load file} menu option brings up a file browser that you
can use to select another @file{.inv} file.  The @command{Quit} menu
options lets you quit the Tree GUI@.

@item Program point tree
The top part of the Invariants Display consists of the Program point
tree --- a hierarchy of program points broken down by class and method.
Click on various program points in the tree to see tables of invariants
for those program points.  You may use the @key{Ctrl} and @key{Shift}
keys to make an arbitrary selection of program points.  Selecting a
class or method automatically selects all the program points
associated with that method or class.

@item Invariant tables
Invariant tables that display the actual invariants appear at the bottom
of the Invariants Display.

@itemize @bullet
@item
Use @key{Alt} along with the @key{up} or @key{down} arrow keys to scroll
by a table at a time.
@item
Sort a column in a table by clicking on the column header.  Shift-click
to sort the column in reverse order.
@end itemize

@end table

@node    Control panel,  , Invariants Display, Tree GUI
@subsection Control panel

The Control Panel determines which invariants are displayed.
@c As of 2/2002
(This picture of the Control Panel is slightly out of date; it needs to
be updated.)

@c Force a paragraph break so the image is on its own line.
@*

@ifnotinfo
@c @ifhtml
@c <p>
@c @end ifhtml
@image{images/gui-ControlPanel,3in,}
@c <center><table><tr><td>
@c <img src="gui-ControlPanel.gif" width=411 height=425>
@c </td></tr></table></center><p>
@end ifnotinfo


@menu
* Property filters::            
* Variable filters::            
@end menu

@node    Property filters, Variable filters, Control panel, Control panel
@subsubsection Property filters
@cindex property filters

Property filters narrow down the list of invariants that are displayed.
You can adjust which Property filters are being applied.  By default,
all Property filters are enabled.  Daikon supports the following
property filters:

@table @var
 
@item Suppress invariants containing non-canonical variables

For many program points there are sets of variables that are equal to
each other.  When this happens, one variable from the set is chosen to
be the canonical variable.  This filter hides invariants involving the
remaining non-canonical variables, because they are implied by
invariants involving the canonical variable.

@item Suppress parameter-derived postcondition invariants

Generally speaking, Daikon formulates invariants in terms of the
parameters to methods and their return values, in order to produce
invariants that describe a method's visible behavior, rather than
details of its implementation.  This policy has some subtleties,
though, when a method modifies one of its parameters.  When a
parameter is passed by value, the method can modify its copy of it
without the changes being visible to a caller, but if an argument
refers to another object, changes to that object may be visible.  This
filter hides invariants that are postconditions (i.e., occur in EXIT
program points) and that involve the final values of parameters, or
of derived properties of parameters that may have been modified, since
such invariants usually describe hidden implementation details.

@item Suppress unjustified invariants

For every invariant, Daikon estimates the probability of that invariant
happening by chance.  If that probability is less than the limit, then
the invariant is deemed to be an actual invariant, not just a chance
occurrence.  Currently the limit is .01%.  So by default, only invariants
with probabilities of less than .01% are shown.

@item Suppress obvious invariants

This filter suppresses invariants because they are obvious from looking
at other invariants.  Some examples are:

@itemize @bullet

@item If ``size(args[])==0'' is shown, then ``size(args[])-1==-1'' is
obvious and will not be displayed by default.
@item If ``this.topOfStack < size(this.theArray[])-1'' is shown, then
``this.topOfStack < size(this.theArray[])'' is obvious and will not be
displayed by default.
@end itemize

@item Suppress invariants with few modified samples

This filter suppresses invariants with a relatively few number of
modified samples.  An example of such an invariant would be the
following: ``x >= 5'', where ``x'' is observed to be 5 three times
and 10 five times.  The observed values of @code{x} --- i.e., the samples of
@code{x} --- did not change enough for Daikon to be confident that this
invariant is an actual invariant.

@item Suppress comparisons containing only constants

This filter suppresses comparison invariants in which all of the
variables being compared were observed to be constant.  In the current
version of Daikon, most such invariants are not even created in the
first place, because constants are detected on an early pass over the
data. However, Daikon will note that all of the invariants that had
any particular constant value were also equal to each other: such
invariants will be suppressed by this filter.

@c This one is commented out, since it is in the source too -SMcC
@c @item Suppress invariants with uninteresting literals
@c This filter suppresses invariants containing literal numbers, such as
@c ``x < 45'' and ``y[] one of { [42, 12, 23], [-4, 46] }'', based on a
@c heuristic judgement that some numbers are more interesting than
@c others. Such potential invariants are sometimes undesirable because
@c they are likely to represent a limitation of the way in which a
@c program was tested, rather than a true invariant thst would hold over
@c all possible program executions.

@item Suppress implied postcondition invariants

Implied postcondition invariants are invariants involving @code{orig()}
variables that exist as precondition invariants.  For example, say that
@code{StackAr.isEmpty():::ENTER} has the invariant ``x==y''.  Then in
@code{StackAr.isEmpty():::EXIT48}, the invariant ``orig(x)==orig(y)''
is an implied postcondition invariant and will not be displayed by
default.

@item Eliminate invariants based on Simplify

Daikon can use the Simplify theorem-prover to eliminate even more
implied invariants than Daikon's built-in tests are able to eliminate.
Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to take advantage of this filter.

@item Suppress obvious equality invariants

Like ``Suppress obvious invariants'', but applies only to equality
invariants of the form ``x==y''.

@item Suppress controlled invariants

A controlled invariant is an invariant that is "controlled" --- or
implied --- by another program point.  For example, for Java instrumented
code each class is associated with an object program point, which
contain invariants that are found at the entry and exit of all public
methods.  So in addition to the usual program points such as
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, daikon outputs invariants for the
artificial program point @code{StackAr:::OBJECT}.  The invariants for
@code{StackAr:::OBJECT} control the invariants for
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, because the former imply the latter.
Because of this redundancy, controlled invariants are not displayed by
default.  Note that if for some reason, the controlling invariant is not
displayed (for example, because it's unjustified), then the controlled
invariant @emph{will} be displayed.

@end table

@node    Variable filters,  , Property filters, Control panel
@subsubsection Variable filters
@cindex variable filters

Variable filters let you display only the invariants that contain
certain variables.  The left-hand box displays the variables that you
are interested in.  By default, the box is empty and invariants containing
any variables are displayed.  There are two ways to add variables to the
variables list:
@enumerate
@item 
Type the name of the variable into the @command{Add variable}
textfield, and click the @command{Add variable} button (or just press
@key{enter}).
@item
Each Invariant table in the Invariants Display has a @command{Show
variables} button.  Click on that button to see a list of variables for
that program point.  Select any set of variables and click the
@command{Filter on selected variables} button.
@end enumerate

To remove variables from the variables list, select the variables in
question and click on the @command{Remove selected
variables} button.

If you click on the @command{any variable} checkbox,
invariants are displayed if they contain any of the variables in the
variables list.  If you click on the @command{all
variables} checkbox, invariants are displayed if they contain all
of the variables in the variables list.



@node    Context GUI,  , Tree GUI, GUIs
@section Context GUI
@cindex Context GUI
@cindex GUI, context

The Daikon Context GUI displays invariants for the Java or C code displayed
in a text editor or code browser; as the cursor moves, the invariant
display is updated.
(Before using the Context GUI, you must follow the installation
instructions; @pxref{Installing the Context GUI}.)

@c Force a paragraph break so the image is on its own line.
@*

@ifnotinfo
@c @ifhtml
@c <p>
@c @end ifhtml
@image{images/context-gui,5in,}
@c <center><table><tr><td>
@c <img src="context-gui.jpg" width=411 height=425>
@c </td></tr></table></center><p>
@end ifnotinfo

Currently, the Context GUI is integrated with the Emacs text editor.
However, users can extend it to other Java or C editors.  The Context GUI can
also be run stand-alone. This provides the user the ability to browse
the invariants without having to load up the text editor in case the
user wants to do a quick lookup on invariants.

@menu
* Context GUI with Emacs::      
@end menu

@node    Context GUI with Emacs,  , Context GUI, Context GUI
@subsection Running the Context GUI with Emacs
@cindex Emacs, with Context GUI

In order to use the Context GUI, perform the following steps:
@enumerate
@item
Use the Daikon invariant detector to create a @file{.inv} file containing the
invariants.
@example
  java daikon.Daikon -o foo.inv decl-files... trace-files...
@end example



@item

Start the Context GUI by typing @kbd{M-x daikon-context-gui}
while visiting a Java or C file in Emacs.  When prompted, select the
appropriate @file{.inv} file, containing the invariants.

@item
Stop the Context GUI by typing @kbd{M-x daikon-context-gui-end}

@end enumerate



@node    Front ends, Enhancing Daikon output, GUIs, Top
@chapter Front ends


@menu
* Java front end dfej::         
* C front end dfec::            
* Perl front end dfepl::        
* CSV front end convertcsv.pl::  
@end menu

@node    Java front end dfej, C front end dfec, Front ends, Front ends
@section Java front end dfej

@cindex front end for Java
@cindex Java front end
@cindex dfej (Daikon front end for Java)

This section contains details about dfej, the Daikon front end for Java.

For brief information about running dfej, see @ref{Instrumenting Java programs}.
For information about installing dfej, see @ref{Installing dfej}.
The @command{dfej} usage message also contains some usage information;
run @command{dfej --help} to see it.

@command{dfej} works on Java code that corresponds to any version of
the Java language, from 1.0 to 1.3.

The Daikon front end for Java has two effects:
@itemize @bullet
@item
  dfej writes instrumented versions of the files, by default in directory
  @file{daikon-instrumented/}
@item
  dfej creates declaration files named
  @file{@var{filename1}.decls}, etc., by default in directory
  @file{daikon-output/}
@end itemize


@menu
* dfej options::                
* Scope of instrumentation::    
* Refined runtime types::       
@end menu

@node    dfej options, Scope of instrumentation, Java front end dfej, Java front end dfej
@subsection dfej options

The simplest way to invoke dfej is simply to supply it with a list of
Java files:
@example
      dfej @var{filename1}.java @var{filename2}.java @var{...}
@end example

dfej also accepts the following options, which should be provided before
the first Java file name.
@c
@c The options can be divided into the following
@c categories:
@c @table @b
@c @item where (in what directory) to produce output
@c 
@c @end table
@c
@c Details of the options are as follows.  
When conflicting options are specified (for instance, both
@option{+daikon_functions} and @option{-daikon_functions}, or both
@option{-declsfiledir} and @option{-declsfiledirflat}), the last one
takes precedence.


@table @t
@item -daikon_debug
Produce debugging information.

@item -daikon_depth=@var{n}
Depth to which to examine structure components (default 2).
This parameter determines which variables dfej causes to be output at
runtime.  For instance, suppose that a program contained the following
data structures and variables:
@example
  class A @{
    int x;
    B b;
  @}
  class B @{
    int y;
    int z;
  @}
  A myA;

  class Link @{
    int val;
    Link next;
  @}
  Link myList;
@end example
@itemize @bullet
@item
If depth=0, only the identities (hashcodes) of @code{myA} and
@code{myList} would be examined; those variables could be determined to
be equal or not equal to other variables.
@item
If depth=1, then also @code{MyA.b}, @code{myList.next}, and the integers
@code{myA.x} and @code{myList.val} would be examined.
@item
If depth=2, then also @code{MyA.b.y}, @code{MyA.b.y},
@code{myList.next.next}, and @code{myList.next.val} would be examined.
@end itemize

Values that do not exist are not examined.  For instance, if @code{myA}
is @code{null} on a particular execution of a program point, then
@code{myA.b} is not accessed on that execution regardless of the depth
parameter.

@item +daikon_functions
Produce data trace output at procedure entry/exit (default).

@item -daikon_functions
Do not produce data trace output at procedure entry/exit.

@item +daikon_classes
Produce data trace output for class invariants (default).

@item -daikon_classes
Do not produce data trace output for class invariants.

@c @item +daikon_loops
@c Produce data trace output for loop invariants.
@c @emph{This option has no effect:  loop invariants are not currently supported.}
@c 
@c @item -daikon_loops
@c Do not produce data trace output for loop invariants (default).

@item -daikon_includeonly=@var{string}
Only produce trace output for matching classes/procedures. Cannot be used
in conjunction with @option{-daikon_omit}.  May only be supplied once.
The argument provided must be a regex (and be surrounded by forward
slashes on both sides).

If the the regular expression does not match the name of a particular
class, then that class is omitted entirely, along with all procedures
within it.  Thus, the @option{-daikon_includeonly} flag does not cause
output for exactly the procedures that the @option{-daikon_omit} flag
omits, with the same argument.  For instance, suppose that class C
contains procedures foo and bar.  Then @option{-daikon_omit=bar} would
cause foo to be instrumented, but @option{-daikon_includeonly=bar}
would cause nothing to be instrumented, because regular
expression``bar'' does not match the class name C, so no part of C
would be further considered.

To instrument only method bar of class C, one possible command is:

@example
dfej -daikon_includeonly='/C$|C.bar/' Foo.java
@end example


@item -daikon_omit=@var{string}
Do not produce data trace output for matching classes/procedures.  This
reduces the size of the data trace file and also may make the
instrumented program run faster, since it need not output those variables.

The @option{-daikon_omit} argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its class, fully qualified procedure name, or complete program point
name exactly matches one of the omitting criteria.

For example, to avoid detecting invariants over an iterator class, you
can call dfej like so:
@example
dfej '-daikon_omit=HashSetLinear$HslIterator' \
     HashSetLinear.java
@end example

As another example, to avoid detecting invariants over a particular
method, you could use:
@example
dfej '-daikon_omit=StackAr.topAndPop()Ljava/lang/Object;' \
     StackAr.java
@end example

Finally, to avoid detecting invariants at a particular program point,
try:
@example
dfej '-daikon_omit=StackAr.<init>(I)V:::EXIT33' StackAr.java
@end example

The argument is treated as a literal string by default.  However, if
surrounded by a forward slash (/) on either side, it is interpreted as a
regular expression.

For example, to avoid detecting invariants over all classes in package
daikon.util, you can call dfej like so:
@example
  dfej '-daikon_omit=/^daikon\.util\..*/' *.java
@end example


@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
@cindex DTRACEAPPEND environment variable
@cindex environment variable DTRACEAPPEND
@cindex trace file name
@cindex dtrace file name
@cindex file name, for dtrace file
@item -tracefilename=@var{filename}
Specifies the default name for the trace output (@file{.dtrace}) file
(default @file{daikon-output/@var{CLASSNAME}.dtrace}).
The filename is relative
to the current directory at runtime, or is absolute.  If the DTRACEFILE
environment variable is set when the instrumented program is run, it
overrides this default.  Furthermore, if the DTRACEAPPEND environment
variable is set to any value, the dtrace file will be appended to
instead of overwritten.  Compressed data trace files may not be appended
to.  In some cases you may find a single large data trace file more
convenient; in other cases, a collection of smaller data trace files may
give you more control over which subsets of runs to invoke Daikon on.

@item -declsfiledir=@var{decldir}
Specifies the directory in which to create
@file{@var{PACKAGES}/@var{CLASSNAME}.decls} (default
@file{daikon-output}, unless @option{-declsfiledirflat} is
specified).  @var{PACKAGES} is the relative path from the current
directory to the source file; that is, the relative path from
@var{decldir} to the @file{.decls} file is the same as the relative
path from the current directory to the source file.  The directory
structure of the @file{.decls} files mirrors the directory structure of
the source files.

@item -declsfiledirflat=@var{decldir}
Specifies the directory in which to create @file{@var{CLASSNAME}.decls}
(no default).  All @file{.decls} files appear in the same directory.

@item -instrsourcedir=@var{instrdir}
Specifies the directory in which to write instrumented source files
(default @file{daikon-instrumented/}).  The instrumented files have the
same names and directory structure as the original input files.

@c not yet implemented for dfej as of 6/13/2001
@c If the value of this field is @samp{.} (i.e., a single period), then
@c instrumented files replace the original versions in the original
@c directories, but the original source files are backed up by appending
@c @file{.uninst}.  More specifically,
@c @enumerate
@c @item each instrumented file is copied from @file{filename} to
@c @file{filename.uninst}, unless filename @file{filename.uninst} already
@c exists, in which case no copying occurs
@c @item the system reads from @file{filename.uninst} and writes to
@c @file{filename}.
@c @end enumerate
@c This behavior permits in-place instrumentation, which may be desirable
@c to ease compiling the instrumented code.  (This feature is probably more
@c important for C than for Java programs.)  Running the instrumenter a
@c second time reads the original source code rather than inserting an
@c additional set of instrumentation into the already-instrumented source
@c code files.

@quotation
Note for Java:

If you do not override the default value of this variable (and possibly
even if you do, if you do not set it to @samp{.}), then you should run
@command{dfej} from a directory in your classpath.  For example, if
directory @file{parent/} is in your classpath and you want to instrument
@file{parent/foo/Bar.java}, you should run @samp{dfej foo/Bar.java} from
directory @file{parent/}.  This will create a file
@file{parent/daikon-instrumented/foo/Bar.java}.  You must add directory
@file{parent/daikon-instrumented} to your classpath.

(The reason for running @command{dfej} from a directory in your
classpath is that it allows the directory structure to remain consistent
with the package structure. If @file{Bar.java} specifies its package, it
does so with a line like @samp{package foo;}.  If you run @command{dfej}
from the @file{parent/foo} directory, the instrumented version of
@file{Bar.java} will go in @file{parent/foo/daikon-instrumented/Bar.java}; this
is not consistent with the package structure.)
@end quotation

@item -noajax
@cindex AJAX_DIR environment variable
@cindex environment variable AJAX_DIR
Do not use Ajax.  Ordinarily, the Ajax module
"ComparablePairsDescFileReader" updates the variable comparability
information in the @file{.decls} file.  The comparability information
can indicate which variables should not be compared to one another.
(For instance, the number of people that a recipe serves should not be
compared to the page number in a cookbook where the recipe is found,
even if both are integers.)  Use of Ajax to update this information is
entirely optional; its effect is to suppress invariants over incomparable
variables.  These comparisons are usually  nonsensical, so using Ajax makes
Daikon report fewer irrelevant invariants.

Use of Ajax requires environment variable AJAX_DIR to be set to a
directory containing various Ajax helper files (such as
@file{main-harness.csal}, @file{tweaked-classes.zip}, etc.).  The proper
directory is @file{java/ajax-ship} in the Daikon distribution and is set
by the provided @file{daikon.cshrc} and @file{daikon.bashrc}
initialization files.

@item -ajaxap=@var{apdir}
This is the directory in which the Ajax comparability module looks
for @file{.class} files for the current application.  (It is a classpath
entry, so the @file{.class} files might appear in a subdirectory named
for the appropriate package.  If this option is not supplied, the
@option{-classpath} argument is used.  A sensible value is required for
code that (for example) calls libraries that do not appear under the
current directory.

@item -ajaxap=@var{apdir}
Classpath to give to Ajax in its "-cp" flag, similar to -ajaxap.

@item -ajax_runnable=@var{class}
This is a Java class, in dot-delimited form (e.g., "foo.bar.Baz"), that
contains a @samp{public static void main(String[])} method.  This class
need not be one of the instrumented ones.  If it is not supplied, the
first instrumented class with such a @samp{main} method is used instead.

@c @item -ajax_runnables=@var{classes}
@c This is a whitespace-separated list of Java classes, in dot-delimited
@c form (e.g., "foo.bar.Baz"), that contain @samp{public static void
@c main(String[])} methods.  Those Java classes need not be among the
@c instrumented ones.  In addition, all such @samp{main} methods in the
@c instrumented classes are also used as entry points.  In order to run,
@c Ajax requires the name of at least one runnable class.
@c (Actually, Ajax requires the name of exactly one runnable class.)
@c 
@c @item -ajax_all_runnables=@var{classes}
@c Just like @option{-ajax_runnables}, except that no @samp{main} methods
@c in the instrumented classes are used as entry points.

@item -ajaxdumpdir=@var{dumpdir}
This is the directory in which the Ajax comparability module writes its
log file, named @file{ajax.log}.  By default, @file{ajax.log} is written
to the current directory.

@end table


@node    Scope of instrumentation, Refined runtime types, dfej options, Java front end dfej
@subsection Controlling what classes are instrumented

Only the specified Java files are instrumented; other files are
run uninstrumented.  This permits you to control the scope of invariant
detection.

In any of the specified files, all classes defined in any of those
files are instrumented.  For instance, after
@example
dfej Foo.java Bar.java
@end example
@noindent
the instrumented versions of @file{Foo.java} and @file{Bar.java} output
information about all Foo objects (including Foo objects that are
components of Bar objects, that are arguments to Bar procedures, etc.),
and likewise for Bar objects.

After
@example
dfej Foo.java
dfej Bar.java
@end example
@noindent
the same procedures (all those in the @file{Foo} and @file{Bar} classes)
are instrumented, but in Foo procedures, no detail is provided
about the structure of any Bar objects that might appear.  In other
words, the instrumenter assumes that the only classes instrumented (and
about which information is desired) are those presented to it on the
command line.  One way to determine all the @file{.java} files that are
included in a specified program is to run the following commands:
@example
find . -name '*.class' -print | xargs rm -f
javac MyProgram.java
find . -name '*.class' -print
@end example

@command{dfej} tracks all modifications of instrumented classes; if you
do not instrument all users of a class, then modifications in
uninstrumented classes may not be detected.  This can affect Daikon's
statistical tests, but in practice usually has little impact. The program 
makes approximations to the missing modification information.

@c (The @command{modbit-munge.pl} script makes approximations to the missing
@c modification information.


@node    Refined runtime types,  , Scope of instrumentation, Java front end dfej
@subsection Refined runtime types

Daikon uses the declared types of variables to determine what fields
those variables have and what methods may be legally applied to those
variables.  However, sometimes the declared type is excessively general:
the runtime value may be guaranteed to be of a more specific type.  This
often results from use of polymorphic datatypes or methods.  For
instance, a Java variable may be declared as @code{Object} even though
it always holds an @code{Integer}.  In that case, methods such as
@code{intValue} may be safely called on the object, even though it is
not applicable to arbitrary @code{Object}s.

You can indicate the runtime type of a variable to dfej by inserting a
@example
  /*refined_type: Integer*/ 
@end example
@noindent
comment immediately before the declared type (but after any modifiers like
"public" or "static").  For example, a list element that only contains
@code{Integer}s might be annotated as follows:
@example
  class ListNode @{
    /*refined_type: Integer*/ Object element;
    ListNode next;

    ListNode( /*refined_type: Integer*/ Object theElement ) @{ ... @}
    ListNode( /*refined_type: Integer*/ Object theElement,
              ListNode n ) @{ ... @}
  @}
@end example



@c 
@c <hr>
@c <h1><a name="manifest">Manifest (list of files in the distribution)</a></h1>
@c 
@c @example
@c User documentation
@c   daikon.html		This file; the main Daikon documentation
@c   README		Says to see daikon.html instead
@c   daikon.gif		The Daikon logo
@c 
@c Java front end
@c   java-front-end/	A modified version of the <a href="http://oss.software.ibm.com/developerworks/opensource/jikes/project/">Jikes Java compiler</a>
@c     src/                Source code
@c       dfej              The main executable (Daikon front end for Java);
@c                           you must build this yourself (see <a href="#build-dfej">instructions</a>)
@c 
@c C front end
@c   c-front-end/
@c     dump_trace.c	Writing data values to a data trace
@c     dump_trace.h	Header files for the above
@c     Makefile-sample	Sample Makefile for linking in the above
@c     dfec		Script for instrumenting C files (you also
@c                           need the edgcpfe executable; see "<a
@c                           href="#install">Installing Daikon</a>")
@c     dfec.sh		Version of dfec written in shell script, not Perl
@c     label.txt		Auxiliary file for output filename selection at runtime
@c 
@c Invariant detector
@c   java/			Source code for Daikon, which is written in Java
@c     Daikon.java         The entry point for Daikon
@c 
@c Auxiliary programs
@c   bin/			Helper scripts and programs
@c 
@c Miscellaneous files
@c   Makefile		Makefile for the invariant detection system
@c   VERSION		Timestamp of this distribution
@c   dtrace-format.txt	Documentation of the trace file format; somewhat old
@c   daikon-python/        An old version of Daikon, written in Python.
@c   			  The current version does not require Python.
@c @end example



@node    C front end dfec, Perl front end dfepl, Java front end dfej, Front ends
@section C front end dfec

@cindex front end for C
@cindex C front end
@cindex dfec
@cindex dfec (Daikon front end for C)


This section contains details about dfec, the Daikon front end for C@.
For brief information about running dfec, see @ref{Instrumenting C programs}.
For information about installing dfec, see @ref{Installing dfec}.

Recall that dynamic invariant detection over a C program requires
three steps:
@enumerate
@item
Run dfec, creating an instrumented version of the program and a
declaration file.
@item
Run the instrumented program, creating data trace files.
@item
Run Daikon on the declaration files and data trace files.
@end enumerate

This section discusses the steps in more detail, with an emphasis on the
first step.  If you have trouble, see @ref{dfec requirements}.

@c The three crucial files are @command{dfec}, 
@c @file{daikon_runtime.h}, and 
@c @file{daikon_runtime.o}.

To instrument a C file, run @command{dfec} on it.  dfec produces
instrumented source as well as a @file{.decls} file.  @command{dfec}
must be run on all source files, including any header files that
contain code or definitions to be instrumented (header files typically
end in @file{.h}).  All files to be included in a single executable
must be instrumented simultaneously; for example,
@example
dfec file1.c file2.c file1.h file2.h
@end example

Even if you do not wish to detect invariants in one of the files, it
must be run through dfec so it can correctly interact with the
instrumented versions of the other files.  @xref{dfec command-line
arguments}, for instructions on how to exclude files from
instrumentation.

Running @command{dfec @var{arguments} myprog.c} creates
a file named @file{myprog.cc} in the @file{daikon-instrumented/}
directory.  (It has a @file{.cc} extension, regardless of its original
extension.)  It also creates a file named @file{myprog.decls}, which
appears in the @file{daikon-output/} directory by default.  To change
these defaults, see @ref{dfec command-line arguments}.


@c Before compiling the instrumented program, either copy or link
@c @file{daikon_runtime.h} and @file{daikon_runtime.o} from
@c @file{daikon/front-end/c/} to the current directory.  (See
@c @ref{Installing dfec}, for details on creating @file{daikon_runtime.o}.)
@c @example
@c   cp -p $DFECDIR/daikon_runtime.h $DFECDIR/daikon_runtime.o .
@c @end example

Compile the instrumented program in the usual way, except that the link
step should include @file{daikon_runtime.o}, and the compiler should be
@command{g++}, since the instrumented files are C++ files.
For instance,
@example
gcc -g -o @var{exefile} myprog.c
@end example
@noindent
would become
@example
g++ -g -o @var{exefile} daikon-instrumented/myprog.cc\
     $DFECDIR/daikon_runtime.o
@end example

@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
Now you can run your executable in the usual way.  Running the
executable creates a @file{myprog.dtrace} file.  By default, this file
appears in @file{daikon-output/}, and subsequent runs overwrite to that
file.  This default can be overridden via the @option{--tracefilename}
argument to dfec or the DTRACEFILE environment variable at runtime.

Given the @file{myprog.decls} file that dfec created and the
@file{myprog.dtrace} file that running the instrumented program created,
you can run Daikon:
@example
java daikon.Daikon daikon-output/myprog.decls \
     daikon-output/myprog.dtrace
@end example

@menu
* dfec command-line arguments::  
* Daikon runtime customization::  
* Pointer type disambiguation::  
* Instrumentation scope::       
* dfec requirements::           
@end menu

@node    dfec command-line arguments, Daikon runtime customization, C front end dfec, C front end dfec
@subsection dfec command-line arguments

This section describes dfec's command-line options.
When conflicting options are specified (for instance, both
@option{--declsfiledir} and @option{--declsfiledirflat}), the last one
takes precedence.

@table @option

@item -I@var{path}
Adds @var{path} to the end of the system include path.  The system
include path that @command{gcc} uses is automatically detected by dfec,
so you should not have to use the @option{-I} option unless you wish to
use additional include
paths or @command{gcc} defaults to using header files
that cannot be processed by @command{dfec}.
For example,
@example
dfec -I/usr/local/.../2.95.3/include myprog.c
@end example
@c  @noindent
@c  To determine your system include path, run
@c  @example
@c  touch searchpath.cc; gcc -v -E searchpath.cc > /dev/null; rm searchpath.cc
@c  @end example
@c  @noindent
@c  and look for what follows "@samp{#include <...> search starts here:}".


@c [this is deprecated - we want the c++ searchpath only.]
@c For instance, on
@c Unix run one of these commands, depending on whether you want the C or
@c C++ search path:
@c @example
@c touch searchpath.c; gcc -v -E searchpath.c > /dev/null; rm searchpath.c
@c touch searchpath.cc; gcc -v -E searchpath.cc > /dev/null; rm searchpath.cc
@c @end example


@item -D@var{macro}=@var{value}
Defines the preprocessor macro @var{macro} to be @var{value}.
@c    For example,
@c  to get dfec to correctly traverse the include files on our system, we use
@c  @example
@c    dfec @var{...includepath...} -D__GNUG__=1 -D__null=0
@c  @end example


@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
@cindex DTRACEAPPEND environment variable
@cindex environment variable DTRACEAPPEND
@cindex trace file name
@cindex dtrace file name
@cindex file name, for dtrace file
@item --tracefilename=@var{filename}
Specifies the default name for the trace output (@file{.dtrace}) file (default
@file{daikon-output/@var{myprog}.dtrace}, where @file{@var{myprog}.c} is
the instrumented program file that contains the main() procedure).
A relative filename is interpreted with respect
to the current directory at runtime, not at compile time.
If the DTRACEFILE environment
variable is set (to a file name) when the instrumented program is run,
it overrides the default specified by this flag.  Furthermore, if the DTRACEAPPEND environment
variable is set to any value at runtime, the dtrace file is appended to
instead of overwritten, which can be handy if you wish to run
the instrumented program multiple times.

@item --declsfiledir=@var{decldir}
Specifies the directory in which to create
@file{@var{PATH}/@var{myprog}.decls} (default
@file{daikon-output/}, unless @option{--declsfiledirflat} is
specified).  @var{PATH} is the relative path from the current
directory to the source file; that is, the relative path from
@var{decldir} to the @file{.decls} file is the same as the relative
path from the current directory to the source file.  The directory
structure of the @file{.decls} files mirrors the directory structure of
the source files.

@item --declsfiledirflat=@var{decldir}
Specifies the directory in which to create @file{@var{myprog}.decls}
(no default).  All @file{.decls} files appear in the same directory.

@item --instrsourcedir=@var{instrdir}
Specifies the directory in which to write instrumented source files
(default @file{daikon-instrumented/}).  The instrumented files have the
same names and directory structure as the original input @file{.c} files, with the
slight exception that the file suffix is always set to @file{.cc}, so if you
instrument @file{@var{myprog}.c}, you will end up with
@file{daikon-instrumented/@var{myprog}.cc}.  Header files (files with a @file{.h} extension) are textually substituted into the instrumented @file{.cc} files, so they do not appear in the instrumented source directory.  If @var{instrdir} is ``.'',
then instrumentation is performed in-place, first copying the source
file @file{myprog.c} to @file{myprog.c.uninst}, then overwriting
@file{myprog.c} with instrumented source.  If @file{myprog.c.uninst}
already exists, it is left in place:  the copy step is not performed.
This is useful in situations with Makefiles that you don't want to
change, or when compiling a system requires many files to be in place.


@item --disambigfilename=@var{filename}
Specifies the filename for the pointer type disambiguation file
(@pxref{Pointer type disambiguation}), which must be given relative to
the @file{daikon-output} directory.  If this file exists, dfec uses it
to make decisions about how to output the referents of pointer
variables.  If the file does not exist, dfec creates it,
specifying default instrumentation behavior for all
pointer types.  It may then be edited and used on subsequent runs.

@item --disambig
Tells dfec to create or read pointer type disambiguation with the
default filename, which is @file{@var{myprog}.disambig} in the same
directory as the @file{.decls} file.  For more information, see
@ref{Pointer type disambiguation}.

@item --flatten-mdas
Ensures that each multi-dimensional array in the instrumented program will be
allocated as a single contiguous block of memory.  A multi-dimensional array
is a variable declared with multiple sets of square brackets after it, e.g.:
@example
  int foo[5][10];
@end example
@noindent
This is necessary if the program under analysis performs operations that
assume that its sub-arrays appear in contiguous blocks of memory (that
is, that @code{foo[3][0]} appears immediately after  @code{foo[2][9]});
examples of such operations are clearing the entire array with
@code{memset()}, manually calculating addresses of elements
in the array using memory offsets from the first element, etc.
Use of the @option{--flatten-mdas} removes padding at the beginnings
and ends of subarrays and diminishes the ability of the runtime
library to report array overflow errors, so this option should only be
specified if necessary.

@item --help
Displays a usage message.

@item -l
Indicates that the next file (only) should not produce @file{.dtrace}
file output (@pxref{Instrumentation scope}).
For instance, if you have two source files, @file{file1.c} and @file{file2.c},
and each has its own header file, but you don't want to instrument the
procedures defined in @file{file2.c}, you would instrument as follows:
@example
  dfec file1.c -l file2.c file1.h file2.h
@end example
@noindent
This is the only command-line switch that can be used in the midst of the
list of filenames; it may be specified multiple times.

@item --no-lackwit
@cindex LACKWIT_HOME environment variable
@cindex --no-lackwit flag to dfec
@cindex Lackwit, runs slowly
Turns off Lackwit postprocessing of the @file{.decls} file.  You can also
turn off Lackwit postprocessing by unsetting the LACKWIT_HOME environment
variable.  Lackwit processing can be very slow, especially on large programs.

@item --struct-depth=@var{N}
For nested or recursive types (structs or classes that have members that
are also structs or classes), this argument specifies how deep to instrument.
For example, suppose you have a simple linked list structure as follows:
@example
struct node @{
  struct node *next;
  int val;
@} list;
@end example
@noindent
Setting the struct instrumentation depth to 1 would cause the runtime
library to output @var{node.val} and @var{node.next}.  Setting the
struct instrumentation depth to 2 would cause the runtime library to
output @var{node.val}, @var{node.next}, @var{node.next->val}, and
@var{node.next->next}.  The default instrumentation depth is 3, which
allows Daikon to capture invariants about nonadjacent nodes, but results
in larger dtrace files than smaller values do.

@item --pcc-array-addresses
In ANSI/ISO C, the address operator applied to an ``array of T''
yields a ``pointer to array of T,'' whereas some compilers (such as
pcc) treat @samp{&a} the same as @samp{a} --- that is, as a pointer to
the first element of @samp{a}.  If you have code that uses the latter
interpretation, your best bet is to rewrite @samp{&a} as the simpler,
clearer, and correct @samp{a}.  Failing that, you can supply the
@option{--pcc-array-addresses} option to dfec to make it treat all
address-of-array operations in the older, pcc-style manner.

@end table


@node    Daikon runtime customization, Pointer type disambiguation, dfec command-line arguments, C front end dfec
@subsection Daikon runtime customization

@cindex dfec customizations
@cindex Daikon C runtime customizations
@cindex daikon_runtime.h file
Many customization options for the Daikon C front end appear in the
file @file{$DAIKONDIR/front-end/c/daikon_runtime.h}.
Each option in the file has a comment explaining its function and how
to enable it.
Some examples of the options are:

@itemize @bullet
@item
The instrumented program can have the capability to produce gzipped
(compressed) @file{.dtrace} files.  (This option requires zlib to be
available on your system.)
@item
You can allocate extra space at the ends of arrays, so that your
program can continue despite (some) memory errors.  You can customize
what error code is returned if your program contains a memory error
and is terminated by the Daikon runtime.  You can (dangerously) tell
the Daikon runtime not to check for specific memory errors.
@item
You can turn specific Daikon warnings on and off.
@end itemize



@node    Pointer type disambiguation, Instrumentation scope, Daikon runtime customization, C front end dfec
@subsection Pointer type disambiguation

@cindex pointer type disambiguation
@cindex disambiguation of pointer types

dfec permits users (or external analyses) to specify whether pointers
refer to arrays or to single values.  For example, in
@example
void sum(int * array, int * result) @{ ... @}  // definition of "sum"
...
int a[40];
int total;
...
sum(a, &total);        // use of "sum"
@end example
@noindent
the first pointer parameter refers to an array while the second refers to
a single value.  dfec (and Daikon) should treat these values
differently.  For instance, @code{*array} is better printed as @code{array[0]},
and @code{result[]} isn't a sensible array at all, even though in C
@code{result[0]} is semantically identical to @code{*result}.
By default, dfec treats all pointers as referencing arrays.  For
instance, it would print @code{result[0]} rather than @code{*result}
and would indicate that the length of array @code{result[]} is always 1.
In order to improve the formatting of Daikon's output (and to speed it
up), you can indicate to Daikon that certain pointers refer to single
elements rather than to arrays.
Also see the example below (@pxref{Pointer type disambiguation example}).

Information about whether each pointer refers to an array or a single
element can be specified in a ``disambig file'' that resides in the
same directory as the decls file.  The @option{--disambig} option
instructs dfec to read this file.  (dfec can also produce the file
automatically, permitting users to edit it for use on subsequent runs,
rather than having to create it from scratch.)  The disambig file
lists all the instrumented program points, and under each, a list of
all the variables in scope at that program point, along with the types
that the variables are instrumented as.  The list of disambiguation
options is:

@enumerate
@item
For variables of type @code{char}:
@enumerate
@item
'I': an integer.
@item
'C': a single character, output as a string.
@end enumerate
@item
For pointers to (or arrays of) @code{char}:
@enumerate
@item
'S': a string, possibly zero-terminated.
@item
'C': a single character, output as a string.
@item
'A': an array of integers.
@item
'P': a single integer.
@end enumerate
@item 
For pointers to (or arrays of) @code{int}:
@enumerate
@item
'A': an array of integers.
@item
'P': a single integer.
@end enumerate
For pointers to (or arrays of) @code{float}:
@enumerate
@item
'A': an array of integers.
@item
'P': a single integer.
@end enumerate
For pointers to (or arrays of) @code{struct} or @code{class} types:
@enumerate
@item
'A': an array of structs.  For each scalar field of the type, an array of that field will be output.  Aggregate children (arrays, other structs) will not be output.
@item
'P': a pointer to a single struct.  Each field of the type will be instrumented as a single instance, and child aggregate types will be output recursively.
@end enumerate
@end enumerate

The disambig file that dfec creates contains an entry for each program
point in instrumentation scope (@pxref{Instrumentation scope}), which
can be used to disambiguate parameter variables visible at
that program point.  It also contains an entry for every user-defined
class or struct, which can be used to disambiguate member variables of
that struct.  Disambiguation information entered here will apply to all
instances of a struct or class of that type, at all program points.
There is also an entry called 'globals', which disambiguates global
variables which are output at every program point.  The entries in the
disambig file may appear in any order, and whole entries or individual
variables within an entry may be omitted.  In this case, dfec will
retain their default values.

@c This isn't really relevant to users of Daikon, though it is quite
@c interesting from an implementation point of view.
@c A C pointer type is output to the decls and dtrace files in two
@c ways: firstly, as the memory address it points to (the equivalent of the
@c java hashcode), and secondly, its contents.  By default, the
@c contents of an array or pointer type is the list of values pointed to by
@c the pointer variable.  The Daikon runtime library keeps track of all
@c pointer variables, and notes what the highest referenced value beyond a
@c base is, and assumes that all values between the base and that are
@c valid.  Then, when outputting to the decls and dtrace files, it outputs
@c the full list of ``known valid'' values.  In addition to this, there are
@c certain safety features built into the Daikon runtime library, such as
@c bounds-checking on arrays that have been declared with static size.
@c However, not all pointers point to arrays; many are simply pointers to
@c single elements.


@menu
* Pointer type disambiguation example::  
@end menu

@node    Pointer type disambiguation example,  , Pointer type disambiguation, Pointer type disambiguation
@subsubsection Pointer type disambiguation example

Consider this file:

@example
  void foo(int *bar) @{
    (*bar)++;
  @}

  int main() @{
    int baz=6;
    foo(&baz);
  @}
@end example

In @code{foo()}, @code{bar} is an @code{int *}.  By default, dfec would
instrument @code{bar} as an array of int, keeping track of how many ints
@code{bar} addressed (in this case, only one), and outputting
@code{bar[]} to the @file{.decls} and @file{.dtrace} files as a
sequence, which yields these invariants:

@example
======================================================================
std.foo(int *;):::ENTER
bar[0] == min(bar[]) == max(bar[]) == sum(bar[])
bar has only one value
bar[] == [6]
bar[] elements == 6
size(bar[]) == 1
======================================================================
std.foo(int *;):::EXIT1
bar == orig(bar)
bar[0] == min(bar[]) == max(bar[]) == sum(bar[])
orig(bar[0]) == min(orig(bar[])) == max(orig(bar[])) == sum(orig(bar[]))
bar has only one value
bar[] == [7]
bar[] elements == 7
orig(bar[]) == [6]
orig(bar[]) elements == 6
size(bar[]) == 1
@end example

This is a bit wordy.  But, by running dfec with the @option{--disambig}
option, we create the @file{daikon-output/@var{myprog}.disambig} file,
which we can then edit and feed back to dfec to change how the pointer
is instrumented.  (In other words, we run dfec twice on the same
source file(s), but we edit the @file{.disambig} file in between the runs.)
@example
  dfec @var{...options...} --disambig @var{myprog}.c
@end example

This creates the @file{daikon-output/@var{myprog}.disambig} file.  It
contains, at the top:

@example
std.foo(int *;)void:::ENTER
bar
A

std.foo(int *;)void:::EXIT1
bar
A
@end example

This means that at the two program points corresponding to the entry and
exit of foo(), the variable bar is instrumented as an @samp{A}rray type.  To
change it so dfec instruments it as a @samp{P}ointer type, change the
two @samp{A} entries to @samp{P} entries:
@example
std.foo(int *;)void:::ENTER
bar
P

std.foo(int *;)void:::EXIT1
bar
P
@end example

Then, running dfec again with the @option{--disambig}
option causes dfec to open the existing
@file{daikon-output/@var{myprog}.disambig} file, reading the definitions
you gave, and changing the instrumentation accordingly:
@example
  dfec @var{...options...} --disambig @var{myprog}.c
@end example

This means that bar will be instrumented as a @samp{P}ointer to a
single element.  If you compile and run the program, then run Daikon
on the output, you'll see much cleaner invariants:
@example
======================================================================
std.foo(int *;):::ENTER
bar has only one value
*bar == 6
======================================================================
std.foo(int *;):::EXIT1
bar == orig(bar)
bar has only one value
*bar == 7
orig(*bar) == 6
@end example


@node    Instrumentation scope, dfec requirements, Pointer type disambiguation, C front end dfec
@subsection Instrumentation scope

@cindex instrumentation scope
@cindex scope of instrumentation
@cindex uninstrumented libraries
@cindex libraries, uninstrumented

When you run an instrumented C program to produce a @file{.dtrace}
file, the executable may contain three varieties of code:  fully
instrumented code that produces @file{.dtrace} file output (and also
tracks memory), partially instrumented code that only tracks memory,
and entirely uninstrumented code.  The default level of
instrumentation is full instrumentation.  The @option{-l} command-line
argument to @command{dfec} (@pxref{dfec command-line arguments})
specifies partial instrumentation for a
file.  Uninstrumented code is only included by being linked from a
library that was not processed with dfec --- for instance, system
libraries.  You should not intentionally leave part of your program
entirely uninstrumented, because dfec's memory tracking is important
both for improved output and for correctness.
If you must link your program against uninstrumented libraries, you need
to make some small changes to your program.

@enumerate
@item
If there are calls from instrumented code to uninstrumented code, then
memory tracking will not occur in the uninstrumented code.  To correct
this problem, see @ref{Memory tracking in libraries}.

@item
If there are calls from uninstrumented code to instrumented code, your
program will not link, because the instrumented code is C++ and the
uninstrumented code is C@.  If certain procedures are called from
uninstrumented code (an example is @code{usage} in @file{wc.c}), then
you can place
@example
#ifdef DAIKON_RUNTIME_H
extern "C"
#endif
@end example
@noindent
in front of the procedure definition (and declaration).
This will not affect calls from within the file, nor will it affect
compilation of the program, but it will enable dfec to process it.
@end enumerate


@menu
* Memory tracking details::     
* Memory tracking in libraries::  
@end menu

@node    Memory tracking details, Memory tracking in libraries, Instrumentation scope, Instrumentation scope
@subsubsection Memory tracking details

Here are some details about dfec's operation, to help you understand
linker errors or other problems.

Instrumented
programs perform memory tracking, which checks and records the
program's memory accesses.  This has many benefits.  It tracks whether
pointers are valid, so Daikon does not attempt to dereference
uninitialized or deallocated pointers.  It tracks how many elements of
memory have been initialized, so Daikon does not output garbage
values.  It catches memory errors in user programs.  It protects
Daikon's runtime data structures from program memory errors that would
otherwise corrupt them (and which would then appear to the user as
Daikon errors).

Memory tracking is implemented by converting all pointers and arrays
in the program to ``smart pointers'' and ``smart arrays'', implemented
as the classes DaikonSmartPointer and DaikonSmartArray.
Additionally, dfec outputs C++, whereas the original user program is
written in C@.

@node    Memory tracking in libraries,  , Memory tracking details, Instrumentation scope
@subsubsection Memory tracking in libraries

The C front end keeps track of the maximum read or written element
of each array.  This enables it to avoid outputting (meaningless)
uninitialized elements.  For example, consider the following code:
@example
char * mystring = malloc(100);
strcpy(mystring, "hello");
@end example
@noindent
Even though @samp{mystring} has 100 elements, only the first six of them are
valid.  dfec will only communicate those first six elements to
Daikon.  After a subsequent operation:
@example
strcat(mystring, ", world");
@end example
@noindent
dfec would communicate 13 elements to Daikon.

dfec tracks all array accesses in the instrumented program, and dfec
also contains special-case handling for certain library routines,
including all the stdc library functions found in @file{string.h}.
However, array accesses in files not supplied to dfec (for instance,
in other library functions) might not be recorded, causing too little
of the array to be output to Daikon.

The rest of this section describes how to add 
other functions to dfec's list of special-case functions.
Suppose system header file @file{<bar.h>} contains a function with signature
@example
  int foo(char *arg1, char *arg2)
@end example
@noindent
Then you would need to do these things:

@enumerate
@item
Add a @code{#include} directive for @file{<bar.h>} to @file{daikon_runtime.cc},
in the section with the other overloaded functions.
That section starts with this text:
@example
/* functions to overload with DAIKON_* implementations: */
#include <string.h>
@end example

@item
Add an instrumented implementation to @file{daikon_runtime.cc}.  This requires
knowledge of how smartpointers and the basemap work.  Typically, the
instrumented implementation calls the normal library function, then
manually adjusts the max_seen pointers in the basemap to their correct values,
based on semantic knowledge about the function itself.  For examples, see
the implementations provided for @file{string.h}.
The signature of the function must be changed in two ways:  the name should
have "DAIKON_" prepended to it, to avoid namespace pollution (the calls are
resolved through a macro definition explained below), and the argument and
return value types must be changed as well to reflect the use of
smartpointers.  In this example, @code{foo()} as above would be declared as
@example
int DAIKON_foo(DaikonSmartPointer<char> arg1,
               DaikonSmartPointer<char> arg2);
@end example

@item
Add a macro definition and a function declaration to @file{daikon_runtime.h}.
There is a large section of these near the end of the file.  In the case of
@code{foo()} above, we would need to insert:
@example
extern int DAIKON_foo(DaikonSmartPointer<char> arg1,
                      DaikonSmartPointer<char> arg2);
#define foo DAIKON_foo
@end example
@noindent
You can find the section to add this in by searching for
@example
/* add other user-overloaded functions here */
@end example
@noindent
Be sure to place the declaration and macro definition before the @code{#endif}
signifying the end of the !COMPILING_DAIKON_RUNTIME block.  If you put the
macro definition outside this block, then the runtime library will fail to
compile.

@end enumerate


@node    dfec requirements,  , Instrumentation scope, C front end dfec
@subsection dfec requirements

@command{dfec} does not output the contents of C unions.  This section
of the manual lists other requirements and limitations.

If you have trouble with @command{dfec}, you should first ensure that
the input to @command{dfec} (the program being instrumented) is
proper, according to the requirements set out in this section.
@command{dfec} sometimes issues obscure error messages when provided
invalid input.
For additional help troubleshooting dfec, see @ref{dfec problems}.

@menu
* C program requirements::      
* Header file dependencies::    
* gcc version::                 
@end menu

@node    C program requirements, Header file dependencies, dfec requirements, dfec requirements
@subsubsection C program requirements


@command{dfec} only instruments ANSI/ISO C programs.  (More
specifically, @command{dfec} only instruments programs that are both
legal C and legal C++.  This is essentially the same as C, but
avoiding C++ keywords.)  @command{dfec} does not support K&R C or
other non-ANSI/ISO C dialects.  Before running @command{dfec}, you
should ensure that your code is legal ANSI/ISO C (and legal ANSI/ISO
C++) and that it compiles cleanly.

@cindex ANSI C
@cindex ISO C
@cindex C89 standard
@cindex C99 standard
@cindex K&R C

Running your code through a C compiler is necessary, but not
sufficient, to verify that your program is valid C@.  (@command{dfec}
issues warnings about a number of erroneous C constructs that
@command{gcc} and other compilers accept.)  You should remove all
warnings produced by @command{gcc -g -Wall -ansi -pedantic}.  (Lack of
errors from that command does not guarantee your code is ANSI/ISO C,
or that your code is acceptable to dfec.  However, errors from that
command do indicate that your code is not ANSI/ISO C@.)  Likewise,
your code should compile
@c and link??
using @command{g++} (instead of @command{gcc}) as the compiler.

Here are some steps you may find necessary in converting code from C
to the intersection of ANSI/ISO C and ANSI/ISO C++.

@table @asis

@item prototypes
@cindex C prototypes
@cindex prototypes, C
@cindex protoize tool
@cindex function declarations, C
@cindex procedure declarations, C
@cindex declaration formats, of C functions
You must convert any K&R function prototypes to ANSI/ISO form.  In K&R
function declarations, parameters may be omitted entirely, and in K&R
function definitions, variable types may appear as variable
declarations between the ``)'' that ends the signature and the ``@{''
that starts the body.  In ANSI/ISO C, variable types always appear in
the function signature.  Furthermore, signatures must match
@b{exactly} between declarations and definitions.
(C library functions needn't be declared at all, since they should
appear in header files; a fallback would be to make the declarations
@samp{extern "C"}.)

@c Stephen McCamant says:
@c When debugging linking problems, I usually find it helpful to compile
@c everything to .o files. This will let the linker give you a sensible
@c file name to tell where the unsatisfied usages are, and let you see
@c for yourself which symbols are needed or provided, using nm.

The best way to convert prototypes is to use the @command{protoize}
program.  Even if you believe your code to be ANSI/ISO C, you should
check that @command{protoize} has no effect.  Protoize is distributed
with gcc, among other places; you can find documentation at
@uref{http://gcc.gnu.org/onlinedocs/gcc/Running-Protoize.html}.

After running @command{protoize}, you may need to perform additional
fixups by hand. A common problem is function declarations of the form
@code{f()} that specify no parameters.  In K&R C, the corresponding
definition was allowed to have any number of arguments, but such
declarations are obsolescent under the ANSI/ISO C standard, and in C++
they always denote a function that takes no arguments.  To specify a
prototype in ANSI/ISO C for a function that takes no arguments, write
@code{f(void)}.

@item type checking, casts, and const
C++ is stricter about type checking than C is.  Some C compilers permit
function prototypes to differ slightly from function definitions.
Whereas C silently inserts conversions,
C++ requires types to match or explicit casts to be inserted.
Therefore, your program may need to have variable types refined or
changed.

Furthermore, certain functions have different types in the C and C++
standard libraries.  In particular, more functions have parameters
annotated as ``const'' in the C++ library, and in more modern C
libraries, than in older C libraries. 
In order to satisfy the type checker, you may need to change the types
of variables, for instance by adding ``const'' the types of variables
that are assigned string literals, or assigned the results of functions
that return ``const'' pointers.
Alternatively, you can add casts every time a value of type ``char *''
(for instance) must be converted to a value of type ``const char *''.
Adding such casts is only safe if your program never actually modifies
the value pointed to.
In some cases, changing the declaration of a variable may be easier,
since only the declaration, and not each use, must be changed.
In others, adding casts will require fewer changes, because when
variable becomes const, other variables that receive its value may
also need to be declared const, causing a cascade of required
changes.

@item reserved words
C++ reserves the following keywords that are not reserved words in C:
@example
  asm catch class const_cast delete dynamic_cast explicit
  export friend inline mutable namespace new operator
  private protected public reinterpret_cast static_cast
  template this throw try typeid typename using virtual

  and and_eq bitand bitor bool compl false not not_eq
  or or_eq true wchar_t xor xor_eq
@end example
@noindent
(Those in the second group are defined as macros in the 1999 ISO C
standard).
Additionally, the C++ standard libraries define certain other
identifiers, such as ``string''.
Any use of these words as identifiers must be changed.

@item nested enums
@cindex template-argument uses local type error
In C, enums that appear inside structs have global scope and can be
accessed anywhere in the program.  When converting to C++, you will
have to raise the enum to top level or else use a qualified name,
which may not work with your C compiler.
The error message @samp{template-argument `...' 
uses local type `...'} may indicate this problem.

@end table


@command{dfec} does not accept every legal program in the intersection
of ANSI/ISO C and ANSI/ISO C++.  Here are the exceptions.
@enumerate

@item
If g++ gives an error message while compiling the instrumented code,
then first try compiling the uninstrumented code with @command{g++},
and remove any errors that g++ issues.  For instance, C++ requires
declaration of prototypes, whereas C can sometimes guess the types for
missing prototypes.

@item 
Instrumented programs must not redeclare functions defined in system
headers; for instance, do not do the following:
@example
       #include <stdlib.h>
       ...
       char *getenv(const char *name);
@end example

The reason is that dfec expects every C file to contain either only
code and declarations that are instrumented (with respect to smart
pointer tracking), or no code that is instrumented (with respect to
smart pointer tracking).  User code is instrumented, but library
functions are not, so you should use the declaration in
@file{stdlib.h} rather than repeating it in your own code.

@item
@command{dfec} redefines certain functions defined in system headers.
Your program must not define these as macros or otherwise use them
in a non-standard way.

@item
Instrumented programs must not use nested structures or enums that are
declared inside procedures.
You should raise all nested structures to
the top level (and after raising them, remove any
``static'' modifier, which is not relevant to top-level definitions).

You should also separate all declarations from uses.  For example, change
@example
  enum @{ make, user @} current_access;
@end example
to
@example
  enum current_access_type @{ make, user @};
  current_access_type current_access;
@end example

@item
@command{dfec} does not deal properly with bitfields (declared like
@samp{unsigned int env:1} for a single bit).  Change any bitfield
variables to full-width variables.

@end enumerate


@node    Header file dependencies, gcc version, C program requirements, dfec requirements
@subsubsection Header file dependencies

Some programs contain dependences on header files that make code that
is legal C but not legal C++.  dfec's input must be both legal C and
legal C++ (@pxref{C program requirements}).  This section shows how to
work around such problems by modifying the header files.

For example, the GNU @command{wc} program
(@uref{http://www.gnu.org/software/textutils/}; download from
@uref{ftp://ftp.gnu.org/pub/gnu/textutils/textutils-2.0.tar.gz})
contains the following test on line 179 (in textutils version 2.0):
@example
  (current_pos = lseek (fd, (off_t) 0, SEEK_CUR)) != -1
@end example
@noindent
However, Linux's header files define @samp{off_t} as @samp{__quad_t},
and @file{bits/types.h} in turn defines @samp{__quad_t} as
follows:
@example
  #ifdef __GNUC__
  __extension__ typedef long long int __quad_t;
  #else
  typedef struct
    @{
      long int __val[2];
    @} __quad_t;
  #endif
@end example

dfec uses the non-@samp{__GNUC__} branch.  (Many non-standard
extensions are enabled when @samp{__GNUC__} is defined, and dfec can
understand many but not all of them.)  In C, it is legal to cast the
number 0 to a struct.  Such a cast is not legal in C++.  Because
dfec's input must be both legal C and legal C++, dfec issues an error
message for line 179 of @file{wc.c}.

To work around the problem, execute the following two lines to create
a local copy of @file{bits/types.h}:
@example
  mkdir -p $DFECDIR/bits
  cp -p /usr/include/bits/types.h $DFECDIR/bits/types.h
@end example
@noindent
and then edit @file{$DFECDIR/bits/types.h} to remove all but the
second line of the above snippet.  This will define @samp{__quad_t} as
@samp{long long int} instead of as a struct.  dfec uses files found
under @file{$DFECDIR} in preference to other system headers, so
@file{wc.c} will compile.

You may need to make similar changes to other header files in order to
ensure that your code is both legal C and legal C++, or to work around
other problems.


@node    gcc version,  , Header file dependencies, dfec requirements
@subsubsection gcc version


@cindex gcc version for use with dfec
@cindex gcc 3, does not work with dfec
@cindex gcc 2.96

@command{dfec} works with gcc 2.95.3 or 2.95.2, so long as you do not
include both C's @file{math.h} and C++'s @file{complex.h}.
@command{dfec} also works with gcc 2.96; this is not an official gcc
release, but it does appear in some Linux distributions, such as Red Hat's.
@command{dfec} does not currently work with other
compilers or other versions of gcc.  In particular, gcc 3 does not
work, nor does the pre-release version labeled ``gcc 2.95.4'' that
appears in some Linux distributions (including some versions of
Debian).


@cindex gcc 2.95.3, installing
@cindex installing gcc 2.95.3

You can download gcc 2.95.3, which is the last official release in the
gcc 2.x series, from @uref{http://gcc.gnu.org/releases.html}.

gcc is easy to install; see the @uref{http://gcc.gnu.org/install/, ,
GCC installations instructions}.  If you do not wish to read them,
then the following commands may work for you.  They do not require
that you have superuser privileges on your machine.  They create
directory @file{/tmp/build-gcc-2.95.3}, then build gcc and install
gcc under directory @file{/tmp/build-gcc-2.95.3/gcc-installation}.
You may wish to adjust those directory names.

@example
cd /tmp
mkdir build-gcc-2.95.3
cd build-gcc-2.95.3
wget ftp://prep.ai.mit.edu/pub/gnu/gcc/gcc-2.95.3.tar.gz
gunzip gcc-2.95.3.tar.gz
tar xf gcc-2.95.3.tar
mkdir gcc-2.95.3-build
cd gcc-2.95.3-build
../gcc-2.95.3/configure --prefix=/tmp/build-gcc-2.95.3/gcc-installation
make bootstrap
make install
@end example

To test the installation, do the following:
@example
which gcc
gcc -v
set path = (/tmp/build-gcc-2.95.3/gcc-installation $path)
which gcc
gcc -v
@end example

Now you can just use it; "gcc" refers to the new version.  You should
also add the "set path" command to your .cshrc file.  If you use sh or
bash rather than csh, then add the following to your @file{.bashrc} or
equivalent file.
@example
  export PATH=/tmp/build-gcc-2.95.3/gcc-installation:$PATH
@end example


@node Perl front end dfepl, CSV front end convertcsv.pl, C front end dfec, Front ends
@section Perl front end dfepl

@cindex front end for Perl
@cindex Perl front end
@cindex dfepl (Daikon front end for Perl)

This section contains details about dfepl, the Daikon front end for
Perl. For a brief introduction to dfepl, see @ref{Perl examples} and
@ref{Instrumenting Perl programs}.

dfepl works with Perl versions 5.8 and later. (To be precise, Perl
programs instrumented with dfepl can also be run with Perl 5.6, but
the instrumentation engine, which is itself written in Perl, requires
version 5.8). dfepl reads the source code for Perl modules or
programs, and writes out instrumented versions of that code that
keep track of function parameters, and make calls to routines in the
@file{daikon_runtime} package whenever an instrumented subroutine is
entered or exited.

The instrumentation engine recognizes parameters as those variables
that are declared with @code{my(...)} or @code{local(...)} and, in the
same expression, assigned to from a value related to the argument
array @code{@@_}, but only among the first contiguous series of such
assignments in the body of a subroutine. This will capture the most
common assignment idioms, such as @code{my $self = shift;} (where
@code{shift} is short for @code{shift @@_}), @code{my $x = $_[0];}, and
@code{my($x, $y, @@a) = @@_;}, but the arguments to subroutines which
access them only directly through @code{@@_}, or that perform other
operations before reading their arguments, will not be recognized.

If the uninstrumented code requested warnings via the @code{use
warnings} pragma or by adding the @code{-w} flag on the @code{#!}
line, the instrumented code will also request warnings. In this case,
or if @code{-w} is specified on the command line when running it, the
instrumented code may produce warnings that the original code did
not.  There are several situations in which the instrumented code
produced by dfepl, while functionally equivalent to the original,
generates more warnings.  The most common such problem, which arises
from code that captures the scalar-context return value of a
subroutine that returns a list, has been avoided in the current
version by disabling the warning in question.  Other warnings which
are known to be produced innocuously in this way include
@code{Ambiguous call resolved as CORE::foo(), qualify as such or use
&} (caused by code that uses @code{CORE::} to distinguish a built-in
function from a user subroutine of the same name), and @code{Constant
subroutine foo redefined} (caused by loading both instrumented and
uninstrumented versions of a file).  Though some such warnings
represent deficiencies in the instrumentation engine, they can be
safely ignored when they occur.

Because Perl programs do not contain static type information to
distinguish, for instance, between strings and numbers, the Perl
front-end incorporates an additional dynamic analysis to infer these
types.  This type guessing, which occurs as a first pass before the
program can be instrumented to produce output for Daikon, operates in
a manner somewhat analogous to Daikon itself: watching the execution
of a program, the runtime system chooses the most restrictive type for
a variable that is not contradicted during that execution.  These
types indicate, for instance, whether a scalar value always holds an
integer, a possibly fractional numeric value, or a reference to
another object.  It should not be necessary to examine or modify this
type information directly, but for the curious, the syntax of the type
information is described in comments in the @file{Daikon::PerlType}
module.

The safest course is to infer types for variables using exactly the
same program executions (e.g., test cases) which will later be used to
generate traces for Daikon, as this guarantees that the type
information will match the actual data written to the trace file.
However, because the type-guessing-instrumented versions of programs
run fairly slowly in the current version, you may be tempted to use a
subset of the input data for type guessing.  Doing so is possible, but
it will only work correctly if the smaller tests exercise all of the
instrumented subroutines and exit points with all the types of data
they will later be used with. If the trace runtime tries to output a
data value that doesn't match the inferred type, the value may
silently be converted according to Perl's usual conventions (for
instance, a non-numeric string may be treated as the number zero), or
it may cause an error during tracing (for instance, trying to
dereference a supposed array reference that isn't).  Also, if a
subroutine exit point is traced but was never encountered during type
guessing, the generated @file{.decls} and @file{.dtrace} files will be
incompatible in a way that will cause Daikon to abort with an error
message of the form ``Program point foo():::EXIT22 appears in dtrace
file but not in any decl file''.

The workflow of instrumenting Perl code with dfepl is summarized in
the following diagram:
@*
@center @image{images/dfepl-flow,4in,}

The @command{dfepl} command works by reading one or more Perl programs
or modules, and writing out new versions of those files, instrumented
to capture information about their execution, by default to another
directory.  dfepl is used in two passes: first, before type
information is available, instrumented versions are written to a
directory @file{daikon-untyped}.  These untyped programs, when run,
will write
files containing dynamically inferred type information (with the
extension @file{.types}), by default to the @file{daikon-instrumented}
directory.  When dfepl is rerun with this type information, it
produces type-aware instrumented code in the
@file{daikon-instrumented} directory, which when run produces
execution traces in files with the extension @file{.dtrace} in the a
directory @file{daikon-output}.

@menu
* dfepl options::               
@end menu

@node dfepl options,  , Perl front end dfepl, Perl front end dfepl
@subsection dfepl options

@table @code
@item --absolute
@itemx --noabsolute
@option{--absolute} stores the absolute path to the output directories
(by default named @file{daikon-untyped}, @file{daikon-instrumented} or
@file{daikon-output}) in the instrumented programs, so that no matter
where the instrumented program is run, the output will go to a fixed
location. Even if these directories are given as relative paths (as is
the default), @option{--absolute} specifies that they should always be
taken as relative to the directory that was the working directory when
@command{dfepl} was run.

@option{--noabsolute} specifies the opposite, causing the output paths
to be interpreted relative to the current working directory each time
the instrumented program is invoked. The default, when neither option
is specified, is for @file{.types} files to use an absolute path, but
all others to use relative path, so that the @file{.types} files will
always be in the same place as the instrumented source files that
generated them, but the @file{daikon-output} directory will be created
in the current directory when the program runs.

@item --accessor-depth=@var{num}
Controls the number of nested invocations of object accessor methods
to examine. For instance, suppose that the @code{Person} class has a
method @code{mother()} that returns another person (and has been
specified to @command{dfepl} as an accessor), and that @code{$me} is
an instrumented variable. If the accessor depth is 1, only
@code{$me->mother()} will be examined. If the depth is 2,
@code{$me->mother()->mother()} will also be examined. Specifying large
accessor depths is generally not advisable, especially with many
accessor methods, as the number of variables examined can be too many
for Daikon to process efficiently.

By default, the Daikon Perl trace runtime will examine at most a
single level of accessors.

@item -A
@itemx --accessors-dir=@var{directory}
Look for files containing accessor lists in @var{directory}, or the
current directory if @var{directory} is omitted. For a class
@code{Acme::Foo}, accessors are methods that return information about
an object but do not modify it. @command{dfepl} cannot determine on
its own which methods are accessors, but when a list of them is
provided, it can call an object's accessors when examining a variable
of that class to obtain more information about the object. To tell
@code{dfepl} about the accessors for @code{Acme::Foo}, make a file
listing the names of each accessor method, one per line with no other
punctuation, named @file{Acme/Foo.accessors} in the same directory as
@file{Acme/Foo.pm}.

@item --decls-basedir=@var{directory}
Put generated declaration files in @var{directory} and its
subdirectories. The default is @file{daikon-output}.

@item --decls-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}. A style of @option{combined} specifies that the
declarations for all packages should be merged, in a file named
@file{prog-combined.decls} where @file{prog} is the name of the
program. A style of @option{flat} specifies that the declarations for
each package should be in a separate file named after the package, but
that these files should go in a single directory; for instance, the
declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.decls} and @file{Acme::Skates::Rocket.decls}. A
style of @option{tree} specifies that each package should have its own
declarations file, and that those files should be arranged in
directories whose structure matches the structure of their package
names; in the example above, the files would be
@file{Acme/Trampoline.decls} and @file{Acme/Skates/Rocket.decls}.

The default is @option{tree}.  Note that @option{--decls-style} and
@option{--types-style} are currently constrained to be the same; if
one is specified, the other will use the same value.

@item --dtrace-append
@itemx --nodtrace-append
When @option{--dtrace-append} is specified, the instrumented program
will append trace information to the appropriate
@file{.dtrace} file each time it runs. When
@option{--nodtrace-append} is specified, it will overwrite the file
instead. 

The default behavior is to overwrite. This choice can also be
overridden, when the program is run, to always append by setting the
environment variable @code{DTRACEAPPEND} to 1.

@item --dtrace-basedir=@var{directory}
Put generated trace files in @var{directory} and its
subdirectories. The default is @file{daikon-output}.

@item --dtrace-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}. A style of @option{combined} specifies that the traces
for all packages should be merged, in a file named
@file{prog-combined.dtrace}, where @file{prog} is the name of the
program. A style of @option{flat} specifies that the
traces for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.dtrace} and
@file{Acme::Skates::Rocket.dtrace}. A style of @option{tree} specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be @file{Acme/Trampoline.dtrace} and
@file{Acme/Skates/Rocket.dtrace}.

The default is @option{combined}.

@item --instr-basedir=@var{directory}
@itemx --instrsourcedir=@var{directory}
Put instrumented source files in @var{directory} and its
subdirectories. The default is @file{daikon-untyped}, or
@file{daikon-instrumented} if type information is available.

@item --list-depth=@var{DEPTH}
Consider as many as @var{DEPTH} of the first elements of a list to be
distinct entities, for the purpose of guessing their types. When
subroutines return a list of values, each value may have a distinct
meaning, or the list may be homogeneous. When trying to assign types
to the elements of a list, the Daikon Perl trace runtime will try
making separate guesses about the types of the elements of a short
list, but it would be inefficient to make retain this distinction for
many elements. This parameter controls how many elements of a list
will be examined individually; all the others will be treated
uniformly.

The default is 3.

@item --output-dir=@var{directory}
Put all of the files that are the output of the tracing process (and
therefore input to the Daikon invariant detection engine) in
@var{directory} and its subdirectories. This option is a shorthand
equivalent to setting both @option{--decls-basedir} and
@option{--dtrace-basedir} to the same value.

The default behavior is as if @option{--output-dir=daikon-output} had
been specified.

@item --perl=@var{path}
Use @var{path} as the location of Perl when calling the annotation
back end (a module named @code{B::DeparseDaikon}), rather than the
version of Perl under which @command{dfepl} itself is running, which
is probably the first @command{perl} that occurs on your path. For
instance, if the first version of @command{perl} on your path isn't
version 5.8 or later, you should this option to specify another
@command{perl} program that is.

@item --reference-depth=@var{num}
When examining nested data structures, traverse as many as @var{num}
nested references. For instance, suppose that @code{@@a} is the array

@example
@@a = (@{1 => [2, 3]@}, @{5 => [4, 2]@})
@end example

If the depth is 0, then when examining @code{@@a}, Daikon's Perl trace
runtime will consider it to be an array whose elements are references,
but it won't examine what those references point to. If the depth is
1, it will consider it to be an array of references to hashes whose
keys are integers and whose values are references, but it won't
examine what @emph{those} references point to. Finally, if the depth
is 2 or more, it will consider @code{@@a} to be an array of references
to hashes whose keys are integers and whose values are references to
arrays of integers.

The default reference depth is 3.

When referenced objects have accessor methods, or when accessors
return references, the @option{--accessor-depth} and
@option{--reference-depth} options interact. Specifically, if these
depths are A and R, the behavior is as if the runtime has a budget of
1 unit, which it can use either on accessors which cost 1/A or
references which cost 1/R@.  It may thus sometimes be useful to specify
fractional values for @option{--accessor-depth} and
@option{--reference-depth}; in fact, the default accessor depth is
1.5.

@item --types-append
@itemx --notypes-append
When @option{--types-append} is specified, the instrumented program
will append type information to the appropriate
@file{.types} file each time it runs. When
@option{--notypes-append} is specified, it will overwrite the file
instead. 

The default behavior is to append. If @option{--notypes-append} is
specified, however, this choice can also be overridden, when the
program is run, to append by setting the environment variable
@code{TYPESAPPEND} to 1. There is no way to use environment variables
to force the runtime to overwrite a types file, but an equivalent
effect can be obtained by simply removing the previous types file
before each run.

@item -T
@itemx --types-dir=@var{directory}
Look for @file{.types} files in @var{directory}, or
@file{daikon-instrumented} if @var{directory} is omitted. When
instrumenting a module @code{Acme::Trampoline}, used in a program
@file{coyote.pl},  @command{dfepl} will look for
files named @file{coyote-combined.types}, @file{Acme::Trampoline.types}, and
@file{Acme/Trampoline.types}, corresponding to the possible choices of
@option{--types-style}. Once discovered, the files are used in the
same way as for @option{-t}.

@item --types-file=@var{file}
@itemx -t @var{file}
Include type information from @var{file} when instrumenting programs
or modules. Since Daikon needs to know the types of variables when
they are declared, useful @file{.decls} and @file{.dtrace} files can
only be produced by source code instrumented with type
information. Since Perl programs don't include this information to
begin with, and it would be cumbersome to produce by hand, type
information must usually be produced by running a version of the
program that has itself been annotated, but without type
information. The Daikon Perl trace runtime will automatically decide
whether to output types, or declarations and traces, depending on
whether the source was instrumented without or with types. This option
may occur multiple times, to read information from multiple types
files (irrelevant type information will be ignored).

@item --types-basedir=@var{directory}
Put files containing type information in @var{directory} and its
subdirectories. By default, this is whatever @option{--instr-basedir}
is, usually @file{daikon-instrumented}.

@item --types-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}. A style of @option{combined} specifies that the types
for all packages should be merged, in a file named
@file{prog-combined.types}, where @file{prog} is the name of the
program.  A style of @option{flat} specifies that the
types for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.types} and
@file{Acme::Skates::Rocket.types}. A style of @option{tree} specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be @file{Acme/Trampoline.types} and
@file{Acme/Skates/Rocket.types}.

The default is @option{tree}. Note that @option{--types-style} and
@option{--decls-style} are currently constrained to be the same; if
one is specified, the other will use the same value.

@item --verbose
@itemx -v
Print additional information about what @command{dfepl} is doing,
including external commands invoked.
@end table

@node CSV front end convertcsv.pl,  , Perl front end dfepl, Front ends
@section Comma-separated-value front end convertcsv.pl

@cindex csv files
@cindex comma-delimited files
@cindex comma-separated-value files
@cindex tab-separated files
@cindex Excel files
@cindex spreadsheet files

Daikon can process data from spreadsheets such as Excel.  In order to
use such files, first save them in comma-separated-value, also known
as csv or comma-delimited, format.
Then, convert the @file{.csv} file into a @file{.dtrace} file (and a
@file{.decls} file) to be used by Daikon by running the
@command{convertcsv.pl} program found in the @file{$DAIKONDIR/bin}
directory.  For example,
@example
  convertcsv.pl myfile.csv
@end example
@noindent
produces files @file{myfile.decls} and @file{myfile.dtrace}.  Run
@command{convertcsv.pl} without any arguments in order to see a usage
message.

@node    Enhancing Daikon output, Tools, Front ends, Top
@chapter Enhancing Daikon output

@menu
* Configuration options::       
* Conditional invariants::      
* Enhancing conditional invariant detection::  
@end menu

@node    Configuration options, Conditional invariants, Enhancing Daikon output, Enhancing Daikon output
@section Configuration options

@cindex configuration options
@cindex dkconfig_ variables

Many aspects of Daikon's behavior can be controlled by setting various
configuration parameters.  These configuration parameters control which
invariants are checked and reported, the statistical tests for
invariants, which derived variables are created, and more.

The configuration options are set by creating a configuration file and
supplying it to Daikon on the command line using the @option{--config
@var{filename}} option.  Daikon reads all supplied configuration files
in order, overriding the defaults.  You may wish to use the supplied
example configuration file
@file{daikon/java/daikon/config/example-settings.txt} as an example when
creating your own configuration files.  (If you did not downloaded
Daikon's sources, you will have to extract the example from
@file{daikon.jar} to read it.)

You may also specify a configuration setting directly on the command line,
using the @option{--config_option @var{name}=@var{value}} option.

The configuration options are different from the debugging flags
@option{--debug} and @option{--dbg @var{category}} (@pxref{Command line
options}).  The debugging flags permit Daikon to produce debugging
output, but they do not affect the invariants that Daikon computes.

@menu
* List of configuration options::  
@end menu

@node    List of configuration options,  , Configuration options, Configuration options
@subsection List of configuration options

This is a list of all Daikon configuration options.
The configuration option name contains the
Java classes in which it is defined.  (In the Daikon source code, the
configuration value is stored in a variable whose name contains a
@code{dkconfig_} prefix, but that should be irrelevant to users.)
To learn more about a specific invariant or derived variable, see
its source code.

@table @asis
@include config-options.texinfo
@end table


@node    Conditional invariants, Enhancing conditional invariant detection, Configuration options, Enhancing Daikon output
@section Conditional invariants and implications
@cindex splitting
@cindex splitting condition
@cindex conditional invariant
@cindex invariant, conditional
@cindex implication invariant
@cindex invariant, implication

Conditional invariants are invariants that are true only part of the time.
For instance, the postcondition for the absolute value procedure is
@example
if arg < 0
  then return == -arg
  else return == arg
@end example
@noindent
The invariant @code{return == -arg} is a conditional invariant because
it depends on the predicate @code{arg < 0} being true.  An
@emph{implication} is a compound invariant that includes both the
predicate and the conditional invariant (also called the consequent).

Daikon must be supplied with the predicate for an implication.  Daikon has
certain built-in predicates that it uses for finding conditional invariants;
examples are which return statement was executed in a procedure and whether a
boolean procedure returns true or false.  Additionally, Daikon can read
predicates from a file called a splitter info (@file{.spinfo}) file and find
implications based on those predicates. The splitter info file can be produced
automatically, such as by static analysis of the program using the CreateSpinfo
and CreateSpinfoC programs or by cluster analysis of the
traced values in the data trace file. Details of these techniques and usage
guides can be found in @ref{Enhancing conditional invariant detection}.  Users
can also create splitter info files by hand or manually augment
automatically-created ones.

To detect conditional invariants and implications:
@enumerate
@item
Create the splitter info file, either automatically or by hand.
@item
Run Daikon with the @file{.spinfo} file as one of its arguments.  
(The order of arguments does not matter.)
For example,
@example
java daikon.Daikon Foo.decls Foo.spinfo Foo.dtrace
@end example
@end enumerate

The term ``splitter'' comes from Daikon's technique for detecting
implications and conditional invariants.  For each predicate, Daikon
creates two conditional program points --- one for program executions
that satisfy the condition and one for those that don't --- and splits
the data trace into two parts.  Invariant detection is then performed
on the conditional program points (that is, the parts of the data
trace) separately and any invariants detected are reported as
conditional invariants (as implications).

To be precise, we say that an invariant holds exclusively if it is
discovered on one side of a split, and its negation is discovered on
the opposite side.  Daikon creates conditional invariants whose
predicates are invariants that hold exclusively on one side of a
split, and whose consequents are invariants that hold on that side of
the split but not on the un-split program point.  If Daikon finds
multiple exclusive conditions, it will create biconditional (``if and
only if'') invariants between the equivalent conditions.  Within the
context of the program, each of the exclusive conditions is equivalent
to the splitting condition.  In particular, if both the splitting
condition and its negation are within the grammar of invariants that
Daikon detects, the splitting condition may appear as the predicate of
the generated conditional invariants.  On the other hand, if other
equivalent conditions are found, or if the splitting condition is not
expressible in Daikon's grammar, it might not appear in the generated
implications.

@cindex dummy invariant
@cindex invariant, dummy

In some cases, the default policy of selecting predicates from
Daikon's output may be insufficient.  For instance, Daikon might not
detect any invariant equivalent to the splitting condition, if it is
sufficiently complex or application-specific.  In such situations,
Daikon can also use the splitting condition itself as the predicate of
an implication, as what is called a ``dummy invariant''.  A ``dummy
invariant'' is one whose meaning is not dealt with directly by Daikon;
instead Daikon knows only how to print the invariant in its output.
When a tool or a user writes a splitter info file, the file can
specify a way to print the condition represented by the splitter in
any of Daikon's output formats.  If the use of dummy invariants is
enabled, invariants with the supplied output formats will be used as
the predicates of conditional invariants.

To use dummy invariants, a condition's formatting must be specified in
the splitter info file, and the configuration option
@option{daikon.PptTopLevel.dummy_invariant_level} must be set to a
non-zero value (see @ref{List of configuration options}).

@menu
* Splitter info file::          
* Indiscriminate splitting::    
* Example splitter info file::  
@end menu

@node    Splitter info file, Indiscriminate splitting, Conditional invariants, Conditional invariants
@subsection Splitter info file
@cindex splitter info file
@cindex .spinfo file
@cindex spinfo file

A splitter info file contains the conditions that Daikon should use to
create conditional invariants.  Each section in the @file{.spinfo}
file consists of a sequence of non-blank lines; sections are separated
by blank lines.  There are two types of sections:  program point
sections and replacement sections.
@xref{Example splitter info file}, for an example splitter info file.

@menu
* Program point sections::      
* Replacement sections::        
@end menu

@node    Program point sections, Replacement sections, Splitter info file, Splitter info file
@subsubsection Program point sections

Program point sections have a line specifying a program point name
followed by lines specifying the condition(s) associated with that
program point, each condition on its own line.  Additional information
about a condition may be specified on indented lines.  For example, a
typical entry is

@example
PPT_NAME @var{pptname}
@var{condition1}
@var{condition2}
    DAIKON_FORMAT @var{output string}
    ESC_FORMAT @var{output string}
@var{condition3}
...
@end example
@noindent
@var{pptname} can be any string that matches a part of the desired
program point name as printed in the decls file.  In finding matching
program points, Daikon uses the first program point that matches
@code{pptname}.  Caution is necessary when dealing with method names
that are prefixes of other method names.  For instance, if the class
@code{List} has methods @code{add} and @code{addAll}, specifying
@code{PPT_NAME List.add} might select either method, depending on
which was encountered first.  Instead writing @code{PPT_NAME
List.add(} will match only the @code{add} method.

Each condition is a Java expression of boolean type.  All variables
that appear in the condition must also appear in the declaration of
the program point in the @file{.decls} file.  (In other words, all the
variables must be in scope at the program point(s) where the Splitter
is intended to operate.) The automatically generated Splitter source
code fails to compile (but Daikon proceeds without it) if a variable
name in a condition is not found at the matching program point.

Indented lines beginning with @option{DAIKON_FORMAT},
@option{JAVA_FORMAT}, @option{ESC_FORMAT}, @option{SIMPLIFY_FORMAT},
or @option{IOA_FORMAT} may be used to specify how to represent the
condition specified by the splitter in each of Daikon's output
formats, to allow the splitting condition to be used as a dummy
invariant.

@node    Replacement sections,  , Program point sections, Splitter info file
@subsubsection Replacement sections

Ordinarily, a splitting condition may not invoke user-defined methods,
because when Daikon reads data trace files, it does not have access to the
program source.  A replace section of the splitter info file can specify
the bodies of methods, permitting conditions to invoke those methods.  The
format is as follows:
@example
REPLACE
@var{procedure1}
@var{replacement1}
@var{procedure2}
@var{replacement2}
...
@end example
@noindent
where @samp{replacement@var{i}} is a Java expression for the body
of @samp{procedure@var{i}}.  In each condition, Daikon replaces procedure
calls by their replacements.  A replace section may appear anywhere in
the splitter info file.

@node    Indiscriminate splitting, Example splitter info file, Splitter info file, Conditional invariants
@subsection Indiscriminate splitting

Ordinarily, each condition in an @file{.spinfo} file gives rise to
conditional invariants only at the program point in whose section the
condition appears.  Alternately, every condition can be used at every
program point, regardless of where in the @file{.spinfo} file the
condition appeared; this latter approach is called ``indiscriminate
splitting''.

The advantage of indiscriminate splitting is that a condition that is
useful at one program point may also be useful at another --- if the
same variables are in scope or other variables of the same name are in
scope.  The disadvantage of indiscriminate splitting is that often the
condition is not applicable everywhere, and when it is, it may not be
useful at all such locations, so checking for many conditional
invariants may slow down Daikon without a corresponding benefit. 
Indiscriminate splitting can result in Daikon attempting
to use many conditions that are inappropriate at certain program
points, for instance because the program point does not have (in
scope) all the variables that are used in the condition.  For example,
the condition @code{myArray.length == x} is inapplicable at a program
point if either of @samp{myArray} and @samp{x} is not in scope at that
program point.  In this case, Daikon prints a warning message and
proceeds, using conditions wherever they are valid.

By default, Daikon uses indiscriminate splitting.  To use
non-indiscriminate splitting, place the following line in a file that is
passed to Daikon via the @option{--config} flag (@pxref{Command line
options}):
@example
daikon.split.SplitterList.all_splitters = false
@end example


@node    Example splitter info file,  , Indiscriminate splitting, Conditional invariants
@subsection Example splitter info file

Below is an implementation of a simple Queue for positive integers and
a corresponding @file{.spinfo} file. The splitter info file is like
the one that @command{CreateSpinfo} would create for that class, but
also demonstrates some other features.

@menu
* Example class::               
* Resulting .spinfo file::      
@end menu

@node    Example class, Resulting .spinfo file, Example splitter info file, Example splitter info file
@subsubsection Example class

@smallexample
class simpleStack @{
 
  private int[] myArray;
  private int currentSize;
 
  public simpleStack(int capacity) @{
    myArray = new int[capacity];
    currentSize = 0;
  @}
 
  /** Adds an element to the back of the stack, if the stack is
    * not full.
    * Returns true if this succeeds, false otherwise.  **/
  public String push(int x) @{
    if ( !isFull() && x >= 0) @{
      myArray[currentSize] = x;
      currentSize++;
      return true;
    @} else @{
      return false;
    @}
  @}
 
  /** Returns the most recently inserted stack element.
    * Returns -1 if the stack is empty. **/
  public int pop() @{
    if ( !isEmpty() ) @{
      currentSize--;
      return myArray[currentSize];
    @} else @{
      return -1;
    @}
  @}

 /** Returns true if the stack is empty, false otherwise. **/
  private boolean isEmpty() @{
    return (currentSize == 0);
  @}

  /** Returns true if the stack is full, false otherwise. **/
  private boolean isFull() @{
    return (currentSize == myArray.length);
  @}
@}
@end smallexample

@node    Resulting .spinfo file,  , Example class, Example splitter info file
@subsubsection Resulting .spinfo file

@smallexample
REPLACE
isFull()
currentSize == myArray.length
isEmpty()
currentSize == 0

PPT_NAME  simpleStack.push
!isFull() && x >= 0
    DAIKON_FORMAT !isFull() and x >= 0
    SIMPLIFY_FORMAT (AND (NOT (isFull this)) (>= x 0))

PPT_NAME  simpleStack.pop
!isEmpty()

PPT_NAME  simpleStack.isFull
currentSize == myArray.length - 1

PPT_NAME  simpleStack.isEmpty
currentSize == 0
@end smallexample

@node    Enhancing conditional invariant detection,  , Conditional invariants, Enhancing Daikon output
@section Enhancing conditional invariant detection

The built-in mechanisms (@pxref{Conditional invariants}) have
limitations in the invariants they can find.  By supplying splitting
conditions to Daikon via a splitter info file, the user can infer more
conditional invariants.  To ease this task, there are two methods to
automatically create splitter info files for use by Daikon.

@menu
* Static analysis for splitters::  
* Cluster analysis for splitters::  
@end menu

@node   Static analysis for splitters, Cluster analysis for splitters, Enhancing conditional invariant detection, Enhancing conditional invariant detection
@subsection Static analysis for splitters

@cindex splitting conditions, static analysis
@cindex static analysis for splitters
@cindex CreateSpinfo
@cindex CreateSpinfoC

In static analysis, all explicitly stated boolean statements in the program
source are extracted and used as splitting conditions.  The assumption is that
conditions that are explicitly tested in the program are likely to affect the
program's behavior and could lead to useful conditional invariants.  

The CreateSpinfo program takes Java source code as input and creates a
splitter info file for each input file; for instance,
@example
java daikon.tools.jtb.CreateSpinfo Foo.java Bar.java
@end example
@noindent
creates the splitter info files @file{Foo.spinfo} and
@file{Bar.spinfo}.
Given an @option{-o @var{filename}} argument, CreateSpinfo puts all the
splitters in the specified file instead.
The resulting splitter info file(s) contains each
boolean expression that appears in the source code.  The conditional
statements that the programmer used in the source code are likely to
have important semantic properties.  This simple heuristic of using
these conditional statements as predicates for conditional invariant
detection is often quite effective.  

If you get an error such as
@example
  jtb.ParseException: Encountered ";" at line 253, column 8.
  Was expecting one of: "abstract" ...
@end example
@noindent
then you may have encountered a bug in the JTB library on which
CreateSpinfo is built.  It does not permit empty declarations in a
class body.  Remove the extra semicolon in your Java file (at the
indicated position) and re-rerun CreateSpinfo.

The @command{CreateSpinfoC} program performs the same function, for
C source code.  It can only be run on postprocessed source
files---that is, source files contain no CPP commands.  CPP commands
are lines starting with @samp{#}, such as @samp{#include}.  To
expand CPP commands into legal C, run either @command{cpp -P} or
@command{gcc -P -E}.  For instance, here is how you could use it.
@example
cpp -P foo.c foo.c-expanded
cpp -P bar.c bar.c-expanded
java daikon.tools.jtb.cparser.CreateSpinfoC \
     foo.c-expanded bar.c-expanded
@end example
@noindent

If you get an error such as
@example
... Lexical error at line 5, column 1.
Encountered: "#" (35), after : ""
@end example
@noindent
then you forgot to run cpp before running CreateSpinfoC@.

@node   Cluster analysis for splitters,  , Static analysis for splitters, Enhancing conditional invariant detection
@subsection Cluster analysis for splitters

@cindex splitting conditions, cluster analysis
@cindex cluster analysis for splitters
@cindex runcluster.pl program

Cluster analysis is a statistical method that finds groups or clusters
in data.  The clusters may indicate conditional properties in the
program.  A conditional property at a program point separates the data
into those that satisfy it and those that do not, and conditional
invariants can be induced by clustering.  Any invariant that is
discovered over one cluster but not over another is a conditional
invariant---the predicate for the conditional invariant being
membership in the cluster in which the invariant was found.  The
cluster analysis mechanism finds clusters in the data trace file,
infers invariants over any clusters that it finds, and writes these
invariants into a splitter info file for conditional invariant
detection.

To find splitting conditions using cluster analysis, run the
@command{runcluster.pl} program (found in the @file{$DAIKONDIR/bin}
directory) in the following way:
@example
runcluster.pl [OPTIONS] dtrace_file(s) decls_files(s)
@end example

The options are:
@table @option

@item -a @var{ALG}
@item --algorithm @var{ALG}
@var{ALG} specifies a clustering algorithm.
Current options are @samp{km} (for kmeans), @samp{hierarchical},
and @samp{xm} (for xmeans).  The default is @samp{xm}.

@item -k
The number of clusters to use (for algorithms which require
this input, which is everything except xmeans).  The default is 4.

@item --keep    
Don't delete the temporary files created by the clustering
process.  This is a debugging flag.
@end table

The @command{runcluster.pl} script currently supports three clustering
programs. They are implementations of the kmeans algorithm,
hierarchical clustering and the xmeans algorithm (kmeans algorithm
with efficient discovery of the number of clusters). The kmeans and
hierarchical clustering tools are provided in the daikon
distribution. The xmeans code and executable are publicly available at
@uref{http://www.cs.cmu.edu/~dpelleg/kmeans.html} (fill in the license
form and mail it in).


@node    Tools, Troubleshooting, Enhancing Daikon output, Top
@chapter Tools

This chapter gives information about tools that are part of the Daikon
distribution and are not described elsewhere in the manual.

@menu
* MergeESC::                    
* MakeInvariantChecker::        
* LogicalCompare::              
@end menu

@node    MergeESC, MakeInvariantChecker, Tools, Tools
@section MergeESC

@cindex MergeESC tool
@cindex ESC output format
@cindex output format, ESC

The MergeESC program inserts Daikon-generated invariants into Java
source code as ESC/JML annotations.  These annotations are comments that
can be automatically verified or otherwise manipulated by other tools.
Invoke MergeESC like this:
@example
java daikon.tools.jtb.MergeESC Myprog.inv Myprog.java Myprog2.java ...
@end example

The first argument is a Daikon @file{.inv} file produced by running
Daikon with the @option{-o} command-line argument.  All subsequent
arguments are .java files.  The original .java files are left
unmodified, but MergeESC produces new @file{-escannotated} versions that
include the Daikon invariants as comments.


@node    MakeInvariantChecker, LogicalCompare, MergeESC, Tools
@section MakeInvariantChecker

@cindex MakeInvariantChecker tool

The MakeInvariantChecker program takes a set of invariants found by Daikon
and creates a specialized checking program that checks (only) those
invariants.  The checking program can be run on new data trace files
to determine whether the new trace files exhibit all the behavior that
the old ones (that Daikon originally used to create the set of
invariants) did.

Invoke MakeInvariantChecker like this:
@example
java daikon.Daikon myProgram.decls myProgram.dtrace -o myProgram.inv
java daikon.tools.MakeInvariantChecker myProgram.inv TestMyProgram.java
javac TestMyProgram.java
java TestMyProgram myProgram_new.dtrace
@end example

The first argument to MakeInvariantChecker is a Daikon output file name
(which must contain a @file{.inv} extension) and the second argument
is a Java file name into which Java source for the specialized checker
will be generated.
  
Command line options to the generated program:
 - h prints the usage line
 - o filename writes all the invariant violations in the file called filename

The specialized checker program takes one argument, a data trace file.
(It is typically a different file than the one used for generating the
".inv" file that was provided to MakeInvariantChecker.)

If the new trace violates any invariants in the set provided to
MakeInvariantChecker, then MakeInvariantChecker prints a message that
indicates the invariant and the variable values that violate it. 

@node LogicalCompare,  , MakeInvariantChecker, Tools
@section LogicalCompare

@cindex LogicalCompare tool
@cindex implication checking tool
@cindex comparison tool, logical

Given two sets of invariants describing the operation of a software
module, or describing two implementations of a module with the same
interface, we can define one set of invariants to be ``stronger'' than
another roughly if in any situation where the ``stronger'' invariants
hold, the ``weaker'' invariants also hold. The LogicalCompare tool
examines two sets of invariants, and checks using the Simplify
automatic theorem prover whether they satisfy a precise version of
this relationship.

Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to use this program.

The LogicalCompare program takes two mandatory arguments, which are
@file{.inv} files containing invariants; the invariants will be
checked to verify if the invariants in the first file are weaker
(implied by) the invariants in the second file, and exceptions to this
implication are printed. If no other regular arguments are supplied,
all the method or function program points that exist in both files
will be compared, with a exception message reported for each method
that exists in the ``weaker'' set but not the ``stronger''.
Alternatively, one or two additional arguments may be supplied, which name an 
ENTER program point and an EXIT program point to examine (if only an
ENTER program point is supplied, the corresponding combined EXIT point
is selected automatically). To be precise, for each
pair of program points representing a single method or function,
LogicalCompare will check that each precondition (ENTER point
invariant) in the ``stronger'' invariant set is implied by some
combination of invariants in the ``weaker'' invariant set, and that
each postcondition (EXIT point invariant) in the ``weaker'' invariant
set is implied by some combination of postconditions in the
``stronger'' set and preconditions in the ``weaker'' set. In summary,
the syntax of an invocation of LogicalCompare will have the following
form:

@example
java daikon.tools.compare.LogicalCompare [options...]
      WEAK-INVS STRONG-INVS [ENTER-PPT [EXIT-PPT]]
@end example

LogicalCompare accepts the following options:

@table @code
@item --assume @var{file}
Read additional assumptions about the behavior of compared routines
from the file @var{file}. The assumptions file should consist of lines
starting with @code{PPT_NAME}, followed by the complete name of an
ENTER program point, followed by lines each consisting of a Simplify
formula, optionally followed by a @code{#} and a human-readable
annotation. Blank lines and lines beginning with a @code{#} are
ignored. The assumption properties will be used as if they were
invariants true at the strong EXIT point when checking weak EXIT point
invariants.

@item --cfg @var{option}=@var{value}
Specify a single configuration setting. The available settings are the
same as can be passed to Daikon's @option{--config_option} option,
though because the invariants have already been generated, some will
have no effect.  For a list of
available options, @xref{Configuration options}.

@item --config-file=@var{file}
Read configuration options from the file @var{file}. This file should
have the same format as one passed to Daikon's @option{--config}
option, though because the invariants have already been generated,
some will have no effect.

@item --debug-all
@itemx --dbg CATEGORY
These options have the same effect as the @option{--debug} and
@option{--dbg} options to Daikon, causing debugging logs to be
printed.

@item --filters=[bBoOmjpi]
Control which invariants are removed from consideration before
implications are checked. Note that except as controlled by this
option, LogicalCompare does not perform any of the filters that
normally control whether invariants are printed by Daikon. Also,
invariants that cannot be formatted for the Simplify automatic theorem
prover will be discarded in any case, as there would be no other way
to process them. Each letter controls a filter: an invariant is reject
if it is reject by any filter (or, equivalently, kept only if it
passes through every filter).

@table @code
@item b
Discard bound invariants (such as ``x <= c'' and ``x >= c'' for a
constant c), when Daikon considers the constant to be uninteresting.
Currently, Daikon has a configurable range of interesting constant: by
default, -1, 0, 1, and 2 are interesting, and no other numbers are.

@item B
Discard all bound invariants, whether or not the constants in them are
considered interesting.

@item o
Discard ``one-of'' invariants (which signify that a variable always
had one of a small set of values at runtime), when the values that the
variable took are considered uninteresting by Daikon.

@item O
Discard all ``one-of'' invariants, whether or not the values involved
are interesting.

@item m
Discard invariants for which it was never the case that all the
variables involved in the invariant were present at the same time.

@item j
Discard invariants that Daikon determines to be statistically
unjustified, according to its tests.

@item p
Discard invariants that refer to the values of pass-by-value
parameters in the postcondition, or to the values of objects pointed
to by parameters in postconditions, when the pointer is not
necessarily the same as at the entrance to the method or function.
Usually such invariants reflect implementation details that would not
be visible to the caller of a method.

@item i
Discard implication invariants when they appear in ENTER program
points.
@end table

The default set of filters corresponds to the letters ``ijmp''.

@item --help
@itemx -h
Print a brief summary of available command-line options.

@item --no-post-after-pre-failure
If implication is not verified between two invariant sets after
examining the preconditions, do not continue to check the implication
involving postconditions. Because the postconditions aren't formally
meaningful outside the domain specified by the preconditions, this is
the safest behavior, but in practice trivial precondition mismatches
may prevent an otherwise meaningful postcondition comparison. See also
@code{--post-after-pre-failure}.

@item --proofs
For each implication among invariants that is verified, print a
minimal set of conditions that establish the truth of the conclusion.
The set is minimal, in the sense that if any condition were removed,
the conclusion would no longer logically follow according to Simplify,
but it is not the least such set: there may exist a smaller set of
conditions that establish the conclusion, if that set is not a subset
of the set printed. Beware that because this option uses a naive
search technique, it may significantly slow down output.

@item --post-after-pre-failure
Even if implication is not verified between two invariant sets after
examining the preconditions, continue to check the implication
involving postconditions. This is somewhat dangerous, in that if the
implication does not hold between the preconditions, the invariant
sets may be inconsistent, in which case reasoning about the
postconditions is formally nonsensical, but the tool will attempt to
ignore the contradiction and carry on in this case. This is now the
default behavior, so the option has no effect, but it is retained for
backward compatibility. See also @code{--no-post-after-pre-failure}.

@item --show-count
Print a count of the number of invariants checked for implication.

@item --show-formulas
For each invariant, show how it is represented as a logical formula
passed to Simplify.

@item --show-sets
Rather than testing implications among invariants, simply print the
sets of weak and strong ENTER and EXIT point invariants that would
normally be compared. The invariants are selected and filtered as
implied by other options.

@item --show-valid
Print invariants that are verified to be implied (``valid''), as well
as those for which the implication could not be verified (``invalid''
invariants, which are always printed).

@item --timing
For each set of invariants checked, print the total time required for
the check. This time includes both processing done by LogicalCompare
directly, and time spent waiting for processing done by Simplify, but
does not include time spent de-serializing the @file{.inv} input
files.

@end table

@node    Troubleshooting, Details, Tools, Top
@chapter Troubleshooting

@cindex troubleshooting
@cindex warning messages
@cindex error messages

This chapter gives solutions for certain problems you might have with
Daikon; it also tells you how to report bugs in a useful manner.


@menu
* Installation problems::       
* dfej problems::               
* dfec problems::               
* Daikon problems::             
* Large dtrace files::          
* Other problems::              
* Reporting bugs::              
* Known bugs::                  
* Further reading::             
@end menu


@node    Installation problems, dfej problems, Troubleshooting, Troubleshooting
@section Problems installing Daikon

The tar file may appear to contain a file named @file{././@@LongLink}.
This is inserted in a tar file when a filename is longer than a specific
maximum length (often 100 characters).  If you see this file, then your
version of the tar program does not recognize this indication.  It is
possible that some filenames (including the one contained in
@file{././@@LongLink}) have been truncated.

@c As of Daikon 2.3.5 (March 1, 2002), the two affected files were:
@c daikon/java/jakarta-oro-2.0.3/docs/classes/org/apache/oro/text/regex/MalformedPatternException.class
@c daikon/java/jakarta-oro-2.0.3/docs/classes/org/apache/oro/text/perl/MalformedPerl5PatternException.class


@node    dfej problems, dfec problems, Installation problems, Troubleshooting
@section Problems with dfej

@menu
* dfej installation problems::  
* dfej invocation problems::    
@end menu

@node    dfej installation problems, dfej invocation problems, dfej problems, dfej problems
@subsection Problems installing dfej

gcc 2.95.2 on Linux raises an internal error when compiling
@file{stream.cpp} using the @option{-Wall} flag.  You can simply compile
that file without the @option{-Wall} flag.

@cindex cannot convert `const char **' to `char **'

If you get an error like
@example
stream.cpp: In method `void LexStream::ProcessInputUnicode
                                       (const char *, long int)':
stream.cpp:901: cannot convert `const char **' to `char **' for
argument `2' to `iconv (void *, char **, size_t *, char **, size_t *)'
@end example
@noindent
then
@c undefine preprocessor macro @code{HAVE_ICONV_H}
define preprocessor macro @code{HAVE_ERROR_CALL_ICONV_CONST}
and try compiling again --- that is, run the command that failed, but
add the @samp{-DHAVE_ERROR_CALL_ICONV_CONST} command-line argument.
(This has been reported on Red Hat Linux 7.@i{x}.)

@c reported 12/19/2001 by Tao Xie
Also reported on Red Hat Linux 7.0 is the following error:
@example
daikon-context.cpp:466: no matching function for call to `pair<Ast *, 
Ast *>::pair (Ast *&, void *)'
@end example
@noindent
We do not yet have a fix, but if you find one, please let us know.


@node    dfej invocation problems,  , dfej installation problems, dfej problems
@subsection Problems running dfej

@cindex dfej, runs slowly

You may find that dfej runs very slowly, even on small programs.  dfej
itself finishes quite quickly, but it calls the external Ajax program,
which is extremely slow.  If you disable Ajax with the
@option{-noajax} argument to dfej, then Daikon may output slightly
more irrelevant invariants, but dfej will run much faster.

@cindex could not find package named, dfej error

If you get an error like
@example
% dfej MyProg.java
MyProg.java:0:0:0:0: Error: Could not find package named: 
                ./java/util
MyProg.java:0:0:0:0: Error: Could not find package named: 
                ./java/lang
@end example
@noindent
then you need to add @file{rt.jar} to your
CLASSPATH@.  This should be automatic, if you are using the
@file{daikon.bashrc} or @file{daikon.cshrc} file and have set the
JDKDIR environment variable correctly.  Also see @ref{Installing dfej}.

@cindex zip file, invalid

If you get an error like
@example
MyProg.java:0:0:0:0: Error: Could not find package named:
                MyProg.MyPackage
@end example
@noindent
then the root of your packages in not in your classpath.  For example,
if you have a package A in directory src/A and a class A.B, then you
have to add the superdirectory of A (src) to your classpath so that
dfej can find package A@.  For example,
@example
dfej -classpath src:$CLASSPATH src/A/B.java
@end example
@noindent
Note that this behavior is identical to that of jikes, but differs
from javac.

If you get a warning like
@example
*** Warning: the file "/cygdrive/c/jswdk-1.0.1/jspengine.jar"
    is not a valid zip file.
@end example
@noindent
then you have set your CLASSPATH incorrectly:  it names a nonexistent
file or a file that is not a @file{.jar} Java archive.  You should adjust
your CLASSPATH to remove the offending file.  This warning has no effect
on the operation of dfej, however.

@cindex duplicate definition, in instrumented Java file

While compiling files instrumented by dfej, if you get an error like
@example
Duplicate declaration of local variable "this_invocation_nonce".
Duplicate declaration of method "daikonPrintArrayMissing"
    in type "StackAr".
@end example
@noindent
then you have instrumented an already-instrumented file.  Remove the
instrumented version and re-run dfej on the original version.  (If you
are using the Daikon regression tests, run @command{make clean}.)

@menu
* Ajax errors::                 
@end menu

@node    Ajax errors,  , dfej invocation problems, dfej invocation problems
@subsubsection Ajax errors

@cindex Ajax, problem with

The warning ``Problem with Ajax; using original .decls files instead''
indicates that the Ajax variable comparator could not run.

Ajax
indicates which variables are comparable to which other variables.  This
information can reduce the amount of spurious output from Daikon by
preventing it from making spurious comparisons and reporting irrelevant
output.  For example, two integer variables that never appear together
in an expression (and that don't appear with variables that appear
together, etc.)@ should not be compared to one another, because those
variables are likely to be entirely unrelated and any properties over
them are incidental and uninformative.

Use of Ajax is optional and can be disabled via the
@option{-noajax} argument to dfej (@pxref{dfej options}).
If Ajax cannot be run, then a more primitive method of determining
comparability is used instead.  Even if Ajax cannot be run, Daikon
proceeds without error.

@cindex No such method in call, Ajax error
@cindex ajax.jbc.InvalidClassDataError
@cindex InvalidClassDataError, Ajax

Ajax cannot deal with binary .class files of version later that 1.1.
Thus, before running ajax, compile all your code using @command{javac
-target 1.1} to create correct format .class files.  Note that all the
.jar files and other class files in your classpath used by the code
also need to be compiled using @command{javac -target 1.1} in order
for ajax to be able to execute.

As of July 2002, Ajax cannot deal with JDK 1.2 (or later) libraries.
For instance, Ajax issues the error ``ajax.jbc.InvalidClassDataError:
No such method in call'' for methods such as
java.lang.Math.toDegrees(Double) that do not appear in JDK 1.1.

@cindex Invalid class loading, Ajax warning

Ajax may produce the warning message ``Invalid class loading ...'';
you will notice this if environment variable DFEJ_VERBOSE is set.
You may safely ignore this message if Ajax does not produce any
further warnings or errors.  The message results from Ajax's inability
to handle JDK 1.2 libraries.

@cindex classpath cycles
@cindex Too many levels of symbolic links, Ajax exception

Due to a bug in Java 1.3,
Ajax may throw a RuntimeException with a message stating
``Too many levels of symbolic links''.  This can be caused
by cycles in the classpath (for example, a link from a directory to
itself).  To locate the problem link, rerun the the the failing command
as before, but prefixed by ``strace ''.  If the original command had
been @samp{wc ~/.emacs}, then you would instead run 
@samp{strace wc ~/.emacs}.
Search the resulting output for the exception stack trace, containing
the message, "Too many levels of symbolic links".  On the line just
before the stack trace begins should appear the name of the link being
processed.  For example,
@example
lstat("a/sources/sources", st_mode=S_IFLNK|0777, st_size=53, ...) = 0
@end example
@noindent
Removing the link identified, in this case @file{.../sources/sources},
should solve the problem.


@node    dfec problems, Daikon problems, dfej problems, Troubleshooting
@section Problems with dfec

If you have trouble while instrumenting a C program, or while
compiling the instrumented program, first make sure that the program
being instrumented satisfies dfec's requirements: @xref{C program requirements}.

Problems with dfec can be divided into those encountered when running
dfec; those encountered when compiling and linking the instrumented code; and
those encountered when running the instrumented code.

@menu
* dfec instrumentation problems::  
* Compilation and linking of instrumented code problems::  
* Running instrumented code problems::  
@end menu


@node    dfec instrumentation problems, Compilation and linking of instrumented code problems, dfec problems, dfec problems
@subsection Problems running dfec

dfec errors in system files, such as
@file{.../gcc-3.2.1/include/c++/3.2.1/cstdlib}, or in the Daikon C
runtime, @file{daikon_runtime.h}, are likely to indicate that you are
using an unsupported version of gcc.  In particular, when you run
dfec, the version of gcc on your path should be 2.95.2, 2.95.3, or
2.96; @xref{gcc version}.

@cindex ?: operator, types of operands

dfec is sometimes confused by the conditional expression (@samp{?:})
operator, saying that the two sides are of different types.  If either
of the reported types involve ``DaikonSmartPointer'', then the problem
may be that the compiler could interconvert the two different types in
the original code, but after dfec instrumented those types, the
resulting ones were no longer interconvertible.  You have
two options.  The first option is to
rewrite the expression using a conditional statement (@samp{if
... else}).
@c Take care, because in C it is illegal to insert statements in the middle
@c of a list of declarations.
The second option is to add an appropriate cast to give the two
arms of the conditional expression the same type.  For example, change
the second line of
@example
  char * mystring = ...;
  foo ? "literal" : mystring;
@end example
@noindent
to
@example
  foo ? (char *)"literal" : mystring;
@end example
@noindent
or perhaps to
@example
  foo ? strdup("literal") : mystring;
@end example
@noindent
(though the latter introduces a small memory leak).

@menu
* Lackwit problems::            
@end menu

@node    Lackwit problems,  , dfec instrumentation problems, dfec instrumentation problems
@subsubsection Lackwit problems

@cindex Lackwit error, identifier undefined
@cindex identifier undefined, Lackwit error
@cindex undefined identifier, Lackwit error

By default, dfec runs the Lackwit variable comparability analysis
package.  Use of Lackwit is optional, but it can make invariant
detection more accurate and efficient.  Lackwit errors are non-fatal
to dfec, which can continue even if Lackwit fails.  (Lackwit is
pickier than dfec, so it may fail when dfec does not.)

If Lackwit (but not dfec proper) gives errors of the form
``identifier "strcat" is undefined'', then you have failed to include
the proper header file.  In this case, you should add @samp{#include
<string.h>} to the program to make the program valid ANSI C@.  dfec
does not produce this particular error, because it includes
@file{daikon_runtime.h}, which itself includes @file{string.h}.

@cindex lwpp-init.pl error

If Lackwit gives an error of the form
@example
sh: lwpp-init.pl: not found
@end example
@noindent
then you have not correctly installed the dfec distribution
(@pxref{Installing dfec}).  The @file{lwpp-init.pl} file should appear
in the directory referred to by environment variable DFECDIR@.  (That
directory is placed on your path by the standard Daikon dotfiles.)

Note, lackwit may have different preprocessor parameters set than
@command{gcc} or @command{g++} (and @command{dfec}) do.  As a result,
you may get errors about undefined function definitions with
@command{lackwit}, but not with @command{dfec} proper.  Check if the
preprocessor is following the wrong branch, and adjust your code to
follow the right branch.  

@node    Compilation and linking of instrumented code problems, Running instrumented code problems, dfec instrumentation problems, dfec problems
@subsection Problems compiling and linking instrumented programs

This section discusses errors encountered when compiling instrumented
code (with g++) and linking the resulting compiled files.  (In some
cases, compiling and linking may be performed by a single command line
invocation, but the two steps are still logically distinct.)

  In Emacs, run this command from the @file{.cc} file
buffer to comment out the @samp{#line} directives:
@example
(replace-regexp "^\\(#line.*\\)$" "/* \\1 */" nil nil nil)
@end example


@menu
* Compiler problems::           
* Linker problems::             
@end menu

@node    Compiler problems, Linker problems, Compilation and linking of instrumented code problems, Compilation and linking of instrumented code problems
@subsubsection Compiler problems

When compiling the instrumented code (e.g., @samp{g++ myfile.cc},
where @file{myfile.cc} was created by dfec from @file{myfile.c}), g++
produces error messages referring to lines of the original file
@file{myfile.c}.  Often this indicates the problem, but in other
cases, you may wish to know which line in the @file{.cc} file is the
wrong one.  In that case, remove or comment out all the @samp{#line}
directives from the @file{.cc} file and re-compile.  For example, run
this command in the @file{daikon-instrumented} directory:
@example
  perl -pi -e 's|^(#line.*)$|/* $1 */|' myfile.cc
@end example


@cindex DaikonSmartPointer errors in compilation of instrumented code
@cindex function not defined errors in compilation of instrumented code

@c Can this happen, if the original g++ compilation worked?
A ``function not defined'' error may indicate a type mismatch in the
original code.  Code shold not declare a parameter but omit the
correspondng argument at the function call.  The solution is to make
the function declaration consistent with the use.

@cindex template-argument uses local type errors
@cindex local type in template-argument error

An error of the form ``template-argument ... uses local type'' is
probably due to use of a nested (local) structure declaration; raise
the declaration to top level in your C program.

An error of the form @samp{`__T142459136' was not declared in this
scope} likely means that you simultaneously declared and used an enum
or other type.  Separate the declaration from the use.


@node    Linker problems,  , Compiler problems, Compilation and linking of instrumented code problems
@subsubsection Linker problems

This section discusses problems that may occur when linking files that
have been instrumented by dfec.  For more details,
@xref{Instrumentation scope}.

@cindex undefined symbol error
@cindex error, undefined symbol
@cindex ld error
@cindex symbol referencing errors
@cindex DaikonSmartPointer link errors

A linker error involving DaikonSmartPointer, such as
@example
Undefined                       first referenced
 symbol                             in file
foo(DaikonSmartPointer<Bar>)/var/tmp/ccPtoCZc.o
ld: fatal: Symbol referencing errors. No output written to MyProgram
@end example
@noindent
means that
instrumented (or partially instrumented) code contains a declaration
of @samp{foo(bar *)}, but the definition appears in uninstrumented
code.  The instrumented version uses smart pointers, but the
uninstrumented version does not.  You should supply the @file{.c} file
containing the definition to @command{dfec} (preceded by @option{-l}
if you do not wish to fully instrument the file).

If you cannot specify the @file{.c} containing the definition of
@samp{foo()} to dfec (for instance, if it appears in a pre-compiled
library), then no code supplied to dfec should contain a declaration
for @samp{foo()}.   The declaration should occur in a @file{.h} file
that your code @samp{#include}s, but that is not specified on the dfec
command line.

Other linker problems may indicate a mismatch between part of
your code that was compiled with gcc and part of it that was compiled
with g++.  gcc creates files using ``C linkage'', and g++ creates
files using ``C++ linkage''; the two are not compatible.  (It is
possible to direct g++ to use C linkage in certain circumstances;
@xref{Instrumentation scope}.)
While g++ can compile and link in the same step,
you should never provide the link step (the one that creates an
executable) with uninstrumented C code.  You should only provide the
link invocation of g++ with either
@itemize @bullet
@item
@file{.cc} files (or their @file{.o} versions) that were output
by dfec, or
@item
@file{.o} or @file{.a} files for (completely) uninstrumented code;
these files should be created by calling gcc, never
g++.
@end itemize


@node    Running instrumented code problems,  , Compilation and linking of instrumented code problems, dfec problems
@subsection Problems running instrumented code

@cindex daikon_runtime error
@cindex error, daikon_runtime
@cindex attempted to access index error
@cindex error, attempted to access index

A program instrumented by dfec may produce a message such as
@example
daikon_runtime: attempted to access index 5 of a 4-length array!
@end example
@noindent
Such a message indicates that there is an error in your program.  Your
program attempts to read or write memory beyond the end of an array.
You should fix this error before proceeding to try to detect
invariants.  If you do not do so, then the program's results cannot be
relied on, because the erroneous array access might corrupt (or access
meaningless values from) other variables, the Daikon runtime data
structures, or your program's stack.  When this occurs, the Daikon
runtime immediately halts your program to let you know where the error
occurred and to prevent memory corruption.  The Daikon runtime's
discovery of these errors, while not directly related to invariant
detection, is a pleasant side effect of using Daikon.  You also might
want to consider using the Valgrind tool for Linux on x86 processors
(@uref{http://developer.kde.org/~sewardj/}), which can help you correct
memory errors; this reduces the number of warnings/errors produced by
the Daikon runtime, and it also improves your code.

@cindex daikon_runtime.h file
@cindex customizing the Daikon C runtime

The Daikon runtime's behavior when a program
contains a memory error is customizable.
For instance, it can halt immediately; it
can allocate extra buffer space around arrays (but cannot do so around
dynamically allocated (malloced) blocks, because the type is not known
at the time of the malloc call) and only halt if the program goes
beyond those bounds; or the checking can be turned off entirely, which
is extremely dangerous.  These and many other customizations for the
Daikon C runtime library are described in the @file{daikon_runtime.h}
file.


@node    Daikon problems, Large dtrace files, dfec problems, Troubleshooting
@section Problems running Daikon

You may find the debugging flags @option{--debug} and @option{--dbg
@var{category}} useful if you wish to track down bugs or better
understand Daikon's operation; @xref{Command line options}.
@xref{Configuration options}, for another way to adjust Daikon's output.


@menu
* No return from procedure::    
* Out of memory::               
* Simplify errors::             
* Contradictory invariants::    
* Method needs to be implemented::  
* JVM initialization error::    
* Daikon runs slowly::          
@end menu

@node    No return from procedure, Out of memory, Daikon problems, Daikon problems
@subsection No return from procedure

@cindex no return from procedure, warning
@cindex return from procedure, warning

Daikon sometimes issues a warning that a procedure in the target program
was entered but never exited (that is, the target program abnormally
terminated).  Thus, the @file{.dtrace} file contains more entry records
than exit records for the given procedure.  Some procedures that were
entered were never recorded to have exited: either they threw an
exception, skipping the instrumentation code that would have recorded
normal termination, or the target program's run was interrupted.

@cindex nonce, invocation
@cindex this_invocation_nonce

In some cases, exceptional exit from a procedure can cause
@code{orig(@var{x})} values to be incorrect.  This depends on the
technique used to associate procedure exits with entries.  Daikon has
two such techniques --- the nonce technique and the stack technique.  If
a @file{.dtrace} file uses the nonce technique, @code{orig(@var{x})}
values are guaranteed to be correct.  If a @file{.dtrace} file uses the
stack technique, then incorrect @code{orig(@var{x})} values are likely
to occur.  You can tell which technique Daikon will use by examining the
@file{.dtrace} file.  If the second line of each entry in the
@file{.dtrace} file is "this_invocation_nonce", then Daikon uses the
nonce technique.  Otherwise, it uses the stack technique.  Which
technique is used is determined by the front end, which creates the
@file{.dtrace} file, and typically cannot be controlled by the user.



@node    Out of memory, Simplify errors, No return from procedure, Daikon problems
@subsection Out of memory

@cindex out of memory error
@cindex java.lang.OutOfMemoryError
@cindex memory exhaustion
@cindex HotSpot JVM
@cindex JVM memory management
@cindex permanent generation (in HotSpot JVM)

If Daikon runs out of memory, generating a message like
@example
        Exception in thread "main" java.lang.OutOfMemoryError
                <<no stack trace available>>
@end example
@noindent
then the problem is likely to be an excessively large input
file.  In addition to the solutions discussed in @ref{Large dtrace
files}, you can try increasing the amount of memory available to Java
with the @option{-mx} argument to @command{java}.  (This flag is
JVM-specific; see your JVM documentation for details. For instance,
its correct name in JDK versions 1.3 and later is @option{-Xmx}.)  
The default may be 64 megabytes or less; to permit use of up to 256
megabytes, you would run Java like so:
@example
        java -mx256m ...
@end example

When using the Java HotSpot JVM, an additional parameter may need to
be increased. HotSpot uses a separately-limited memory region, called
the `permanent generation', for several special kinds of allocation,
one of which (interned strings) Daikon sometimes uses heavily.  It may
be necessary to increase this limit as well, with the
@option{-XX:MaxPermSize=} option. For instance, to use 512 megabytes,
of which at most 256 can be used for the permanent generation, you
would run Java like so:
@example
        java -Xmx512m -XX:MaxPermSize=256m
@end example

Another possible problem is the creation of too many derived variables.
If you supply the @option{--output_num_samples} argument to Daikon
(@pxref{Command line options}), then it will list all
variables at each program point.  If some of these are of no interest,
you may wish to suppress their creation.  (This manual does not
presently tell you how to do that, but you can see the source code or
ask an expert.)

Any output generated before the out-of-memory error is perfectly valid.


@node    Simplify errors, Contradictory invariants, Out of memory, Daikon problems
@subsection Simplify errors

@cindex Simplify, could not utilize

The warning ``Could not utilize Simplify'' indicates that the Simplify
theorem-prover could not be run; this usually indicates that the
@command{Simplify} binary was not found on the user's path.
Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed.

If Simplify is not used, certain redundant (logically implied)
invariants may appear in Daikon's output.  The output is
correct, but more verbose than it would be if you used Simplify.

@node Contradictory invariants, Method needs to be implemented, Simplify errors, Daikon problems
@subsection Contradictory invariants

@cindex contradictory invariants
@cindex inconsistent invariants
@cindex invariants, inconsistent
@cindex invariants, contradictory

The invariants Daikon produces are all true statements about the
supplied program executions, so they should be mutually consistent.
Sometimes, however, because of a bug or a limitation in Daikon,
contradictory invariants are produced.

One known problem involves object invariants. Daikon infers object
invariants by observing the state of an object when its public methods
are called. However, if an object has publicly accessible fields that
are changed by code outside the class, after which no public methods
are called, invariants about the state of the object as seen by other
code can contradict the class's object invariants. A workaround is to
allow changes to an object's state from outside the class only by
way of public methods.

Besides confusing the user, contradictory invariants also cause
trouble for the Simplify theorem prover that implements the
@option{--suppress_redundant} option. When the invariants at a
particular program point contradict each other or background
information (such as the types of objects), Simplify becomes unable to
distinguish redundant invariants from non-redundant ones.

The best solution in such cases is to fix the underlying cause of the
contradictory invariants, but since that is sometimes not possible,
Daikon will try to work around the problem by avoiding the invariants
that cause a contradiction. Daikon will attempt to find a small subset
of the invariants that aren't mutually consistent, and remove one,
repeating this process until the remaining invariants are consistent.
(Note that the invariants are removed only for the purposes of
processing by Simplify; this does not affect whether they will be
printed in the final output).  While this technique can allow
redundant invariants to be found when they otherwise wouldn't be, it
has some drawbacks: the choice of which invariant to remove is
somewhat arbitrary, and the process of finding contradictory subsets
can be time consuming. The removal process can be disabled with the
@option{daikon.simplify.LemmaStack.remove_contradictions}
configuration option.

@node    Method needs to be implemented, JVM initialization error, Contradictory invariants, Daikon problems
@subsection Method needs to be implemented

@cindex method needs to be implemented warning
@cindex needs to be implemented warning

Daikon may produce output like the following (but all on one line):
@example
method daikon.inv.binary.twoSequence.SubSequence.format_esc()
needs to be implemented:
this.theArray[0..this.topOfStack] is a subsequence of
orig(this.theArray[0..this.topOfStack])
@end example
@noindent
This indicates that a particular invariant (shown on the last two lines
above) cannot be formatted using the current formatting.  In this example,
the invariant can be formatted using Daikon's default
formatting (which is how it is shown above), but (as of April 2002)
Daikon cannot output it in ESC format, so Daikon prints the above
message instead.  The message also shows exactly what Java method needs
to be implemented to correct the problem.  You can ignore such messages,
or else use an output formatting that can handle those invariants.
MergeESC (@pxref{MergeESC}) automatically ignores unformattable invariants.


@node    JVM initialization error, Daikon runs slowly, Method needs to be implemented, Daikon problems
@subsection JVM initialization error

@cindex JVM initialization error
@cindex initialization error, JVM
@cindex Vector, dfej cannot instrument

Instrumenting Vector prevents the Java Virtual Machine from initializing
properly, because instrumented classes attempt to use the JVM's
facilities when they are loaded, but the JVM loads Vector during its own
initialization.  The same problem may be true for other classes used
internally by the JVM@.  Users can create a new class MyVector, replace
uses of Vector by MyVector, and then instrument MyVector.


@node    Daikon runs slowly,  , JVM initialization error, Daikon problems
@subsection Daikon runs slowly

@cindex slow operation, of Daikon
@cindex runtime, of Daikon

Daikon's runtime and space depend on the particular data that it analyzes.
Informally, invariant detection time can be characterized as O((vars^3 *
falsetime + trueinvs * testsuite) * procedures), where vars is the number
of variables @emph{at a program point}, falsetime is the (small constant)
time to falsify a potential invariant, trueinvs is the (small) number of
true invariants at a program point, testsuite is the size of the test
suite, and program is the number of instrumented program points.  The first
two products multiply a number of invariants by the time to test each
invariant.

If there are many true invariants over an input, then Daikon continues
to check them all over the entire input.  By contrast, if not many
invariants are true, then Daikon need no longer check them once they
are falsified (which in practice happens quickly).  Daikon processes
each procedure independently.

Another important factor affecting Daikon's runtime is the number of
variables.  Because invariants involve up to three variables each, the
number of invariants to check is cubic in the number of variables at a
single program point.  Derived variables (such as @samp{a[i]},
introduced whenever there is both an array @samp{a} and an integer
@samp{i}) can increase the number of variables substantially.

For details on improving Daikon's performance, see @ref{Out of
memory}, and @ref{Large dtrace files}.

@node    Large dtrace files, Other problems, Daikon problems, Troubleshooting
@section Large data trace (.dtrace) files

@cindex data trace files, too large
@cindex large data trace files

Running instrumented code can create very large @file{.dtrace} files.
This can be a problem because writing the large files can slow the
target programs substantially, because the large files may fill up
your disk, or because when reading the large files, Daikon fills up
your computer's physical or virtual memory.  There are three general
solutions to this problem:  compute invariants over fewer program
points (functions), compute invariants over fewer variables, or
compute invariants over fewer samples (executions).

It is usually possible to create an @file{.inv} file equivalent to
the one that Daikon would have computed, had Daikon been able to
process your entire program over its full test suite.  First, use the
techniques below (@pxref{Reducing program points}) to split your
@file{.dtrace} file into parts.  Next, run Daikon on each resulting
@file{.dtrace} file. Finally, use the union function of @ref{Invariant
Diff} to combine the resulting @file{.inv} files into one.

@menu
* Reducing program points::     
* Reducing variables::          
* Reducing executions::         
@end menu

@node    Reducing program points, Reducing variables, Large dtrace files, Large dtrace files
@subsection Reducing program points (functions)

Here are ways to compute invariants over a subset of the program
points (functions) in your program.
@enumerate
@item 
You can make Daikon ignore some program points.  With the
@example
  --ppt @var{ppt_regexp}
@end example
@noindent
flag (@pxref{Command line options}), only program points matching
the regular expression are processed.  Likewise, the
``@option{--ppt_omit} @var{ppt_omit_regexp} option causes program points
matching the regular expression to be ignored.

@item 
@cindex trace-purge-fns.pl script
You can remove some program points (functions) from your
@file{.dtrace} file.  The @command{trace-purge-fns.pl} script takes as
arguments a (Perl) regular expression and a list of files.  It
modifies each file in place, removing every program point (function)
whose name matches the regular expression.  The @option{-v} flag means
to retain rather than discard matching program points.  For instance,
to create two subparts of a @file{.dtrace} file --- one containing the
getters and setters, and the other containing all other functions --
use the following commands:
@example
  cp myprog.dtrace myprog-setters.dtrace
  trace-purge-fns.pl -v 'set|get' myprog-setters.dtrace
  cp myprog.dtrace myprog-non-setters.dtrace
  trace-purge-fns.pl 'set|get' myprog-non-setters.dtrace
@end example

@item 
You can instrument fewer methods, creating smaller @file{.dtrace}
files in the first place (rather than cutting the @file{.dtrace} files
down afterward).
@itemize
@item With dfej, use the 
@example
  -daikon_omit=@var{string}
@end example
@noindent
argument (@pxref{dfej options}).  Dfej will not produce data trace
output for classes or procedures that match @var{string}.  Running the
instrumented program will result in a smaller @file{.dtrace} file that
contains fewer records.
@item With dfec, split your program into multiple files, then
instrument only some of them (see below).
@end itemize

@item
You can instrument fewer files.
@itemize
@item With dfej, only supply it the files you wish to instrument.
@item With dfec, use the @option{-l} command (@pxref{dfec command-line
arguments}) on the command line immediately before any file you wish
not to instrument.
@end itemize

@end enumerate

@node    Reducing variables, Reducing executions, Reducing program points, Large dtrace files
@subsection Reducing variables

Here are ways to compute invariants over a subset of the variables in
your program.  This changes the resulting invariants, because
invariants over the missing variables (including any relationship
between a missing variable and a retained variable) are not detected
or reported.  For instance, you might remove uninteresting variables
(or ones that shouldn't be compared to certain others) or variables
that use a lot of memory (such as some arrays).

@enumerate
@item
You can make Daikon ignore certain variables rather than modifying
the @file{.dtrace} file directly.  Analogously with the
@option{--ppt_omit} flag, the @option{--var_omit} flag makes Daikon
ignore any variable matching the following regular expression.

@item
You can reduce the number of variables that are output by instrumented
code.  Do this by reducing the class/structure instrumentation depth.
@itemize
@item With dfej, use the @option{-daikon_depth=@var{N}} option.
@item With dfec, use the @option{--struct-depth=@var{N}} option.
@end itemize

@item 
You can pare down an existing @file{.dtrace} file using the
@command{trace-purge-vars.pl} script.  Analogously to the 
@command{trace-purge-fns.pl} script, it removes certain variables from
all program points in a function (or retains them, with the
@option{-v} flag).  After running this command, you will need
to edit the corresponding @file{.decls} file by hand to remove the
same variables.

@end enumerate

@node    Reducing executions,  , Reducing variables, Large dtrace files
@subsection Reducing executions

Here are ways to run Daikon over fewer executions of each program
point.  (You cannot combine the resulting invariants in order to
obtain the same result as running Daikon over all the executions.)

@enumerate
@item
If you have multiple @file{.dtrace} files (perhaps resulting from 
multiple program runs), you can run Daikon on just some of them.

@item 
@cindex trace-untruncate program
You can terminate the instrumented program when it has created a
sufficiently large @file{.dtrace} file.  If you interrupt the program
while it is in the middle of writing a record to the @file{.dtrace}
file, the last record may be only partially written.  Use the
@command{daikon/bin/trace-untruncate} program to remove the last,
possibly partial, record from the file:
@example
  trace-untruncate @var{myfile}.dtrace
@end example
@noindent
modifies @file{myfile.dtrace} in place to remove the last record.

Alternately, you can use the
@command{daikon/bin/trace-untruncate-fast} program.  It operates much
faster on very large files.  In order to use
@command{trace-untruncate-fast}, you must have already compiled it
(@pxref{Installing Daikon}).

@end enumerate

@node    Other problems, Reporting bugs, Large dtrace files, Troubleshooting
@section Other problems

@menu
* Tree GUI font errors::        
@end menu

@node    Tree GUI font errors,  , Other problems, Other problems
@subsection Tree GUI font errors

@cindex font not found

When running the Tree GUI on Linux, you may get font errors such as the following:

@example
Font specified in font.properties not found
  [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
@end example

These errors are harmless; the Tree GUI will still run correctly.  To
prevent these errors from appearing in the future, take the following
steps:

@itemize @bullet
@item
Find out where your JDK root directory is.  In general, the JDK root directory
is where you run java from: @file{@var{JDK_ROOT}/bin/java}.
@item
Edit @file{@var{JDK_ROOT}/jre/lib/font.properties}, and comment out all lines
with the offending fonts.  For example, to eliminate the error messages
shown above, one would comment out all lines containing "fontspecific".
@end itemize

If you don't have permission to edit @file{font.properties}, ask
your system administrator to do so.


@node    Reporting bugs, Known bugs, Other problems, Troubleshooting
@section Reporting bugs

@cindex reporting bugs
@cindex bugs, reporting

If you have any questions, can suggest ways to improve the
documentation, find bugs in the system, or have suggestions for its
improvement, please send email to
@email{daikon-developers@@pag.lcs.mit.edu}.  While Daikon is a
research prototype, we will try to assist you and to correct any
problems, so please don't hesitate to ask for help or report
difficulties.  Additionally, if you can contribute enhancements or bug
fixes, those will be gratefully accepted.

Your bug report will be most helpful if you include:
@itemize @bullet
@item
the version of Daikon, which appears in the file @file{daikon/README}
and is also printed when you run Daikon; also, whether you are running
from the @file{.class} files or from the @file{.jar} file.
If you are not using the most recent version, download a newer version
from @uref{http://pag.lcs.mit.edu/daikon/} to see whether your problem
has already been corrected.
@item
a description of exactly what you did, exactly what happened, and what
you expected to happen instead.
For instance, a transcript of your commands and the system's output
may provide this information.  (A transcript is @strong{much} more
useful than a vague description.)
@item
input files that permit the problem to be replicated.  The
most important thing is the original, uninstrumented source files.
It is also helpful to include instrumented source files,
@file{.decl} files, and @file{.dtrace} files.
@item
any other information that you consider relevant.
@end itemize

It is frequently more difficult to reproduce an error than to correct
it; if you make it easy to reproduce and verify the problem, then it is
much more likely to be corrected.

You may also wish to take advantage of the Daikon mailing lists
(@pxref{Mailing lists}).


@node    Known bugs, Further reading, Reporting bugs, Troubleshooting
@section Known bugs

@c [The following problems are already known.  (You may report them again,]
@c [to encourage us to release the fix faster, if you like.)]

There are no outstanding user-reported problems at this time.


@node    Further reading,  , Known bugs, Troubleshooting
@section Further reading

More information on Daikon can be found in the Daikon Developer Manual.
For instance, the Daikon Developer Manual indicates how to extend
Daikon with new invariants, new derived variables, and front ends for
new languages.  It also contains information about the implementation
and about debugging flags.

The mailing list archives (@pxref{Mailing lists}) may contain helpful
information (we strive to incorporate that information in this
manual), or you may find discussions on those lists helpful to you.

For further reading, see the list of publications at the 
Daikon homepage, @uref{http://pag.lcs.mit.edu/daikon/}.


@node    Details, File formats, Troubleshooting, Top
@chapter Details

The Daikon invariant detector is named after an Asian radish.
``Daikon'' is pronounced like the combination of the two one-syllable
English words "die-con".

More information on Daikon can be found in the Daikon Developer Manual.
For instance, the Daikon Developer Manual indicates how to extend
Daikon with new invariants, new derived variables, and front ends for
new languages.  It also contains information about the implementation
and about debugging flags.


@menu
* History::                     
* License::                     
* Credits::                     
@end menu

@node    History, License, Details, Details
@section History
@cindex history of Daikon

This manual describes Daikon version 2.5.3, released October 1, 2003.
A list of revisions since mid-2001 can be found in file
@file{daikon/doc/CHANGES} in the distribution; this section gives a
high-level view of the package's history.

There have been two major implementations of Daikon, with different
features and capabilities.  Readers of technical papers may be confused
by the apparently different claims about Daikon's capabilities.  These
apparent contradictions result from the papers referring to the current
version of Daikon at the time of publication.  This section of the
manual clarifies the development of the Daikon tool in order to reduce
such confusion.

@cindex Lisp front end
@cindex front end for Lisp
@cindex loop heads, instrumenting
@cindex instrumenting loop heads
@cindex Python implementation of Daikon
@cindex Daikon 1

Daikon 1 was written in the Python programming language in 1998.  It included
front ends for C, Java, and Lisp.  The C front end was extremely limited
and failed to operate correctly on all C programs:  sometimes it
suffered a segmentation fault while instrumenting a target program, and even
when that did not happen, sometimes the instrumented program
segmentation-faulted while running.  The Lisp front end operated
correctly on all Lisp programs, but only instrumented certain common
constructs, leaving other language features uninstrumented.  The Java front
end was reasonably reliable.  The Lisp front end instrumented procedure
entries, exits, and loop heads; the C front ends instrumented only
procedure entries and exits; and the Java front end instrumented program
points for object invariants as well as procedure entries and exits.

Daikon 2 was a complete rewrite in the Java programming language and was
the first version to contain a substantive manual.  Daikon 2 uses the
same Java front end as did Daikon 1, though with certain enhancements.
(Actually, there have been 5 Java front ends; the first two were
binary re-writers; the next two were source code re-writers; and the
last (experimental as of January 2003) one is a binary rewriter.)
Its C front end is rewritten from scratch; it instruments only
procedure entries and exits.  A front end also exists for the IOA
programming language, but is not included in the Daikon distribution.

Daikon 3 is a redesign of the invariant detection engine to work
incrementally -- that is, to examine each sample (execution of a
program point) once, then discard it.  By contrast, Daikon 1 and
Daikon 2 made multiple passes over the data.  This simplified their
algorithms but required storing all the data in memory at once, which
was prohibitive, particularly since data trace files may be gigabytes
in size.  Daikon 3 also introduces the idea of a @emph{dataflow
hierarchy}, a way to relate and connect program points based on their
variables.

@node    License, Credits, History, Details
@section License


Daikon is made available for education, research, and evaluation
purposes (not for direct commercial gain), and there is no warranty.
All rights are reserved, and copyright is held by the authors.  If you
have difficulties with the software, let us know and we will do our best
to correct the problem.  Unfortunately, we cannot make any guarantees of
support, or any other guarantees regarding the software.  As a condition
of use, you agree to promptly communicate any changes, improvements, or
enhancements to the authors for inclusion in a future release under
these same conditions, and to promptly report any errors, problems, or bugs.
If you do not agree to this license, please do
not use or examine the software.  Other licensing terms are available;
send mail to @email{mernst@@lcs.mit.edu}.

Daikon uses the Java port of the GNU getopt library, which is
copyright 1998 Aaron M. Renn. The getopt library is free software, and
may be redistributed or modified under the terms of the GNU Library
General Public License version 2. A copy of this license is included
with the Daikon distribution as the file
@file{java/gnu/getopt/COPYING.LIB}.

@comment We plan to stop using the org.apache.oro.* regex package
@comment soon, at which point this paragraph should be removed.
This product includes software developed by the Apache Software
Foundation (http://www.apache.org/), Copyright (c) 2000 The Apache
Software Foundation. All rights reserved. The license governing this
software is included with the Daikon distribution as the file
@file{java/jakarta-oro-2.0.6/LICENSE}.

Daikon's unit tests use the JUnit testing framework, which is governed
by the Common Public License, version 1.0. JUnit is provided on an
``as is'' basis, without warranties or conditions of any kind, either
express or implied including, without limitation, any warranties or
conditions of title, non-infringement, merchantability or fitness for
a particular purpose. Neither the Daikon developers nor the authors of
the JUnit framework shall have any liability for any direct, indirect,
incidental, special, exemplary, or consequential damages (including
without limitation lost profits), however caused and on any theory of
liability, whether in contract, strict liability, or tort (including
negligence or otherwise) arising in any way out of the use or
distribution of JUnit or the exercise of any rights granted in
the Common Public License, even if advised of the possibility of such
damages. Those portions of JUnit that appear in the Daikon
distribution may be redistributed under the same terms as Daikon
itself; this offer is made by the Daikon developers exclusively and
not by any other party. The Common Public License is included with the
Daikon distribution as the file @file{java/junit/cpl-v10.html}.

Note that the front ends discussed in this manual are separate
programs, and some are made available under different licenses.  All
of the software in the main Daikon distribution is made available
under the same license as the Daikon tool proper, or a less
restrictive license.  However, because the front ends are separate
programs not derived from the Daikon invariant detection tool, you are
neither required nor entitled to use the Daikon invariant detector
itself under these other licenses.

The Daikon Perl front end dfepl may be used and distributed under the
regular Daikon license or, at your option, either the GNU General
Public License or the Perl Artistic License (that is, under the same
terms as Perl itself).

If you use Daikon, please subscribe to the daikon-announce and
daikon-discuss mailing lists (@pxref{Mailing lists}).  The
daikon-announce list will inform you of new versions, enhancements,
and bug fixes.  On the daikon-discuss mailing list, you can obtain
help from, and offer help to, other users.  We would also appreciate a
brief description of how you are using Daikon, sent to
@email{daikon-developers@@pag.lcs.mit.edu}.  We are curious about how
users exploit Daikon, and we are eager for anecdotes about its
successes and failures, so that we can make Daikon more effective for
its users.


@node    Credits,  , License, Details
@section Credits

@cindex contributors to Daikon

The following individuals have contributed to Daikon:
Yuriy Brun,
Jake Cockrell,
Adam Czeisler,
Alan Donovan,
Nii Dodoo,
Alan Dunn,
Michael Ernst,
William Griswold,
Melissa Hao,
Michael Harder,
Lee Lin,
Greg Jay,
Josh Kataoka,
Vikash Mansinghka,
Stephen McCamant,
Samir Meghani,
Jelani Nelson,
Ryan Newton,
Jeremy Nimmer,
Toh Ne@w{ }Win,
David Notkin,
Carlos Pacheco,
Matthew Tschantz,
Iuliu Vasilescu,
Tao Xie.

Craig Kaplan carved the Daikon logo.

The feedback of Daikon users has been very valuable.  We are
particularly grateful to
Rich Angros,
Tadashi Araragi,
Seung Mo Cho,
David Cok,
Dorothy Curtis,
Engelbert Hubbers,
Scott McMaster,
Manos Renieris,
Tao Xie.
Many others have also been generous with their feedback, for which we
are also grateful.

@c This work was supported in part by NSF grants CCR-9506779 and CCR-9508745,
@c an IBM Cooperative Fellowship, and a gift from Edison Design Group.

If your name has been inadvertently omitted from this section, please
let us know so we can correct the oversight.


@node     File formats, Index, Details, Top
@appendix File formats

@cindex file formats

This chapter contains information about the file format of Daikon's data
trace and declaration files.  It is of most information to those who
wish to write a front end (@pxref{Instrumentation}), enabling Daikon to
detect invariants in another programming language.

Data trace files contain runtime values for variables at particular program
points.  Each record in a data trace file represents one execution of a
program point.  The record names a program point and lists a number of
variables and their runtime values.  This dynamic information about values
at a program point is generated when an instrumented program is run.  By
convention, data trace files have the suffix @file{.dtrace}.

A declaration file describes the structure of the data trace file; it
lists the program points that may appear in the data trace file and, for
each program point, which variables appear at that program point.  This
static lexical information about a program point can be determined when
a program is instrumented.  By convention, declaration files have the
suffix @file{.decls} or @file{.decl}.

(Actually, both declarations and data trace records may appear together in
a single file.  In that case, the program point information must precede
the first appearance of values at that point, but it is not required that
all the program point declarations appear before any values are written to
the file.  This is intended to provide flexibility for instrumentation
implementations.  However, it is encouraged to place declarations in
different files than data traces.)


@menu
* Conventions::                 
* Declaration files::           
* Data trace files::            
* Examples::                    
@end menu

@node    Conventions, Declaration files, File formats, File formats
@section File format conventions


Daikon files are textual, to permit easier viewing and editing by humans.
Each record is separated by one or more blank lines.
To permit easier parsing by programs, each piece of information in a record
appears on a separate line.

Outside a record, any line starting with a pound sign (#) is ignored as
a comment.  Comments are not permitted inside a record.


@node    Declaration files, Data trace files, Conventions, File formats
@section Declaration files

@cindex declaration file format
@cindex .decls file format

A declaration file consists of a sequence of program point declarations
separated by blank lines.

The format of the program point information is:
@example
  DECLARE
  program-point-name
  varname1
  declared-type1 [# auxiliary-information1]
  representation-type1 [= constant-value1]
  comparable1
  varname2
  declared-type2 [# auxiliary-information2]
  representation-type2 [= constant-value2]
  comparable2
  ...
@end example

Program point information includes:
@itemize @bullet
@item
name ("tag") of this program point, an arbitrary string containing no
tab or newline characters.  This name contains information such as the
class name or method name; what information is contained depends on
which instrumenter is being used.  @xref{pptname format}, for a full
specification of the naming format.

By convention, the entry and exit points for a function have names of
a special form so that they can be associated with one another.
(Currently, those names end with ":::ENTER" and ":::EXIT".)  This
convention permits instrumenters not to remember the original values
of variables and output them at the procedure exit point.  When there
are multiple exit points, then each one should be suffixed by a number
(such as a line number, for example, "foo::EXIT22").  Daikon produces
the main (non-numbered) ":::EXIT" point automatically.  All the
numbered exits should contain the same set of variables; in general,
this means that local variables are not included at exit points.

Another convention is to have another program point whose name ends
with ":::OBJECT" for the representation invariant of an object or
class.  This program point is not created automatically, because
there isn't a way to know whether a particular method is a private
helper method or not --- that is, whether the representation
invariants should hold on entry to and exit from it.

@item
for each variable:
@itemize @bullet
@item
name: an string containing no tabs or newlines.  For the most part,
the variable name can be any string, except that the period character,
square brackets, and parentheses have special meanings.  (The exact
requirement is that the VarInfoName @code{parse} method must be able
to parse the name).  A pair of empty square brackets ("[]") represent
an array-valued variable.  For instance, "a" might stand for the array
object itself (appearing in the trace file as a unique ID or
hashcode), and "a[]" would stand for the array contents (appearing in
the trace file as a sequence of values).  Otherwise, square brackets
represent selecting an element of a sequence (as in the C or Java
array access operator); the index should not itself contain square
brackets. A period character represents field access, and any field
name is allowed, except for the restrictions above and the special
case that a field named "class" represents the type of a value.
Finally, the name may begin with "orig(" and end with ")", though
usually such names are generated by Daikon and should not appear in a
decls file.  No other uses of parentheses are allowed.

@item
declared type: this is what the programmer used in the declaration of
the variable.  Array types must be suffixed by the proper number of
"[]" to indicate their dimensionality.  Names for standard types
should use Java's names (e.g., "int", "boolean", etc.), but names for
user-defined or language-specific types can be arbitrary strings.

@item
auxiliary information: optionally, Daikon can be given information
about the meaning of the variable to help it better interpret the
values it later sees.  Information is provided as a comma-separated
list of items, with each item in the form of "key = value".  Unrecognized
keys are silently ignored.  All values are
either "true" or "false".  Mainly, this information is used for
collections, which are presented to Daikon as arrays.  Valid keys are:

@itemize @bullet

@item
hasDuplicates: whether a collection can contain duplicates.  If it
cannot, Daikon does not check for some invariants that only have
meaning for collections that can contain duplicate elements.

@item
hasOrder: whether order has meaning for a collection.  If order does
not have meaning in a collection, then Daikon does not check for
element-wise comparisons between it and other collections.  

@item
hasNull: whether zero has the special meaning null for the variable or
collection.  If it does, then Daikon checks for whether a value or the
elements in a collection are null.

@item
nullTerminated: whether a collection has a value (usually null) that
ends its representation.  If it does, then Daikon looks at the
collection's size and at the collection's size-1 as "interesting"
values.  If it does not, then Daikon only looks at the collection's
size.

@item
isParam: whether a given variable is a parameter to a method.  If a
variable is a parameter, Daikon avoids printing some information that
would be considered uninteresting for parameters.  First, invariants
that use the parameter variable "p" in its post-state form are not
printed.  Second, invariants that use fields of p (such as "p.x") are
printed only if p has not changed.  Lastly, some immutable
characteristics, such as the size of arrays and data types are not
printed (both can be changed if p is changed, but then, p would no
longer be interesting).

@end itemize

@item
representation type:  this describes what will appear in the data
trace file.  For instance, the declared type might be "char[]" but
the representation type might be "java.lang.String".  Or, the declared
type might be "Object" but the representation type might be
"hashcode", if the address of the object is written to the data trace
file.

The representation type should be one of boolean, integer (written
"int"), hashcode, double, string (written "java.lang.String"), or an
array of one of those (indicated by a "[]" suffix, as in Java).
Hashcodes are treated like integers, except that their actual values
are considered uninteresting for the purposes of output; they are
intended for unique object identifiers like memory addresses or the
return value of Java's @code{Object.hashCode} method.

The representation type may optionally be followed by an equals
sign and a value; in that case, the variable is known to have a
compile-time constant value and should be omitted from the data
trace file.
@end itemize
@item
@cindex comparability, for variables
@cindex variable comparability
comparable variables.  These indicate
which other variables are comparable to this one, which is typically
obtained via type-inference based analysis.

A comparability for a non-compound type is an integer.  Comparisons
succeed exactly if either integer is negative or if both integers are
the same.  An implicit comparability for an array type may contain an
integer for each index and for the contents; for instance, "5[22][17]"
for a two-dimensional array.  Comparisons succeed if comparisons over
each component succeed.

If no information is supplied (i.e., this line is blank), then
the variable is compared to all other variables of the same type.

As an example, in the following code:
@example
int sum(int len, int[] a) @{
  int sum=0;
  for (int i=0; i++; i<len)
    sum += a[i];
  return sum;
@}
@end example
variables @samp{i} and @samp{len} are comparable to one another (and
to indices of array @samp{a}).  Furthermore, the result is comparable
to the elements of array @samp{a}.  A declaration file for these
variables might look like
@example
len
int
int
5
a
int[]
int[]
8[5]
return
int
int
8
@end example

@end itemize

@c Future enhancements may include:
@c @itemize @bullet
@c @item
@c permit variables to be omitted if they haven't changed (but always
@c outputting the bit permits us to write a sanity checker)
@c @item
@c permit variables to appear in any order (not sure this is so worthwhile)
@c @item
@c specify which @file{.decl} files should be used (including their pathnames
@c and/or MD5 hashes)
@c @end itemize

A declaration file optionally starts with a "VarComparability" record,
which might look like the following:
@example
  VarComparability
  explicit
@end example
@noindent
This controls how the comparability field in the declarations is
interpreted.  The default VarComparability is "implicit".  Note that a
blank line is required between this record and the next one.

@menu
* pptname format::              
@end menu


@node    pptname format,  , Declaration files, Declaration files
@subsection Program point name format specification

Instrumenting code creates a @file{.decls} file that contains program
point names such as:

@example
  StackAr.makeEmpty()V:::EXIT54
  StackAr.makeEmpty()V:::ENTER
  StackAr.top()Ljava/lang/Object;:::EXIT64
  StackAr.top()Ljava/lang/Object;:::EXIT65
  StackAr.top()Ljava/lang/Object;:::ENTER
@end example

This section describes the format of these program point names.  Someone
writing an instrumenter for a new language must be sure to follow this
format specification.

A program point name is a string with no tabs or newlines in it. The basic
format is:

@example
  topLevel.bottomLevel:::pptInfo
@end example

For the first example given above, the top level of the hierarchy would
be @file{StackAr}, the bottom level would be @file{makeEmpty()V}, and the
program point information would be @file{EXIT54}.

@file{topLevel} and @file{bottomLevel} can represent anything. Currently
for Java, @file{topLevel} consists of the class name while
@file{bottomLevel} consists of the method name and method signature. For
C, @file{topLevel} could consist of a filename and @file{bottomLevel}
could consist of a method name and signature. For IOA, @file{topLevel}
could consist of an Automaton name and @file{bottomLevel} could consist of
information for a transition state.

@file{topLevel} may contain any number of periods ('.'). @file{bottomLevel}
and @file{pptInfo} may not contain any periods. The string ":::" may only
appear once.

@file{topLevel} and @file{pptInfo} are required (i.e., they must be non-empty),
as are the period to the right of @file{topLevel} and the colons to the
left of @file{pptInfo}. However, @file{bottomLevel} is optional. For
example, the Java instrumenter creates an artificial object program point
which contains invariants that are true for all of an object's methods,
rather than for just one method:

@example
  StackAr:::OBJECT
@end example


@node    Data trace files, Examples, Declaration files, File formats
@section Data trace files

@cindex data trace file format
@cindex .dtrace file format

The format of the value information is:
@example
  program-point-name
  varname1
  var-value-1
  var-modified-1
  varname2
  var-value-2
  var-modified-2
  ...
@end example

Value information includes:
@itemize @bullet
@item name of the program point

@item for each variable:
@itemize @bullet
@item name
@item value
@itemize @bullet
@item    integer: sequence of digits, optionally preceded by a minus sign.
Boolean values are written as the number 0 (for false) or the number 1
(for true).
@item    string: characters surrounded by double-quotes; internal
double-quotes and backslashes are escaped by a backslash; newlines and
carriage returns are represented as "\n" and "\r", respectively
@item    array: elements are listed on one line, separated by spaces.
The entire array contents are in square brackets.  (Also, the array name
should end in "[]"; use "a[]" for array contents, but "a" for the identity
of the array itself.)
@end itemize

The value may also be the string "nonsensical" (without the
quotes).  That means that the variable does not have a value because
the expression that computes it cannot be evaluated.  For instance, if
variable @samp{a} has value @samp{null}, then variable @samp{a.b} would
have value @samp{nonsensical}.  When the value is "nonsensical", the
modified field should be 2.

@item modified? (0, 1, or 2).
@cindex modified bit
This value is 0 if the variable has not been assigned to since the
last time this program point was executed, and 1 if the variable has
been assigned to since then.  It is safe for an implementation to
always set it to 1.  It is also safe to always set it to 0, because
Daikon corrects obviously incorrect modification bits (such as 0 for a
never-before-seen value).

The special value 2 should be used only (and always) when the value
field is "nonsensical".

@c if the
@c modbit-munge.pl script is run on the resulting @file{.dtrace} file to fix up
@c the modbits.
@end itemize

The variables should appear in the same order as they did in the
declaration of the program point, without omissions or additions.
@end itemize

@cindex nonce, invocation
@cindex this_invocation_nonce

As a special case, the first variable in a record may be
"this_invocation_nonce", in which case there is no modification
information, only a value.  The nonce is used to match up procedure entries
(whose names end with ":::ENTER") with procedure exits (whose names end
with ":::EXIT"); this is necessary in concurrent systems because there may
be several invocations of a procedure active at once and they do not
necessarily follow a stack discipline, being exited in the reverse order of
entry.  For non-concurrent systems, this nonce is not necessary and may be
omitted.


@node    Examples,  , Data trace files, File formats
@section Examples


Here are two files, p180-15.1.1.decls and (part of) p180-15.1.1.dtrace, for
a program that sums the values in an integer array.

@menu
* Example declaration file::    
* Example data trace file::     
@end menu

@node    Example declaration file, Example data trace file, Examples, Examples
@subsection Example declaration file

This is part of the file @file{StackAr.decls}, a declaration file for
the @file{StackAr.java} program (@pxref{Example use}).

@example
DECLARE
StackAr.push(Ljava/lang/Object;)V:::ENTER
x
Object
int
1
x.class
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr.push(Ljava/lang/Object;)V:::EXIT96
x
Object
int
1
x.class
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr:::OBJECT
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0
@end example


@node    Example data trace file,  , Example declaration file, Examples
@subsection Example data trace file

This is part of file @file{StackAr.dtrace}, which you can create by
running the instrumented @file{StackAr.java} program (@pxref{Example
use}).  This excerpt contains only the first two calls to @code{push}
and the first return from @code{push}, along with the associated object
program point records; omitted records are indicated by ellipses.


@example
...

StackAr.push(Ljava/lang/Object;)V:::ENTER
this_invocation_nonce
55
x
1217030
1
x.class
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

...

StackAr.push(Ljava/lang/Object;)V:::EXIT96
this_invocation_nonce
55
x
1217030
1
x.class
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[1217030]
1
this.theArray[].class
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[1217030]
1
this.theArray[].class
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

...

StackAr.push(Ljava/lang/Object;)V:::ENTER
this_invocation_nonce
94
x
1482257
1
x.class
"DataStructures.StackAr"
1
this.theArray
350965
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
350965
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

...
@end example



@node     Index,  , File formats, Top
@unnumbered Index

@printindex cp


@bye
