\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename daikon.info
@settitle The Daikon Invariant Detector
@c %**end of header

@c To update all the nodes and menus all at once:   C-u C-c C-u m
@c You shouldn't need to do that, though; the Makefile does it for you.

@c I can't get this to work, don't know why.  MDE 4/2001.
@c @alias directory = file

@c texi2html doesn't work if I use this macro
@c @macro daikonurl{}
@c http://sdg.lcs.mit.edu/daikon/
@c @end macro

@macro daikonemail{}
@email{daikon@@sdg.lcs.mit.edu}
@end macro

@c @setchapternewpage odd

@c @ifinfo
@c This is a short example of a complete Texinfo file.
@c 
@c Copyright 1990 Free Software Foundation, Inc.
@c @end ifinfo

@c avoid black boxes marking overfull hboxes in TeX output
@finalout

@titlepage
@sp 10
@c Could also use @title, @subtitle, @author here.
@center @titlefont{Daikon Invariant Detector User Manual}

@sp 2
@center Daikon version 2.5.0

@sp 1
@c Daikon version 2.5.0 date
@center August 26, 2001

@sp 5
@c reads daikon.eps, daikon.pdf, daikon.txt, daikon.png, or daikon.jpg
@image{images/daikon-logo,4in,}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998-2001
@c Copyright @copyright{} 1998-2001 Michael Ernst
@end titlepage

@html
<img src="images/daikon-logo.gif" alt="Daikon logo">

<h1>Daikon invariant detector</h1>

This is the manual for the Daikon invariant detector.
It describes Daikon version 2.5.0, released August 26, 2001.

@end html

@c Putting this lower in the HTML version looks a little bit strange,
@c but it's acceptable. 
@ifnothtml
@contents
@end ifnothtml

@node    Top, Introduction, (dir), (dir)
@comment node-name, next,          previous, up

@ifnottex
This is the manual for the Daikon invariant detector.
@end ifnottex

@menu
* Introduction::                
* Installing::                  
* Example use::                 
* Detecting invariants::        
* Daikon output::               
* Front ends::                  
* Extending Daikon::            
* Troubleshooting::             
* Details::                     
* File formats::                
* Index::

@ifhtml
@contents
@end ifhtml
@ifnothtml

@detailmenu
 --- The Detailed Node Listing ---

Installing Daikon

* Installing dfej::             
* Installing dfec::             
* Requirements::                

Requirements for running Daikon

* Windows requirements::        

Example use of Daikon

* Step-by-step instructions::   
* Summary::                     
* Automating the process::      
* Understanding the invariants::  
* Second example::              

Using Daikon to detect invariants

* Instrumentation::             
* Run the instrumented program::  
* Detect invariants::           
* All-in-one script::           

Instrumentation

* Instrumenting Java programs::  
* Instrumenting C/C++ programs::  

Run the instrumented program

* Run Java::                    

Details on running instrumented Java programs

* Java applets::                

Detect invariants in the data trace files

* Command line options for Daikon::  

All-in-one script daikon.pl

* daikon.pl arguments::         

Daikon output

* Interpreting output::         
* GUI::                         
* Printing Invariants::         
* Invariant Diff::              

Interpreting Daikon output

* Program points::              
* Variable names::              
* Invariant syntax::            

Tree-structured invariant browser

* Invoking GUI::                
* Using GUI::                   

Using the invariant browser

* Invariants Display::          
* Control panel::               

Front ends

* Java front end dfej::         
* C/C++ front end dfec::        

Java front end dfej

* dfej options::                
* Scope of instrumentation::    
* Refined runtime types::       

Refined runtime types

* C/C++ front end dfec::

C/C++ front end dfec

* dfec command-line arguments::  
* Pointer type disambiguation::  
* Pointer type disambiguation example::  
* Limitations::                 

Extending Daikon

* New invariants::              
* New derived variables::       
* New formatting for invariants::  

Troubleshooting

* dfej problems::               
* Daikon problems::             
* Other problems::              
* Reporting bugs::              
* Known bugs::                  
* Further reading::             

Problems with dfej

* dfej compilation problems::   
* dfej invocation problems::    

Problems running Daikon

* Abnormal termination::        
* Out of memory::               

Other problems

* Large dtrace files::          
* Font errors from running GUI::  

Reporting bugs

* Known bugs::                  
* Further reading::             

Details

* License::                     
* Credits::                     

File formats

* Conventions::                 
* Declaration files::           
* Data trace files::            
* Examples::                    

Declaration files

* pptname format::              

Examples

* Example declaration file::    
* Example data trace file::     

@end detailmenu
@end ifnothtml
@end menu

@node    Introduction, Installing, Top, Top
@chapter Introduction

The @uref{http://sdg.lcs.mit.edu/daikon, ,Daikon invariant detector}
reports properties that are likely to hold at certain points in a
program.  The reported properties are arithmetic equations such as you
might write in an assert statement or a formal specification; for
example, "x > abs(y)" or "x = 3*y + 4*z - 7" or "x = 0 (mod 4)".  These
invariants can be useful in program understanding and a host of other
applications.  Daikon operates by running the program and examining the
values it computes, looking for patterns and relationships among those
values.  Front ends (@pxref{Instrumentation}) exist for Java and for C
and C++.


@node    Installing, Example use, Introduction, Top
@chapter Installing Daikon

In order to install Daikon, perform the following steps.
@xref{Requirements}, for a few additional requirements running Daikon
(in short, you must be able to run Java programs, because Daikon is
written in Java).  Differences between various versions of Daikon appear
in the file @file{doc/CHANGES} in the distribution.

@enumerate
@item
Download Daikon from
from @uref{http://sdg.lcs.mit.edu/daikon/download/}.

There are two distributions to choose from.  The pre-compiled
distribution,
@uref{http://sdg.lcs.mit.edu/daikon/download/daikon-jar.tar.gz,,@file{daikon-jar.tar.gz}},
permits you to run Daikon and to detect invariants, but does not permit
you to modify Daikon or to rebuild it.  The source distribution,
@uref{http://sdg.lcs.mit.edu/daikon/download/daikon-source.tar.gz,,@file{daikon-source.tar.gz}},
plus sources for Daikon and for dfej.

Daikon is also available via anonymous CVS.  Send email to
@daikonemail{} if you desire such access.

@item
In the directory where you want to install Daikon (we'll call this
the @var{parent} directory), unpack the tarfile:
@example
tar zxvf daikon.tar.gz
@end example
@noindent
This creates a @file{@var{parent}/daikon/} subdirectory.

@item
Add the Daikon Java files to your Java class path.  There are two
different ways to do this; you should choose one or the other.

@itemize @bullet
@item
The first technique is to run Daikon from the precompiled bytecode files
in @file{daikon.jar}.  This is the easiest way to proceed, and it must
be used if you downloaded the pre-compiled Daikon distribution.

Add the supplied @file{daikon.jar}
file to your classpath.
For instance, if your shell is @command{csh}, add the following to your
@file{.cshrc} file: 
@example
setenv CLASSPATH @var{parent}/daikon/daikon.jar:$@{CLASSPATH@}
@end example

@item
Alternately, you may run run Daikon from @file{.class} files that you
compile yourself.  This permits you to modify Daikon (most users will
not need to do so), and may be used if you downloaded the source
distribution.

Add the @file{@var{parent}/daikon/java/} directory to
your classpath.  If your shell is @command{csh}, add the
following to your @file{.cshrc} file.
@example
setenv CLASSPATH @var{parent}/daikon/java:$@{CLASSPATH@}
@end example

The distribution includes compiled @file{.class} files, so you do not
need to compile them yourself unless you make changes; @xref{Compiling
Daikon}.

@end itemize

@item
Add the @file{@var{parent}/daikon/bin/} directory to your path.  (Your
path is a list of directories in which the shell searches for
commands; this permits you to type just the program name rather than
supplying a full pathname.)  In csh, add the following to your
@file{.cshrc} file:
@example
set path = (@var{parent}/daikon/bin $path)
@end example

@end enumerate

@menu
* Installing dfej::             
* Installing dfec::             
* Requirements::                
@end menu

@node    Installing dfej, Installing dfec, Installing, Installing
@section Installing the Daikon front end for Java



If you wish to detect invariants in Java programs, perform the following
steps.

@enumerate
@item
Ensure that @file{rt.jar} is on your Java class path.  For instance, if
your shell is @command{csh}, place something like the following in your
@file{.cshrc} file:
@example
setenv CLASSPATH $@{CLASSPATH@}:$HOME/java/jdk/jre/lib/rt.jar
@end example

@item
Obtain or build an executable for dfej, the Daikon front end for Java.

@itemize @bullet
@item
The easiest approach is to download a precompiled version of @file{dfej}
from @url{http://sdg.lcs.mit.edu/daikon/download/}.  Place that
executable somewhere on your path, and you are ready to run dfej.  (If
no executable is available for your architecture, send mail to
@daikonemail{} and we may be able to produce an executable for you.)

@item
Alternately, you can build dfej from the sources which are included in
the Daikon source distribution.  
To build dfej, see file @file{INSTALL} in the dfej sources.  In
summary, you should be able to build dfej by running the following
commands:
@example
cd front-end/java
./configure
make
@end example
@noindent
after which file @file{src/dfej} (on Windows, @file{src/dfej.exe}) is
the dfej executable.  Place it somewhere on your path.

If the @file{front-end/java} directory does not exist in your
distribution, then download the Daikon source distribution from
@uref{http://sdg.lcs.mit.edu/daikon/}.

If you are running under Solaris, you may need to edit
@file{Makefile} to indicate use of the @file{libw} library; change
@example
LDFLAGS=-L. -o $(EXECUTABLE)
@end example
@noindent
to
@example
LDFLAGS=-L. -lw -o $(EXECUTABLE)
@end example

If you are running under Microsoft Windows, you should install the
@uref{http://sources.redhat.com/cygwin/,Cygwin toolset}; see
@ref{Windows requirements}.  Without Cygwin, compiling dfej under
Windows is likely to be a chore.


@c (or, alternately, at
@c @uref{ftp://ftp.freesoftware.com/pub/sourceware/cygwin/latest/setup.exe}).

If you modify the source code for dfej (which is not recommended
unless you know what you are doing), just run @command{make} again to
build a new binary.

@end itemize
@end enumerate

@node    Installing dfec, Requirements, Installing dfej, Installing
@section Installing dfec, the Daikon front end for C/C++


If you wish to detect invariants in C programs, perform the following
steps.

@enumerate
@item
Compile the Daikon C runtime library.
@example
cd front-end/c
make
@end example
@noindent
This creates the file @file{daikon_runtime.o}; you will use it and
@file{daikon_runtime.h}, which also appears in @file{front-end/c},
when compiling C and C++ programs in which you wish to detect invariants.

@item
Obtain a dfec executable.

The easiest approach is to download a precompiled version of dfec from
@url{http://sdg.lcs.mit.edu/daikon/download/}.  Place that executable
somewhere on your path.  (If no executable is available for your
architecture, send mail to @daikonemail{} and we may be able to produce
an executable for you.)

License restrictions prohibit us from distributing the source for dfec,
except to other parties who hold a license to the EDG (Edison Design
Group) C/C++ front end.  If you hold such a license, send mail to
@email{daikon@@sdg.lcs.mit.edu} to obtain a patch to the EDG front end
(version 2.44).  The patch file is named @file{dfec-src.tgz}.  To build
dfec for yourself, perform the following steps:
@enumerate
@item unpack the EDG 2.44 source tree somewhere
@item unpack @file{dfec-src.tgz} in the @file{release_2.44/src/}
subdirectory.  This installs new Makefiles and adds the dfec source
modifications.
@item run @command{make} from the @file{release_2.44/} subdirectory.
This creates the dfec executable,  @file{release_2.44/bin/dfec}.
@end enumerate

@end enumerate

@c how to put something on your path:
@c 	      <li>copy or link the @command{dfej} program to a directory on
@c 	          your path, or
@c 	      <li>add the @file{java-front-end/src} directory to your path;
@c 		  for instance, in csh place the following in your
@c 		  @file{.cshrc} file:<br>
@c 		  <tt>set path = (<em>parent</em>/daikon/java-front-end/src $path)</tt><br>


@node    Requirements,  , Installing dfec, Installing
@section Requirements for running Daikon

In order to run Daikon, you must have a Java 1.3 (or later) JVM, or
@uref{http://java.sun.com,, Java virtual machine}.

If you wish to re-compile Daikon from scratch, you will need the C
preprocessor, @command{cpp}.

You also need a compiler for whatever language your target programs are
written in.  For instance, if you wish to analyze Java programs, you
need a Java compiler such as @command{javac} or @command{jikes}.  If you
wish to analyze C or C++ programs, you need a C or C++ compiler such as
@command{gcc}.

If you wish to build the Daikon front end for Java yourself, rather than
using a precompiled binary provided at
@uref{http://sdg.lcs.mit.edu/daikon/}, you need a C++ compiler such as
@uref{http://gcc.gnu.org/,, gcc}.  (This front end, which permits you to
detect invariants in Java programs, is written in C++, and sources are
distributed with Daikon.)

@menu
* Windows requirements::        
@end menu

@node    Windows requirements,  , Requirements, Requirements
@subsection Windows requirements for running Daikon

If you are running Daikon under Windows, we strongly recommend that you
install the @uref{http://sources.redhat.com/cygwin/,Cygwin toolset},
which contains everything you need to compile and run Unix programs
under Windows.  You can install Cygwin by simply running the program
found at @uref{http://sources.redhat.com/cygwin/setup.exe}.

@c ** Commented out with the elimination of the need for modbit-munge
@c You may also need to install
@c @uref{http://www.activestate.com/ASPN,ActiveState Perl} in order to run
@c the @command{modbit-munge.pl} script.  A user reports that Cygwin perl
@c does not deal properly with files whose lines are separated by
@c "@samp{\r\n}", which is the DOS default.  It deals fine with files whose
@c lines are separated with "@samp{\n}", which is the Unix default.  By
@c contrast, ActiveState Perl deals properly with both varieties.  You can
@c download ActiveState Perl from
@c @uref{http://www.activestate.com/ASPN/Downloads/ActivePerl/index/}.


@node    Example use, Detecting invariants, Installing, Top
@chapter Example use of Daikon

This chapter gives step-by-step instructions for running Daikon on a
sample Java program, @file{StackAr.java}.  @xref{Detecting invariants},
for complete details about running Daikon.


@menu
* Step-by-step instructions::   
* Summary::                     
* Automating the process::      
* Understanding the invariants::  
* Second example::              
@end menu

@node    Step-by-step instructions, Summary, Example use, Example use
@section Step-by-step instructions

@c We recommend you run Daikon on Unix, but it can also be run on Windows.

You need to perform three basic tasks:  instrument the target program
(steps 1-4), run the instrumented program to create a data trace file
(steps 5-7), and run Daikon over the data trace file to produce
invariants (steps 8-9).

You must first install Daikon if you haven't done so already; see
@ref{Installing}.


@enumerate
@item Change to the directory containing the @file{StackAr.java} program.
@example
cd examples/StackAr
@end example

@item Compile the original version of the program.
@example
javac DataStructures/*.java
@end example

These instructions assume you have the current working directory (".")
in your CLASSPATH.

@item Instrument the @file{StackAr.java} file.
@example
dfej DataStructures/StackAr.java
@end example

We instrument only this one file because we are only interested in the
invariants of the StackAr class, not the other classes in the program.

This command creates two directories, @file{daikon-instrumented} and
@file{daikon-output}.  It creates an instrumented version of
@file{StackAr.java} at @file{daikon-instrumented/DataStructures/StackAr.java}.
It creates a declaration file at
@file{daikon-output/DataStructures/StackAr.decls}.

@item Compile the instrumented version of StackAr.java.
@c I think this comment about "." on the classpath is correct.  -MDE 8/26/01
(This step requires "." to be on your classpath.)

@example
javac daikon-instrumented/DataStructures/StackAr.java
@end example

@item Run the StackAr test suite, using the instrumented
@file{StackAr.class} class file instead of the original (but the
original version of all other files):

@example
java -classpath "daikon-instrumented:$CLASSPATH" DataStructures.StackArTester
@end example

This will generate a trace file at
@file{daikon-output/StackAr.dtrace}.  This could take anywhere from
a few seconds to a few minutes, depending on the speed of your
computer.

@item Change to the @file{daikon-output} directory to analyze
the output.

@example
cd daikon-output
@end example

@c @item Due to a bug in the Java front end, there can be problems in the
@c trace file.  Run the @command{modbit-munge} script to fix these problems:
@c @table @r
@c @item Unix
@c @t{modbit-munge.pl StackAr.dtrace}
@c @item Windows
@c @t{modbit-munge.bat StackAr.dtrace}
@c @end table

@item Run Daikon on the trace file.

@example
java daikon.Daikon -noajax -o StackAr.inv DataStructures/StackAr.decls StackAr.dtrace
@end example

The invariants are printed to standard output, and a binary
representation of the invariants is written to
@file{StackAr.inv}.

@item Examine the invariants.  There are two ways to do this.
@itemize @bullet
@item Examine the output from running Daikon.  (You may find it
convenient to capture the output in a file; add @command{> Stackar.txt}
to the end of the command that runs Daikon.)

@item Use the Daikon GUI to browse the invariants.  The GUI contains a
tree which hierarchically organizes program points according to their
class and method.  Using the GUI, you can look at invariants for only
the methods and program points you care about.

@example
java daikon.gui.InvariantsGUI StackAr.inv
@end example
@end itemize

@end enumerate

@node    Summary, Automating the process, Step-by-step instructions, Example use
@section Summary

The steps above can be divided into three stages:

@itemize
@item Instrumentation (steps 1-4)
@example
cd examples/StackAr
javac DataStructures/*.java
dfej DataStructures/StackAr.java
javac daikon-instrumented/DataStructures/StackAr.java
@end example

@c @item Trace file generation (steps 5-7)

@item Trace file generation (step 5)
@example
java -classpath "daikon-instrumented:$CLASSPATH" DataStructures.StackArTester
@end example

@c cd daikon-output
@c modbit-munge.pl StackAr.dtrace
@c @end example

@item Invariant detection (steps 6-8)
@example
cd daikon-output
java daikon.Daikon -noajax -o StackAr.inv DataStructures/StackAr.decls StackAr.dtrace
java daikon.gui.InvariantsGUI StackAr.inv
@end example

@end itemize

@node    Automating the process, Understanding the invariants, Summary, Example use
@section Automating the process

The script @command{daikon.pl} automates all steps of the invariant
detection process.

@example
cd examples/StackAr
daikon.pl DataStructures.StackArTester
@end example

This command instruments your program, generates a trace file, and
displays the invariants in the GUI.  Currently, this script only works
on Unix.  For more details, @xref{All-in-one script}.


@node    Understanding the invariants, Second example, Automating the process, Example use
@section Understanding the invariants

This section examines some of the invariants for the StackAr example.
For more help interpreting invariants, see @ref{Interpreting output}.

The StackAr example is an array-based stack implementation.  Take a
look at @file{DataStructures/StackAr.java} to get a sense of the
implementation.  Now, look at the first section of Daikon output. In
the GUI, expand the node labeled @command{StackAr}, then select the
node labeled @command{StackAr:Object}.

@emph{(Note: The invariants displayed in the GUI may be different than the
invariants written to standard out by Daikon.  This is because the
invariants are being filtered differently.  We are currently working
to resolve this issue.)}

@example
======================================================================
StackAr:::OBJECT
this.theArray != null
this.theArray.class == "[Ljava.lang.Object;"
this.topOfStack >= -1
this.theArray[this.topOfStack+1..] elements == null
this.theArray[0..this.topOfStack] elements != null
this.topOfStack <= size(this.theArray[])-1
======================================================================
@end example

These six annotations describe the representation invariant.  The
array is never null, and its runtime type is @code{Object[]}.  The
@code{topOfStack} index is at least -1 and is less than the length
of the array.  Finally, the elements of the array are non-null if
their index is no more than @code{topOfStack} and are null
otherwise.

Next, look at the invariants for the @code{top()} method.  In
the GUI, expand the node labeled @command{top()Ljava/lang/Object;}.
@code{top()} has two different exit points, at lines 78 and 79
in the original source.  There is a set of invariants for each exit
point, as well as a set of invariants that hold for all exit points.
Look at the invariants when @code{top()} returns at line 79.  In
the GUI, select the node labeled @command{EXIT79}.

@example
======================================================================
StackAr.top():::EXIT79
return == this.theArray[this.topOfStack]
this.theArray == orig(this.theArray)
this.theArray[] == orig(this.theArray[])
this.topOfStack == orig(this.topOfStack)
return != null
this.topOfStack >= 0
this.theArray[this.topOfStack+1..] elements == this.theArray[-1]
======================================================================
@end example

The return value is never null, and is equal to the array element at
index @code{topOfStack}.  The top of the stack is at least 0.  The
array, the elements of the array, and @code{topOfStack} are not
modified by this method - this method is an "observer".  The
last invariant is not particularly interesting.

@node    Second example,  , Understanding the invariants, Example use
@section A second example

A second example is located in the @file{examples/QueueAr} subdirectory.
Run this sample using the following steps:

@itemize
@item Instrumentation (steps 1-4)
@example
cd examples/QueueAr
javac DataStructures/*.java
dfej DataStructures/QueueAr.java
javac daikon-instrumented/DataStructures/QueueAr.java
@end example

@c @item Trace file generation (steps 5-7)
@item Trace file generation (step 5)
@example
java -classpath "daikon-instrumented:$CLASSPATH" DataStructures.QueueArTester
@c cd daikon-output
@c modbit-munge.pl QueueAr.dtrace
@end example

@item Invariant detection (steps 6-8)
@example
cd daikon-output
java daikon.Daikon -noajax -o QueueAr.inv DataStructures/QueueAr.decls QueueAr.dtrace
java daikon.gui.InvariantsGUI QueueAr.inv
@end example

@end itemize


@node    Detecting invariants, Daikon output, Example use, Top
@chapter Using Daikon to detect invariants

Detecting invariants involves three steps:
@enumerate
@item
Run @file{dfej} or @file{dfec} to instrument the target program
(@pxref{Instrumentation}).
This adds instructions to the target program so that, in addition to
performing its original task, it also writes variable values to a data
trace file.

@item
Run the instrumented program in the usual way, probably using a test
suite (@pxref{Run the instrumented program}).  This creates data trace
files.

@item
Run the Daikon invariant detector over the data trace files
(@pxref{Detect invariants}).  This detects invariants in the data trace
files and displays them, textually or via a graphical user interface.
@end enumerate



@menu
* Instrumentation::             
* Run the instrumented program::  
* Detect invariants::           
* All-in-one script::           
@end menu

@node    Instrumentation, Run the instrumented program, Detecting invariants, Detecting invariants
@section Instrumentation

Instrumentation performs two actions:
@itemize @bullet
@item
  Instrumentation adds instructions to the target program so that, in
  addition to performing its original task, it also writes variable values
  to a data trace file.
@item
  Instrumentation creates declaration files which describe the format of
  the data trace files.  For instance, these declaration files describe
  the names of functions and variables in the data trace file.
@end itemize

There are two instrumenters:  @file{dfej} for Java programs and
@file{dfec} for C and C++.  The names @file{dfej} and @file{dfec} stand
for "Daikon front end for Java" and "Daikon front end for C/C++".  The
Java front end is more complete and robust than the C/C++ front end.

@menu
* Instrumenting Java programs::  
* Instrumenting C/C++ programs::  
@end menu

@node    Instrumenting Java programs, Instrumenting C/C++ programs, Instrumentation, Instrumentation
@subsection Instrumenting Java programs

To instrument Java source programs, simply invoke @file{dfej}, the
Daikon front end for Java, on them:
@example
      dfej @var{filename1}.java @var{filename2}.java @var{...}
@end example

After running dfej, compile the instrumented version of the code, which
by default appears in the @file{daikon-instrumented/} directory.

The Daikon front end for Java has two effects:
@itemize @bullet
@item
  dfej writes instrumented versions of the files to a
  @file{daikon-instrumented/} directory 
@item
  dfej creates declaration files named
  @file{@var{filename1}.decls}, etc. in a
  @file{daikon-output/} directory.
@end itemize

For more information about dfej, see @ref{Java front end dfej}.


@node    Instrumenting C/C++ programs,  , Instrumenting Java programs, Instrumentation
@subsection Instrumenting C/C++ programs


To instrument C/C++ source, invoke @file{dfec}, The Daikon front end for
C/C++, on a single source file at a time.  @file{dfec} must be run from
a directory that contains the file @file{daikon_runtime.h}, the header
file for the Daikon runtime library:
@example
     ln -s ~/daikon/front-end/c/daikon_runtime.h .
     dfec @var{...options...} @var{myprog}.cc
@end example

You'll most likely need to specify one or more command-line options, in
particular @option{-I}; see @ref{dfec command-line arguments}.

After dfec is run, you must compile the instrumented source, linking
it with the object file for the Daikon runtime library and the stdc++
library.  By default, dfec places instrumented source in the
@file{daikon-instrumented/} directory.
@example
      gcc -o @var{myprog}.exe daikon-instrumented/@var{myprog}.cc daikon_runtime.o -lstdc++
@end example

In addition, you may want to specify the @option{-w} flag to gcc, to
suppress warnings.  dfec's output, while valid C++, may not be as
intuitive to gcc as the input was.

The Daikon front end for C/C++ has three effects:
@itemize @bullet
@item
dfec writes instrumented versions of the files to a
@file{daikon-instrumented/} directory 
@item
dfec creates declaration files named
@file{@var{myprog}.decls}, etc. in a
@file{daikon-output/} directory.
@item
optionally, dfec may create a pointer
type disambiguation file named
@file{@var{myprog}.disambig} in the
same directory as the @file{@var{myprog}.decls}
file.
@end itemize

For more information about dfec, including more detailed documentation
on the command-line options dfec needs to correctly instrument on your
system, see @ref{C/C++ front end dfec}.


@c <ol>
@c      <tt>dfec</tt> is written in Perl.  If Perl is not available, you may
@c      instead use <tt>dfec.sh</tt>, which is written in sh shell script.<p>
@c 
@c      The Daikon C front end:
@c      <ol>
@c        <li>copies your original files to @file{<i>myprog1.c</i>.uninst},
@c 	   etc.<br>
@c        <li>overwrites the original files with instrumented versions
@c        <li>creates declaration files named @file{<i>myprog1.c</i>.decls}, etc.
@c      </ol>
@c      You may wish to perform this operation with a copy of your program,
@c      to safeguard your original source code.<p>
@c 
@c      If you supply the @option{-d <i>directory</i>} argument (before
@c      the file names), then the instrumented source files are placed in the
@c      specified directory instead (and no backup files need be made).
@c  <li>Create or modify a @file{Makefile}.  Either:
@c    <ul>
@c      <li>If you have no @file{Makefile}, copy @file{Makefile-sample}
@c          to @file{Makefile} and add the names of your source files to its
@c          <tt>OBJS</tt>, and edit its <tt>EXEC</tt> executable name.
@c      <li>If you have a @file{Makefile}, add @file{dump_trace.o} to the
@c          list of object files that need to be created (and linked to create
@c          your executable).
@c    </ul>
@c  <li>Create an instrumented executable by building your program in the
@c      usual way (perhaps by running <tt>make</tt> or <tt>cc</tt> or <tt>gcc</tt>).
@c </ol>


@node    Run the instrumented program, Detect invariants, Instrumentation, Detecting invariants
@section Run the instrumented program

To create data trace files, run the instrumented program over some test
suite (of your own choosing, such as regression tests or a typical user
input session).  You can run the instrumented program in just the same
way you did before; the only behavioral change is writing a
@file{.dtrace} file.  Only one @file{.dtrace} file is created, even
though multiple @file{.decls} files might have been created (one for
each source file) when the program was instrumented.

The instrumented Java program creates its @file{.dtrace} file in the
@file{daikon-output/} subdirectory of the current directory.  It
overwrites any previously existing @file{.dtrace} file.

The instrumented C/C++ program creates its @file{.dtrace} file in the
current directory.  If a @file{.dtrace} file already existed, it is appended
to.

@c After running your program, run @command{bin/modbit-munge.pl} on the
@c resulting @file{.dtrace} files:
@c @example
@c modbit-munge.pl @var{myprog}.dtrace
@c @end example
@c @noindent
@c This step fixes up some potential problems that may appear in the
@c @file{.dtrace} file.


@menu
* Run Java::                    
@end menu

@node    Run Java,  , Run the instrumented program, Run the instrumented program
@subsection Details on running instrumented Java programs

After instrumentation, there are two versions of your Java program:  the
original version, and the instrumented version which appears in the
@file{daikon-instrumented/} directory.  Make sure that the
@file{daikon-instrumented/} directory appears on your class path before the
directory containing the original Java code.  You can do this by running
the program from that directory, if @file{.} (the current directory)
appears early on your class path, or you can add the relevant
@file{daikon-instrumented/} directory to your class path explicitly.


@menu
* Java applets::                
@end menu

@node    Java applets,  , Run Java, Run Java
@subsubsection Java applets

In order to run an applet, you must take two additional steps.

@enumerate
@item
Copy or link all class files, jar files, input files, and html files
that your applet needs to the @file{daikon-instrumented/} directory.  This
includes the @file{daikon/java} directory itself.  For example, to
create a link to the @file{daikon/java} directory, type (while in the
@file{daikon-instrumented/} directory):
@example
ln -s @var{parent}/daikon .
@end example

@item
By default, the Java 2 applet security model does not allow applets to
write files.  To get around this so that Daikon can write its @file{.dtrace}
files, create a file named @file{javaPolicy} in the @file{daikon-instrumented/}
directory that contains the text
@example
grant @{
    permission java.io.FilePermission "<<ALL FILES>>", "read, write, delete, execute";
@};
@end example
@noindent
Do not use this policy file with untrusted applets.

@item
Finally, run the applet:
@example
       appletviewer -J-Djava.security.policy=javaPolicy @var{html-file}
@end example
@end enumerate


@node    Detect invariants, All-in-one script, Run the instrumented program, Detecting invariants
@section Detect invariants in the data trace files

Run the Daikon invariant detector via the command
@example
    java daikon.Daikon @i{[@var{flags}]} @var{decl-files...} @var{dtrace-files...}
@end example

The @var{decl-files} are declaration (@file{.decl}) files created at
instrumentation time.
The @var{trace-files} are data trace (@file{.dtrace}) files created by
running the instrumented program.
The file type is determined by whether the file name contains
@file{.decls} or @file{.dtrace}.

Be sure to include all declaration files that are needed for the particular
data trace file; the simplest way is to include every the declaration file
created when instrumenting the program that is read.

The optional flags are described in @ref{Command line options for Daikon}.

@menu
* Command line options for Daikon::  
@end menu

@node    Command line options for Daikon,  , Detect invariants, Detect invariants
@subsection Command line options for Daikon

The Daikon invariant detector is invoked as follows:
@example

    java daikon.Daikon @i{[@var{flags}]} @var{decl-files...} @var{dtrace-files...}
@end example

This section describes the optional flags.


@c Unfortunately, @option{} adds quotes in the Info and printed output
@c which is not necessary in a table.  However, @t and @code compress
@c the two hyphens to 1 in Info and HTML output, which is even worse.
@table @option
@item -h
@item --help
Print usage message.

@item --ppt @var{ppt_regexp}
Only process program points whose names match the regular expression,
which uses Perl syntax.

@item --ppt_omit @var{ppt_regexp}
Do not process program points whose names match the regular expression,
which uses Perl syntax.  This takes priority over the
@option{--ppt_omit} argument.

@item --var_omit @var{var_regexp}
Ignore variables (whether in the trace file or derived) whose names
match the regular expression, which uses Perl syntax.

@item -o @var{inv_file}
Serialize invariants to the specified file; they can later be
postprocessed, compared, etc.

@item --no_text_output
Don't print invariants as text output.  This option should be used in
conjunction with the @option{-o} option.

@item --suppress_cont
Suppress display of implied invariants (by controlling ppt).

@item --suppress_post
Suppress display of obvious postconditions on prestate.

@item --prob_limit @var{pct}
Sets the probability limit for justifying invariants.  The default is
1%.  Smaller values yield stronger filtering.

@item --esc_output
Write output in ESC-like format.

@item --simplify_output
Write output in Simplify format.

@item --output_num_samples
Output numbers of values and samples for invariants and program points;
for debugging.
@end table


@node    All-in-one script,  , Detect invariants, Detecting invariants
@section All-in-one script daikon.pl

The @command{daikon.pl} script automates all steps of the invariant
detection process:  instrumentation, trace file generation, invariant
display.  Currently, this script only works on Unix.
This script is not currently the preferred way to run Daikon, but some
users may find it helpful.

Running @command{daikon.pl} without without any arguments will display usage information:
@example
% daikon.pl
Usage: daikon.pl [OPTIONS] MAIN_CLASS [MAIN_ARGUMENTS]
Options:
  -o, --output FILE   Save invariants in FILE.inv
  ...
@end example

At minimum, you must supply the name of a "main" class which provides
the method @code{public static void main(String[] args)}.
@command{daikon.pl} will run this class to exercise your program.
@xref{daikon.pl arguments}, for details on the available
options for @command{daikon.pl}.

@c <!--
@c <h2><a xname="example">Example</a></h2>
@c 
@c You can try an example provided by the staff:
@c <pre>
@c   athena% cd ~/6.170
@c   athena% mkdir daikon-testing; cd daikon-testing
@c   athena% cp -rp /mit/6.170/handouts/daikon/example .
@c   athena% daikon --verbose xxx
@c </pre>
@c This will run <tt>xxx</tt>, detect invariants for the program, and
@c display the daikon GUI to browse the results.  See the <a
@c href="#interpret-output">interpreting the output</a> section below for
@c details on the meaning of the invariants.
@c 
@c <p>Each run of daikon creates two files: an <tt>.inv</tt> file which
@c contains the invariants in a special format, and a
@c <tt>.src.tar.gz</tt> file which contains a snapshot of the program
@c source.  You may specify names for these files using the <tt>--output
@c <i>file</i></tt> parameter to daikon.  For example <tt>--output
@c mytest</tt> will create <tt>mytest.inv</tt> and
@c <tt>mytest.src.tar.gz</tt>.
@c 
@c <p>If your main class requires arguments, you may place them after the
@c class name, just as if you were running <tt>java</tt> instead of
@c <tt>daikon</tt>.
@c -->

@menu
* daikon.pl arguments::         
@end menu

@node    daikon.pl arguments,  , All-in-one script, All-in-one script
@subsection Command line options for daikon.pl

@table @option
@item -o
@item --output @var{FILE}
Save invariants in @file{@var{FILE}.inv} and source in
@file{@var{FILE}.src.tar.gz}.  If no name 
is given, a name is automatically generated and used.

@item -t
@item --textfile
Save a textual listing of invariants to a @file{.txt} file.

@item -v
@item --verbose
Display progress messages while running.

@item -c
@item --cleanup
Remove files left over from an interrupted session before starting.
Should be used only when @code{daikon.pl} detects left-over files and instructs
you to use this option.

@item -n
@item --nogui
Create the invariants file (and @file{.txt} file,
if @option{-t} is given), but do not start the GUI.
@end table



@node    Daikon output, Front ends, Detecting invariants, Top
@chapter Daikon output


@menu
* Interpreting output::         
* GUI::                         
* Printing Invariants::         
* Invariant Diff::              
@end menu

@node    Interpreting output, GUI, Daikon output, Daikon output
@section Interpreting Daikon output

If nothing gets printed before the @samp{Exiting} line, then Daikon
found no invariants.  You can get a little bit more information by using
the @option{--output_num_samples} flag to Daikon (@pxref{Command line
options for Daikon}).


@menu
* Program points::              
* Variable names::              
* Invariant syntax::            
@end menu

@node    Program points, Variable names, Interpreting output, Interpreting output
@subsection Program points
@cindex program point

A program point is a specific place in the source code, such as
immediately before a particular line of code.  Daikon's output is
organized by program points, both in the textual output and in the GUI.

@cindex :::ENTER program point
@cindex ENTER program point

For example, @code{foo():::ENTER} is the point at the entry to procedure
@code{foo()}; the invariants at that point are the preconditions for the
@code{foo()} method.

@cindex :::EXIT program point
@cindex EXIT program point

Likewise, @code{foo():::EXIT} is the program point at the procedure
exit, and invariants there are postconditions.  When there are multiple
exit points from a procedure (for instance, because of multiple
@code{return} statements), the different exits are differentiated by
suffixing them with their line numbers; for instance,
@code{StackAr.top():::EXIT79}.  The exit point lacking a line number (in
this example, @code{StackAr.top():::EXIT}) collects the postconditions
that are true at every numbered exit point.  This is an example of a
program point that represents a collection of locations in the program
source rather than a single location.

@cindex :::OBJECT program point
@cindex OBJECT program point
@cindex :::CLASS program point
@cindex CLASS program point

Two other program point tags are @code{:::OBJECT} and @code{:::CLASS}.
The former indicates object invariants (sometimes called representation
invariants or class invariants) that always hold for any object of the
given class, from the point of view of a client or user.  These
properties hold at entry to and exit from every public method of the
class.  The @code{:::CLASS} tag is just like @code{:::OBJECT}, but only
for static variables, which have only one value for all objects.


@node    Variable names, Invariant syntax, Program points, Interpreting output
@subsection Variable names

@itemize @bullet
@item
@code{orig(x)} refers to the value of formal parameter @code{x} upon
entry to a procedure (because the procedure body might modify the value
of @code{x}).  These variables appear only at @code{:::EXIT} program
points.
@item
@code{a} is the identity of @code{a} --- think of it as a
comparison over hash codes
@item
@code{a.class} is the runtime type of a, which may
differ from its declared type for arrays of non-primitive type;
"a.class" is omitted for arrays of primitive type
@item
"a[]" is the contents of a, namely an array; "a=b" implies "a[] =
b[]" but the reverse is not true
@item
"a[].class" is an array of types, representing the run-time classes
of the contents of a; it is omitted for arrays of primitive type
@item
@code{a[-1]} denotes the last element of array @code{a};
it is just syntactic sugar for @code{a[a.length-1]}.
@end itemize


@node    Invariant syntax,  , Variable names, Interpreting output
@subsection Invariant syntax

(Eventually, see the JML manual.)


@node    GUI, Printing Invariants, Interpreting output, Daikon output
@section Tree-structured invariant browser


By default, Daikon outputs a textual list of invariants; this list may
be very long.  The graphical user interface (GUI) is designed to make the
task of browsing invariants easier.  The GUI contains a tree which
hierarchically organizes program points according to their class and
method.  Using the GUI, you can look at invariants for only the methods
and program points you care about.  You can also sort invariants by a
property (e.g., probability) or filter invariants (e.g., only look at
invariants containing a certain variable).

@menu
* Invoking GUI::                
* Using GUI::                   
@end menu

@node    Invoking GUI, Using GUI, GUI, GUI
@subsection Starting the invariant browser

To use the GUI, first make a @file{.inv} file by invoking Daikon with
the @option{-o} option; for instance, to create @file{foo.inv}, run
@example
java daikon.Daikon -o foo.inv @var{decl-files...} @var{trace-files...}
@end example

Then, run the GUI with the @file{.inv} file as an argument:
@example
java daikon.gui.InvariantsGUI foo.inv
@end example

If you run the GUI with no arguments, it presents a file browser that
asks you to choose a @file{.inv} file for viewing.


@node    Using GUI,  , Invoking GUI, GUI
@subsection Using the invariant browser



This invariant browser consists of two windows.  The main window is the
Invariants Display, which gives a tree-structured view of program
points; you can navigate through the program points and view invariants.
The other window is the Filter Control Panel, where you can control
which invariants from each program point are displayed in the Invariants
Display.


@menu
* Invariants Display::          
* Control panel::               
@end menu

@node    Invariants Display, Control panel, Using GUI, Using GUI
@subsubsection Invariants Display

@ifnotinfo
@image{images/gui-InvariantsDisplay-small,3in,}
@c </td>
@c <td width=20></td>
@c <td><img src="gui-InvariantsDisplay-small.gif" width=298 height=348></td>
@c </tr></table>
@end ifnotinfo

@table @strong
@item File menu

The @command{Load file} menu option brings up a file browser which you
can use to select another @file{.inv} file.  The @command{Quit} menu
options lets you quit the GUI.

@item Program point tree
The top part of the Invariants Display consists of the Program point
tree --- a hierarchy of program points broken down by class and method.
Click on various program points in the tree to see tables of invariants
for those program points.  You may use the @key{Ctrl} and @key{Shift}
keys to make an arbitrary selection of program points.  Selecting a
class or method automatically selects all the program points
associated with that method or class.

@item Invariant tables
Invariant tables that display the actual invariants appear at the bottom
of the Invariants Display.

@itemize @bullet
@item
Use @key{Alt} along with the @key{up} or @key{down} arrow keys to scroll
by a table at a time.
@item
Sort a column in a table by clicking on the column header.  Shift-click
to sort the column in reverse order.
@end itemize

@end table

@node    Control panel,  , Invariants Display, Using GUI
@subsubsection Control panel

The Control Panel determines which invariants are displayed.

@c Force a paragraph break so the image is on its own line.
@*

@ifnotinfo
@c @ifhtml
@c <p>
@c @end ifhtml
@image{images/gui-ControlPanel,3in,}
@c <center><table><tr><td>
@c <img src="gui-ControlPanel.gif" width=411 height=425>
@c </td></tr></table></center><p>
@end ifnotinfo


@table @strong

@table @r
@item Property filters
Property filters narrow down the list of invariants that are displayed.
You can adjust which Property filters are being applied.  By default,
all Property filters are enabled.  Daikon supports the following
property filters:

@table @var

@item Suppress controlled invariants

A controlled invariant is an invariant that is "controlled" --- or
implied --- by another program point.  For example, for Java instrumented
code each class is associated with an object program point, which
contain invariants that are found at the entry and exit of all public
methods.  So in addition to the usual program points such as
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, daikon outputs invariants for the
artificial program point @code{StackAr:::OBJECT}.  The invariants for
@code{StackAr:::OBJECT} control the invariants for
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, because the former imply the latter.
Because of this redundancy, controlled invariants are not displayed by
default.  Note that if for some reason, the controlling invariant is not
displayed (for example, because it's unjustified), then the controlled
invariant @emph{will} be displayed.

@item Suppress implied postcondition invariants

Implied postcondition invariants are invariants involving @code{orig()}
variables that exist as precondition invariants.  For example, say that
@code{StackAr.isEmpty():::ENTER} has the invariant ``x==y''.  Then in
@code{StackAr.isEmpty():::EXIT48}, the invariant ``orig(x)==orig(y)''
is an implied postcondition invariant and will not be displayed by
default.

@item Suppress invariants containing non-canonical variables

For many program points there are sets of variables that are equal to
each other.  When this happens, one variable from the set is chosen to
be the canonical variable.  This filter hides invariants involving the
remaining non-canonical variables, because they are implied by
invariants involving the canonical variable.

@item Suppress invariants containing only constants

This filter suppresses invariants containing only constants.

@item Suppress invariants with few modified samples

This filter suppresses invariants with a relatively few number of
modified samples.  An example of such an invariant would be the
following: ``x >= 5'', where ``x'' is observed to be 5 three times
and 10 five times.  The observed values of @code{x} --- i.e., the samples of
@code{x} --- did not change enough for Daikon to be confident that this
invariant is an actual invariant.

@item Suppress obvious invariants

This filter suppresses invariants because they are obvious from looking
at other invariants.  Some examples are:

@itemize @bullet

@item If ``size(args[])==0'' is shown, then ``size(args[])-1==-1'' is
obvious and will not be displayed by default.
@item If ``this.topOfStack<size(this.theArray[])-1'' is shown, then
``this.topOfStack<size(this.theArray[])'' is obvious and will not be
displayed by default.
@end itemize
@item Suppress unjustified invariants

For every invariant, Daikon estimates the probability of that invariant
happening by chance.  If that probability is less than the limit, then
the invariant is deemed to be an actual invariant, not just a chance
occurrence.  Currently the limit is .01%.  So by default, only invariants
with probabilities of less than .01% are shown.

@end table

@item Variable filters
Variable filters let you display only the invariants that contain
certain variables.  The left-hand box displays the variables that you
are interested.  By default, the box is empty and invariants containing
any variables are displayed.  There are two ways to add variables to the
variables list:
@enumerate
@item 
Type the name of the variable into the @command{Add variable}
textfield, and click the @command{Add variable} button (or just press
@key{enter}).
@item
Each Invariant table in the Invariants Display has a @command{Show
variables} button.  Click on that button to see a list of variables for
that program point.  Select any set of variables and click the
@command{Filter on selected variables} button.
@end enumerate

To remove variables from the variables list, select the variables in
question and click on the @command{Remove selected
variables} button.

If you click on the @command{any variable} checkbox,
invariants are displayed if they contain any of the variables in the
variables list.  If you click on the @command{all
variables} checkbox, invariants are displayed if they contain all
of the variables in the variables list.

@end table

@end table

@node    Printing Invariants, Invariant Diff, GUI, Daikon output
@section Printing Invariants

Daikon provides many options for modifying the printed output of
invariants.  Often, you may want to print the same set of invariants
several different ways.  However, you only want to run Daikon once,
since it may be very time consuming.  The PrintInvariants utility is
designed to print a set of invariants from a @file{.inv} file.

PrintInvariants is invoked as follows:
@example
    java daikon.PrintInvariants @i{[@var{flags}]} @var{inv-file}
@end example

PrintInvariants shares many flags with Daikon:

@table @option
@item -h
@item --help
Print usage message.

@item --suppress_cont
Suppress display of implied invariants (by controlling ppt).

@item --suppress_post
Suppress display of obvious postconditions on prestate.

@item --esc_output
Write output in ESC-like format.

@item --simplify_output
Write output in Simplify format.

@item --output_num_samples
Output numbers of values and samples for invariants and program points;
for debugging.
@end table


@node    Invariant Diff,  , Printing Invariants, Daikon output
@section Invariant Diff

The invariant diff utility is designed to output the differences between
two sets of invariants.  This is useful, for example, if you want to
compare the invariants generated by two versions of the same program.

Invariant diff is invoked as follows:
@example
    java daikon.diff.Diff @i{[@var{flags}]} @var{inv-file1} [@var{inv-file2}]
@end example

If @file{inv-file2} is not specified, @file{inv-file1} is compared with an
empty set of invariants.

This section describes the optional flags.

@table @option
@item -h
Print usage message.

@item -d
Display the tree of differing invariants (default).

@item -a
Display the tree of all invariants.

@item -s
Display the statistics between two sets of invariants (default).

@item -u
Display uninteresting invariants.

@item -j
Ignore justification when displaying differing invariants.

@item -v
Verbose output.

@end table


@node    Front ends, Extending Daikon, Daikon output, Top
@chapter Front ends


@menu
* Java front end dfej::         
* C/C++ front end dfec::        
@end menu

@node    Java front end dfej, C/C++ front end dfec, Front ends, Front ends
@section Java front end dfej

@cindex front end for Java
@cindex Java front end
@cindex dfej (Daikon front end for Java)

This section contains details about dfej, the Daikon front end for Java.

For brief information about running dfej, see @ref{Instrumenting Java programs}.
For information about installing dfej, see @ref{Installing dfej}.
The @file{dfej} usage message also contains some information.

@command{dfej} works on Java code which corresponds to any version of
the Java language, from 1.0 to 1.3.

The Daikon front end for Java has two effects:
@itemize @bullet
@item
  dfej writes instrumented versions of the files, by default in directory
  @file{daikon-instrumented/}
@item
  dfej creates declaration files named
  @file{@var{filename1}.decls}, etc., by default in directory
  @file{daikon-output/}
@end itemize


@menu
* dfej options::                
* Scope of instrumentation::    
* Refined runtime types::       
@end menu

@node    dfej options, Scope of instrumentation, Java front end dfej, Java front end dfej
@subsection dfej options

The simplest way to invoke dfej is simply to supply it a list of Java files:
@example
      dfej @var{filename1}.java @var{filename2}.java @var{...}
@end example

dfej also accepts the following options, which should be provided before
the first Java file name.  The options can be divided into the following
categories:
@table @b
@item where (in what directory) to produce output

@end table

Details of the options are as follows:

@table @t
@item -daikon_debug
Produce debugging information.

@item -daikon_depth=@var{n}
Depth to which to examine structure components (default 2).
This parameter determines which variables dfej causes to be output at
runtime.  For instance, suppose that a program contained the following
data structures and variables:
@example
  class A @{
    int x;
    B b;
  @}
  class B @{
    int y;
    int z;
  @}
  A myA;

  class Link @{
    int val;
    Link next;
  @}
  Link myList;
@end example
@itemize @bullet
@item If depth=0, only the hashcodes of @code{myA} and @code{myList}
would be examined; those variables could be determined to be equal
or not equal to other variables.
@item If depth=1, then also @code{MyA.b}, @code{myList.next}, and the integers
@code{myA.x} and @code{myList.val} would be examined.
@item If depth=2, then also @code{MyA.b.y}, @code{MyA.b.y},
@code{myList.next.next}, and @code{myList.next.val} would be examined.
@end itemize

Values that do not exist are not examined.  For instance, if @code{myA}
is @code{null} on a particular execution of a program point, then
@code{myA.b} is not accessed on that execution regardless of the depth
parameter.

@item +daikon_functions
Produce data trace output at function entry/exit (default).

@item -daikon_functions
Do not produce data trace output at function entry/exit.

@item +daikon_classes
Produce data trace output for class invariants (default).

@item -daikon_classes
Do not produce data trace output for class invariants.

@c @item +daikon_loops
@c Produce data trace output for loop invariants.
@c @emph{This option has no effect:  loop invariants are not currently supported.}
@c 
@c @item -daikon_loops
@c Do not produce data trace output for loop invariants (default).

@item -daikon_omit=@var{string}
Do not produce data trace output for matching classes/functions.  This
reduces the size of the data trace file and also may make the
instrumented program run faster, since it need not output those variables.

The @option{-daikon_omit} argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its class, fully qualified function name, or complete program point
name exactly matches one of the omitting criteria.

For example, to avoid detecting invariants over an iterator, you can
call dfej like so:
@example
  dfej '-daikon_omit=HashSetLinear$HslIterator' HashSetLinear.java
@end example

@item -tracefilename=@var{filename}
Specifies the default name for the @file{.dtrace} file (default
@file{daikon-output/@var{CLASSNAME}.dtrace}).  The filename is relative
to the current directory at runtime, or is absolute.  If the DTRACEFILE
environment variable is set when the instrumented program is run, it
overrides this default.

@item -declsfiledir=@var{decldir}
Specifies the directory in which to create
@file{@var{PACKAGES}/@var{CLASSNAME}.decls} (default
@file{daikon-output}, unless @option{-declsfiledirflat} is
specified).  @var{PACKAGES} is the relative path from the current
directory to the source file; that is, the relative path from
@var{decldir} to the @file{.decls} file is the same as the relative
path from the current directory to the source file.  The directory
structure of the @file{.decls} files mirrors the directory structure of
the source files.

@item -declsfiledirflat=@var{decldir}
Specifies the directory in which to create @file{@var{CLASSNAME}.decls}
(no default).  All @file{.decls} files appear in the same directory.

@item -instrsourcedir=@var{instrdir}
Specifies the directory in which to write instrumented source files
(default @file{daikon-instrumented/}).  The instrumented files have the
same names and directory structure as the original input files.

@c not yet implemented for dfej as of 6/13/2001
If the value of this field is @samp{.} (i.e., a single period), then
instrumented files replace the original versions in the original
directories, but the original source files are backed up by appending
@file{.uninst}.  More specifically,
@enumerate
@item each instrumented file is copied from @file{filename} to
@file{filename.uninst}, unless filename @file{filename.uninst} already
exists, in which case no copying occurs
@item the system reads from @file{filename.uninst} and writes to
@file{filename}.
@end enumerate
This behavior permits in-place instrumentation, which may be desirable
to ease compiling the instrumented code.  (This feature is probably more
important for C/C++ than for Java programs.)  Running the instrumenter a
second time reads the original source code rather than inserting an
additional set of instrumentation into the already-instrumented source
code files.

@quotation
Note for Java:

If you do not override the default value of this variable (and possibly
even if you do, if you do not set it to @samp{.}), then you should run
@command{dfej} from a directory in your classpath.  For example, if
directory @file{parent/} is in your classpath and you want to instrument
@file{parent/foo/Bar.java}, you should run @samp{dfej foo/Bar.java} from
directory @file{parent/}.  This will create a file
@file{parent/daikon-instrumented/foo/Bar.java}.  You must add directory
@file{parent/daikon-instrumented} to your classpath.

(The reason for running @command{dfej} from a directory in your
classpath is that it allows the directory structure to remain consistent
with the package structure. If @file{Bar.java} specifies its package, it
does so with a line like @samp{package foo;}.  If you run @command{dfej}
from the @file{parent/foo} directory, the instrumented version of
@file{Bar.java} will go in @file{parent/foo/daikon-instrumented/Bar.java}; this
is not consistent with the package structure.)
@end quotation

@item -noajax
Do not fill in the variable comparability information in the
@file{.decls} file.  By default, the Ajax module
"ComparablePairsDescFileReader" does this rewriting.
Use of Ajax also requires environment variable AJAX_DIR to be set to a
directory containing various Ajax helper files.

@item -ajaxap=@var{apdir}
This is the directory in which the Ajax comparability module looks
for @file{.class} files for the current application.  (It is a classpath
entry, so the @file{.class} files might appear in a subdirectory named
for the appropriate package.  If this option is not supplied, the
@option{-classpath} argument is used.  A sensible value is required for
code that (for example) calls libraries which do not appear under the
current directory.

@item -ajax_runnable=@var{class}
This is a Java class, in dot-delimited form (e.g., "foo.bar.Baz"), that
contains a @samp{public static void main(String[])} method.  This class
need not be one of the instrumented ones.  If it is not supplied, the
first instrumented class with such a @samp{main} method is used instead.

@c @item -ajax_runnables=@var{classes}
@c This is a whitespace-separated list of Java classes, in dot-delimited
@c form (e.g., "foo.bar.Baz"), that contain @samp{public static void
@c main(String[])} methods.  Those Java classes need not be among the
@c instrumented ones.  In addition, all such @samp{main} methods in the
@c instrumented classes are also used as entry points.  In order to run,
@c Ajax requires the name of at least one runnable class.
@c (Actually, Ajax requires the name of exactly one runnable class.)
@c 
@c @item -ajax_all_runnables=@var{classes}
@c Just like @option{-ajax_runnables}, except that no @samp{main} methods
@c in the instrumented classes are used as entry points.

@end table

When conflicting options are specified (for instance, both
@option{+daikon_functions} and @option{-daikon_functions}, or both
@option{-declsfiledir} and @option{-declsfiledirflat}), the last one
takes precedence.


@node    Scope of instrumentation, Refined runtime types, dfej options, Java front end dfej
@subsection Controlling what classes are instrumented

Only the specified Java files are instrumented; other files are
run uninstrumented.  This permits you to control the scope of invariant
detection.

In any of the specified files, all classes defined in any of those
files are instrumented.  For instance, after
@example
dfej Foo.java Bar.java
@end example
@noindent
the instrumented versions of @file{Foo.java} and @file{Bar.java} output
information about all Foo objects (including Foo objects that are
components of Bar objects, that are arguments to Bar functions, etc.),
and likewise for Bar objects.

After
@example
dfej Foo.java
dfej Bar.java
@end example
@noindent
the same functions (all those in the @file{Foo} and @file{Bar} classes)
are instrumented, but in Foo functions, no detail is provided
about the structure of any Bar objects that might appear.  In other
words, the instrumenter assumes that the only classes instrumented (and
about which information is desired) are those presented to it on the
command line.  One way to determine all the @file{.java} files that are
included in a specified program is to run the following commands:
@example
find . -name '*.class' -print | xargs rm -f
javac MyProgram.java
find . -name '*.class' -print
@end example

@command{dfej} tracks all modifications of instrumented classes; if you
do not instrument all users of a class, then modifications in
uninstrumented classes may not be detected.  This can affect Daikon's
statistical tests, but in practice usually has little impact. The program 
makes approximations to the missing modification information.

@c (The @command{modbit-munge.pl} script makes approximations to the missing
@c modification information.


@node    Refined runtime types,  , Scope of instrumentation, Java front end dfej
@subsection Refined runtime types

Daikon uses the declared types of variables to determine what fields
those variables have and what methods may be legally applied to those
variables.  However, sometimes the declared type is excessively general:
the runtime value may be guaranteed to be of a more specific type.  This
often results from use of polymorphic datatypes or methods.  For
instance, a Java variable may be declared as @code{Object} even though
it always holds an @code{Integer}.  In that case, methods such as
@code{intValue} may be safely called on the object, even though it is
not applicable to arbitrary @code{Object}s.

You can indicate the runtime type of a variable to dfej by inserting a
@example
  /*refined_type: Integer*/ 
@end example
@noindent
comment immediately before the declared type (but after any modifiers like
"public" or "static").  For example, a list element that only contains
@code{Integer}s might be annotated as follows:
@example
  class ListNode @{
    /*refined_type: Integer*/ Object element;
    ListNode next;

    ListNode( /*refined_type: Integer*/ Object theElement ) @{ ... @}
    ListNode( /*refined_type: Integer*/ Object theElement, ListNode n ) @{ ... @}
  @}
@end example



@c 
@c <hr>
@c <h1><a name="manifest">Manifest (list of files in the distribution)</a></h1>
@c 
@c @example
@c User documentation
@c   daikon.html		This file; the main Daikon documentation
@c   README		Says to see daikon.html instead
@c   daikon.gif		The Daikon logo
@c 
@c Java front end
@c   java-front-end/	A modified version of the <a href="http://oss.software.ibm.com/developerworks/opensource/jikes/project/">Jikes Java compiler</a>
@c     src/                Source code
@c       dfej              The main executable (Daikon front end for Java);
@c                           you must build this yourself (see <a href="#build-dfej">instructions</a>)
@c 
@c C front end
@c   c-front-end/
@c     dump_trace.c	Writing data values to a data trace
@c     dump_trace.h	Header files for the above
@c     Makefile-sample	Sample Makefile for linking in the above
@c     dfec		Script for instrumenting C files (you also
@c                           need the edgcpfe executable; see "<a
@c                           href="#install">Installing Daikon</a>")
@c     dfec.sh		Version of dfec written in shell script, not Perl
@c     label.txt		Auxiliary file for output filename selection at runtime
@c 
@c Invariant detector
@c   java/			Source code for Daikon, which is written in Java
@c     Daikon.java         The entry point for Daikon
@c 
@c Auxiliary programs
@c   bin/			Helper scripts and programs
@c 
@c Miscellaneous files
@c   Makefile		Makefile for the invariant detection system
@c   VERSION		Timestamp of this distribution
@c   dtrace-format.txt	Documentation of the trace file format; somewhat old
@c   daikon-python/        An old version of Daikon, written in Python.
@c   			  The current version does not require Python.
@c @end example

@menu
* C/C++ front end dfec::
@end menu

@node    C/C++ front end dfec,  , Java front end dfej, Front ends
@section C/C++ front end dfec

@cindex front end for C/C++
@cindex C/C++ front end
@cindex dfec (Daikon front end for C/C++)


This section contains details about dfec, the Daikon front end for C/C++.
For brief information about running dfec, see @ref{Instrumenting C/C++ programs}.

Recall that dynamic invariant detection over a C/C++ program requires
three steps:
@enumerate
@item
run dfec, creating an instrumented version of the program and a
declaration file
@item
run the instrumented program, creating data trace files
@item
run Daikon on the declaration files and data trace files
@end enumerate

This section discusses the steps in more detail, with an emphasis on the
first step.

@c The three crucial files are @file{dfec}, 
@c @file{daikon_runtime.h}, and 
@c @file{daikon_runtime.o}.

To instrument a C file, run @command{dfec} on it.  (You must supply the
@option{-I} argument, and possibly others; @xref{dfec command-line
arguments}.)  dfec produces instrumented source as well as a
@file{.decls} file.  Do not run dfec on header files (ending in
@file{.h}), only on C or C++ source files.

Running @command{dfec @var{arguments} myprog.c} creates
a file named @file{myprog.cc} in the @file{daikon-instrumented/}
directory.  (It has a @file{.cc} extension, regardless of its original
extension.)  It also creates a file named @file{myprog.decls}, which
appears in the @file{daikon-output/} directory by default.  To change
these defaults, see the @ref{dfec command-line arguments} section.


Before compiling the instrumented program, either copy or link
@file{daikon_runtime.h} and @file{daikon_runtime.o} from
@file{daikon/front-end/c/} to the current directory.  (See
@ref{Installing dfec}, for details on creating @file{daikon_runtime.o}.)

Compile the instrumented program in the usual way, except that the link
step should include @file{daikon_runtime.o} and the stdc++ library.
For instance,
@example
  gcc -o @var{exefile} myprog.c
@end example
@noindent
would become
@example
  gcc -o @var{exefile} -lstdc++ daikon-instrumented/myprog.cc daikon_runtime.o
@end example

Now you can run your executable in the usual way.  Running the
executable creates a @file{myprog.dtrace} file.  By default, this file
appears in @file{daikon-output/}, and subsequent runs overwrite to that
file.  This default can be overridden via the @option{--tracefilename}
argument to dfec or the DTRACEFILE environment variable at runtime.

Given the @file{myprog.decls} file that dfec created and the
@file{myprog.dtrace} file that running the instrumented program created,
you can run Daikon:
@example
  java daikon.Daikon daikon-output/myprog.decls daikon-output/myprog.dtrace
@end example

@menu
* dfec command-line arguments::  
* Pointer type disambiguation::  
* Pointer type disambiguation example::  
* Limitations::                 
@end menu

@node    dfec command-line arguments, Pointer type disambiguation, C/C++ front end dfec, C/C++ front end dfec
@subsection dfec command-line arguments

This section describes the command-line options dfec accepts.
@table @option

@item -I@var{path}
Adds @var{path} to the end of the system include path.  @strong{You must
supply an @option{-I} option for each directory on the system include path.}
For example,
@example
  dfec -I/usr/local/include -I/usr/include myprog.c
@end example
@noindent
To determine your system include path, run
@example
touch searchpath.cc; gcc -v -E searchpath.cc > /dev/null; rm searchpath.cc
@end example
@noindent
and look for what follows "@samp{#include <...> search starts here:}".


@c [this is deprecated - we want the c++ searchpath only.]
@c For instance, on
@c Unix run one of these commands, depending on whether you want the C or
@c C++ search path:
@c @example
@c touch searchpath.c; gcc -v -E searchpath.c > /dev/null; rm searchpath.c
@c touch searchpath.cc; gcc -v -E searchpath.cc > /dev/null; rm searchpath.cc
@c @end example


@item -D@var{macro}=@var{value}
Defines the preprocessor macro @var{macro} to be @var{value}.  For example,
to get dfec to correctly traverse the include files on our system, we use
@example
  dfec @var{...includepath...} -D__GNUG__=1 -D__null=0
@end example

@item --tracefilename=@var{filename}
Specifies the default name for the @file{.dtrace} file (default
@file{daikon-output/@var{myprog}.dtrace}, where @file{@var{myprog}.c} is
the instrumented program).  The filename is relative to the current
directory at runtime, or is absolute.  If the DTRACEFILE environment
variable is set when the instrumented program is run, it overrides this
default.  Furthermore, if the DTRACEAPPEND environmental variable to any
value, the dtrace file will be appended to instead of overwritten, which
can be handy if you have a script to run the instrumented program multiple
times.

@item --declsfiledir=@var{decldir}
Specifies the directory in which to create
@file{@var{PATH}/@var{myprog}.decls} (default
@file{daikon-output/}, unless @option{--declsfiledirflat} is
specified).  @var{PATH} is the relative path from the current
directory to the source file; that is, the relative path from
@var{decldir} to the @file{.decls} file is the same as the relative
path from the current directory to the source file.  The directory
structure of the @file{.decls} files mirrors the directory structure of
the source files.

@item --declsfiledirflat=@var{decldir}
Specifies the directory in which to create @file{@var{myprog}.decls}
(no default).  All @file{.decls} files appear in the same directory.

@item --instrsourcedir=@var{instrdir}
Specifies the directory in which to write instrumented source files
(default @file{daikon-instrumented/}).  The instrumented files have the
same names and directory structure as the original input files, with the
slight exception that the file suffix is set to .cc, so if you instrument
@file{@var{myprog}.c}, you will end up with
@file{daikon-instrumented/@var{myprog}.cc}.  If
@var{instrdir} is '.', then instrumentation is performed in-place,
first copying the source file @file{myprog.c} to @file{myprog.c.uninst},
then overwriting @file{myprog.c} with instrumented source.  If
@file{myprog.c.uninst} already exists, the copy step is not performed.
This is useful in situations with Makefiles that you don't want to
change, or when compiling a system requires many files to be in place.


@item --disambigfilename=@var{filename}
Specifies the filename for the pointer type disambiguation file.  If
this file exists, dfec reads from it, using the information within
to make decisions about how to output the 'contents' of pointer and
array variables.  If the file does not exist, dfec creates it,
specifying default instrumentation behavior for all
pointer types.  For more information, see
@ref{Pointer type disambiguation}.

@item --disambig
Tells dfec to use pointer type disambiguation with the default filename,
which is @file{@var{myprog}.disambig} in the same directory as the
@file{.decls} file.  For more information, see
@ref{Pointer type disambiguation}.

@end table

When conflicting options are specified (for instance, both
@option{--declsfiledir} and @option{--declsfiledirflat}), the last one
takes precedence.

@node    Pointer type disambiguation, Pointer type disambiguation example, dfec command-line arguments, C/C++ front end dfec
@subsection Pointer type disambiguation

dfec permits users (or external analyses) to specify whether pointers
refer to arrays or to single values.  For example, in
@example
void sum(int * array, int * result) @{ ... @}  // definition
...
sum(a[], &total);  // use
@end example
@noindent
the first pointer parameter refers to an array while the second refers to
a single value.  dfec (and Daikon) should treat these values
differently.  For instance, "*array" is better printed as "array[0]",
and "result[]" isn't a sensible array at all.  By default, dfec treats
all pointers as referencing arrays.  Eliminating unnecessary array
variables --- in this case, preventing Daikon from treating result as a
single-element array --- can speed up Daikon and improve its output.
(See the example below.)

Information about whether each pointer refers to an array or a single
element can be specified in a 'disambig file' that resides in the same
directory as the decls file.  The @option{--disambig} option instructs
dfec to read this file.  (dfec can also produce the file automatically,
permitting users to edit it for use on subsequent runs, rather than
having to create it from scratch.)  The disambig file
lists all the instrumented program points, and under each, a list of
pairs of variable names and the types that they're instrumented as:  'A'
for array, 'P' for pointer to single value, 'I' for integer, 'C' for
character.


@c This isn't really relevant to users of Daikon, though it is quite
@c interesting from an implementation point of view.
@c A C/C++ pointer type is output to the decls and dtrace files in two
@c ways: firstly, as the memory address it points to (the equivalent of the
@c java 'hashcode'), and secondly, its 'contents'.  By default, the
@c contents of an array or pointer type is the list of values pointed to by
@c the pointer variable.  The Daikon runtime library keeps track of all
@c pointer variables, and notes what the highest referenced value beyond a
@c base is, and assumes that all values between the base and that are
@c valid.  Then, when outputting to the decls and dtrace files, it outputs
@c the full list of 'known valid' values.  In addition to this, there are
@c certain safety features built into the Daikon runtime library, such as
@c bounds-checking on arrays that have been declared with static size.
@c However, not all pointers point to arrays; many are simply pointers to
@c single elements.


@node    Pointer type disambiguation example, Limitations, Pointer type disambiguation, C/C++ front end dfec
@subsection Pointer type disambiguation example



For instance, let's look at this file:

@example
  void foo(int *bar) @{
    (*bar)++;
  @}

  int main() @{
    int baz=6;
    foo(&baz);
  @}
@end example

In foo(), bar is an int *.  By default, dfec would instrument bar as an
array of int, keeping track of how many ints bar addressed, and outputting
bar[] to the decls and dtrace as a sequence, which yields these invariants:

@example
===========================================================================
std.foo(int *;):::ENTER
bar[0] == min(bar[]) == max(bar[]) == sum(bar[])
bar has only one value
bar[] == [6]
bar[] elements == 6
size(bar[]) == 1
===========================================================================
std.foo(int *;):::EXIT1
bar == orig(bar)
bar[0] == min(bar[]) == max(bar[]) == sum(bar[])
orig(bar[0]) == min(orig(bar[])) == max(orig(bar[])) == sum(orig(bar[]))
bar has only one value
bar[] == [7]
bar[] elements == 7
orig(bar[]) == [6]
orig(bar[]) elements == 6
size(bar[]) == 1
@end example

This is a bit wordy.  But, by running dfec with the @option{--disambig}
option, we create the @file{daikon-output/@var{myprog}.disambig} file,
which we can then edit and feed back to dfec to change how the pointer
is instrumented.
@example
  dfec @var{...options...} --disambig @var{myprog}.cc
@end example

This creates the @file{daikon-output/@var{myprog}.disambig} file.  Opening
it up, we see at the top:

@example
std.foo(int *;)void:::ENTER
bar
A

std.foo(int *;)void:::EXIT1
bar
A
@end example

This means that at the two program points corresponding to the entry and
exit of foo(), the variable bar is instrumented as an 'A'rray type.  To
change it so dfec instruments it as a 'P'ointer type, change the two 'A'
entries to 'P' entries:
@example
std.foo(int *;)void:::ENTER
bar
P

std.foo(int *;)void:::EXIT1
bar
P
@end example

Then, running dfec again with the @option{--disambig}
option causes dfec to open the existing
@file{daikon-output/@var{myprog}.disambig} file, reading the definitions
you gave, and changing the instrumentation accordingly:
@example
  dfec @var{...options...} --disambig @var{myprog}.cc
@end example

This means that bar will be instrumented as a 'P'ointer to a single element.
If you compile and run the program, then run Daikon on the output, you'll
see much cleaner invariants:
@example
===========================================================================
std.foo(int *;):::ENTER
bar has only one value
*bar == 6
===========================================================================
std.foo(int *;):::EXIT1
bar == orig(bar)
bar has only one value
*bar == 7
orig(*bar) == 6
@end example


@node    Limitations,  , Pointer type disambiguation example, C/C++ front end dfec
@subsection Limitations

@file{dfec} technically only instruments C++ programs.  However, most
ANSI C programs are also legal C++ programs.  Programs that define
symbols that are C++ keywords, such as @samp{bool}, require some
additional effort to process with dfec.  dfec does not support K&RC or
other non-ANSI/ISO C dialects; convert such programs to ISO C before
running dfec.  The @command{protoize} program (distributed with many
versions of Unix and also widely available online) helps to perform this
task.

@c 7/02/2001
The current C/C++ front end does minimal instrumentation of pointers.  It
keeps track of the memory address they hold (roughly equivalent to the
Java hashcode).  In the case of arrays and pointers to blocks of data,
it holds information about the maximum 'touched' element of the array, to
enable it to make guesses about what part of the array is valid, and only
output that much.  This guessing is not always completely accurate, however,
and changes to array variables done outside the scope of instrumentation
(for instance, in the stdc library functions found in 'string.h') will not
be recorded and hence may yield sparse output.

@c [the following limitation is deprecated as of 7/02/2001.]
@c [global/local/class vars are now scoped with '::', '', and 'this->'.]
@c @c 4/10/2001
@c When a local variable shadows a global variable of the same name, dfec
@c tries to output both to the @file{.dtrace} and @file{.decls} files.  The
@c instrumented C program will run fine, but the local variable will be
@c output twice, and Daikon will issue an error when it is given files
@c containing two variables of the same name.



@node    Extending Daikon, Troubleshooting, Front ends, Top
@chapter Extending Daikon
@cindex extending Daikon
@cindex changing Daikon
@cindex modifying Daikon

This chapter describes how to customize Daikon to your specific needs.

Readers are also referred to Chapter 7, "Implementation", of
@cite{Dynamically Discovering Likely Program Invariants} by Michael
D. Ernst, PhD dissertation, University of Washington Department of
Computer Science and Engineering, Seattle, Washington, USA, August 2000.
This document is available online at
@url{http://sdg.lcs.mit.edu/~mernst/pubs/invariants-thesis-abstract.html}.



@menu
* Compiling Daikon::
* New invariants::              
* New derived variables::       
* New formatting for invariants::  
@end menu

@node    Compiling Daikon, New derived variables, Extending Daikon, Extending Daikon
@section Compiling Daikon
@cindex compiling daikon

To compile Daikon, type @command{make} in any directory under
@file{@var{parent}/daikon/java/}.  The distribution includes compiled
@file{.class} files, so you do not need to compile them yourself unless
you make changes.

In order to compile Daikon, you either need the C preprocessor
@command{cpp}, which is used to convert each @file{.jpp} file in the
distribution into multiple @file{.java} files, which are then compiled.
If you do not have @command{cpp}, you may run @command{make avoid-jpp}, in
which case changes to @code{.jpp} files will not be reflected in the
compiled @file{.class} files.

You may wish to create a @file{Makefile.user} file to set your Java
compiler:
@example
  JAVAC ?= jikes -g +E +F
@end example

For more information about copmiling Daikon, see the comments in the Makefiles.


@node    New invariants, New derived variables, Extending Daikon, Extending Daikon
@section New invariants

You can easily write your own invariants and have Daikon check them,
along with all the other invariants that are built in to Daikon already.
Adding a new invariant to Daikon requires writing one Java class, adding
a line to another file to inform Daikon of the new class, and
recompiling Daikon.

The new Java class will be a concrete subclass of one of the following
abstract classes:
@itemize @bullet
@item
@samp{SingleScalar}, for invariants over a single numeric (scalar) variable,
such as "x != 0".
@item
@samp{TwoScalar}, for invariants over two numeric variables, such as "y
= abs(x)".
@item
@samp{ThreeScalar}, for invariants over three numeric variables, such as
"z = ax + by + c".
@item
@samp{SingleSequence}, for invariants over one sequence (array)
variable, such as "a[] contains no duplicates".
@item
@samp{TwoSequence}, for invariants over two sequences, such as "a[] is a
subsequence of b[]".
@item
@samp{SequenceScalar}, for invariants over a scalar and a sequence, such
as "x is a member of a[]".
@end itemize
@noindent
For a complete list of the types appears in classes @samp{PptSlice1},
@samp{PptSlice2}, and @samp{PptSlice3}, in their respective
@samp{instantiate_invariants} methods.

Daikon's invariants are first instantiated, then are presented samples
(tuples of values for all the variables of interest to the invariant;
this might be a 1-tuple, a 2-tuple, or a 3-tuple) in turn.  If any
sample falsifies the invariant, it destroys itself.  All remaining
invariants at the end of the program run can be reported as likely to be
true.

The key methods of the new invariant are
@table @samp
@item @r{constructor}
Creates a new invariant object.  Its typical implementation is
@example
  super(ppt);
@end example
@item instantiate
returns either a new invariant object or null.  For instance,
@samp{instantiate} might check whether particular conditions that are
required for the invariant to be sensible hold.  Its typical
implementation is
@example
  return new @var{InvName}(ppt);
@end example
@item add_modified
presents a tuple of values to the invariant.  The @samp{count} variable
indicates copy may samples have this value.  For example, three calls to
@samp{add_modified} with a @samp{count} parameter of 1 is equivalent to
one call to @samp{add_modified} with a @samp{count} parameter of 3.
@item computeProbability
returns the probability that the observed data could have happened by
chance alone.  The result usually falls between 0 and 1, where 1 means
the values seen so far certainly happened by chance and 0 means they
could never have happened by chance.  The method may also return one of
the following constants in the @samp{Invariant} class (which see for
documentation): @samp{PROBABILITY_JUSTIFIED},
@samp{PROBABILITY_UNJUSTIFIED}, @samp{PROBABILITY_UNKNOWN},
@samp{PROBABILITY_NEVER}.

For example, suppose your new invariant has a 50% chance of being true
by chance for each sample.  ("x is even" is an example of such an
invariant.)  Then a reasonable body for @samp{computeProbability} would
be
@example
  return Math.pow(.5, ppt.num_values());
@end example
@noindent
If 5 values had been seen, then this implementation would return 1/32,
which is the likelihood that all 5 values seen so far were even purely
by chance.  Invariants are only printed if their probabilities are small
enough (by default, less than .01).
@item format
returns a high-level printed representation of the
invariant, for user output.  The @samp{repr} formatting routines
produces low-level, detailed output for debugging.  When first writing
an invariant, you can make @samp{repr}, @samp{format_esc}, and
@samp{format_simplify} all simply call @samp{format}, then fix up the
implementations later as needed.
@end table

After the invariant is written, add a call to its @samp{instantiate}
method in pass 2 of the @samp{instantiate} method of the appropriate
factory; for instance, add a line like
@example
  result.add(MyInvariant.instantiate(ppt));
@end example
@noindent
to @samp{SingleScalarFactory.instantiate}.


@node    New derived variables, New formatting for invariants, New invariants, Extending Daikon
@section New derived variables

(To be written)


@node    New formatting for invariants,  , New derived variables, Extending Daikon
@section New formatting for invariants

Daikon can print invariants in three formats:  its native format, ESC
format (which is a subset of the JML specification language), and
Simplify format.

To support a new output format, you need to do two things:
@itemize
@item
Add, to every subclass of @samp{Invariant}, a
@samp{format_@var{newtype}()} method.  Each subclass of Invariant
already has three such methods --- @samp{format()}, @samp{format_esc()},
and @samp{format_simplify()} --- for you to crib from.
@item
Edit @samp{PptTopLevel.print_invariants()} to add a call to your new
method, near the calls to the other formatting methods.
@end itemize


@node    New front ends,  , New derived variables, Extending Daikon
@section New front ends

@cindex front end, writing

A front end for Daikon takes as input a target program to be analyzed.
The front end produces two outputs:  a @file{.decls} file and an
instrumented program which, when run, produces a @file{.dtrace} file.
For more information about these files, @xref{File formats}.

Conceptually, instrumentation is very simple.  For instance, suppose we
wish to instrument file @file{Example.java}.
@example
class Example {
  // Return either the square of x or the square of (x+1).
  int squar(int x, boolean b) {
    if (b)
      x++;
    return x*x;
  }
}
@end example

The @file{.decls} file might look like the following.
@example
DECLARE
Example.squar:::ENTER
x
int
int
1
b
boolean
int
2

DECLARE
Example.squar:::EXIT
x
int
int
1
b
boolean
int
2
return
int
int
1
@end example

The instrumented @file{.java} file might look like the following.
@example
class Example {
  static {
    daikon.Runtime.setDtraceMaybe("daikon-output/StackAr.dtrace");
  }

  // Return either the square of x or the square of (x+1).
  int squar(int x, boolean b) {
    synchronized (daikon.Runtime.dtrace) {
      daikon.Runtime.dtrace.println();
      daikon.Runtime.dtrace.println("Example.squar:::ENTER");
      daikon.Runtime.dtrace.println("x");
      daikon.Runtime.dtrace.println(x);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("b");
      daikon.Runtime.dtrace.println(b ? 1 : 0);
      daikon.Runtime.dtrace.println(1);  // modified bit
    }

    if (b)
      x++;

    int daikon_return_value = x*x;
    synchronized (daikon.Runtime.dtrace) {
      daikon.Runtime.dtrace.println();
      daikon.Runtime.dtrace.println("Example.squar:::EXIT");
      daikon.Runtime.dtrace.println("x");
      daikon.Runtime.dtrace.println(x);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("b");
      daikon.Runtime.dtrace.println(b ? 1 : 0);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("return");
      daikon.Runtime.dtrace.println(daikon_return_value);
      daikon.Runtime.dtrace.println(1);  // modified bit
    }

    return daikon_return_value;
  }
}
@end example


@node    Troubleshooting, Details, Extending Daikon, Top
@chapter Troubleshooting

This chapter gives solutions for certain problems you might have with
Daikon; it also tells you how to report bugs in a useful manner.

@menu
* dfej problems::               
* Daikon problems::             
* Other problems::              
* Reporting bugs::              
* Known bugs::                  
* Further reading::             
@end menu

@node    dfej problems, Daikon problems, Troubleshooting, Troubleshooting
@section Problems with dfej

@menu
* dfej compilation problems::   
* dfej invocation problems::    
@end menu

@node    dfej compilation problems, dfej invocation problems, dfej problems, dfej problems
@subsection Problems compiling dfej


gcc 2.95.2 on Linux raises an internal error when compiling
@file{stream.cpp} using the @option{-Wall} flag.  You can simply compile
that file without the @option{-Wall} flag.


If you get an error like
@example
stream.cpp: In method `void LexStream::ProcessInputUnicode (const char *, long int)':
stream.cpp:901: cannot convert `const char **' to `char **' for
argument `2' to `iconv (void *, char **, size_t *, char **, size_t *)'
@end example
@noindent
then undefine preprocessor macro @code{HAVE_ICONV_H} and try compiling
again.
(This has been reported on Red Hat Linux 7.0.)



@node    dfej invocation problems,  , dfej compilation problems, dfej problems
@subsection Problems running dfej

If you get an error like
@example
% dfej MyProg.java
MyProg.java:0:0:0:0: Error: Could not find package named: 
                ./java/util
MyProg.java:0:0:0:0: Error: Could not find package named: 
                ./java/lang
@end example
@noindent
then you need to add @file{rt.jar} to your
CLASSPATH; see @ref{Installing dfej}.


If you get a warning like
@example
     *** Warning: the file "/cygdrive/c/jswdk-1.0.1/jspengine.jar" is not a valid zip file.
@end example
@noindent
then you have set your CLASSPATH incorrectly:  it names a nonexistent
file or a file that is not a @file{.jar} Java archive.  You should adjust
your CLASSPATH to remove the offending file.  This warning has no effect
on the operation of dfej, however.


dfej does not handle anonymous classes like that created by the expression
@example
  new ItemListener() @{
      public void itemStateChanged( ItemEvent evt ) @{
         ...
      @}
  @}
@end example
@noindent
You may be able to work around this by running dfej on other files of
your application, but not those with anonymous classes.


@c @node    Instrumented code problems, Daikon problems, dfej problems, Troubleshooting
@c @section Problems running instrumented code


@node    Daikon problems, Other problems, dfej problems, Troubleshooting
@section Problems running Daikon



@menu
* Abnormal termination::        
* Out of memory::               
@end menu

@node    Abnormal termination, Out of memory, Daikon problems, Daikon problems
@subsection Abnormal termination warnings


Daikon sometimes issues a warning that it has detected abnormal termination
of the target program.  This means that the @file{.dtrace} file contains more
entry records than exit records for the given procedure.  This means that
some functions that were entered were never recorded to have exited:
either they threw an exception, skipping the instrumentation code that
would have recorded normal termination, or the target program's run was
interrupted.


In some cases, exceptional exit from a procedure can cause orig(x) values
to be incorrect.  This depends on the technique used to associate procedure
exits with entries.  Daikon has two such techniques --- the nonce technique
(which is the default for Java programs) and the stack technique.  If
Daikon is using the nonce technique, orig(x) values are guaranteed to be
correct.  If Daikon is using the stack technique, then the orig(x) values
are likely to occur.  You can tell which technique Daikon is using by
examining the @file{.dtrace} file.  If the second line of each entry in
the @file{.dtrace} file is "this_invocation_nonce", then Daikon uses
the nonce technique.  Otherwise, it uses the stack technique.



@node    Out of memory,  , Abnormal termination, Daikon problems
@subsection Out of memory

If Daikon runs out of memory, generating a message like
@example
        Exception in thread "main" java.lang.OutOfMemoryError
                <<no stack trace available>>
@end example
@noindent
then the problem is likely to be an excessively large @file{.dtrace}
file.  In addition to the solutions discussed in @ref{Large dtrace
files}, you can try increasing the amount of memory available to Java
with the @option{-mx} argument to @command{java}.  (This flag is
JVM-specific; see your JVM documentation for details.)  The default is
only 1 megabyte; to permit use of up to 128 megabytes, you would run
Java like so:
@example
        java -mx128m ...
@end example

Another possible problem is the creation of too many derived variables.
If you supply the @option{--output_num_samples} argument to Daikon
(@pxref{Command line options for Daikon}), then it will list all
variables at the program point.  If some of these are of no interest,
you may wish to suppress their creation.  (This manual does not
presently tell you how to do that.)

Any output generated before the out-of-memory error is perfectly valid.


@node    Other problems, Reporting bugs, Daikon problems, Troubleshooting
@section Other problems

@menu
* Large dtrace files::          
* Font errors from running GUI::  
@end menu

@node    Large dtrace files, Font errors from running GUI, Other problems, Other problems
@subsection Large data trace (.dtrace) files

Running code instrumented by dfej can result in very large
@file{.dtrace} files.  This can be a problem because writing the large
files can slow the target programs substantially, because the large files
may fill up your disk, or because Daikon is unable to process the large
files.  There are several solutions to this problem.

@enumerate
@item 
You can terminate the instrumented program when it has created a
sufficiently large @file{.dtrace} file.  If you interrupt the program
while it is in the middle of writing a record to the @file{.dtrace}
file, the last record may be only partially written.  Use the
@command{invariants/scripts/trace-untruncate} script to remove the last,
possibly partial, record from the file:
@example
  trace-untruncate @var{myfile}.dtrace
@end example
@noindent
modifies @file{myfile.dtrace} in place to remove the last record.
@item 
If you wish to instrument fewer methods, you can use the 
@example
  -daikon_omit=@var{STRING}
@end example
@noindent
argument to dfej.  (For a list of dfej's options, see @ref{dfej
options}.)  Dfej will not produce data trace output for classes or
procedures that match the STRING.  Running the instrumented program
will result in a smaller @file{.dtrace} file that contains fewer
records.
@item 
You can pare down an existing @file{.dtrace} file using the
@command{invariants/scripts/trace-purge-fns.pl} and
@command{trace-purge-vars.pl} scripts. These remove (or retain) certain
program points, or certain variables, from @file{.dtrace} files; see
their documentation (at the top of the files) for details.  Removing
program points obviously prevents Daikon from considering them;
removing variables can eliminate certain large uses of memory or keep
Daikon from doing uninteresting comparisons.
@item 
To make Daikon ignore some program points, use its
@example
  -r @var{PPT_REGEXP}
@end example
@noindent
argument.  (Run "@command{java daikon.Daikon}" to see a list of
arguments.)  With the @option{-r} flag, only program points matching
the regular expression are processed.  This can take the place of the
@command{trace-purge-fns.pl} script.
@end enumerate



@node    Font errors from running GUI,  , Large dtrace files, Other problems
@subsection Font errors from running GUI

When running the GUI on Linux, you may get font errors such as the following:

@example
Font specified in font.properties not found [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
Font specified in font.properties not found [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
Font specified in font.properties not found [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
Font specified in font.properties not found [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
Font specified in font.properties not found [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
@end example

These errors are harmless; the GUI should still run correctly.  To
prevent these errors from appearing in the future, take the following
steps:

@itemize @bullet
@item Find out where your jdk root directory is.  In general, the jdk root directory
is where you run java from: JDK_ROOT/bin/java.
@item Edit JDK_ROOT/jre/lib/font.properties, and comment out all lines
with the offending fonts.  For example, to eliminate the error messages
shown above, one would comment out all lines containing "fontspecific".
@end itemize

If you don't have permission to edit font.properties, please contact
your system administrator.



@node    Reporting bugs, Known bugs, Other problems, Troubleshooting
@section Reporting bugs

If you have any questions, can suggest ways to improve the documentation,
find bugs in the system, or have suggestions for its improvement, please
send email to @daikonemail{}.  While Daikon is a research prototype
and not rock-solid, we will try to assist you and to correct any
problems, so please don't hesitate to ask for help or report difficulties.

Your bug report will be most helpful if you include:
@itemize @bullet
@item the contents of the @file{VERSION} file, which indicates the
      release date of your copy of Daikon.  If you are not using the
      most recent version, it is best if you download a newer version
      from @uref{http://sdg.lcs.mit.edu/daikon/} to see whether your
      problem has already been corrected.
@item a description of exactly what you did and exactly what went wrong.
      For instance, a transcript of your commands and the system's output
      may provide this information.
@item input files that permit the problem to be replicated.  The
      most important thing is the original, uninstrumented source files.
      It is also helpful to include instrumented source files,
      @file{.decl} files, and @file{.dtrace} files.
@item any other information that you consider relevant
@end itemize

It is frequently more difficult to reproduce an error than to correct
it; if you make it easy to reproduce and verify the problem, then it is
much more likely to be corrected.

@menu
* Known bugs::                  
* Further reading::             
@end menu

@node    Known bugs, Further reading, Reporting bugs, Troubleshooting
@section Known bugs

The following problems are already known.  (You may report them again,
to encourage us to release the fix faster, if you like.)
@itemize @bullet
@item Java front end:
@itemize @bullet
@item Inner classes:  Daikon inserts static members; this is not legal
      in inner classes.  The members should be non-static or should be
      inserted into the parent class.
@c @item Invalid modbits:  The front end sometimes produces invalid
@c       modbits.  This can be solved by postprocessing the data trace
@c       files using the @command{modbit-munge.pl} program.
@item Floating-point values are often ignored; the infrastructure is
      there, but I haven't gotten around to writing code to test for
      specific invariants.
@end itemize
@item C front end:
@itemize @bullet
@item Produces bad @file{.dtrace} and @file{.decls} files when a local
      variable shadows a global one.
@end itemize
@end itemize

@node    Further reading,  , Known bugs, Troubleshooting
@section Further reading

See the @uref{http://sdg.lcs.mit.edu/daikon/, Daikon homepage}.

[ This list is out of date; perhaps it should be replaced by a pointer
to a more up-to-date list. ]

Dynamic invariant detection is further described in several papers, including:
@itemize @bullet
@item
@uref{http://sdg.lcs.mit.edu/~mernst/pubs/invariants-tse-abstract.html, Dynamically
      Discovering Likely Program Invariants to Support Program
      Evolution} (IEEE TSE, February 2001)
@item
      @uref{http://sdg.lcs.mit.edu/~mernst/pubs/invariants-icse2000-abstract.html, Quickly Detecting Relevant Program Invariants} (ICSE 2000)
@item
@uref{http://sdg.lcs.mit.edu/~mernst/pubs/invariants-pointers-abstract.html,
Dynamically
  Discovering Pointer-Based Program Invariants} (technical report)
@end itemize


@node    Details, File formats, Troubleshooting, Top
@chapter Details



@menu
* License::                     
* Credits::                     
@end menu

@node    History, Credits, Details, Details
@section History
@cindex history of Daikon

This manual describes Daikon version 2.5.0, released August 26, 2001.

There have been two major implementations of Daikon, with different
features and capabilities.  Readers of technical papers may be confused
by the apparently different claims about Daikon's capabilities.  These
apparent contradictions result from the papers referring to the current
version of Daikon at the time of publication.  This section of the
manual clarifies the development of the Daikon tool in order to reduce
such confusion.

@cindex Lisp front end
@cindex front end for Lisp
@cindex loop heads, instrumenting
@cindex instrumenting loop heads

Daikon 1 was written in the Python programming language.  It included
front ends for C, Java, and Lisp.  The C front end was extremely limited
and failed to operate correctly on all C programs.  Sometimes it
suffered a segmentation fault while instrumenting a target program; even
when that did not happen, sometimes the instrumented program
segmentation-faulted while running.  The Lisp front end operated
correctly on all Lisp programs, but only instrumented certain common
constructs, leaving other language features unmodified.  The Java front
end was reasonably reliable.  The Lisp front end instrumented procedure
entries, exits, and loop heads; the C front ends instrumented only
procedure entries and exits; and the Java front end instrumented program
points for object invariants as well as procedure entries and exits.

Daikon 2 was a complete rewrite in the Java programming language and was
the first version to contain a substantive manual.  Daikon 2 uses the
same Java front end as did Daikon 1, though with certain enhancements.
Its C/C++ front end is rewritten from scratch; it instruments only
procedure entries and exits.  A front end also exists for the IOA
programming language, but is not included in the distribution.


@node    License, Credits, Details, Details
@section License


Daikon is made available for education, research, and evaluation purposes
(not for direct commercial gain), and there is no warranty.  All rights are
reserved, and copyright is held by the authors.  If you have difficulties
with the software, let us know and we will try to correct the problem, but
we cannot make any guarantees of support, or any other guarantees regarding
the software.  As a condition of use, you agree to promptly communicate any
changes, improvements, or enhancements to the authors for inclusion in a
future release under these same conditions.  If you do not agree to this
license, please do not use or examine the software.  For other licensing
terms, send mail to @daikonemail{}.

If you use Daikon, please send mail to @daikonemail{}, so that you can
be informed of new versions, enhancements, and bug fixes.  We would also
appreciate a brief description of how you are using Daikon, because we
are curious about how users exploit it (and am eager for anecdotes about
its successes and failures), and we want to make Daikon more effective
for its users.


@node    Credits,  , License, Details
@section Credits

The following individuals have contributed to Daikon:
@itemize @bullet
@item Jake Cockrell
@item Adam Czeisler
@item @uref{http://sdg.lcs.mit.edu/~mernst/,,Michael Ernst}
@item @uref{http://www.cs.ucsd.edu/~wgg/,,William Griswold}
@item Josh Kataoka
@item @uref{http://web.mit.edu/mhao/www/,,Melissa Hao}
@item @uref{http://web.mit.edu/mharder/www/,,Michael Harder}
@item @uref{http://web.mit.edu/mistere/www/,,Jeremy Nimmer}
@item @uref{http://www.cs.washington.edu/homes/notkin/,,David Notkin}
@end itemize

@uref{http://www.cs.washington.edu/homes/csk/,,Craig Kaplan} carved the
Daikon logo.

The feedback of Daikon users has been very valuable.  We are
particularly grateful to Rich Angros and Manos Renieris.

Many of our other colleagues have also been generous with their feedback
and advice, for which we are grateful.

This work was supported in part by NSF grants CCR-9506779 and CCR-9508745,
an IBM Cooperative Fellowship, and a gift from Edison Design Group.


@node     File formats, Index, Details, Top
@appendix File formats

This chapter contains information about the file format of Daikon's data
trace and declaration files.  It is of most information to those who
wish to write a front end (@pxref{Instrumentation}), enabling Daikon to
detect invariants in another programming language.

Data trace files contain runtime values for variables at particular program
points.  Each record in a data trace file represents one execution of a
program point.  The record names a program point and lists a number of
variables and their runtime values.  This dynamic information about values
at a program point is generated when an instrumented program is run.  By
convention, data trace files have the suffix @file{.dtrace}.

A declaration file describes the structure of the data trace file; it
lists the program points that may appear in the data trace file and, for
each program point, which variables appear at that program point.  This
static lexical information about a program point can be determined when
a program is instrumented.  By convention, declaration files have the
suffix @file{.decls} or @file{.decl}.

(Actually, both declarations and data trace records may appear together in
a single file.  In that case, the program point information must precede
the first appearance of values at that point, but it is not required that
all the program point declarations appear before any values are written to
the file.  This is intended to provide flexibility for instrumentation
implementations.  However, it is encouraged to place declarations in
different files than data traces.)


@menu
* Conventions::                 
* Declaration files::           
* Data trace files::            
* Examples::                    
@end menu

@node    Conventions, Declaration files, File formats, File formats
@section File format conventions


Daikon files are textual, to permit easier viewing and editing by humans.
Each record is separated by one or more blank line.
To permit easier parsing by programs, each piece of information in a record
is on a separate line

Any line starting with a pound sign (#) is ignored as a comment (except
inside a record, where comments are not permitted)


@node    Declaration files, Data trace files, Conventions, File formats
@section Declaration files


A declaration file consists of a sequence of program point declarations
separated by blank lines.

The format of the program point information is:
@example
  DECLARE
  program-point-name
  varname1
  declared-type1
  representation-type1 [= constant-value1]
  comparable1
  varname2
  declared-type2
  representation-type2 [= constant-value2]
  comparable2
  ...
@end example

Program point information includes:
@itemize @bullet
@item
name ("tag") of this program point, an arbitrary string containing no
tab or newline characters.  This name contains information such as the
class name or method name; what information is contained depends on
which instrumenter is being used.  @xref{pptname format}, for a full
specification of the naming format.

By convention, the entry and exit points for a function have names of
a special form so that they can be associated with one another.
(Currently, those names end with ":::ENTER" and ":::EXIT".)  This
convention permits instrumenters not to remember the original values of
variables and output them at the procedure exit point.

Another convention is to have another program point whose name ends
with ":::OBJECT" for the representation invariant of an object or
class.  This program point is not created automatically, because
there isn't a way to know whether a particular method is a private
helper method or not --- that is, whether the representation
invariants should hold on entry to and exit from it.

@item
for each variable:
@itemize @bullet
@item
name: an arbitrary, uninterpreted string containing no tabs or
newlines.  However, the names of array-valued variables must end
with "[]".  For instance, "a" might stand for the array object itself
(appearing in the trace file as a unique ID or hashcode), and "a[]" would
stand for the array contents (appearing in the trace file as a sequence
of values).
@item
declared type:  this is what the programmer used in the
declaration of the variable.  
This is currently uninterpreted, except that array types must be
suffixed by the proper number of "[]" to indicate their dimensionality.
Names for standard types should use Java's names (e.g., "int",
"boolean", etc.), but names for user-defined or language-specific types
can be arbitrary strings.
@item
representation type:  this describes what will appear in the data
trace file.  For instance, the declared type might be "char[]" but
the representation type might be "String".  Or, the declared type
might be "Object" but the representation type might be "int"
(because only the object's hashcode, not the object itself, is
written to the data trace file).
The representation type is currently constrained to be integer,
string, or array of integer or string.
The representation type may optionally be followed by an equals
sign and a value; in that case, the variable is known to have a
compile-time constant value and should be omitted from the data
trace file.
@end itemize
Arrays types are followed by square brackets:  "int[]", "char[][]".
@item
comparable variables, also known as "Lackwit types".  These indicate
which other variables are comparable to this one, which is typically
obtained via type-inference based analysis.  There are two formats,
"implicit" and "explicit", for this information.  (See below for how
to specify which format the information is in.)
@itemize @bullet
@item
An implicit lackwit type is an arbitrary string, and comparisons
succeed exactly if the two lackwit types are identical.
@item
An explicit lackwit type is a list of other variables, and
comparisons succeed if each variable is in the list of the other.
It takes the form of
@itemize @bullet
@item
for scalar types:  A space-separated list of all the other
variables mentioned in this record that are comparable to this
one.
@item
for array types:  The lists are surrounded by parentheses, and
variables are given in parentheses for indices, like so:
"(a b c)[(d e)][(f g h)]".
The elements and indices of an array are named according to 
%s-element and %s-index%d, where the indices are numbered
starting with 1.
@item
If no information is supplied (i.e.,, this line is blank), then
the variable is compared to all other variables of the same type.
@end itemize
@end itemize
@end itemize

Future enhancements may include:
@itemize @bullet
@item
      permit variables to be omitted if they haven't changed (but always
      outputting the bit permits us to write a sanity checker)
@item
      permit variables to appear in any order (not sure this is so worthwhile)
@item
      specify which @file{.decl} files should be used (including their pathnames
      and/or MD5 hashes)
@end itemize

A declaration file optionally starts with a "VarComparability" record,
which might look like the following:
@example
  VarComparability
  explicit
@end example
@noindent
This controls how the comparability field in the declarations is interpreted.


@menu
* pptname format::              
@end menu


@node    pptname format,  , Declaration files, Declaration files
@subsection Program point name format specification

Instrumenting code creates a .decls file that contains program point names
such as:

@example
  StackAr.makeEmpty()V:::EXIT54
  StackAr.makeEmpty()V:::ENTER
  StackAr.top()Ljava/lang/Object;:::EXIT64
  StackAr.top()Ljava/lang/Object;:::EXIT65
  StackAr.top()Ljava/lang/Object;:::ENTER
@end example

This section describes the format of these program point names.  Someone
writing an instrumenter for a new language must be sure to follow this
format specification.

A program point name is a string with no tabs or newlines in it. The basic
format is:

@example
  topLevel.bottomLevel:::pptInfo
@end example

For the first example given above, the top level of the hierarchy would
be @file{StackAr}, the bottom level would be @file{makeEmpty()V}, and the
program point information would be @file{EXIT54}.

@file{topLevel} and @file{bottomLevel} can represent anything. Currently
for Java, @file{topLevel} consists of the class name while
@file{bottomLevel} consists of the method name and method signature. For
C, @file{topLevel} could consist of a filename and @file{bottomLevel}
could consist of a method name and signature. For IOA, @file{topLevel}
could consist of an Automaton name and @file{bottomLevel} could consist of
information for a transition state.

@file{topLevel} may contain any number of periods ('.'). @file{bottomLevel}
and @file{pptInfo} may not contain any periods. The string ":::" may only
appear once.

@file{topLevel} and @file{pptInfo} are required (i.e., they must be non-empty),
as are the period to the right of @file{topLevel} and the colons to the
left of @file{pptInfo}. However, @file{bottomLevel} is optional. For
example, the Java instrumenter creates an artificial object program point
which contains invariants that are true for all of an object's methods,
rather than for just one method:

@example
  StackAr.:::OBJECT
@end example


@node    Data trace files, Examples, Declaration files, File formats
@section Data trace files


The format of the value information is:
@example
  program-point-name
  varname1
  var-value-1
  var-modified-1
  varname2
  var-value-2
  var-modified-2
  ...
@end example

Value information includes:
@itemize @bullet
@item name of the program point
@item for each variable:
@itemize @bullet
@item name
@item value
@itemize @bullet
@item    integer: sequence of digits, optionally preceded by a minus sign
@item    string: characters surrounded by double-quotes; internal
double-quotes and backslashes are escaped by a backslash; newlines and
carriage returns are represented as "\n" and "\r", respectively
@item    array: elements are listed on one line, separated by spaces.
The entire array contents are in square brackets.  (Also, the array name
should end in "[]"; use "a[]" for array contents, but "a" for the identity
of the array itself.)
@end itemize
@item modified? (0 or 1).
This value is 0 if the variable has not been assigned to since the
last time this program point was executed, and 1 if the variable has
been assigned to since then.  It is safe for an implementation to
always set it to 1.  It is also safe to always set it to 0, as daikon
fixes up the modbits.

@c if the
@c modbit-munge.pl script is run on the resulting @file{.dtrace} file to fix up
@c the modbits.
@end itemize
The variables should appear in the same order as they did in the
declaration of the program point, without omissions or additions.
@end itemize

As a special case, the first variable in a record may be
"this_invocation_nonce", in which case there is no modification
information, only a value.  The nonce is used to match up procedure entries
(whose names end with ":::ENTER") with procedure exits (whose names end
with ":::EXIT"); this is necessary in concurrent systems because there may
be several invocations of a procedure active at once and they do not
necessarily follow a stack discipline, being exited in the reverse order of
entry.  For non-concurrent systems, this nonce is not necessary and may be
omitted.


@node    Examples,  , Data trace files, File formats
@section Examples


Here are two files, p180-15.1.1.decls and (part of) p180-15.1.1.dtrace, for
a program which sums the values in an integer array.

@menu
* Example declaration file::    
* Example data trace file::     
@end menu

@node    Example declaration file, Example data trace file, Examples, Examples
@subsection Example declaration file

This is part of the file @file{StackAr.decls}, a declaration file for
the @file{StackAr.java} program (@pxref{Example use of Daikon}).

@example
DECLARE
StackAr.push(Ljava/lang/Object;)V:::ENTER
x
Object
int
1
x.class
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr.push(Ljava/lang/Object;)V:::EXIT96
x
Object
int
1
x.class
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr:::OBJECT
this.theArray
Object[]
int
-2
this.theArray.class
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].class
Class[]
String[]
-1
this.topOfStack
int
int
0
@end example


@node    Example data trace file,  , Example declaration file, Examples
@subsection Example data trace file

This is part of file @file{StackAr.dtrace}, which you can create by
running the instrumented @file{StackAr.java} program (@pxref{Example use
of Daikon}).  This excerpt contains only the first two calls to
@code{push} and the first return from @code{push}, along with the
associated object program point records; omitted records are indicated
by ellipses.


@example
...

StackAr.push(Ljava/lang/Object;)V:::ENTER
this_invocation_nonce
55
x
1217030
1
x.class
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

...

StackAr.push(Ljava/lang/Object;)V:::EXIT96
this_invocation_nonce
55
x
1217030
1
x.class
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[1217030]
1
this.theArray[].class
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[1217030]
1
this.theArray[].class
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

...

StackAr.push(Ljava/lang/Object;)V:::ENTER
this_invocation_nonce
94
x
1482257
1
x.class
"DataStructures.StackAr"
1
this.theArray
350965
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
350965
1
this.theArray.class
"[Ljava.lang.Object;"
1
this.theArray[]
[null]
1
this.theArray[].class
[null]
1
this.topOfStack
-1
1

...
@end example



@node     Index,  , File formats, Top
@unnumbered Index

@printindex cp


@bye

