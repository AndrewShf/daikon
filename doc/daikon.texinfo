\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename daikon.info
@settitle The Daikon Invariant Detector User Manual
@c %**end of header

@c To update all the nodes and menus all at once:   C-u C-c C-u m
@c You shouldn't need to do that, though; the Makefile does it for you.

@c I can't get this to work, don't know why.  MDE 4/2001.
@c @alias directory = file

@c texi2html doesn't work if I use this macro
@c @macro daikonurl{}
@c http://pag.csail.mit.edu/daikon/
@c @end macro

@c Note about ``@table @option''.
@c Unfortunately, @option{} adds quotes in the Info and printed output
@c which is not necessary in a table.  However, @t and @code compress any
@c two adjacent hyphens to one in Info and HTML output, which is even worse.

@c Problem: with texinfo 4.0, the HTML formatting leaves the "{}" after
@c uses of the macro.  (Formatting seems fine for info, for printing, etc.)
@c So for now, I have inlined all instances of the macro.  Yuck.
@c Another solution would be to use "makeinfo -E" (then process the
@c resulting file with "makeinfo --html").
@macro daikonemail{}
@email{daikon-developers@@lists.csail.mit.edu}
@end macro

@c @setchapternewpage odd

@c @ifinfo
@c @c This text appears only in the Info Version.
@c 
@c Copyright 1998-2005
@c @end ifinfo

@c Avoid black boxes marking overfull hboxes in TeX output.
@finalout

@titlepage
@sp 10
@c Could also use @title, @subtitle, @author here.
@center @titlefont{Daikon Invariant Detector User Manual}

@sp 2
@center Daikon version 4.1.7

@sp 1
@c Daikon version 4.1.7 date
@center November 1, 2005

@sp 5
@c reads daikon-logo.{eps,pdf} (not .txt, .png, or .jpg, because info
@c and HTML don't get the title page)
@image{images/daikon-logo,4in,}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998-2005
@c Copyright @copyright{} 1998-2001 Michael Ernst
@end titlepage

@html
<img src="images/daikon-logo.gif" alt="Daikon logo">
@end html
@c Why is this here?  It duplicates the stuff further down.
@c @html
@c <h1>Daikon Invariant Detector User Manual</h1>
@c
@c This is the user manual for the Daikon invariant detector.
@c It describes Daikon version 4.1.7, released November 1, 2005.
@c @end html

@c Putting this lower in the HTML version looks a little bit strange,
@c but it's acceptable. 
@ifnothtml
@contents
@end ifnothtml

@node    Top, Introduction, (dir), (dir)
@comment node-name, next,          previous, up

@ifnottex
@c Unfortunately, the Daikon logo doesn't look good in ASCII.
@c @ifinfo
@c @image{images/daikon-logo,4in,}
@c 
@c @end ifinfo
This is the user manual for the Daikon invariant detector.
It describes Daikon version 4.1.7, released November 1, 2005.
@end ifnottex

@menu
* Introduction::                
* Installing Daikon::           
* Example usage::               
* Running Daikon::              
* Daikon output::               
* Enhancing Daikon output::     
* Front ends::                  
* Tools::                       
* Troubleshooting::             
* Details::                     
* File formats::                
* Index::

@ifhtml
@contents
@end ifhtml
@ifnothtml

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Mailing lists::               

Installing Daikon

* Minimal installation::        
* Complete installation::       

Complete installation instructions

* Requirements::                
* Installation steps::          
* Windows installation notes::  
* Cygwin installation notes::   

Requirements for running Daikon

* Optional requirements::       

Example usage for Java, C/C++, and Perl

* Detecting invariants in Java programs::  
* Detecting invariants in C/C++ programs::  
* Detecting invariants in Perl programs::  

Detecting invariants in Java programs

* StackAr example::             
* Understanding the invariants::  

Understanding the invariants

* Second Java example::         

Detecting invariants in C/C++ programs

* C examples::                  
* Dealing with large examples::  

Detecting invariants in Perl programs

* Instrumenting Perl programs::  
* Perl examples::               

Running Daikon

* Options to control Daikon output::  
* Options to control invariant detection::  
* Processing only part of the trace file::  
* Daikon configuration options::  
* Daikon debugging options::    

Daikon output

* Invariant syntax::            
* Program points::              
* Variable names::              
* Interpreting output::         
* Invariant list::              
* Invariant filters::           

Variable names

* orig variable example::       

Interpreting Daikon output

* Equal variables::             

Enhancing Daikon output

* Configuration options::       
* Conditional invariants::      
* Enhancing conditional invariant detection::  
* Loop invariants::             

Configuration options

* List of configuration options::  

Conditional invariants and implications

* Splitter info file::          
* Indiscriminate splitting::    
* Example splitter info file::  

Splitter info file

* Program point sections::      
* Replacement sections::        

Example splitter info file

* Example class::               
* Resulting .spinfo file::      

Enhancing conditional invariant detection

* Static analysis for splitters::  
* Cluster analysis for splitters::  
* Random selection for splitters::  

Front ends

* Chicory::                     
* Kvasir::                      
* Mangel-Wurzel::               
* dfepl::                       
* convertcsv.pl::               
* Other front ends::            

Java front end Chicory

* Chicory options::             

Chicory options

* Program points in Chicory output::  
* Variables in Chicory output::  
* Chicory miscellaneous options::  

C front end Kvasir

* Using Kvasir::                
* Kvasir options::              
* DynComp dynamic comparability analysis::  
* Tracing only part of a program::  
* Pointer type disambiguation::  
* Online execution::            
* Installing Kvasir::           
* Kvasir limitations::          

Pointer type disambiguation

* Pointer type coercion::       
* Pointer type disambiguation example::  
* Using pointer type disambiguation with partial program tracing::  

Source-based C/C++ front end Mangel-Wurzel

* Using Mangel-Wurzel::         
* Mangel options::              
* Pointer/array disambiguation in Mangel-Wurzel::  
* Mangel-Wurzel usage notes::   
* Interaction with Purify::     
* Installing Mangel-Wurzel::    

Mangel options

* Standard compiler options for Mangel::  
* Mangel configuration options::  
* Mangel annotation options::   
* Options files for Mangel::    

Perl front end dfepl

* dfepl options::               

Tools for use with Daikon

* Tools for manipulating invariants::  
* DtraceDiff utility::          

Tools for manipulating invariants

* Printing invariants::         
* Invariant Diff::              
* Annotate::                    
* Runtime-check instrumenter::  
* InvariantChecker::            
* LogicalCompare::              

Invariant Diff

* Annotate::                    
* Runtime-check instrumenter::  
* InvariantChecker::            
* LogicalCompare::              

Runtime-check instrumenter (runtimechecker)

* Accessing violations::        

Troubleshooting

* Daikon problems::             
* Large dtrace files::          
* Parsing Java 5.0 code::       
* Chicory problems::            
* Reporting bugs::              
* Known bugs::                  
* Further reading::             

Problems running Daikon

* Too much output::             
* No samples::                  
* No return from procedure::    
* Unsupported class version::   
* Out of memory::               
* Simplify errors::             
* Contradictory invariants::    
* Method needs to be implemented::  
* Daikon runs slowly::          

Large data trace (.dtrace) files

* Reducing program points::     
* Reducing variables::          
* Reducing executions::         

Problems with Chicory

* VerifyError constant pool index error::  

Details

* History::                     
* License::                     
* Mailing lists reminder::      
* Credits::                     
* Citing Daikon::               

File formats

* Conventions::                 
* Declarations::                
* Data trace records::          
* Example files::               

Declarations

* Program point declarations::  
* pptname format::              
* VarComparability declaration::  
* ListImplementors declaration::  

Example files

* Example declaration file::    
* Example data trace file::     

@end detailmenu
@end ifnothtml
@end menu

@node    Introduction, Installing Daikon, Top, Top
@chapter Introduction

@c If you edit the introduction, then re-generate daikon.html and insert
@c its ``Introduction'' section into $inv/doc/www/index.html .


@uref{http://pag.csail.mit.edu/daikon/, ,Daikon} is an implementation of
dynamic detection of likely invariants; that is, the Daikon invariant
detector reports likely program invariants.  An invariant is a property
that holds at a certain point or points in a program; these are often
seen in assert statements, documentation, and formal specifications.
Invariants can be useful in program understanding and a host of other
applications.  Examples include ``.field > abs(y)''; ``y = 2*x+3'';
``array a is sorted''; ``for all list objects lst, lst.next.prev =
lst''; ``for all treenode objects n, n.left.value < n.right.value''; ``p
!= null => p.content in myArray''; and many more.  You can extend Daikon
to add newproperties (@pxref{Enhancing Daikon output}).

Dynamic invariant detection runs a program, observes the values that the
program computes, and then reports properties that were true over the
observed executions.  
@c Daikon's output, which is sometimes called an ``operational abstraction'',
@c looks like a formal specification, or the contents of assert statements.
Daikon can detect properties in C, C++, Java,
Perl, and IOA programs;
@c not very helpful: @uref{http://theory.csail.mit.edu/tds/ioa/, ,IOA}
in spreadsheet files; and in other data sources.  (Dynamic invariant
detection is a machine learning technique that can be applied to
arbitrary data.)  It is easy to extend Daikon to other applications; as
one example, an interface exists to the Java PathFinder model checker.
@c Removed this because it was the biggest link on the page, which is
@c not the desired effect:  @uref{http://ase.arc.nasa.gov/visser/jpf/, , }

Daikon is freely available for download from
@uref{http://pag.csail.mit.edu/daikon/download/}.  The distribution
includes both source code and
@uref{http://pag.csail.mit.edu/daikon/download/doc/, ,documentation},
and Daikon's license permits unrestricted use (@pxref{License}).  Many
researchers and practitioners have used Daikon; those uses, and Daikon
itself, are described in various
@uref{http://pag.csail.mit.edu/daikon/pubs/, ,publications}.

More information on Daikon can be found in the Daikon Developer
Manual.  For instance, the Daikon Developer Manual indicates how to
extend Daikon with new invariants, new derived variables, and front
ends for new languages.  It also contains information about the
implementation and about debugging flags.

@menu
* Mailing lists::               
@end menu

@node    Mailing lists,  , Introduction, Introduction
@section Mailing lists
@cindex mailing lists
@cindex daikon-announce mailing list
@cindex daikon-discuss mailing list
@cindex daikon-developers mailing list

The following mailing lists (and their archives) are available:
@table @samp
@item daikon-announce@@lists.csail.mit.edu
A low-volume, announcement-only list.  For example,
announcements of new releases are sent to this list.
To subscribe, visit
@uref{http://lists.csail.mit.edu/mailman/listinfo/daikon-announce}.
@item daikon-discuss@@lists.csail.mit.edu
A moderated list for the community of Daikon users.  Use it to share
tips and successes, and to get help with questions or problems (after
checking the documentation).  To subscribe, visit
@uref{http://lists.csail.mit.edu/mailman/listinfo/daikon-discuss}.
@item daikon-developers@@lists.csail.mit.edu
This list goes to the Daikon maintainers.  Use it for bug reports,
suggestions, and the like.  If you are an active contributor to Daikon,
you may send mail to the list asking to be added.
@end table


@node    Installing Daikon, Example usage, Introduction, Top
@chapter Installing Daikon
@cindex installing Daikon

Shortcut for the impatient:  skip directly to @ref{Installation steps}.

This section describes two ways to install Daikon.  The first gives a
minimal installation that is adequate for the needs of most users.
The second gives a complete installation that some users may prefer.

Use the minimal installation instructions if you only wish to detect
invariants in Java programs.  Use the complete installation instructions
(which are easy to follow) if you wish to detect invariants in C or Perl
programs, or if you wish to edit the source code of Daikon itself.

Differences between various versions of Daikon appear
in the file @file{doc/CHANGES} in the distribution.  
You may wish to subscribe to one of the mailing lists
(@pxref{Mailing lists}), in order to be notified of new releases or join
discussions with other Daikon users and developers.


@menu
* Minimal installation::        
* Complete installation::       
@end menu

@node    Minimal installation, Complete installation, Installing Daikon, Installing Daikon
@section Minimal installation instructions

Daikon is written in Java.  In order to run Daikon, all you really need
is the @file{daikon.jar} file, which is included in the distribution or
can be downloaded separately from
@uref{http://pag.csail.mit.edu/daikon/download/daikon.jar}.  Place
@file{daikon.jar} on your classpath so that Java can find it.  You are
now ready to use Daikon!

Here are a few additional details.  You must have a Java 5.0 (or later)
JVM (@uref{http://java.sun.com,, Java Virtual Machine}).  The
@file{tools.jar} file that comes with your JVM must also be on your
classpath.


@node    Complete installation,  , Minimal installation, Installing Daikon
@section Complete installation instructions

This section gives step-by-step instructions for installing Daikon.
The instructions in @ref{Installation steps} are targeted for
Unix users.  If you use another operating system such as Windows, you
may need to adjust the instructions, for example to change the shell
quoting conventions.  (Contributions to this manual
for other operating systems are welcome.)

@menu
* Requirements::                
* Installation steps::          
* Windows installation notes::  
* Cygwin installation notes::   
@end menu


@node    Requirements, Installation steps, Complete installation, Complete installation
@subsection Requirements for running Daikon

In order to run Daikon, you must have a Java 5.0 (or later) JVM
(@uref{http://java.sun.com,, Java Virtual Machine}).

@menu
* Optional requirements::       
@end menu

@node    Optional requirements,  , Requirements, Requirements
@subsubsection Optional requirements for running Daikon

All the remaining requirements listed here are optional (they enable you
to perform certain additional tasks with Daikon).

If you plan to use one of Daikon's source-based front ends, such as
Mangel-Wurzel (@pxref{Mangel-Wurzel}), then you need a compiler
for whatever language your target programs are written in.  For
instance, if you wish to analyze C or C++ programs, you need a C or C++
compiler such as GCC.  Source code and a compiler are not necessary if
you plan to use one of Daikon's front ends that work on binaries, such
as Chicory (@pxref{Chicory}) and Kvasir (@pxref{Kvasir}).

If you wish to edit the Daikon source code and re-compile Daikon, will
need a Java compiler (such as javac) and a C preprocessor (cpp).  If you
have a C compiler, you almost certainly have cpp.  For more details, see
@ref{Compiling Daikon,,,./developer,Daikon Developer Manual}.


@node  Installation steps, Windows installation notes, Requirements, Complete installation
@subsection Installation steps

@enumerate
@item
In the directory where you want to install Daikon (we'll call this
the @var{daikonparent} directory), 
download and unpack Daikon.  Daikon is available as a zip file from
@uref{http://pag.csail.mit.edu/daikon/download/daikon.zip} or
as a tar file from
@uref{http://pag.csail.mit.edu/daikon/download/daikon.tar.gz}.
The two files contain the same information; you only need one of them.
Windows users typically opt for the zip file.

@itemize
@item Windows:  Download the
@uref{http://pag.csail.mit.edu/daikon/download/daikon.zip, zip file}
extract it into, say, @file{C:\}.  This creates a directory
@file{C:\daikon} containing the Daikon distribution.

@item Unix:  use one of the following sets of commands:
@example
cd @var{daikonparent}
wget http://pag.csail.mit.edu/daikon/download/daikon.tar.gz
tar zxf daikon.tar.gz
@end example
@noindent
or
@example
cd @var{daikonparent}
wget http://pag.csail.mit.edu/daikon/download/daikon.zip
unzip daikon.zip
@end example
@noindent
This creates a @file{@var{daikonparent}/daikon/} subdirectory.
@end itemize

@item
Set up your environment.  You need to arrange for @file{daikon.jar} to
be on your Java classpath.  One easy way to do this is to make your
shell initialization file set the @env{DAIKONPARENT} environment variable (to
an absolute pathname) and source the appropriate Daikon environment
file.  (Alternately, you could set your classpath yourself.)
@itemize 
@item
@cindex C shell
@cindex csh shell
@cindex tcsh shell
If you use the csh or tcsh shell, add the
following to your @file{.cshrc} file:
@example
setenv DAIKONPARENT @var{daikonparent}
source $DAIKONPARENT/daikon/bin/daikon.cshrc
@end example
@noindent
@item
@cindex Bourne shell
@cindex bash shell
If you use the bash shell, add the following to your
@file{.bash_profile} file:
@example
export DAIKONPARENT=@var{daikonparent}
source $DAIKONPARENT/daikon/bin/daikon.bashrc
@end example
@item
If you use Windows, add commands similar to the following to your
startup file (typically @file{C:\AUTOEXEC.BAT}):
@example
set DAIKONPARENT=C:\
set JDKDIR=C:\Program Files\Java\jdk1.5.0_05
%DAIKONPARENT%\daikon\bin\daikonenv.bat
@end example
@end itemize
@noindent

After editing your shell initialization file, either execute the commands
you placed in it, or else log out and log back in to achieve the same
effect.

You can examine the appropriate Daikon environment file to learn of
other variables you can customize.

@item
Optionally, build various executables used by Daikon, such as the
C front end Kvasir (@pxref{Installing Kvasir}).
Optionally, download other executables, such as the source-based C front
end Mangel-Wurzel (@pxref{Installing Mangel-Wurzel}).

@end enumerate


@node    Windows installation notes, Cygwin installation notes, Installation steps, Complete installation
@subsection Windows installation notes

@cindex Windows
@cindex Microsoft Windows

If you are running Daikon under Microsoft Windows, you have two
options:  using native Windows utilities, or using the Cygwin
environment.

Daikon and most of its related programs, such as Chicory, run under
Windows as command-line applications.  You should invoke them from a
command shell --- either an Windows command shell or a Cygwin command
shell --- rather than by double-clicking their icons.  In any event,
double-clicking would not supply the proper arguments to the program.

The first option is to run Daikon using native Windows utilities.
Before running Daikon, you must invoke the @file{daikonenv.bat} batch
file (once) in the Windows command shell to set up the environment
properly.  To automatically run something (such as a batch file) every
time the Windows command shell is started, set the value of this
registry key to the program you want to run:
@example
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\AutoRun
@end example
@noindent

@c This feels quite irrelevant; omit?
You may also wish to set two registry entries to enable automatic completion:
@example
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\CompletionChar
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\PathCompletionChar
@end example
@noindent
The values for these registry entries are ASCII key codes.  Tab is 9.


@node    Cygwin installation notes,  , Windows installation notes, Complete installation
@subsection Cygwin installation notes

@cindex Cygwin toolset

The second option for Windows is to run Daikon using the Cygwin
toolset (available at @uref{http://sources.redhat.com/cygwin/}), which
contains everything you need to compile and run Unix programs under
Windows.  You can install Cygwin by simply running the program found
at @uref{http://sources.redhat.com/cygwin/setup.exe}.  

There is an incompatibility between Cygwin and programs compiled for
Windows.  (The incompatibility does not exist if the program was
compiled for Cygwin.)  The incompatibility is that Windows programs
use the semicolon (@samp{;}) as their path separator (for instance,
for @env{CLASSPATH}), but Unix and Cygwin programs use the colon (@samp{:})
as their path separator.

The @file{cygwin-runner.pl} script in the @file{bin/} directory may
help you run windows-native Java tools from within the Cygwin
environment.  It translates Unix @samp{:}-separated pathlists to
Windows @samp{;}-separated pathlists, changes filenames to their 8.3
``old style'' name (e.g., @file{My Documents} to @file{MYDOCU~1}),
changes forward slashes to backslashes, and translates paths with
Cygwin mount points to simple @file{C:\}-like paths.

For now, @file{cygwin-runner.pl} doesn't touch environment variables,
but you can still use it for classpath by getting your classpath onto
the command line explicitly:
@example
$ dfej -classpath $CLASSPATH DataStructures/StackAr.java
@end example
(It would be nice to patch cygwin-runner to translate environment
variables, too.  For example, always translate @env{CLASSPATH}, or
always translate anything listed in @env{CYGWIN_RUNNER_ENV} (e.g.,
@samp{CYGWIN_RUNNER_ENV="PATH:CLASSPATH:PWD"}) so users can set
@env{CYGWIN_RUNNER_ENV} in their dotfiles or various wrappers.)


@node    Example usage, Running Daikon, Installing Daikon, Top
@chapter Example usage for Java, C/C++, and Perl

Detecting invariants involves two steps:
@enumerate
@item
Obtain a data trace file by running your program under the control of a
front end (also known as an instrumenter) that records information about
variable values.  You can run your program over an input of your own
choosing, such as regression tests or a typical user input session.
Often, you will choose to obtain trace data for only a certain part of
your program; this can improve performance and avoid inundating you with
output.

@item
Run the Daikon invariant detector over the data trace files
(@pxref{Running Daikon}).  This detects invariants in the recorded
information.  You can view the invariants textually, or process them
with an additional program.
@end enumerate
@noindent
Often, you can run a single command that performs both steps.

This section briefly describes how to obtain data traces for Java, C,
and Perl programs, and how to run Daikon.  For detailed information about
these and other front ends that are available for Daikon, @ref{Front ends}.

@menu
* Detecting invariants in Java programs::  
* Detecting invariants in C/C++ programs::  
* Detecting invariants in Perl programs::  
@end menu

@node    Detecting invariants in Java programs, Detecting invariants in C/C++ programs, Example usage, Example usage
@section Detecting invariants in Java programs

In order to detect invariants in a Java program, run the
program using the Chicory front end to create a data trace file, then
run Daikon itself to detect invariants.
With the @option{--daikon} option to Chicory, a single command performs
both steps.

For example, if you usually run
@example
java mypackage.MyClass arg1 arg2 arg3
@end example
@noindent
@noindent
then instead you would run
@example
java daikon.Chicory --daikon mypackage.MyClass arg1 arg2 arg3
@end example


@menu
* StackAr example::             
* Understanding the invariants::  
@end menu

@c Commented out as of summer 2005, because David Cok doesn't seem likely
@c to pick this up again, and we don't want to lead users astray or
@c discourage them with non-functional software.
@c @node    Eclipse plug-in, StackAr example, Detecting invariants in Java programs, Detecting invariants in Java programs
@c @subsection Eclipse plug-in
@c @cindex Eclipse plug-in
@c @cindex GUI, Eclipse
@c 
@c Daikon is integrated with the 
@c @uref{http://eclipse.org/, ,
@c Eclipse} IDE (Integrated Development Environment) for Java.
@c The Daikon plug-in provides a convenient way to instrument files,
@c obtain trace information, analyze those traces,
@c and create appropriately annotated Java source code.
@c For
@c details, see the @uref{daikonHelp.html, , Daikon Eclipse plug-in
@c documentation}.
@c 
@c As of this writing (February 11, 2005), the plug-in only works with 
@c Daikon 3 (for instance, version 3.1.7), not with Daikon 4.  Support for
@c Daikon 4 is underway.
@c 
@c For brief troubleshooting information, see @ref{Eclipse plug-in problems}.


@node    StackAr example, Understanding the invariants, Detecting invariants in Java programs, Detecting invariants in Java programs
@subsection StackAr example

The Daikon distribution contains some sample programs that will help
you get practice in running Daikon.

To detect invariants in the StackAr sample program, perform the following steps.

@enumerate
@item
Compile the program with the @option{-g} switch to enable debugging
symbols.  (The program and test suite appear in the
@file{DataStructures} subdirectory directory.)
@example
cd examples/StackAr
javac -g DataStructures/*.java
@end example

@item Run the program under the control of the Chicory front end, in
order to create a @file{StackArTester.dtrace.gz} file.

@example
java daikon.Chicory DataStructures.StackArTester
@end example

@item Run Daikon on the trace file.

@example
java daikon.Daikon StackArTester.dtrace.gz
@end example

Alternately, you can combine this step and the previous one into a
single command:
@example
java daikon.Chicory --daikon DataStructures.StackArTester
@end example

In either case, the invariants are printed to standard output, and a binary
representation of the invariants is written to @file{StackAr.inv.gz}.


@item Examine the invariants.

There are various ways to do this.
@itemize @bullet
@item Examine the output from running Daikon.  (You may find it
convenient to capture the output in a file; add @samp{> StackAr.txt}
to the end of the command that runs Daikon.)

@item Use the PrintInvariants program to display the invariants.

@example
java daikon.PrintInvariants StackAr.inv.gz
@end example

For more options to the PrintInvariants program, see @ref{Printing
invariants}.

@item Use the Annotate program to insert the invariants as comments
into the Java source program.

@example
cd ..
java daikon.tools.jtb.Annotate daikon-output/StackAr.inv.gz \
     DataStructures/StackAr.java
@end example

Now examine file @file{DataStructures/StackAr.java-escannotated}.
For more information about the Annotate program, see @ref{Annotate}.

@c @item Use the Daikon Tree GUI to browse the invariants.  The Tree GUI
@c contains a tree that hierarchically organizes program points according
@c to their class and method.  Using the GUI, you can look at invariants
@c for only the methods and program points you care about.
@c 
@c @example
@c java daikon.gui.treeGUI.InvariantsGUI StackAr.inv.gz
@c @end example

@c @item Use the Daikon Context GUI to browse the invariants.  As you move
@c the cursor in an editor window, the Context GUI displays the invariants
@c applicable to the current location (class or method).  For details on
@c running the Context GUI, see @ref{Context GUI}.  

@end itemize
@end enumerate


@node    Understanding the invariants,  , StackAr example, Detecting invariants in Java programs
@subsection Understanding the invariants

This section examines some of the invariants for the StackAr example.
For more help interpreting invariants, see @ref{Interpreting output}.

The StackAr example is an array-based stack implementation.  Take a
look at @file{DataStructures/StackAr.java} to get a sense of the
implementation.  Now, look at the first section of Daikon output.

@c   In
@c the Tree GUI, expand the node labeled @command{StackAr}, then select the
@c node labeled @command{StackAr:Object}.
@c 
@c @emph{(Note: The invariants displayed in the Tree GUI may be different than the
@c invariants written to standard out by Daikon.  This is because the
@c invariants are being filtered differently.  We are currently working
@c to resolve this issue.)}

@example
======================================================================
StackAr:::OBJECT
this.theArray != null
this.theArray.getClass() == java.lang.Object[].class
this.topOfStack >= -1
this.theArray[this.topOfStack+1..] elements == null
this.theArray[0..this.topOfStack] elements != null
this.topOfStack <= size(this.theArray[])-1
======================================================================
@end example

These six annotations describe the representation invariant.  The
array is never null, and its runtime type is @code{Object[]}.  The
@code{topOfStack} index is at least -1 and is less than the length
of the array.  Finally, the elements of the array are non-null if
their index is no more than @code{topOfStack} and are null
otherwise.

Next, look at the invariants for the @code{top()} method.
@c In
@c the Tree GUI, expand the node labeled @command{top()Ljava/lang/Object;}.
@code{top()} has two different exit points, at lines 78 and 79
in the original source.  There is a set of invariants for each exit
point, as well as a set of invariants that hold for all exit points.
Look at the invariants when @code{top()} returns at line 79.
@c In the Tree GUI, select the node labeled @command{EXIT79}.

@example
======================================================================
StackAr.top():::EXIT79
return == this.theArray[this.topOfStack]
this.theArray == orig(this.theArray)
this.theArray[] == orig(this.theArray[])
this.topOfStack == orig(this.topOfStack)
return != null
this.topOfStack >= 0
this.theArray[this.topOfStack+1..] elements == this.theArray[-1]
======================================================================
@end example

The return value is never null, and is equal to the array element at
index @code{topOfStack}.  The top of the stack is at least 0.  The
array, the elements of the array, and @code{topOfStack} are not
modified by this method --- this method is an ``observer''.  The
last invariant is not particularly interesting.


@menu
* Second Java example::         
@end menu

@node    Second Java example,  , Understanding the invariants, Understanding the invariants
@subsubsection A second Java example

A second example is located in the @file{examples/QueueAr} subdirectory.
Run this sample using the following steps:

@itemize @bullet
@item Compile
@example
cd examples/QueueAr
javac -g DataStructures/*.java
@end example

@item Trace file generation
@example
java daikon.Chicory DataStructures.QueueArTester
@end example

@item Invariant detection
@example
java daikon.Daikon QueueArTester.dtrace.gz
@end example

@end itemize



@node    Detecting invariants in C/C++ programs, Detecting invariants in Perl programs, Detecting invariants in Java programs, Example usage
@section Detecting invariants in C/C++ programs

In order to detect invariants over C or C++ programs, you must first install
a C/C++ front end.  You can choose Kvasir (@pxref{Installing Kvasir}) or
Mangel-Wurzel (@pxref{Mangel-Wurzel}).  This section gives examples
using Kvasir.

To use the C front end Kvasir with your program, first make sure that
your program has been compiled with DWARF-2 format debugging
information, such as by giving the @option{-gdwarf-2} flag to GCC when
compiling.  Then, run your program as usual, but prepend
@command{kvasir-dtrace} to the command line.

For more information about Kvasir, including more detailed
documentation on its command-line options, see @ref{Kvasir}.


@menu
* C examples::                  
* Dealing with large examples::  
@end menu

@node    C examples, Dealing with large examples, Detecting invariants in C/C++ programs, Detecting invariants in C/C++ programs
@subsection C examples

The Daikon distribution comes with several example C programs in the
@file{examples/kvasir-examples} directory to enable users to become
familiar with running Daikon on C programs.

@c There are two sets of examples, corresponding to the two supplied C
@c front ends.  Examples intended for use with the binary-based front end
@c Kvasir are in a subdirectory @file{kvasir-examples}; examples for the
@c older source-based front end dfec are in a subdirectory
@c @file{dfec-examples}.  It should be possible to instrument the dfec
@c examples with Kvasir, though we will not give directions here.
@c Instrumenting the Kvasir examples with dfec is not recommended (and is
@c not likely to work).


To detect invariants for a program with Kvasir, you need to perform
two basic tasks:  run the program under Kvasir to create a data trace
file (steps 1--2), and run
Daikon over the data trace file to produce invariants (steps 3--4).
The following instructions are for the wordplay example, which is a
program for finding anagrams.

@enumerate
@item Change to the directory containing the program.
@example
cd $DAIKONDIR/examples/kvasir-examples/wordplay
@end example

@item Compile the program with DWARF-2 debugging information enabled
(and all optimizations disabled).
@example
gcc -gdwarf-2 wordplay.c -o wordplay
@end example

Kvasir can also be used for programs constructed by compiling a number
of @file{.c} files separately, and then linking them together; in such
a program, specify @option{-gdwarf-2} when compiling each source file
containing code you wish to see invariants about.

@item Run the program just as you normally would, but prepend
@command{kvasir-dtrace} to the command line.
@example
kvasir-dtrace ./wordplay -f words.txt 'daikon dynamic invariant detector'
@end example

Any options to the program can be specified as usual; here, for
instance, we give commands to look for anagrams of the phrase ``Daikon
Dynamic Invariant Detector'' using words from the file @file{words.txt}.

Executing under Kvasir, the program runs normally, but Kvasir
executes additional checks and collects trace information (for this
reason, the program will run more slowly than usual).  Kvasir creates a
directory named @file{daikon-output} under the current directory, and
creates the @file{wordplay.dtrace} file, which lists both variable
declarations and values.

Kvasir will also print messages if it observes your program doing
something with undefined effects; these may indicate bugs in your
program, or they may be spurious.  (If they are bugs, they can also be
tracked down by using Valgrind (@uref{http://www.valgrind.org/})
with its regular memory checking
tool; if they do not appear with that tool, they are probably
spurious).

@item Run Daikon on the trace file.
@example
java daikon.Daikon \
     --config_option daikon.Daikon.disable_derived_variables=true \
     daikon-output/wordplay.dtrace
@end example

The invariants are printed to standard output, and a binary representation
of the invariants is written to @file{wordplay.inv.gz}.  Note that the
example uses a configuration option to disable the use of derived
variables; it can also run without that option, but takes significantly
longer.

@item Examine the invariants.  As described in @xref{StackAr example},
there are several ways to do this:
@itemize 
@item Examine the output from running Daikon.
@item Use the PrintInvariants program to display the invariants.
@c @item Use the Daikon Tree GUI to browse the invariants.  (Deprecated.)
@end itemize
@noindent
For help understanding the invariants, see @ref{Interpreting output}.

@end enumerate


@node    Dealing with large examples,  , C examples, Detecting invariants in C/C++ programs
@subsection Dealing with large examples

Since the default memory size used by Java virtual machines varies, we
suggest that Daikon be run with at least 256 megabytes of
memory (and perhaps much more), specified for many JVMs by the option @option{-Xmx256m}.
(The schedule example uses even more space: we suggest specifying
@option{-Xmx768m}, and avoiding the example altogether unless your
workstation has at least a gigabyte of physical memory.)  For more
information about specifying the memory usage for Daikon, see
@ref{Out of memory}.

Disk usage can be reduced by specifying that the front end should
compress its output dtrace files.
@c ; see @ref{dfec runtime customization}.

In some cases, the time and space requirements of the examples can be
reduced by reducing the length of the program run.  For instance, when
the test.sh script contains many invocations of the program, some can
be commented out.  The Rijndael example includes preprocessor
definitions at the top of the @file{rijndaeltest-ref.c} that control
how many iterations are performed.  However, Daikon's running time
depends on both the length of the test run and the size of the program
(especially in its use of global variables and nested data
structures).  For more techniques for using Daikon with large programs
and long program runs, see @ref{Large dtrace files}.




@node    Detecting invariants in Perl programs,  , Detecting invariants in C/C++ programs, Example usage
@section Detecting invariants in Perl programs

The Daikon front end for Perl is called dfepl.

Using the Perl front end is a two-pass
process: first you must run the annotated program so that the runtime
system can dynamically infer the kind of data stored in each variable,
and then you must re-annotate and re-run the program with the added
type information.
This is necessary because Perl programs do not contain type declarations. 

dfepl requires version 5.8 or later of Perl.

@menu
* Instrumenting Perl programs::  
* Perl examples::               
@end menu


@node Instrumenting Perl programs, Perl examples, Detecting invariants in Perl programs, Detecting invariants in Perl programs
@subsection Instrumenting Perl programs

Perl programs must be instrumented twice.  First they must be
instrumented without type information.  Then, once the first
instrumented version has been run to produce type information, they
must be instrumented again taking the type information into account.

To instrument a stand-alone Perl program, invoke dfepl with
the name of the program as an argument.

@example
dfepl program.pl
@end example

To instrument a Perl module or a collection of modules, invoke
dfepl either with the name of each module, or with the name
of a directory containing the modules.  To instrument all the modules
in the current directory, give dfepl the argument @file{.}.
For instance, if the current directory contains a module
@code{Acme::Trampoline} in @file{Acme/Trampoline.pm} and another
module @code{Acme::Date} in @file{Acme/Date.pm}, they can be annotated
by either of the following two commands:

@example
dfepl Acme/Trampoline.pm Acme/Date.pm
dfepl .
@end example

Once type information is available, run the instrumentation command
again with the @option{-T} or @option{-t} options added to use the
produced type information.

For more information about dfepl, see @ref{dfepl}.


@node Perl examples,  , Instrumenting Perl programs, Detecting invariants in Perl programs
@subsection Perl examples

The Daikon distribution includes sample Perl programs suitable for use
with Daikon in the @file{examples/perl-examples} directory.

Here are step-by-step instructions for examining a simple module,
@file{Birthday.pm}, as used by a test script @file{test-bday.pl}.

@enumerate
@item Change to the directory containing the @file{Birthday.pm}
module.
@example
cd examples/perl-examples
@end example

@item Instrument the @file{Birthday.pm} file.
@example
dfepl Birthday.pm
@end example

This command creates a directory @file{daikon-untyped}, and puts
the instrumented version of @file{Birthday.pm} into
@file{daikon-untyped/Birthday.pm}.  As the directory name implies, this
instrumented version doesn't contain type information.

@item Run a test suite using the instrumented @file{Birthday.pm}
file.
@example
dtype-perl test_bday.pl 10
@end example

The @file{dtype-perl} is a script that runs Perl with the appropriate
command line options to find the modules used by the Daikon Perl
runtime tracing modules, and to use the instrumented versions of
modules in @file{daikon-untyped} in preference to their original
ones.  The number 10 is an argument to the @file{test_bday.pl} script
telling it to run a relatively short test.

This will also generate a file
@file{daikon-instrumented/Birthday.types} recording the type of each
variable seen during the execution of the instrumented program.

@item Re-annotate the module using the type information.
@example
dfepl -T Birthday.pm
@end example

This step repeats step 2, except that the @option{-T} flag to
dfepl tells it to use the type information generated in the
previous step, and to put the output in the directory
@file{daikon-instrumented}.  dfepl also converts the
type information into a file @file{daikon-output/Birthday.decls}
containing subroutine declarations suitable for Daikon.

@item Run the full test suite with the type-instrumented
@file{Birthday.pm}.
@example
dtrace-perl test_bday.pl 30
@end example

Here we run another test suite, which happens to be the same
@file{test_bday.pl}, but running for longer. (The example will also
work with a smaller number).  The script @command{dtrace-perl} is
similar to @command{dtype-perl} mentioned earlier, but looks for
instrumented source files in @file{daikon-instrumented}.

This creates @file{daikon-output/test_bday-combined.dtrace}, a trace
file containing the values of variables at each invocation. (The
filename is formed from the name of the test program, with
@file{-combined} appended because it contains the trace information
from all the instrumented modules invoked from the program).

@item Change to the @file{daikon-output} directory to analyze the
output.
@example
cd daikon-output
@end example

@item Run Daikon on the trace file
@example
java daikon.Daikon Birthday.decls test_bday-combined.dtrace
@end example

@item Examine the invariants.  They are printed to standard output, and
they are also saved to file @file{Birthday.inv.gz}, which you can
manipulate with the PrintInvariants program and other Daikon tools.
For example:
@example
java daikon.PrintInvariants Birthday.inv.gz
@end example
@c java daikon.gui.treeGUI.InvariantsGUI Birthday.inv.gz

Invariants produced from Perl programs can be examined using the same
tools as other Daikon invariants. 
@end enumerate

In the example above, the script @file{test_bday.pl} was not itself
instrumented; it was only used to test the instrumented code.  The
Perl front end can also be used to instrument stand-alone Perl
programs.  The following sequence of commands, similar to those above,
show how Daikon can be used with the stand-alone program
@file{standalone.pl}, also in the @file{examples/perl-examples}
directory.

@example
dfepl standalone.pl
dtype-perl daikon-untyped/standalone.pl
dfepl -T standalone.pl
dtrace-perl daikon-instrumented/standalone.pl
cd daikon-output
java daikon.Daikon -o standalone.inv standalone-main.decls \
     standalone-combined.dtrace
@end example

Note two differences when running a stand-alone program.  First, the
instrumented versions of the program, in the @file{daikon-untyped} or
@file{daikon-instrumented} directory, are run directly.  Second, the
declarations file is named after the package in which the subroutines
were declared, but since every stand-alone program uses the
@code{main} package, the name of the program is prepended to the
@file{.decls} file name to avoid collisions.


@node    Running Daikon, Daikon output, Example usage, Top
@chapter Running Daikon

Run the Daikon invariant detector via the command
@example
java daikon.Daikon @i{[@var{flags}]} @var{dtrace-files...} @i{[@var{decl-files...}]} @i{[@var{spinfo-files...}]}
@end example

@itemize
@item
The @var{dtrace-files} are data trace (@file{.dtrace}) files containing
variable values from an execution of the target program.

@item
The @var{decl-files} are declaration (@file{.decl}) files containing
program point declarations.  Be sure to include all declaration files
that are needed for the particular data trace file; the simplest way
is to include every declaration file created when instrumenting the
program.

Not all Daikon front ends produce @file{.decl} files, since program point
declarations may also appear in @file{.dtrace} files.  For instance, the 
Chicory front end for Java (@pxref{Chicory}) produces only @file{.dtrace}
files.  If there are no @file{.decl} files, then it is not necessary to
include them on the command line to Daikon.

@item
The @var{spinfo-files} are splitter info (@file{.spinfo}) files that
enable detection of conditional invariants (@pxref{Conditional
invariants}); these are optional and may be created automatically or by hand.

@end itemize
@noindent
The files may appear in any order;
the file type is determined by whether the file name contains
@file{.decls}, @file{.dtrace}, or @file{.spinfo}.
As a special case, a file name of @file{-} means to read data trace
information from standard input.


@cindex command line options for Daikon
@cindex flags for Daikon
The optional flags are described in the sections that follow.

@menu
* Options to control Daikon output::  
* Options to control invariant detection::  
* Processing only part of the trace file::  
* Daikon configuration options::  
* Daikon debugging options::    
@end menu


@node Options to control Daikon output, Options to control invariant detection, Running Daikon, Running Daikon
@section Options to control Daikon output

@c Unfortunately, @option{} adds quotes in the Info and printed output
@c which is not necessary in a table.  However, @t and @code compress
@c the two hyphens to one in Info and HTML output, which is even worse.
@table @option
@item --help
Print usage message.

@item -o @var{inv_file}
Output serialized invariants to the specified file; they can later be
postprocessed, compared, etc.  Default: @file{@var{basename}.inv.gz} in
the current directory, where the first data trace file's basename starts
with @file{@var{basename}.dtrace}.  Default is no serialized output, if
no such data trace file was supplied.  If a data trace file was
supplied, there is currently no way to avoid creating a serialized
invariant file.

@item --no_text_output
Don't print invariants as text output.  This option may be used in
conjunction with the @option{-o} option.

@item --format @var{name}
Produce output in the given format.  For a list of the output formats
supported by Daikon, see @ref{Invariant syntax}.

@item --show_progress
@itemx --no_show_progress
Prints (respectively, suppresses) timing information as major portions of Daikon are executed.

@item --noversion
Suppress the printing of version information

@item --output_num_samples
@cindex samples breakdown output
@cindex mux output
Output numbers of values and samples for invariants and program points;
this is a debugging flag.  (That is, it helps you understand why Daikon
produced the output that it did.)

The ``Samples breakdown'' output indicates how many samples in the
@file{.dtrace} file had a modified value (``m''), had an unmodified
value (``u''), and had a missing value (``x'').  The summary uses a
capital letter if the sample had any of the corresponding type of
variable, and a lower-case letter if it had none.  These types affect
statistical tests that determine whether a particular invariant (that
was true over all the test runs) is printed.

Only variables that appear in both the pre-state and the post-state
(variables that are in scope at both procedure exit and entry) are
eligible to be listed as modified or unmodified.  This is why the list
of all variables is not the union of the modified and unmodified
variables.

@item --files_from @var{filename}
Read a list of @file{.decl}, @file{.dtrace}, or @file{.spinfo} files from the
given text file, one filename per line, as an alternative to providing
them on the command line.

@item --omit_from_output [0rs]
Omit some potentially redundant information from the serialized output
file produced with @option{-o}.
By default, the serialized output contains all of the data structures
produced by Daikon while inferring invariants.
Depending on the use to which the serialized output will later be put,
the file can sometimes be significantly shortened by omitting
information that is no longer needed.
The flag should be followed by one or more characters each representing
a kind of structures the can be omitted.
The following characters are recognized:

@table @option
@item 0 (zero)
Omit information about program points that were declared, but for which
no samples were found in any @file{.dtrace} file.

@item r
Omit ``reflexive'' invariants, those in which a variable appears more
than once.
Usually, such invariants are not interesting, because their meaning is
duplicated by invariants with fewer variables: for instance, @code{x =
x - x} and @code{y = z + z} can be expressed as @code{x = 0} and
@code{y = 2 * z} instead.
However, Daikon generates and uses such invariants internally to
decide what invariants to create when two previously equal variables
turn out to be different.

@item s
Omit invariants that are suppressed by other invariants.
``Suppression'' refers to a particular optimization
in which the processing of an invariant is
postponed as long as certain other invariants that logically imply it
hold.
@end table

For most uses of serialized output in the current version, it is safe
to use the @option{0} and @option{r} omissions, but the @option{s} omission
will cause subtle output changes.
In many cases, the amount of space saved is modest (typically around
10%), but the savings can be more substantial for programs with many
unused program points, or program points with many variables.

@end table

@node Options to control invariant detection, Processing only part of the trace file, Options to control Daikon output, Running Daikon
@section Options to control invariant detection

@table @option
@cindex confidence limit
@item --conf_limit @var{val}
Set the confidence limit for justifying invariants, which is used to filter
invariants which are satisfied purely by chance from Daikon's output.  
@var{val} must be between 0 and 1; the default is .99 (1%).  Larger values 
yield stronger filtering.

@item --list_type @var{classname}
Indicate that the given class implements the @code{java.util.List}
interface.  The preferred mechanism for indicating such information is
the @code{ListImplementors} section of the @file{.decls} file.  
See @ref{ListImplementors declaration}.

@item --nohierarchy
@cindex hierarchy, disabling
@cindex unmatched entries, not ignoring
Avoid connecting program points in a dataflow hierarchy.  For example,
Daikon normally connects the @code{:::ENTER} program points of class methods
with the class's @code{:::CLASS} program point, so that any invariant 
that holds on the @code{:::CLASS} program point is considered to hold 
true on the @code{:::ENTER}
program point.  With no hierarchy, each program point is treated
independently.  This is for using Daikon on applications that do not
have a concept of hierarchy.  It can also be useful when you wish to
process unmatched enter point samples from a trace file that is missing
some exit point samples.

@item --suppress_redundant
Suppress display of logically redundant invariants, using the Simplify
automatic theorem prover.  Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to take advantage of this option.  Beware that the process of
detecting redundant invariants can sometimes be time-consuming; the
amount of effort Simplify exerts for each invariant can be controlled
using the @option{daikon.simplify.Session.simplify_max_iterations} and
@option{daikon.simplify.Session.simplify_timeout} configuration
options.

@end table

@node Processing only part of the trace file, Daikon configuration options, Options to control invariant detection, Running Daikon
@section Processing only part of the trace file

Using @option{--ppt-select-pattern} and @option{--ppt-omit-pattern} can
save time even if there are no samples for the excluded program points,
as Daikon can skip the declarations and need not initializing data
structures that would be used if samples were encountered.

@table @option
@item --ppt-select-pattern=@var{ppt_regexp}
Only process program points whose names match the regular expression,
which uses Perl syntax.

@item --ppt-omit-pattern=@var{ppt_regexp}
Do not process program points whose names match the regular expression,
which uses Perl syntax.  This takes priority over the
@option{--ppt-select-pattern} argument.

@item --var-select-pattern=@var{ppt_regexp}
Only process variables (whether in the trace file or derived) whose
names match the regular expression, which uses Perl syntax.

@item --var-omit-pattern=@var{var_regexp}
Ignore variables (whether in the trace file or derived) whose names
match the regular expression, which uses Perl syntax.  This takes
priority over the @option{--var-select-pattern} argument.

@end table

@node Daikon configuration options, Daikon debugging options, Processing only part of the trace file, Running Daikon
@section Daikon configuration options

@table @option
@item --config @var{filename}
Load the configuration settings specified in the given file.
@xref{Configuration options}, for details.

@item --config_option @var{name}=@var{value}
Specify a single configuration setting.
@xref{Configuration options}, for details.

@end table

@node Daikon debugging options,  , Daikon configuration options, Running Daikon
@section Daikon debugging options

@table @option
@item --dbg @var{category}
@itemx --debug
@cindex debugging flags
@cindex category, for debugging
@cindex logging, for debugging Daikon
@cindex Logger
These debugging options cause output to be written to a log file (by
default, to the terminal); in other words, they enable a Logger.
The @option{--dbg @var{category}} option
enables debugging output for a specific part of Daikon; it may be
specified multiple times, permitting find-grained control over debugging
output.  The @option{--debug} option turns on all debugging flags.
(This produces a lot of output!)  Most categories are class or
package names in the Daikon implementation, such as @code{daikon.split}
or @code{daikon.derive.binary.SequencesJoin}.  Only classes that check
the appropriate categories are affected by the debug flags; you can
determine this by looking for a call to @samp{Logger.getLogger} in
the specific class.

@item --track @var{class}<@var{var1},@var{var2},@var{var3}>@@@var{ppt}
@cindex debugging flags
@cindex category, for debugging
@cindex logging, for debugging Daikon
@cindex Logger
Turns on debugging information on the specified class, variables, and
program point.  In contrast to the @option{--dbg} option, track logging follows
a particular invariant through Daikon.  Multiple @option{--track} options
can be specified.  Each item (class, variables, and program point) is optional.
Multiple classes can be specified separated by vertical bars (|).  Matching
is a simple substring (not a regular expression) comparison.  Each item
must match in order for a printout to occur.  For more information, see
@ref{Track logging,,,./developer,Daikon Developer Manual}.

@item --disc_reason @var{inv_class}<@var{var1},@var{var2},...>@@@var{ppt}
Prints all discarded invariants of class @var{inv_class} at the program point
specified that involve exactly the variables given, as well as a short reason
and discard code explaining why they were not worthy of print.  Any of 
the three parts of the argument may be made a wildcard by excluding it.
For example, @samp{@var{inv_class}} and
@samp{<@var{var1},@var{var2},...>@@@var{ppt}} are valid arguments.
Concrete examples are @samp{Implication<x,y>@@foo():::EXIT},
@samp{Implication<x,y>}, and @samp{<x,y>@@foo():::EXIT}.
To print all discarded invariants, use the argument @samp{all}.

@item --mem_stat
Prints memory usage statistics into a file named @file{stat.out} in the
current directory.

@end table



@node    Daikon output, Enhancing Daikon output, Running Daikon, Top
@chapter Daikon output

Daikon outputs the invariants that it discovers in textual form to your
terminal.  This chapter describes how to interpret those invariants ---
in other words, what do they mean?

Daikon also creates a @file{.inv} file that contains the invariants in
serialized (binary) form.  You can use the @file{.inv} file to print the
invariants (@pxref{Printing invariants}) in a variety of formats, to
insert the invariants in your source code (@pxref{Annotate}), to perform
run-time checking of the invariants (see @ref{Runtime-check instrumenter},
and @ref{InvariantChecker}), and to do various other operations.  See
@ref{Tools}, for descriptions of such tools.


@menu
* Invariant syntax::            
* Program points::              
* Variable names::              
* Interpreting output::         
* Invariant list::              
* Invariant filters::           
@end menu

@node    Invariant syntax, Program points, Daikon output, Daikon output
@section Invariant syntax

Daikon can produce output in a variety of formats.  Each of the format
names can be specified as an argument to the @option{--format} argument
of Daikon (@pxref{Options to control Daikon output}), PrintInvariants
(@pxref{Printing invariants}), and Annotate (@pxref{Annotate}).
When passed on the command line, the format names are case-insensitive:
@option{--format JML} and @option{--format jml} have the same effect.

@cindex invariant output format
@cindex output format, for invariants

@table @asis

@cindex Daikon output format
@cindex output format, Daikon
@item Daikon format

Daikon's default format is a mix of Java, mathematical logic, and some
additional extensions.

@cindex has only one value, in invariant output

The output @samp{@var{var} has only one value} means that every time that
variable @var{var} was encountered, it had the same value.  However,
that value is not interesting to report.  Typically this means that
@var{var} always referred to the same object.  Users may care that the
variable was never rebound to a different object, but it would not be
helpful to print out what the hashcode or address of that object
happened to be at runtime.  @samp{@var{var} has only one value} differs from
saying that @var{var} is unmodified.  

A variable can have only one value but not be reported as unmodified
because the variable is not a parameter to a procedure --- for instance,
if a routine always returns the same object, or in a class invariant.  A
variable can be reported as unmodified but not have only one value
because the variable is never modified during any execution of the
procedure, but has different values on different invocations of the
procedure.

@cindex DBC output format
@cindex output format, DBC
@cindex Jtest DBC output format
@cindex output format, Jtest DBC
@item DBC format
This format produces output in the design-by-contract (DBC) format
expected by Parasoft's Jtest tool (@uref{http://www.parasoft.com}).

@c This implementation detail is not relevant to users
@c Like the Java output format, this output format makes extensive use of
@c helper methods defined in class @code{daikon.Quant}.

@cindex ESC/Java output format
@cindex output format, ESC/Java
@item ESC/Java format
@itemx ESC format
The Extended Static Checker for Java (ESC/Java) is a programming tool
for finding errors in Java programs by checking annotations that are
inserted in source code; for more details, see
@uref{http://research.compaq.com/SRC/esc/}.  Daikon's ESC/Java format
(which can also be specified as ESC format) is intended for use with the
original ESC/Java tool.  Use Daikon's JML format for use with the
@uref{http://www.sos.cs.kun.nl/sos/research/escjava/index.html, ,ESC/Java2}
tool.


@cindex IOA output format
@cindex output format, IOA
@item IOA format
IOA is a formal language for describing computational processes that are
modeled using I/O automata; for details, see
@uref{http://theory.csail.mit.edu/tds/ioa/}.

@cindex Java output format
@cindex output format, Java
@item Java format
Write output as Java expressions.  This means that each invariant
would be a valid Java expression, if inserted at the correct program
point: right after method entry, for method entry invariants; 
right before method exit, for method exit invariants;, or anywhere in
the code, for object invariants.

There are two exceptions.  Method exit invariants that refer to
prestate, such as @samp{x == old(x) + 1}, are output with the tag
@samp{\old} surrounding the prestate expression (e.g. @samp{x ==
\old(x) + 1}.  Method exit invariants that refer to the return value of
the method, such as @samp{return == x + y}, are output with the tag
@samp{\result} in place of the return value (e.g. @samp{\result == x + y}).
These expression are obviously not valid Java code.

@c This implementation detail not relevant to users
@c The Java output format makes extensive use of helper methods defined
@c in class @code{daikon.Quant}, which provides methods for
@c quantification and set comprehension over Java collections.  For
@c example, @code{daikon.Quant.eltsEqual(int[] seq1, int elt)} checks
@c whether all elements in @code{seq1} are equal to @code{elt}.  For
@c detailed meanings of all methods in the @code{Quant} class, see the
@c Javadoc documentation for the class (or look inside
@c @file{daikon/QuantBody.java}).

@cindex JML output format
@cindex output format, JML
@item JML format
Produces output in JML (Java Modeling Language,
@uref{http://www.jmlspecs.org}); for details, see the
@uref{http://www.cs.iastate.edu/~leavens/JML.html, ,JML Manual}.  JML
format lets you use the various JML tools on Daikon invariants,
including runtime assertion checking and the
@uref{http://www.sos.cs.kun.nl/sos/research/escjava/index.html, ,ESC/Java2}
tool.

@c This implementation detail not relevant to users
@c Like the Java output format, this output format makes extensive use of
@c helper methods defined in class @code{daikon.Quant}.

@cindex Simplify output format
@cindex output format, Simplify
@item Simplify format
Produces output in the format expected by the Simplify automated theorem
prover; for details, see
@uref{http://research.compaq.com/SRC/esc/simplify/InputSyntax.html}.

@cindex repair output format
@cindex output format, repair
@cindex data structure repair output format
@cindex output format, data structure repair
@item repair format
This format is used by automated data structure repair tools.

@end table


@node    Program points, Variable names, Invariant syntax, Daikon output
@section Program points
@cindex program point

A program point is a specific place in the source code, such as
immediately before a particular line of code.  Daikon's output is
organized by program points.

@cindex :::ENTER program point
@cindex ENTER program point
@cindex precondition

For example, @code{foo():::ENTER} is the point at the entry to procedure
@code{foo()}; the invariants at that point are the preconditions for the
@code{foo()} method, properties that are always true when the procedure
is invoked.

@cindex :::EXIT program point
@cindex EXIT program point
@cindex postcondition
@cindex hierarchy of program points
@cindex program point hierarchy

Likewise, @code{foo():::EXIT} is the program point at the procedure
exit, and invariants there are postconditions.  When there are multiple
exit points from a procedure (for instance, because of multiple
@code{return} statements), the different exits are differentiated by
suffixing them with their line numbers; for instance,
@code{StackAr.top():::EXIT79}.  The exit point lacking a line number (in
this example, @code{StackAr.top():::EXIT}) collects the postconditions
that are true at every numbered exit point.  This is an example of a
program point that represents a collection of locations in the program
source rather than a single location.  This concept is referred to as 
@emph{hierarchy}.  

@cindex :::OBJECT program point
@cindex OBJECT program point
@cindex :::CLASS program point
@cindex CLASS program point
@cindex object invariants
@cindex representation invariants
@cindex class invariants

Two other program point tags that have special meaning to Daikon's hierarchy
organization are @code{:::OBJECT} and @code{:::CLASS}.
The former indicates object invariants (sometimes called representation
invariants or class invariants) that always hold for any object of the
given class, from the point of view of a client or user.  These
properties hold at entry to and exit from every public method of the
class (except not the entry to constructors, when fields are not yet
initialized).
The @code{:::CLASS} tag is just like @code{:::OBJECT}, but only
for static variables, which have only one value for all objects.

@cindex private methods

(By contrast, ESC/Java and JML make class invariants hold even at the
entry and exit of private methods.  Their designers believe that most
private methods preserve the class invariant and are called only when
the class invariant holds.  ESC/Java and JML require an explicit
``helper'' annotation to indicate a private method for which the class
invariant does not hold.)

The Java instrumenter Chicory selects names for program
points that include an indication of the argument and return types for
each method.  These signatures are presented in the JVML format: one
character for each primitive type (@samp{B} for byte, @samp{C} for
character, @samp{Z} for boolean (so as not to clash with byte), etc.);
@samp{L@var{classname};} for object types; and a @samp{[}
prefix for each level of array nesting.


@node    Variable names, Interpreting output, Program points, Daikon output
@section Variable names

A front end produces a trace file that associates trace variable names
with values.  Trace variable names need not be exactly the same as the
variables in the program.  The trace may contain values that are not
held in any program variables; in this case, the front end must make up
a name to express that value (see below for examples).

Daikon ignores variable names when inferring invariants; it uses the
names only when performing output.  (Thus, the only practical
restriction on trace names is that the VarInfoName @code{parse} method
must be able to parse the name.)

By convention, trace variables are similar to program variables and
field accesses.  For example, @code{w}, @code{x.y.z}, @samp{a[i]}, and
@samp{a[0].next} are legal trace variables.  As in languages such as
Java and C, a period character represents field access and square
brackets represent selecting an element of a sequence.

The remainder of this section describes conventions for naming
expressions.  Those that cannot be named by simple C/Java expressions
are primarily related to arrays and sequences.  (In part, these special
expressions are necessary because Daikon's can only handle variables of
scalar (integer, floating-point, boolean, String) and array-of-scalar
types.  Daikon cannot handle structs, classes, or multi-dimensional
arrays or structures, but such data structures can be represented as
scalars and arrays by choosing variable names that indicate their
relationship.)


@itemize @bullet
@item
@code{a[i]} array access.
@code{a} and @code{i} are themselves
arbitrary variable names, of array and integral type, respectively.
Since @code{a[i]} is not a variable in the program source code, it is
called a ``derived variable''; see @ref{Options to enable/disable
derived variables}.

@item
@cindex @code{-1} array index (counts from end of array)
@cindex negative array index (counts from end of array)
@code{a[-1]} from-end array access.
@code{a[-1]} denotes the last element of array @code{a};
it is syntactic sugar for @code{a[a.length-1]}.

@item
@cindex @code{[]} variable name (array contents)
@code{a[]} array contents.
For array-valued expression @code{a}, all of its elements, as a
sequence.  Simply using the expression @code{a} means the identity
(address or hashcode) of the array, not a list of its elements.  For two
arrays @code{a} and @code{b}, @samp{a=b} implies @samp{a[]=b[]}, but
@samp{a[]=b[]} does not imply @samp{a=b}.

@item @code{x.y}, @code{x->y} field access.
When field access is applied to a structure/class, it has the usual
meaning of selecting one field from the structure/class.

When field access is applied to an array, it means to map the field
access across the elements of the array.  For example, if @code{a} is an
array, then @code{a[].foo} is the sequence consisting of the @code{foo}
fields of each of the elements of @code{a}.  Likewise,
@code{a[].foo.bar} contains the @code{bar} fields of @code{a[].foo}.  By
contrast, @code{a.foo} does not make sense, because one cannot ask for
the @code{foo} field of an address, and @code{a[].foo[]} would be a
two-dimensional array.

@c This is valuable and true, but probably more than users need to know.
@c In Mangel-Wurzel, fields of the @samp{this} parameter print as
@c @samp{this->@var{fieldname}}.

@item
@cindex @code{.getClass()} variable
As in Java, @code{x.getClass()} is the runtime type of @code{x}, which may
differ from its declared type.

@item
@cindex @code{.length} variable name
@code{a.length} is the length (number of elements) of array @code{a};
this is not necessarily the number of initialized or used elements.

@item
@cindex @code{.toString} variable
@code{s.toString} is the string value of String @code{s}, namely a
sequence of characters.

@item
@code{Classname.varname} static class variable.
Static variables of a class have names of the form
@samp{@var{classname}.@var{varname}}

@item
@cindex @code{orig()} variable (pre-state value)
@cindex pre-state variables
@code{orig(x)} refers to the value of variable @code{x} upon
entry to a procedure (because the procedure body might modify the value
of @code{x}).  These variables appear only at @code{:::EXIT} program
points.  Typically, @code{orig()} variables do not appear in the trace,
but are automatically created by Daikon when it matches up
@code{:::ENTER@var{[nn]}} and @code{:::EXIT} program points.
@xref{orig variable example}.

This variable prints as @code{orig} when using Daikon output format
(@pxref{Invariant syntax}), but may print differently in other formats
(such as @code{\old}).

@item
@cindex @code{post()} variable (post-state value)
@cindex post-state variables
@code{post(x)} refers to the value of variable @code{x} upon exit from a
procedure.  Such a value is usually written simply @code{x}; the
@code{post} prefix is needed only within an @code{orig} expression, when
the post-state value needs to be referenced.  Just as @code{orig} may
be used only in a post-state context and specifies an expression to be
evaluated in the pre-state, @code{post} may be may be used only in a
pre-state context and specifies an expression to be evaluated in the
post-state.  @xref{orig variable example}.


@c Old version.  Do any of the front ends still do this?
@c @item
@c @cindex @code{::} variable (C global)
@c @code{::x} is the global variable @code{x}.

@item
@cindex @code{/} variable (C global or file-static)
@code{/globalVar} C global variable.  In C output, global variables with
external linkage are
prefixed with a slash.  For instance, global @code{/x} is distinct from
procedure parameter @code{/x}.  (In Java programs, variables can be
distinguished by prefixing them with @code{this.} or, for class-static
variables, a class name.)

@item
@code{myfile_c/staticVar} C static variable.  In C output, file-static
variables have names of the form @samp{@var{filename}/@var{varname}},
where periods (@samp{.}) in the filename are converted into underscores
(@samp{_}).  For example, @samp{Global_c/x} is the name for a
file-static variable @code{x} declared in the file @file{Global.c}).

@item
@cindex @code{@@} variable (C function-scoped static)
@code{myfile_c@@funcname/funcStaticVar} C function-scoped static variable.
In C output, for static variables which are
declared within functions, an at-sign @samp{@@} separates the filename
and the function name and then a slash separates the function name and
variable name (e.g., @samp{Global_c@@main/funcStaticVar} for a static
variable @code{funcStaticVar} declared within the function @code{main}
in the file @file{Global.c}).

@end itemize

@cindex local variables
@cindex variables, local
Daikon's current front ends do not produce output for local variables,
only for variables visible from outside a procedure.  (Also see the
@option{--std-visibility} option to Chicory, @ref{Chicory options}.)  Thus,
Daikon's output forms a specification from the view of a client of a
procedure.  A future version of Daikon may permit output of local
variables as a user option; send mail to
@email{daikon-developers@@lists.csail.mit.edu} if this functionality is
important to you.


The array introduction operator @code{[]} can made Daikon variables look
slightly odd, but it is intended to assist in interpreting the variables
and to provide an indication that the variable name cannot be
substituted directly in a program as an expression.

Each array introduction operator @code{[]} increases the dimensionality
of the variable, and each array indexing operation @code{[i]} decreases
it.  Since all Daikon variables are scalars or one-dimensional arrays,
these operators must be matched up, or have at most one more @code{[]}
than @code{[i]}.  (There is one exception:  according to a strict
interpretation of the rules, the C/Java expression @code{a[i]} would
turn into the Daikon variable @code{a[][i]}, since it does not change
the dimensionality of any expression it appears in.  However, that would
be even more confusing, and the point is to avoid confusion, so by
convention Daikon front ends use just @code{a[i]}, not @code{a[][i]}.
Strictly speaking, none of the @code{[]} operators is necessary, since a
user with a perfect knowledge of the type of each program variable and
field could use that to infer the type of any Daikon expression.)


@menu
* orig variable example::       
@end menu

@node    orig variable example,  , Variable names, Variable names
@subsection orig variable example

@cindex @code{orig()} variable (pre-state value)

This section gives an example of use of @code{orig()} and @code{post()}
variables and arrays.

Suppose you have initially that (in Java syntax)
@example
int i = 0;
int[] a = new int[] @{ 22, 23 @};
int[] b = new int[] @{ 46, 47 @};
@end example

@noindent
and then you run the following:
@example
// pre-state values at this point
a[0] = 24;
a[1] = 25
a = b;
a[0] = 48;
a[1] = 49;
i = 1;
// post-state values at this point
@end example

The values of various variables are as follows:

@table @code
@item orig(a[i]) = 22
The value of @code{a[i]} in the pre-state: @{22, 23@}[0]

@item orig(a[])[orig(i)] = 22
This is the same as orig(a[i]):   @{22, 23@}[0].

@item orig(a[])[i] = 23
The value of @code{a[]} in the pre-state (which is an array object, not
areference), indexed by the post-state value of i:  @{22, 23@}[1]

@item orig(a)[orig(i)] = 24
@code{orig(a)} is the original value of the reference @code{a}, not
@code{a}'s original elements: @{24, 25@}[0]

@item orig(a)[i] = 25
The original pointer value of a, indexed by the post-state value
of i:  @{24, 25@}[1]

@item a[orig(i)] = 48
In the post-state, @code{a} indexed by the original value of
@code{i}: @{48, 49@}[0]

@item a[i] = 49
The value of @code{a[i]} in the post-state.

@item b = orig(b) = @var{some hashcode}
The identity of the array @code{b} has not changed.

@item b[] = [48, 49]
@itemx orig(b[]) = [46, 47]
For an array @code{b}, @samp{b=orig(b)} does not imply @samp{b[]=orig(b[])}.

@item orig(a[post(i)]) = 23
The pre-state value of @code{a[1]} (because the post-state value of
@code{i} is 1):  @{22, 23@}[1]

@end table

@node    Interpreting output, Invariant list, Variable names, Daikon output
@section Interpreting Daikon output

@cindex @samp{Exiting}, in Daikon output

If nothing gets printed before the @samp{Exiting} line, then Daikon
found no invariants.  You can get a little bit more information by using
the @option{--output_num_samples} flag to Daikon 
(@pxref{Options to control Daikon output}).


By default, Daikon does not display redundant invariants --- those
that are implied by other invariants in the output --- because such
results would merely clutter the output without adding any valuable
information.  For instance, if Daikon reports @samp{x==y}, then it never
also reports @samp{x-1==y-1}.  You can control this behavior to some extent by 
disabling invariant filters; @xref{Invariant filters}.
(You can also print all invariants, even
redundant ones, by saving the invariants to a @file{.inv} file and
then using the PrintInvariants (@pxref{Printing invariants}) or Diff
(@pxref{Invariant Diff}) programs to print the results.)

@menu
* Equal variables::             
@end menu

@node    Equal variables,  , Interpreting output, Interpreting output
@subsection Equal variables

When two or more variables are always equal, any invariant that
is true over one variable is true over all of the variables.  Daikon
prints invariants only over one variable (the leader) from the equal
set. 

An equality invariant is printed for each non-leader in the equal set.
For example, if the variables @code{a}, @code{b}, and @code{c} are all
equal and @code{a} is chosen as the leader, the printed invariants will
include any invariants over @code{a} and the equality invariants @samp{a=b}
and @samp{a=c}.

@node   Invariant list, Invariant filters, Interpreting output, Daikon output
@section Invariant list

@cindex invariant list
@cindex invariants, list of all
The following is a list of all of the invariants that Daikon detects.
Each invariant has a configuration enable switch.  By default most invariants
are enabled.  Any that are not enabled by default are indicated below.
Some invariants also have additional configuration switches that control 
their behavior.  These are indicated below as well.
@xref{Options to enable/disable specific invariants}.

@table @asis
@include invariants-doc.texinfo
@end table

@node Invariant filters,  , Invariant list, Daikon output
@section Invariant filters

@cindex invariant filters
@cindex filters

Invariant filters are used to suppress the printing of invariants that
are true, but not considered ``interesting'' --- usually
because the invariants are considered obvious or redundant in a given
context.

The following is a list of the invariant filters that Daikon supports.
Each of these filters has a corresponding configuration enable switch;
by default, all filters are enabled.  @xref{Options to enable/disable filters},
for details.

@itemize @bullet

@cindex DerivedParameterFilter
@item DerivedParameterFilter:  suppress parameter-derived postcondition invariants

This filter suppresses invariants at procedure exit points that are
uninteresting because they refer to prestate variables derived from
pass-by-value parameters.  For example, suppose that @code{param} is a
parameter to a
Java method.  If @code{param} itself is modified, that change won't be
visible to a caller, so it's uninteresting to print.  If @code{param} points
to an object, and that object is changed, that is visible, but
only if @code{param} hasn't changed; otherwise, the invariant would report a
change in some object other than the one that was passed in.


@cindex ObviousFilter
@item ObviousFilter:  suppress obvious invariants

This filter suppresses invariants because they are obvious from looking
at other invariants.  Some examples are:

@itemize @bullet

@item If @samp{size(args[])==0} is shown, then @samp{size(args[])-1==-1} is
obvious and will not be displayed by default.
@item If @samp{this.topOfStack < size(this.theArray[])-1} is shown, then
@samp{this.topOfStack < size(this.theArray[])} is obvious and will not be
displayed by default.

@end itemize



@cindex OnlyConstantVariablesFilter
@item OnlyConstantVariablesFilter:  suppress invariants containing only constants

This filter suppresses comparison invariants in which all of the
variables being compared were observed to be constant.  In the current
version of Daikon, most such invariants are not even created in the
first place, because constants are detected on an early pass over the
data.  However, Daikon will note that all of the invariants that had
any particular constant value were also equal to each other: such
invariants will be suppressed by this filter.


@cindex ParentFilter
@item ParentFilter:  filter invariants that match a parent program point invariant

A controlled invariant is an invariant that is ``controlled'' --- or
implied --- by a parent program point in the dataflow hierarchy.  
For example, for Java instrumented
code each class is associated with an object program point, which
contain invariants that are found at the entry and exit of all public
methods.  So in addition to the usual program points such as
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, daikon outputs invariants for the
artificial program point @code{StackAr:::OBJECT}.  The invariants for
@code{StackAr:::OBJECT} control the invariants for
@code{StackAr.StackAr(int):::ENTER} and
@code{StackAr.isEmpty():::EXIT48}, because the former imply the latter.
Because of this redundancy, controlled invariants are not displayed by
default.  Note that if for some reason, the controlling invariant is not
displayed (for example, because it's unjustified), then the controlled
invariant @emph{will} be displayed.

@cindex SimplifyFilter
@item SimplifyFilter:  eliminate invariants using Simplify

Daikon can use the Simplify theorem-prover to eliminate even more
implied invariants than Daikon's built-in tests are able to eliminate.
Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to take advantage of this filter.

If you don't also specify the @option{--suppress_redundant} command-line 
option to enable Simplify processing, this filter doesn't do anything.

@cindex UnjustifiedFilter
@item UnjustifiedFilter:  suppress unjustified invariants

For every invariant, Daikon estimates the probability of that invariant
happening by chance.  If that probability is less than the limit, then
the invariant is deemed to be an actual invariant, not just a chance
occurrence.  Currently the limit is .01%.  So by default, only invariants
with probabilities of less than .01% are shown.  See the @option{--conf_limit}
option (@pxref{Options to control invariant detection}).


@cindex UnmodifiedVariableEqualityFilter
@item UnmodifiedVariableEqualityFilter:  suppress invariants that merely indicate that a variable was unmodified

This filter is only useful for ESC output.

@end itemize


@node    Enhancing Daikon output, Front ends, Daikon output, Top
@chapter Enhancing Daikon output

@menu
* Configuration options::       
* Conditional invariants::      
* Enhancing conditional invariant detection::  
* Loop invariants::             
@end menu

@node    Configuration options, Conditional invariants, Enhancing Daikon output, Enhancing Daikon output
@section Configuration options

@cindex configuration options
@cindex dkconfig_ variables

Many aspects of Daikon's behavior can be controlled by setting various
configuration parameters.  These configuration parameters control which
invariants are checked and reported, the statistical tests for
invariants, which derived variables are created, and more.

The configuration options are set by creating a configuration file and
supplying it to Daikon on the command line using the @option{--config
@var{filename}} option.  Daikon reads all supplied configuration files
in order, overriding the defaults.  You may wish to use the supplied
example configuration file
@file{daikon/java/daikon/config/example-settings.txt} as an example when
creating your own configuration files.  (If you did not downloaded
Daikon's sources, you will have to extract the example from
@file{daikon.jar} to read it.)

You may also specify a configuration setting directly on the command line,
using the @option{--config_option @var{name}=@var{value}} option.

The configuration options are different from the debugging flags
@option{--debug} and @option{--dbg @var{category}} 
(@pxref{Daikon debugging options}).  
The debugging flags permit Daikon to produce debugging
output, but they do not affect the invariants that Daikon computes.

@menu
* List of configuration options::  
@end menu

@node    List of configuration options,  , Configuration options, Configuration options
@subsection List of configuration options

This is a list of all Daikon configuration options.
The configuration option name contains the
Java classes in which it is defined.  (In the Daikon source code, the
configuration value is stored in a variable whose name contains a
@code{dkconfig_} prefix, but that should be irrelevant to users.)
To learn more about a specific invariant or derived variable, see
its source code.

@c The config options are categorized into sections by pattern-matching
@c their names.  If you are adding new options, you might want to choose
@c names similar to those of similar options.  
@c Currently the categories are:
@c   daikon.inv.filter.*.enabled  -> turn filters on/off
@c   daikon.inv.*.enabled -> turn invariant detection on/off
@c   daikon.inv.* -> other invariant configuration
@c   daikon.derive.* -> turn derived parameters on/off
@c   daikon.simplify.* -> options for Simplify
@c   * -> general options
@c See ParameterDoclet.java for details.

@include config-options.texinfo


@node    Conditional invariants, Enhancing conditional invariant detection, Configuration options, Enhancing Daikon output
@section Conditional invariants and implications
@cindex splitting
@cindex splitting condition
@cindex conditional invariant
@cindex invariant, conditional
@cindex implication invariant
@cindex invariant, implication

Conditional invariants are invariants that are true only part of the time.
For instance, the postcondition for the absolute value procedure is
@example
if arg < 0
  then return == -arg
  else return == arg
@end example
@noindent
The invariant @code{return == -arg} is a conditional invariant because
it depends on the predicate @code{arg < 0} being true.  An
@emph{implication} is a compound invariant that includes both the
predicate and the conditional invariant (also called the consequent).

Daikon must be supplied with the predicate for an implication.  Daikon has
certain built-in predicates that it uses for finding conditional invariants;
examples are which return statement was executed in a procedure and whether a
boolean procedure returns true or false.  Additionally, Daikon can read
predicates from a file called a splitter info (@file{.spinfo}) file and find
implications based on those predicates.  The splitter info file can be produced
automatically, such as by static analysis of the program using the CreateSpinfo
and CreateSpinfoC programs or by cluster analysis of the
traced values in the data trace file.  Details of these techniques and usage
guides can be found in @ref{Enhancing conditional invariant detection}.  Users
can also create splitter info files by hand or manually augment
automatically-created ones.

To detect conditional invariants and implications:
@enumerate
@item
Create the splitter info file, either automatically or by hand.
@item
Run Daikon with the @file{.spinfo} file as one of its arguments.  
(The order of arguments does not matter.)
For example,
@example
java daikon.Daikon Foo.decls Foo.spinfo Foo.dtrace
@end example
@end enumerate

The term ``splitter'' comes from Daikon's technique for detecting
implications and conditional invariants.  For each predicate, Daikon
creates two conditional program points --- one for program executions
that satisfy the condition and one for those that don't --- and splits
the data trace into two parts.  Invariant detection is then performed
on the conditional program points (that is, the parts of the data
trace) separately and any invariants detected are reported as
conditional invariants (as implications).

To be precise, we say that an invariant holds exclusively if it is
discovered on one side of a split, and its negation is discovered on
the opposite side.  Daikon creates conditional invariants whose
predicates are invariants that hold exclusively on one side of a
split, and whose consequents are invariants that hold on that side of
the split but not on the un-split program point.  If Daikon finds
multiple exclusive conditions, it will create biconditional (``if and
only if'') invariants between the equivalent conditions.  Within the
context of the program, each of the exclusive conditions is equivalent
to the splitting condition.  In particular, if both the splitting
condition and its negation are within the grammar of invariants that
Daikon detects, the splitting condition may appear as the predicate of
the generated conditional invariants.  On the other hand, if other
equivalent conditions are found, or if the splitting condition is not
expressible in Daikon's grammar, it might not appear in the generated
implications.

@cindex dummy invariant
@cindex invariant, dummy

In some cases, the default policy of selecting predicates from
Daikon's output may be insufficient.  For instance, Daikon might not
detect any invariant equivalent to the splitting condition, if it is
sufficiently complex or application-specific.  In such situations,
Daikon can also use the splitting condition itself as the predicate of
an implication, as what is called a ``dummy invariant''.  A ``dummy
invariant'' is one whose meaning is not dealt with directly by Daikon;
instead Daikon knows only how to print the invariant in its output.
When a tool or a user writes a splitter info file, the file can
specify a way to print the condition represented by the splitter in
any of Daikon's output formats.  If the use of dummy invariants is
enabled, invariants with the supplied output formats will be used as
the predicates of conditional invariants.

To use dummy invariants, a condition's formatting must be specified in
the splitter info file, and the configuration option
@option{daikon.PptTopLevel.dummy_invariant_level} must be set to a
non-zero value (see @ref{List of configuration options}).

@menu
* Splitter info file::          
* Indiscriminate splitting::    
* Example splitter info file::  
@end menu

@node    Splitter info file, Indiscriminate splitting, Conditional invariants, Conditional invariants
@subsection Splitter info file
@cindex splitter info file
@cindex .spinfo file
@cindex spinfo file

A splitter info file contains the conditions that Daikon should use to
create conditional invariants.  Each section in the @file{.spinfo}
file consists of a sequence of non-blank lines; sections are separated
by blank lines.  There are two types of sections:  program point
sections and replacement sections.
@xref{Example splitter info file}, for an example splitter info file.

@menu
* Program point sections::      
* Replacement sections::        
@end menu

@node    Program point sections, Replacement sections, Splitter info file, Splitter info file
@subsubsection Program point sections

Program point sections have a line specifying a program point name
followed by lines specifying the condition(s) associated with that
program point, each condition on its own line.  Additional information
about a condition may be specified on indented lines.  For example, a
typical entry is

@example
PPT_NAME @var{pptname}
@var{condition1}
@var{condition2}
    DAIKON_FORMAT @var{output string}
    ESC_FORMAT @var{output string}
@var{condition3}
...
@end example
@noindent
@var{pptname} can be any string that matches a part of the desired
program point name as printed in the decls file.  In finding matching
program points, Daikon uses the first program point that matches
@var{pptname}.  Caution is necessary when dealing with method names
that are prefixes of other method names.  For instance, if the class
@code{List} has methods @code{add} and @code{addAll}, specifying
@samp{PPT_NAME List.add} might select either method, depending on
which was encountered first.  Instead writing @samp{PPT_NAME
List.add(} will match only the @code{add} method.

Each condition is a Java expression of boolean type.  All variables
that appear in the condition must also appear in the declaration of
the program point in the @file{.decls} file.  (In other words, all the
variables must be in scope at the program point(s) where the Splitter
is intended to operate.)  The automatically generated Splitter source
code fails to compile (but Daikon proceeds without it) if a variable
name in a condition is not found at the matching program point.

Indented lines beginning with @option{DAIKON_FORMAT},
@option{JAVA_FORMAT}, @option{ESC_FORMAT}, @option{SIMPLIFY_FORMAT},
or @option{IOA_FORMAT} may be used to specify how to represent the
condition specified by the splitter in each of Daikon's output
formats, to allow the splitting condition to be used as a dummy
invariant.

@node    Replacement sections,  , Program point sections, Splitter info file
@subsubsection Replacement sections

Ordinarily, a splitting condition may not invoke user-defined methods,
because when Daikon reads data trace files, it does not have access to the
program source.  A replace section of the splitter info file can specify
the bodies of methods, permitting conditions to invoke those methods.  The
format is as follows:
@example
REPLACE
@var{procedure1}
@var{replacement1}
@var{procedure2}
@var{replacement2}
...
@end example
@noindent
where @var{replacementi} is a Java expression for the body
of @var{procedurei}.  In each condition, Daikon replaces procedure
calls by their replacements.  A replace section may appear anywhere in
the splitter info file.

@node    Indiscriminate splitting, Example splitter info file, Splitter info file, Conditional invariants
@subsection Indiscriminate splitting

Ordinarily, each condition in an @file{.spinfo} file gives rise to
conditional invariants only at the program point in whose section the
condition appears.  Alternately, every condition can be used at every
program point, regardless of where in the @file{.spinfo} file the
condition appeared; this latter approach is called ``indiscriminate
splitting''.

The advantage of indiscriminate splitting is that a condition that is
useful at one program point may also be useful at another --- if the
same variables are in scope or other variables of the same name are in
scope.  The disadvantage of indiscriminate splitting is that often the
condition is not applicable everywhere, and when it is, it may not be
useful at all such locations, so checking for many conditional
invariants may slow down Daikon without a corresponding benefit. 
Indiscriminate splitting can result in Daikon attempting
to use many conditions that are inappropriate at certain program
points, for instance because the program point does not have (in
scope) all the variables that are used in the condition.  For example,
the condition @code{myArray.length == x} is inapplicable at a program
point if either of @code{myArray} and @code{x} is not in scope at that
program point.  In this case, Daikon prints a warning message and
proceeds, using conditions wherever they are valid.

By default, Daikon uses indiscriminate splitting.  To use
non-indiscriminate splitting, place the following line in a file that is
passed to Daikon via the @option{--config} flag 
(@pxref{Daikon configuration options}):
@example
daikon.split.SplitterList.all_splitters = false
@end example


@node    Example splitter info file,  , Indiscriminate splitting, Conditional invariants
@subsection Example splitter info file

Below is an implementation of a simple Queue for positive integers and
a corresponding @file{.spinfo} file.  The splitter info file is like
the one that @command{CreateSpinfo} would create for that class, but
also demonstrates some other features.

@menu
* Example class::               
* Resulting .spinfo file::      
@end menu

@node    Example class, Resulting .spinfo file, Example splitter info file, Example splitter info file
@subsubsection Example class

@smallexample
class simpleStack @{
 
  private int[] myArray;
  private int currentSize;
 
  public simpleStack(int capacity) @{
    myArray = new int[capacity];
    currentSize = 0;
  @}
 
  /** Adds an element to the back of the stack, if the stack is
    * not full.
    * Returns true if this succeeds, false otherwise.  **/
  public String push(int x) @{
    if ( !isFull() && x >= 0) @{
      myArray[currentSize] = x;
      currentSize++;
      return true;
    @} else @{
      return false;
    @}
  @}
 
  /** Returns the most recently inserted stack element.
    * Returns -1 if the stack is empty. **/
  public int pop() @{
    if ( !isEmpty() ) @{
      currentSize--;
      return myArray[currentSize];
    @} else @{
      return -1;
    @}
  @}

 /** Returns true if the stack is empty, false otherwise. **/
  private boolean isEmpty() @{
    return (currentSize == 0);
  @}

  /** Returns true if the stack is full, false otherwise. **/
  private boolean isFull() @{
    return (currentSize == myArray.length);
  @}
@}
@end smallexample

@node    Resulting .spinfo file,  , Example class, Example splitter info file
@subsubsection Resulting .spinfo file

@smallexample
REPLACE
isFull()
currentSize == myArray.length
isEmpty()
currentSize == 0

PPT_NAME  simpleStack.push
!isFull() && x >= 0
    DAIKON_FORMAT !isFull() and x >= 0
    SIMPLIFY_FORMAT (AND (NOT (isFull this)) (>= x 0))

PPT_NAME  simpleStack.pop
!isEmpty()

PPT_NAME  simpleStack.isFull
currentSize == myArray.length - 1

PPT_NAME  simpleStack.isEmpty
currentSize == 0
@end smallexample

@node    Enhancing conditional invariant detection, Loop invariants, Conditional invariants, Enhancing Daikon output
@section Enhancing conditional invariant detection

The built-in mechanisms (@pxref{Conditional invariants}) have
limitations in the invariants they can find.  By supplying splitting
conditions to Daikon via a splitter info file, the user can infer more
conditional invariants.  To ease this task, there are two methods to
automatically create splitter info files for use by Daikon.

@menu
* Static analysis for splitters::  
* Cluster analysis for splitters::  
* Random selection for splitters::  
@end menu

@node   Static analysis for splitters, Cluster analysis for splitters, Enhancing conditional invariant detection, Enhancing conditional invariant detection
@subsection Static analysis for splitters

@cindex splitting conditions, static analysis
@cindex static analysis for splitters
@cindex CreateSpinfo
@cindex CreateSpinfoC

In static analysis, all explicitly stated boolean statements in the program
source are extracted and used as splitting conditions.  The assumption is that
conditions that are explicitly tested in the program are likely to affect the
program's behavior and could lead to useful conditional invariants.  

The CreateSpinfo program takes Java source code as input and creates a
splitter info file for each input file; for instance,
@example
java daikon.tools.jtb.CreateSpinfo Foo.java Bar.java
@end example
@noindent
creates the splitter info files @file{Foo.spinfo} and
@file{Bar.spinfo}.
Given an @option{-o @var{filename}} argument, CreateSpinfo puts all the
splitters in the specified file instead.
The resulting splitter info file(s) contains each
boolean expression that appears in the source code.  The conditional
statements that the programmer used in the source code are likely to
have important semantic properties.  This simple heuristic of using
these conditional statements as predicates for conditional invariant
detection is often quite effective.  

If you get an error such as
@example
jtb.ParseException: Encountered ";" at line 253, column 8.
Was expecting one of: "abstract" ...
@end example
@noindent
then you may have encountered a bug in the JTB library on which
CreateSpinfo is built.  It does not permit empty declarations in a
class body.  Remove the extra semicolon in your Java file (at the
indicated position) and re-rerun CreateSpinfo.

The @command{CreateSpinfoC} program performs the same function, for
C source code.  It can only be run on postprocessed source
files---that is, source files contain no CPP commands.  CPP commands
are lines starting with @samp{#}, such as @samp{#include}.  To
expand CPP commands into legal C, run either @command{cpp -P} or
@command{gcc -P -E}.  For instance, here is how you could use it.
@example
cpp -P foo.c foo.c-expanded
cpp -P bar.c bar.c-expanded
java daikon.tools.jtb.CreateSpinfoC \
     foo.c-expanded bar.c-expanded
@end example
@noindent

If you get an error such as
@example
... Lexical error at line 5, column 1.
Encountered: "#" (35), after : ""
@end example
@noindent
then you forgot to run CPP before running CreateSpinfoC@.

@node   Cluster analysis for splitters, Random selection for splitters, Static analysis for splitters, Enhancing conditional invariant detection
@subsection Cluster analysis for splitters

@cindex splitting conditions, cluster analysis
@cindex cluster analysis for splitters
@cindex runcluster.pl program

Cluster analysis is a statistical method that finds groups or clusters
in data.  The clusters may indicate conditional properties in the
program.  A conditional property at a program point separates the data
into those that satisfy it and those that do not, and conditional
invariants can be induced by clustering.  Any invariant that is
discovered over one cluster but not over another is a conditional
invariant---the predicate for the conditional invariant being
membership in the cluster in which the invariant was found.  The
cluster analysis mechanism finds clusters in the data trace file,
infers invariants over any clusters that it finds, and writes these
invariants into a splitter info file for conditional invariant
detection.

To find splitting conditions using cluster analysis, run the
@command{runcluster.pl} program (found in the @file{$DAIKONDIR/bin}
directory) in the following way:
@example
runcluster.pl [@var{options}] @var{dtrace_file ...} @var{decls_files ...}
@end example

The @var{options} are:
@table @option

@cindex kmeans cluster analysis
@cindex hierarchical cluster analysis
@cindex xm cluster analysis
@item -a @var{ALG}
@itemx --algorithm @var{ALG}
@var{ALG} specifies a clustering algorithm.
Current options are @samp{km} (for kmeans), @samp{hierarchical},
and @samp{xm} (for xmeans).  The default is @samp{xm}.

@item -k
The number of clusters to use (for algorithms which require
this input, which is everything except xmeans).  The default is 4.

@item --keep    
Don't delete the temporary files created by the clustering
process.  This is a debugging flag.
@end table

The @command{runcluster.pl} script currently supports three clustering
programs.  They are implementations of the kmeans algorithm,
hierarchical clustering and the xmeans algorithm (kmeans algorithm
with efficient discovery of the number of clusters).  The kmeans and
hierarchical clustering tools are provided in the Daikon
distribution.  The xmeans code and executable are publicly available at
@uref{http://www.cs.cmu.edu/~dpelleg/kmeans.html} (fill in the license
form and mail it in).

@node   Random selection for splitters,  , Cluster analysis for splitters, Enhancing conditional invariant detection
@subsection Random selection for splitters

@cindex splitting conditions, random selection
@cindex random selection for splitters
@cindex TraceSelect tool

Random selection can create representative samples of a data set with
the added benefit of finding conditional properties and eliminating
outliers.  Given traced data, the TraceSelect tool creates several
small subsets of the data by randomly selecting parts of the original
trace file.  Any invariant that is discovered in the smaller samples but
not found over the entire data is a conditional invariant.

To find splitting conditions using random selection, run the
@command{daikon.tools.TraceSelect} program in the following way:
@example
java daikon.tools.TraceSelect @var{num_reps} @var{sample_size} [@var{options}] \
    @var{dtrace_file} @var{decls_files ...} [@var{daikon_options}]
@end example

@var{num_reps} is the number of subsets to create, and @var{sample_size} is the
number of invocations to collect for each method.

The @var{daikon_options} are the same options that can be provided to the
daikon.Daikon program.

The @var{options} for TraceSelect are:
@table @option

@item -NOCLEAN
Don't delete the temporary trace samples created by the random
selection process.  This can help for debugging or for using the tool
solely to create trace samples instead of calculating invariants over
the samples.

@item -INCLUDE_UNRETURNED
Allows random selection to choose method invocations that entered the
method successfully but did not exit normally; either from a thrown
Exception or abnormal termination. 

@item -DO_DIFFS
Creates an spinfo file for generating conditional invariants and
implications by reporting the invariants that appear in at least one
of the samples but not over the entire data set.

@end table



@node    Loop invariants,  , Enhancing conditional invariant detection, Enhancing Daikon output
@section Loop invariants

@cindex loop invariants

Daikon does not by default output loop invariants.  Daikon can detect
invariants at any location where it is provided with variable values,
but the front ends do not currently supply Daikon with variable values
at loop heads.

Here is one way to cause Daikon to produce loop invariants.  At the top
of a loop (or at any other location in the program at which you would
like to obtain invariants), insert a call to a dummy procedure that does
not work but returns immediately.  Pass, as arguments to the dummy
procedure, all variables of interest.  Daikon will produce (identical)
preconditions and postconditions for the dummy procedure; these are
properties that held at the call site.



@node    Front ends, Tools, Enhancing Daikon output, Top
@chapter Front ends

@cindex front end

The Daikon invariant detector is a machine learning tool that finds
patterns (invariants) in data.  That data can come from any source, but
Daikon is typically used to find invariants over variable values in
running programs.  A front end is a tool that converts data from some
other format into Daikon's input format; for instance, a front end might
cause a program to output a @file{.dtrace} file that Daikon can process.

This chapter describes several front ends that are part of Daikon.  It
is relatively easy to build your own front end, if these do not serve
your purpose; we are aware of a number of users who have done so.  For
more information about building a new front end, see @ref{New front
ends,,,./developer,Daikon Developer Manual}.


@menu
* Chicory::                     
* Kvasir::                      
* Mangel-Wurzel::               
* dfepl::                       
* convertcsv.pl::               
* Other front ends::            
@end menu

@node    Chicory, Kvasir, Front ends, Front ends
@section Java front end Chicory

@cindex front end for Java
@cindex Java front end
@cindex Chicory (Daikon front end for Java)

The Daikon front end for Java, named Chicory, executes Java programs,
creates data trace (@file{.dtrace}) files, and optionally runs Daikon on
them.  Chicory is named after the chicory plant, whose root is sometimes
used as a coffee substitute or flavor enhancer.

To use Chicory, run your program as you normally would, but 
replace the @command{java} command with @command{java daikon.Chicory}.  For
instance, if you usually run
@example
java mypackage.MyClass arg1 arg2 arg3
@end example
@noindent
then instead you would run
@example
java daikon.Chicory mypackage.MyClass arg1 arg2 arg3
@end example
@noindent
This runs your program and creates file @file{MyClass.dtrace} 
in the current directory.
Furthermore, a single command can both create a trace file and run Daikon:
@example
java daikon.Chicory --daikon mypackage.MyClass arg1 arg2 arg3
@end example
@noindent
See below for more options.

That's all there is to it!  Since Chicory instruments class files 
directly as they are loaded into Java,
you do not need to perform separate instrumentation and recompilation steps.
However, you should compile your program with debugging information
enabled (the @option{-g} command-line switch to @command{javac});
otherwise, Chicory uses the names @code{arg0}, @code{arg1}, @dots{} as
the names of method arguments.

Chicory must be run in a version 5.0 JVM, but it is backward-compatible
with older versions of Java code.

@menu
* Chicory options::             
@end menu

@node    Chicory options,  , Chicory, Chicory
@subsection Chicory options

Chicory is invoked as follows:
@example
java daikon.Chicory @var{classname} @var{args}
@end example
@noindent
where
@example
java @var{classname} @var{args}
@end example
@noindent
is a valid invocation of Java.

This section lists the optional command-line arguments to Chicory, which
appear before the @var{classname} on the Chicory command line.

@menu
* Program points in Chicory output::  
* Variables in Chicory output::  
* Chicory miscellaneous options::  
@end menu

@node    Program points in Chicory output, Variables in Chicory output, Chicory options, Chicory options
@subsubsection Program points in Chicory output

@c Perhaps explain why --trace-percent doesn't appear here:  it doesn't
@c affect the .decls structure.

This section lists options that control which program points appear in
Chicory's output.



@table @option
@item --ppt-select-pattern=@var{regexp}
Only produce trace output for classes/procedures/program points whose
names match the
given regular expression.  This option may be supplied multiple times,
but it cannot be used in conjunction with @option{--ppt-omit-pattern}.  

When this switch is supplied, filtering occurs in the following way:
for each program point, Chicory checks the fully
qualified class name, the method name, and the
the program point name against each @var{regexp} that
was supplied.  If any of these match, then the program point is included
in the instrumentation.

Suppose that method @code{bar} is defined only in class @code{C}.  Then to 
traces only @code{bar}, you could match the method name (in any class)
with regular expression
@samp{bar$}, or you could match the program point name with @samp{C\.bar\(}.

Using Unix shell syntax, you would execute
@example
java daikon.Chicory --ppt-select-pattern='bar$' ...
java daikon.Chicory --ppt-select-pattern='C\.bar\(' ...
@end example

From the Windows command line, you would execute
@example
java daikon.Chicory --ppt-select-pattern='bar$' ...
java daikon.Chicory --ppt-select-pattern='C\.bar\(' ...
@end example


@item --ppt-omit-pattern=@var{regexp}
Do not produce data trace output for classes/procedures/program points
whose names match the given regular expression.  This
reduces the size of the data trace file and also may make the
instrumented program run faster, since it need not output those variables.

This option works just like @option{--ppt-select-pattern} does, except
that matching program points are excluded, not included.
 
The @option{--ppt-omit-pattern} argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its fully qualified class, procedure name, or
complete program point name matches one of the omitting criteria.


The @option{--ppt-omit-pattern} argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its fully qualified class, fully qualified procedure name, or
complete program point name exactly matches one of the omitting criteria.
A regular expression matches if it matches any portion of the program
point name.  Note that currently only classes are matched, not each full
program point name.  Thus, either all of a class's methods are traced, 
or none of
them are.

Here are examples of how to avoid detecting invariants over various
parts of your program.

@itemize
@item omit a whole package:
@example
java daikon.Chicory '--ppt-omit-pattern=^junit\.'
@end example
@example
java daikon.Chicory '--ppt-omit-pattern=^daikon\.util\..*' ...
@end example

@item omit a single class:
@example
java daikon.Chicory '--ppt-omit-pattern=HashSetLinear\$HslIterator' ...
@end example

@item omit a single method:
@example
java daikon.Chicory '--ppt-omit-pattern=StackAr.topAndPop()' \
     ...
@end example

@item omit a single program point:
@example
java daikon.Chicory '--ppt-omit-pattern=StackAr.<init>(int):::EXIT33' ...
@end example

@end itemize
@end table


@node    Variables in Chicory output, Chicory miscellaneous options, Program points in Chicory output, Chicory options
@subsubsection Variables in Chicory output

@c Perhaps explain why --trace-percent doesn't appear here:  it doesn't
@c affect the .decls structure.

This section lists options that control which variables appear in
Chicory's output.



@table @option


@item --nesting-depth=@var{n}
Depth to which to examine structure components (default 2).
This parameter determines which variables the front end causes to be output at
runtime.  For instance, suppose that a program contained the following
data structures and variables:
@example
class A @{
  int x;
  B b;
@}
class B @{
  int y;
  int z;
@}
A myA;

class Link @{
  int val;
  Link next;
@}
Link myList;
@end example
@itemize @bullet
@item
If depth=0, only the identities (hashcodes) of @code{myA} and
@code{myList} would be examined; those variables could be determined to
be equal or not equal to other variables.
@item
If depth=1, then also @code{MyA.b}, @code{myList.next}, and the integers
@code{myA.x} and @code{myList.val} would be examined.
@item
If depth=2, then also @code{MyA.b.y}, @code{MyA.b.y},
@code{myList.next.next}, and @code{myList.next.val} would be examined.
@end itemize

Values whose value is undefind are not examined.  For instance, if @code{myA}
is @code{null} on a particular execution of a program point, then
@code{myA.b} is not accessed on that execution regardless of the depth
parameter.  That variable appears in the @file{.dtrace} file, but its
value is marked as nonsensical.

@item --std-visibility
@cindex private variables
@cindex variables, private
When this switch is on, Chicory will traverse exactly those fields that are
visible from a given program point.  For instance, only the public
fields of class @code{pack1.B} will be included at a program point for 
class @code{pack2.A} whether or not @code{pack1.B} is instrumented.
By default, Chicory outputs all fields in instrumented classes (even 
those that would not be accessible in Java code at the given program point)
and outputs no fields from uninstrumented classes (even those that are
accessible). When you supply
@option{--std-visibility}, consider also supplying @option{--purity-file} to
enrich the set of expressions in Daikon's output.

@item --purity-file=@var{pure-methods-file}
@cindex pure methods
@cindex observer methods, as synonym for pure methods
File @var{pure-methods-file} lists the pure methods (sometimes called
observer methods) in a Java program.  Pure methods have no externally
side effects, such as setting variables or producing output.  For
example, most implementations of the @code{hashCode()},
@code{toString()}, and @code{equals()} methods are pure.

For each variable, Chicory adds to the trace new ``fields'' that
represent invoking each pure method on the variable.  (Currently,
Chicory does so only for pure methods that take no parameters, and
obviously this mechanism is only useful for methods that return a value:
a pure method that returns no value does nothing!)  

Here is an example:

@example
class Point @{
  private int x, y;
  public int radiusSquared() @{ 
    return x*x + y*y;
  @}
@}
@end example

I @code{radiusSquared()} has been specified as pure, then for each point
@var{p}, Chicory will output the variables @code{@var{p}.x},
@code{@var{p}.y}, and @code{@var{p}.radiusSquared()}.  Use of pure
methods can improve the Daikon output, since they represent information
that the programmer considered important but that is not necessarily
stored in a variable.

Invoking a pure method at any time in an application should not change
the application's behavior.  If a non-pure method is listed in a purity
file, then application behavior can change.  Chicory does not verify the
purity of methods listed in the purity file.

The purity file lists a set of methods, one per line.  The format of
each method is given by the Sun JDK API:
@quotation
The string is formatted as the method access modifiers, if any, followed
by the method return type, followed by a space, followed by the class
declaring the method, followed by a period, followed by the method name,
followed by a parenthesized, comma-separated list of the method's formal
parameter types. If the method throws checked exceptions, the parameter
list is followed by a space, followed by the word throws followed by a
comma-separated list of the thrown exception types. For example:
@example 
public boolean java.lang.Object.equals(java.lang.Object)
@end example
The access modifiers are placed in canonical order as specified by "The
Java Language Specification".  This is public, protected or private
first, and then other modifiers in the following order: abstract,
static, final, synchronized native.
@end quotation

By convention, @var{pure-methods-file} has the suffix @file{.pure}.  If
@var{pure-methods-file} is specified as a relative (not absolute) file
name, it is searched for in the configuration directory specified via
@option{--configs=@var{directory}}, or in the current directory if no
configuration dirctory is specified.

@item --avoid-static-recursion
If this switch is on, Chicory will traverse the static fields of a given class
at most once.

Given this code:
@example
class A @{
   private static int x, y;
   private static A a = new A();
@}
@end example

Then if this switch is on, and a program point contains variable
@code{myA} of type @code{A}, then Chicory will produce variables
@code{myA.x}, @code{myA.y}, @code{myA.A}, but not @code{myA.A.x},
@code{myA.A.y}, @code{myA.A.A} and so on.

@end table

@node    Chicory miscellaneous options,  , Variables in Chicory output, Chicory options
@subsubsection Chicory miscellaneous options

This section lists all other Chicory options --- that is, all options
that do not control which program points and variables appear in
Chicory's output.

@table @option
@item --help
Print a help message.

@item --debug
Produce debugging information.

@item --trace-percent=@var{percent}
If this switch is on, then Chicory only produces output for the
specified percentage of all program point executions.  For each method,
output is produced for the given fraction of its executions.  the
randomization is applied only to entry program points; an exit program
point is included if and only if its corresponding entry program point
is included.  

@item --dtrace-file=@var{filename}
@cindex DTRACEFILE environment variable
@cindex environment variable DTRACEFILE
@cindex DTRACEAPPEND environment variable
@cindex environment variable DTRACEAPPEND
@cindex trace file name
@cindex dtrace file name
@cindex file name, for dtrace file
Specifies the default name for the trace output (@file{.dtrace}) file.
If this is not specified, then the value of the @env{DTRACEFILE}
environment variable (at the time the instrumented program runs) is
used.  If that environment variable is not used, then the default is
@file{./@var{CLASSNAME}.dtrace}.

If the @env{DTRACEAPPEND} environment
variable is set to any value, the dtrace file will be appended to
instead of overwritten.  Compressed data trace files may not be appended
to.  In some cases you may find a single large data trace file more
convenient; in other cases, a collection of smaller data trace files may
give you more control over which subsets of runs to invoke Daikon on.

@item --output-dir=@var{directory}
Write the @file{.dtrace} trace output file to the specified directory.
The default is the current directory.

@item --config-dir=@var{directory}
Chicory will use this location to search for configuration files.
Currently, this only includes @file{*.pure} files.

@item --daikon
@itemx --daikon=@var{args}
After creating a data trace (@file{.dtrace}) file, run Daikon on it,
passing the specified arguments, if any, to Daikon.  Also see the
@option{--daikon-online} option.

This option supplies Daikon with a single trace from one execution of
your program.  By contrast to this option (and
@option{--daikon-online}), if you invoke Daikon from the command line,
you can supply Daikon with as many trace files as you wish.

@item --daikon-online
@itemx --daikon-online=@var{args}
This option is like @option{--daikon}, except that no @file{.dtrace}
data trace file is produced.  Instead, Chicory sends trace information
over a socket to Daikon, which processes the information incrementally
(``online''), as Chicory produces it.

Just like with the @option{--daikon} option, Daikon is only given a
single trace from one execution of your program.

@item --premain=@var{path}
Specifies the absolute pathname to the @file{ChicoryPremain.jar} file.
Chicory requires this jar file in order to execute.  By default Chicory
looks for the jar file in the classpath and in @file{$(DAIKONDIR)/java}
(where @file{DAIKONDIR} is an environment variable that points to the
complete installation of Daikon).  

Chicory can also use the @file{daikon.jar} file for this purpose.  If it
doesn't find @file{ChicoryPremain.jar} above, it will use @file{daikon.jar}
itself (if a file named @file{daikon.jar} appears in the classpath).  If
the Daikon jar file is not named @file{daikon.jar}, you can use this
switch to specify its name.  For example:
@example
--premain=C:\lib\daikon-4.1.3.jar
@end example

@item --heap-size=@var{max_heap}
Specifies the maximum size, in bytes, of the memory allocation pool for
the target program.  The size is specified in the same manner as the
-Xmx switch to java.

@end table




@node Kvasir, Mangel-Wurzel, Chicory, Front ends
@section C front end Kvasir

@cindex Kvasir (binary front end for C)
@cindex front end for C
@cindex C front end

Daikon's front end for C, named Kvasir, executes C (and a reasonable subset 
of C++) programs and creates  
data trace (@file{.dtrace}) files of variables and their values by
examining the operation of the binary at 
runtime.  Kvasir is named after the Norse god of knowledge and beet juice.

To use Kvasir, first compile your program using the DWARF-2 debugging
format (e.g., supply the @option{-gdwarf-2} option to @command{gcc}) and
without optimizations (e.g., supply the @option{-O0} option to @command{gcc}).
Then, prefix your command line by @command{kvasir-dtrace}.  For example, 
if you normally run your program with the command 
@example
./program -option input.file
@end example
@noindent
then instead use the command
@example
kvasir-dtrace ./program -option input.file
@end example
@noindent
to run your program and create a data trace file
@file{daikon-output/program.dtrace}, which can be fed as input into
Daikon.
You can also run Daikon without creating an intermediate data trace
file; see @ref{Online execution}.

For information about installing Kvasir, see @ref{Installing Kvasir}.
Kvasir only works under Linux running on an x86 processor; for full
details, see @ref{Kvasir limitations}.
For information about how to create an instrumenter for C that works on
non-Linux or non-x86 platforms, see @ref{Instrumenting C
programs,,,./developer,Daikon Developer Manual}.

@menu
* Using Kvasir::                
* Kvasir options::              
* DynComp dynamic comparability analysis::  
* Tracing only part of a program::  
* Pointer type disambiguation::  
* Online execution::            
* Installing Kvasir::           
* Kvasir limitations::          
@end menu

@node Using Kvasir, Kvasir options, Kvasir, Kvasir
@subsection Using Kvasir

Before using Kvasir, you must compile your program without optimization,
and with the DWARF-2 format of debugging information.
DWARF-2 is the default format for debugging information in GCC 3, and
otherwise is produced by supplying the
@option{-gdwarf-2} command line option.
Also, remove any optimization flags, such as @option{-O} or @option{-O2},
and any flags that affect calling conventions, such as
@option{-fomit-frame-pointer}.  Except for these changes, you should be
able to compile and link your program normally.

In the second step of using Kvasir, run your program as you normally
would, but prepend the command @command{kvasir-dtrace} to the beginning.
For instance, if you normally run your program with the command 
@example
./program -option input.file
@end example
@noindent
just say
@example
kvasir-dtrace ./program -option input.file
@end example
@noindent
As well as running your program (more slowly than usual), this command
also creates a directory @file{daikon-output} in the current
directory containing a @file{program.dtrace} file suitable as input to Daikon.

A number of options to Kvasir may be supplied on the command line
before the argument that is the name of your program (@pxref{Kvasir options}).


@node Kvasir options, DynComp dynamic comparability analysis, Using Kvasir, Kvasir
@subsection Kvasir options

To see a complete list of options, run this command: @command{kvasir-dtrace --help}

Output file format:

@table @option

@item --decls-file=@var{filename}

Write the @file{.decls} file listing the names of functions and
variables (called declarations) to the specified file name.  This forces
Kvasir to generate separate
@file{.decls} and @file{.dtrace} files instead of outputting everything to the 
@file{.dtrace} file, which is the default behavior.    If only a @file{.dtrace} file is
created (default behavior), then it contains both variable declarations and a trace of
values.  If separate @file{.decls} and @file{.dtrace} files are created,
then the @file{.decls} file contains declarations and the @file{.dtrace}
file contains the trace of values.

@item --decls-only

Exit after writing the @file{.decls} file; don't run the program or
generate trace information.  Since the @file{.decls} file is the same for
any run of a program, it can be generated once and then reused on later
runs, as long as no new program points are added and each program point
has the same set of variables.

@item --dtrace-file=@var{filename}

Write the @file{.dtrace} trace file to the specified file name.  The default is
@file{daikon-output/@var{programname}.dtrace}, where @var{programname}
is the name of the program.  A filename of @file{-} may be used to
specify the standard output; in this case, the regular standard output
of the program will be redirected back to the terminal (@file{/dev/tty}), to avoid
intermixing it with the trace output.  If the given filename ends in
@file{.gz}, then @option{--dtrace-gzip} is enabled and the
@file{.dtrace} file will be compressed.

@item --dtrace-no-decs

By default, the @file{.dtrace} file contains both a list of variable
declarations followed by a trace of variable values (@pxref{File
formats}).  If this option is used, then variable declarations are not
outputted in the .dtrace file.  This option is equivalent to
@option{--decls-file=/dev/null}, except that it runs faster.  This is
useful when you want to generate one copy of the declarations in the
.decls file using @option{--decls-only}, generate many
@file{.dtrace} files from different program runs, and then feed 1
@file{.decls} and several @file{.dtrace} files into Daikon.

@item --dtrace-append

Append new trace information to the end of an existing @file{.dtrace}
file.  The default is to overwrite a pre-existing @file{.dtrace} file.
When this option is used, no declaration information is written because
it is assumed that the existing .dtrace file already contains all
declarations (Daikon does not accept duplicate declarations).

@item --dtrace-gzip

Compress trace information with the gzip program before writing
it to the @file{.dtrace} file.  You must have the gzip program
available.

@item --output-fifo

Create the output @file{.decls} and @file{.dtrace} files as FIFOs (also
known as ``named pipes'').  Kvasir will then open first the @file{.decls}
FIFO and then the @file{.dtrace} FIFO, blocking until another program
(such as Daikon) reads from them.  Using FIFOs for the output of Kvasir
avoids the need for large trace files, but FIFOs are not supported by
some file systems, including AFS@.

@item --program-stdout=@var{filename}
@itemx --program-stderr=@var{filename}

Redirect the standard output (respectively, standard error) stream of the
program being traced to the specified path.  By default, the standard
output and standard error streams will be left pointing to the same
locations specified by the shell, except that if @option{--dtrace-file=-}
is specified, then the default behavior is as if
@option{--program-stdout=/dev/tty} were specified, since mixing the
program's output and Kvasir's trace output is not advisable.
If the same filename is given for both options, the streams will be
interleaved in the same way as if by the Bourne shell construction
@code{2>&1}.

Also, as in the shell, @var{filename} can be an ampersand followed by an
integer, to redirect to a numbered file descriptor.  For instance, to
redirect the program's standard output and error, and Kvasir's standard
error, to a single file, you can say @option{--program-stdout='&2'
--program-stderr='&2' 2>@var{filename}}.

@end table

Selective program point and variable tracing:

@table @option


@item --ppt-list-file=@var{filename}
@itemx --var-list-file=@var{filename}

Trace only the program points (respectively, variables) listed in the
given file.  Other program points (respectively variables) will be
omitted from the @file{.decls} and @file{.dtrace} files.  A convenient
way to produce such files is by editing the output produced by the
@option{--dump-ppt-file} (respectively, @option{--dump-var-file}) option
described above.  (@pxref{Tracing only part of a program} section
for detailed instructions on using these options.)

@item --dump-ppt-file=@var{filename}
@itemx --dump-var-file=@var{filename}

Print a list of all the program points (respectively all the variables)
in the program to the specified file.  An edited version of this file can
then be used with the @option{--ppt-list-file} (respectively
@option{--var-list-file}) option.
(@pxref{Tracing only part of a program} section
for detailed instructions on using these options.)
Note: Do not use these options with the
@option{--with-dyncomp} option because the behavior is undefined.
Running Kvasir with these 
options will initialize but not actually execute the target program, so
the dynamic comparability analysis cannot be performed in the first
place.

@item --ignore-globals

Omit any global or static variables from the @file{.decls} and
@file{.dtrace} files.  Leaving these out can significantly improve Kvasir
and Daikon's performance, at the expense of missing properties involving
them.  The default is to generate trace information for 
global and static variables.

@item --ignore-static-vars

Omit any static variables but generate trace information for 
global variables in the  @file{.decls} and @file{.dtrace} files.

@item --limit-static-vars

Limits the output of static variables in the @file{.decls} and
@file{.dtrace} files.  File-static variables are only observed at
program points for functions which belong to the same file as the
variable.  Static variables declared within a particular function are
only observed at program points for that function.  This is a
heuristic to reduce the amount of Kvasir output without greatly
reducing the amount of useful output.

@end table

@ref{Pointer type disambiguation}:

@table @option

@item --disambig-file=@var{filename}
Specifies the name of the pointer type disambiguation file 
(@pxref{Pointer type disambiguation}).
If this file exists, Kvasir uses it to make decisions about how 
to output the referents of pointer variables.  If the file does not exist, 
then Kvasir creates it.  This file may then be edited and used on
subsequent runs. This option initializes but does not fully execute the
target program (unless it is run with the @option{--smart-disambig}
option).

@item --disambig
Tells Kvasir to create or read pointer type disambiguation 
(@pxref{Pointer type disambiguation}) with the default filename, 
which is @file{@var{myprog}.disambig} in the same
directory as the target program, where @var{myprog} is the name of the 
target program. This is equivalent to 
@samp{--disambig-file=@file{@var{myprog}.disambig}}.

@item --smart-disambig
This option should be used in addition to either the @option{--disambig}
or @option{--disambig-file} options (it does nothing by itself).  If the
.disambig file specified by the option does not exist, then Kvasir
executes the target program, observes whether each pointer refers to
either one element or an array of elements, and creates a disambiguation
file that contains suggestions for the disambiguation types of each
pointer variable.  This potentially provides more accuracy than using
either the @option{--disambig} or @option{--disambig-file} options alone,
but at the expense of a longer run time.  (If the .disambig file already
exists, then this option provides no extra functionality.)

@item --func-disambig-ptrs
By default, Kvasir treats all pointers as arrays when outputting their
contents.  This option forces Kvasir to treat function parameters and
return values that are pointers as pointing to single values.  However,
all pointers nested inside of data structures pointed-to by parameters
and return values are still treated as arrays.  This is useful for
outputting richer data information for functions that pass parameters or
return values via pointers, which happens often in practice.

@item --disambig-ptrs
By default, Kvasir treats all pointers as arrays when outputting their
contents.  This option forces Kvasir to treat all pointers as pointing to
single values.  This is useful when tracing nested structures with lots
of pointer fields which all refer to one element.

@end table

@ref{DynComp dynamic comparability analysis}:

@table @option

@item --with-dyncomp

Run Kvasir with the DynComp dynamic
comparability analysis tool to generate .decls files with variable
comparability information in the format specified in the @ref{Program
point declarations} section.  Variable comparability information can
speed up the performance of Daikon and allow it to generate a more
focused and relevant set of invariants.  This option may be used
concurrently with @option{--decls-only} to only generate a .decls file
without .dtrace.

@item --no-dyncomp-gc

By default, DynComp runs with a garbage collector for the tag metadata
that it uses, but this can cause your program to slow down if it runs
too often.  This option turns off the garbage collector.  This is not
recommended for long program runs, because without the garbage
collector, it will likely run out of memory.

@item --gc-num-tags=@var{N}

The DynComp garbage collector runs once after every 10,000,000 tags have
been assigned.  This option tells the garbage collector to run once
after every @var{N} tags have been assigned.  Making the value of
@var{N} larger allows your program to run faster (because the garbage
collector runs less frequently), but may cause your program to run out
of memory as well.  Making the value of @var{N} too small may cause your
program to never terminate if @var{N} is smaller than the total number
of tags that your program uses in steady state.  You will probably need
to experiment with tweaking this value in order to get DynComp to work
properly.

@item --dyncomp-fast-mode

This option applies an approximation for handling literal values which
greatly speeds up the performance of DynComp and drastically lowers its
memory usage, but at the expense of a slight loss in precision of the
generated comparability sets.  If you cannot get DynComp to successfully
run on a large program, even after tweaking @option{--gc-num-vars}, try
turning on this option.

@item --separate-entry-exit-comp

The default behavior for DynComp is to generate the same comparability
numbers for Daikon variables at each pair of function entrance and exit
program points.  If this option is used, then DynComp keeps track of
comparability separately for function entrances and exits, which can
lead to more accurate results, but sometimes generates output .decls
files that Daikon cannot accept.

@end table

Misc. options:

@table @option

@item --flatten-arrays
This option forces the flattening of statically-sized arrays into
separate variables, one for each element.  For example, an array
@var{foo} of size 3 would be flattened into 3 variables: @var{foo[0]},
@var{foo[1]}, @var{foo[2]}.  By default, Kvasir flattens
statically-sized arrays only after is has already exhausted the one
level of sequences that Daikon allows in the .dtrace output format
(e.g. an array of structs where each struct contains a statically-sized
array).

@item --output-struct-vars
This option forces Kvasir to output .decls and .dtrace entries for
struct variables.  By default, Kvasir ignores struct variables because
there is really no value that can be meaningfully associated with these
variables.  However, some tools require struct variables to be
outputted, so we have included this option.  Struct variables are
denoted by a @code{# isStruct=true} annotation in their declarations.

@item --bit-level-precision

When activated, forces more stringent checking of value validity on the
bit-level, which in some cases could result in more accurate output at
the expense of speed.  This is useful when your program performs
lots of bit-level operations, but is unnecessary for most programs.
(Note: If you have trouble getting floating point values to print out
properly, try this option.  It seems to work well in practice.)
This option is fairly untested at the moment.

@item --nesting-depth=@var{N}

For recursively-defined structures (structs or classes with members that
are structs or classes or pointers to structs or classes of @emph{any} type), 
@var{N} (an integer between 0 and 100) specifies approximately how many levels
of pointers to dereference.  This is useful for controlling the output
of complex data structures with many references to other structures.
The default is 2.

@item --struct-depth=@var{N}

For recursively-defined structures (structs or classes with members that
are pointers to the @emph{same} type of struct or class),
@var{N} (an integer between 
0 and 100) specifies approximately how many levels of pointers to dereference. 
This is useful for controlling the output of linked lists and trees. 
The default is 2.  If you are trying to traverse deep into data
structures, try adjusting the @option{--struct-depth} and
@option{--total-depth} options until Kvasir traverses deep enough to
reach the desired variables.

@end table

Debugging:

@table @option

@item --asserts-aborts

Enable Kvasir's internal consistency checks.  By default, they are
disabled.

@item --debug
@itemx --dyncomp-debug

Enable progress messages meant for debugging problems with Kvasir or
DynComp.  By default, they are disabled.  This option is intended mainly
for Kvasir's developers.

@end table

@node    DynComp dynamic comparability analysis, Tracing only part of a program, Kvasir options, Kvasir
@subsection DynComp dynamic comparability analysis

Kvasir comes with the DynComp dynamic comparability analysis tool, which
performs dynamic type inference to group variables at each program point
into comparability sets (see @ref{Program point declarations} for the
numeric representation format of these sets).  All variables in each
comparability set belong to the same ``abstract type'' of data that the
programmer likely intended to represent, which is a richer set of types
than the few basic declared types (e.g., int, float) provided by the
language.  Consider the example below:

@example
int main() @{
  int year = 2005;
  int winterDays = 58;
  int summerDays = 307;
  compute(year, winterDays, summerDays);
@}

int compute(int yr, int d1, int d2) @{
  if (yr % 4)
    return d1 + d2;
  else
    return d1 + d2 + 1;
@}
@end example

The three variables in @code{main()} all have the same C representation
type, @code{int}, but two of them hold related quantities (numbers of
days), as can be determined by the fact that they interact when the
program adds them, whereas the other contains a conceptually distinct
quantity (a year).  The abstract types 'day' and 'year' are both
represented as @code{int}, but DynComp can differentiate them with its
dynamic analysis.  For example, DynComp can infer that @code{winterDays}
and @code{summerDays} are comparable (belong to the same abstract type)
because the program adds their values together within the
@code{compute()} function.

Without comparability information, Daikon attempts to find invariants
over all pairs (and sometimes triples) of variables present at every
program point.  This can lead to two negative consequences: First, it
may take lots of time and memory to infer all of these invariants,
especially when there are many global or derived variables present.
Second, many of those invariants are true but meaningless because they
relate variables which conceptually represent different types (e.g., an
invariant such as @code{winterDays < year} is true but meaningless
because days and years are not comparable).

Use the @option{--with-dyncomp} option to run Kvasir with DynComp to
generate a @file{.decls} file with comparability information along with
the usual value trace in the @file{.dtrace} file.  Using
@option{--decls-only} will only generate the @file{.decls} file without
the extra slowdown of writing the @file{.dtrace} file to disk (however,
because DynComp must execute the entire program to perform its analysis,
the only time saved is I/O time).  Other DynComp options are listed in
the @ref{Kvasir options} section.  Running Kvasir with DynComp takes
more memory and longer time than running Kvasir alone, but remember that
DynComp only needs to be run once to generate a @file{.decls} file with
comparability information. That one file can be passed into Daikon along
with many different @file{.dtrace} files generated during subsequent
Kvasir runs without DynComp.

Here is part of the @file{.decls} file generated by running Kvasir with
DynComp on the above example:

@example
DECLARE
..compute():::ENTER
yr
int # isParam=true
int
1
d1
int # isParam=true
int
2
d2
int # isParam=true
int
2

DECLARE
..compute():::EXIT0
yr
int # isParam=true
int
1
d1
int # isParam=true
int
2
d2
int # isParam=true
int
2
return
int
int
2
@end example

The abstract type of 'year' (and its corresponding comparability set) is
represented by the number 1 while the abstract type of 'day' is
represented by the number 2.  DynComp places two variables in the same
comparability set when their values interact via program operations such
as arithmetic or assignment.  Because the parameters @code{d1} and
@code{d2} were added together, DynComp inferred that those variables
were somehow related and put them in the same comparability set.  The
return value is also related to @code{d1} and @code{d2} because it is
the result of the addition operation.  Notice that @code{yr} never
interacts with any other variables, so DynComp places it into its own
comparability set.  With this comparability information, Daikon will
never attempt to find invariants between @code{yr} and
@code{d1}/@code{d2}, which both saves time and memory and eliminates
meaningless invariants (the savings are miniscule in this trivial
example, but they can be rather dramatic in larger examples).

@node    Tracing only part of a program, Pointer type disambiguation, DynComp dynamic comparability analysis, Kvasir
@subsection Tracing only part of a program

When Kvasir is run on a target program of significant size, often times
too much output is generated, which causes an enormous performance
slowdown of both Kvasir outputting the trace file and also Daikon trying
to process the trace file.  It is often desirable to only trace a
specific portion of the target program, program points and variables
that are of interest for a particular invariant detection application.
For instance, one may only be interested in tracking changes in a
particular global data structure during calls to a specific set of
functions (program points), and thus have no need for information about
any other program points or variables in the trace file.  The
@option{--ppt-list-file} and @option{--var-list-file} options can be
used to achieve such selective tracing.

The program point list file (abbreviated as @file{ppt-list-file})
consists of a newline-separated list of names of functions that the
user wants Kvasir to trace.  Every name corresponds to both the entrance
(@code{:::ENTER}) and exit (@code{:::EXIT}) program points for that function
and is printed out in the exact same format that Kvasir
uses for that function in the trace file (@pxref{Using Kvasir}
section for the program point naming scheme).  In the special case of
certain C++ functions, Kvasir needs to have the mangled versions of the
names in order to optimize the performance of selective tracing.  Those
entries are listed in the @file{ppt-list-file} as three space-delimited
tokens: The string literal ``@code{(mangled)}'', the C++ mangled name,
and the actual name that Kvasir outputs to the trace file.  Here is an
example of a @file{ppt-list-file} which contains both regular and C++
names:

@example
FunctionNamesTest.cpp.staticFoo()
(mangled) _Z17firstFileFunctioni ..firstFileFunction(int)
..main()
second_file.cpp.staticFoo()
(mangled) _Z18secondFileFunctionv ..secondFileFunction()
@end example

It is very important to follow this format in the @file{ppt-list-file}
because Kvasir performs string comparisons to determine which program
points to trace.  Thus, it is often easier to have Kvasir generate a
@file{ppt-list-file} file that contains a list of all program points in a
target program by using the @option{--dump-ppt-file} option, and then
either comment out (by using the @code{'#'} comment character at the
beginning of the line) or delete lines in that file for program points
not to be traced or create a new @file{ppt-list-file} using the names in
the Kvasir-generated file.  This prevents typos and the tedium of
manually typing up program point names (which is nearly impossible in
the case of mangled C++ names).  In fact, the @file{ppt-list-file}
presented in the above example was generated from a C++ test program named
@code{FunctionNamesTest} by using the following command:

@example
kvasir-dtrace --dump-ppt-file=FunctionNamesTest.ppts  ./FunctionNamesTest
@end example

That file represents all the program points that Kvasir would
normally trace.  If the user wanted to only trace the @code{main()}
function, he could comment out all other lines by placing a single
@code{'#'} character at the beginning of each line to be commented out,
as demonstrated here:

@example
#FunctionNamesTest.cpp.staticFoo()
#(mangled) _Z17firstFileFunctioni ..firstFileFunction(int)
..main()
#second_file.cpp.staticFoo()
#(mangled) _Z18secondFileFunctionv ..secondFileFunction()
@end example
@noindent
When running Kvasir with the @option{--ppt-list-file} option using this
as the @file{ppt-list-file}, Kvasir only stops the execution of the target program at the
entrance and exit of @code{main()} in order to output values to the
.dtrace file.  In order to reduce the file size, when running Kvasir
with the @option{--ppt-list-file} option, the .decls file only contains
program point declarations for those listed in the @file{ppt-list-file}
(@code{..main():::ENTER} and @code{..main():::EXIT} in this case) because
no other declarations are necessary.

The variable list file (abbreviated as @file{var-list-file}) contains
all of the variables that the user wants Kvasir to output.  There is one
section for global variables and a section for variables associated with
each function (formal parameters and return values).  Again, the best way to
create a @file{var-list-file} is to have Kvasir generate a file with all
variables using the @option{--dump-var-file} option and then modifying
that file for one's particular needs by either deleting or
commenting out lines (again using the @code{'#'} comment character).  For example,
executing

@example
kvasir-dtrace --dump-var-file=FunctionNamesTest.vars  ./FunctionNamesTest
@end example

@noindent
will generate the following @file{var-list-file} named
@code{FunctionNamesTest.vars}:

@example
----SECTION----
globals
/globalIntArray
/globalIntArray[]
/anotherGlobalIntArray
/anotherGlobalIntArray[]


----SECTION----
FunctionNamesTest.cpp.staticFoo()
x
y


----SECTION----
..firstFileFunction(int)
blah


----SECTION----
..main()
argc
argv
argv[]
return


----SECTION----
second_file.cpp.staticFoo()
x
y


----SECTION----
..secondFileFunction()
@end example

The file format is quite straightforward.  Each section is marked by a
special string ``@code{----SECTION----}'' on a line by itself followed
immediately by a line that either denotes the program point name
(formatted like how it appears in the .decls and .dtrace files) or the
special string ``@code{globals}''.  This is followed by a
newline-delimited list of all variables to be outputted for that
particular program point.  (Global variables listed in the
@code{globals} section are outputted for all program points.)
For clarity, one or more blank lines should separate neighboring sections,
although the ``@code{----SECTION----}'' string literal on a line by itself is the only
required delimiter.  If an entire section is missing, then no variables
for that program point (or no global variables, if it is the special
global section) are traced.

The variables listed in this file are written exactly as they appear in
the .decls and .dtrace file (@pxref{Using Kvasir} section
for the variable naming scheme).  In the program that generated the
output for the above example, @code{int*
globalIntArray} is a global integer pointer variable.  For that
variable, Kvasir generates two Daikon variables: @code{/globalIntArray}
to represent the hashcode pointer value, and @code{/globalIntArray[]} to
represent the array of integers referred-to by that pointer.  The
latter is a derived-variable that can be thought of as the child of
@code{/globalIntArray}.  If the entry for @code{/globalIntArray} is
commented-out or missing, then Kvasir will not output any values for
@code{/globalIntArray} or for any of its children, which in this case is
@code{/globalIntArray[]}.  If a struct or struct pointer variable is
commented-out or missing, then none of its members are traced.  Thus, a
general rule about variable entries in the @file{var-list-file} is that
if a parent variable is not present, then neither it nor its children
are traced.

@example

record
record->entries[1]
record->entries[1]->list
record->entries[1]->list->head
record->entries[1]->list->head->magic

@end example

For example, if you wanted to trace the value of the @code{magic} field
nested deep within several layers of structs and arrays, it would not be
enough to merely list this variable in the @file{var-list-file}.  You
would need to list all variables that are the parents of this one, as
indicated by their names.  This can be easily accomplished by creating a
file with @option{--dump-var-file} and cutting out variable entries,
taking care to not cut out entries that are the parents of entries that
you want to trace.

In order to limit both the number of program points traced as well as
the variables traced at those program points, the user can run Kvasir
with both the @option{--ppt-list-file} and @option{--var-list-file}
options with the appropriate @file{ppt-list-file} and
@file{var-list-file}, respectively.  The @file{var-list-file} only needs
to contain a section for global variables and sections for all program
points to be traced because variable listings for program points not to
be traced are irrelevant (their presence in the @file{var-list-file}
does not affect correctness but does cause an unnecessary
performance and memory inefficiency).

If the @option{--dump-var-file} option is used in conjunction with the
@option{--ppt-list-file} option, then the only sections generated in the
@file{var-list-file} will be the global section and sections for all
program points explicitly mentioned in the @file{ppt-list-file}.  This
is helpful for generating a smaller @file{var-list-file} for use with an
already-existent @file{ppt-list-file}.

@node    Pointer type disambiguation, Online execution, Tracing only part of a program, Kvasir
@subsection Pointer type disambiguation

@cindex pointer type disambiguation
@cindex disambiguation of pointer types

Kvasir permits users (or external analyses) to specify whether pointers
refer to arrays or to single values, and optionally, to specify the type
of a pointer (@pxref{Pointer type coercion}).  For example, in
@example
void sum(int* array, int* result) @{ ... @}  // definition of "sum"
...
int a[40];
int total;
...
sum(a, &total);        // use of "sum"
@end example
@noindent
the first pointer parameter refers to an array while the second refers to
a single value.  Kvasir (and Daikon) should treat these values
differently.  For instance, @code{*array} is better printed as @code{array[]}, 
an array of integers, and @code{result[]} isn't a sensible array 
at all, even though in C @code{result[0]} is semantically identical to 
@code{*result}.
By default, Kvasir treats all pointers as referencing arrays.  For
instance, it would print @code{result[]} rather than @code{result[0]}
and would indicate that the length of array @code{result[]} is always 1.
In order to improve the formatting of Daikon's output (and to speed it
up), you can indicate to Daikon that certain pointers refer to single
elements rather than to arrays.
For an example, see @ref{Pointer type disambiguation example}).

Information about whether each pointer refers to an array or a single
element can be specified in a ``disambig file'' that resides in the
same directory as the target program (by default).  The @option{--disambig} 
option instructs Kvasir to read this file if it exists.  (If it does not exist, 
Kvasir produces the file automatically and, if invoked along with the
@option{--smart-disambig} option, heuristically infers whether each 
pointer variable refers to single or multiple elements. Thus, users can
edit this file for use on subsequent runs rather than having to create it 
from scratch.)  The disambig file lists all the program points and user-defined 
types, and under each, lists certain types of variables along with their 
custom disambiguation types as shown below.  
The list of disambiguation options is:

@enumerate
@item
For variables of type @code{char} and @code{unsigned char}:
@enumerate
@item
'I': an integer, signed for @code{char} and unsigned for @code{unsigned char}. (Default)
@item
'C': a single character, output as a string.
@end enumerate
@item
For pointers to (or arrays of) @code{char} and @code{unsigned char}:
@enumerate
@item
'S': a string, possibly zero-terminated. (Default)
@item
'C': a single character, output as a string.
@item
'A': an array of integers.
@item
'P': a single integer.
@end enumerate
@item 
For pointers to (or arrays of) all other variable types (if invoked
along with @option{--smart-disambig}, Kvasir automatically infers a default 'A' or 'P' for each variable during the generation of a @file{.disambig} file):
@enumerate
@item
'A': an array.  (Default) (For an array of structs, an array will be output for each scalar field of the struct.  Aggregate children (arrays, other structs) will not be output.)
@item
'P': a pointer to a single element.  (For a pointer to a struct, each
field will be output as a single instance, and child aggregate types
will be output recursively. This extra information obtained from struct
pointers is a powerful consequence of pointer type disambiguation.  This
will be the default if the @option{--disambig-ptrs} option is used.)
@end enumerate
@end enumerate

The disambig file that Kvasir creates contains a section for each
function, which can be used to disambiguate parameter variables visible
at that function's entrance program point and parameter and return
value variables visible at that function's exit program point.  It also contains
a section for every user-defined 
struct/class, which can be used to disambiguate member variables of
that struct/class.  Disambiguation information entered here will apply to all
instances of a struct/class of that type, at all program points.
There is also a section called ``globals'', which disambiguates global
variables which are output at every program point.  The entries in the
disambig file may appear in any order, and whole entries or individual
variables within a section may be omitted.  In this case, Kvasir will
retain their default values.


@menu
* Pointer type coercion::       
* Pointer type disambiguation example::  
* Using pointer type disambiguation with partial program tracing::  
@end menu

@node    Pointer type coercion, Pointer type disambiguation example, Pointer type disambiguation, Pointer type disambiguation
@subsubsection Pointer type coercion

In addition to specifying whether a particular pointer refers to one
element or to an array of elements, the user can also specify what type
of data a pointer refers to.  This type coercion acts like an explicit
type cast in C, except that it only works on struct/class types and not
on primitive types.  This feature is useful for traversing inside of
data structures with generic @code{void*} pointer fields.  Another use
is to cast a pointer from one that refers to a 'super class' to one that
refers to a 'sub class'.  This structural equivalence pattern is often
found in C programs that emulate object orientation.  To coerce a
pointer to a particular type, simply write the name of the struct type
after the disambiguation letter (e.g., A, P, S, C, I) in the
@file{.disambig} file:

@example
----SECTION----
function: ..view_foo_and_bar()
f
P foo
b
P bar
@end example

Without the type coercion, Kvasir cannot print out anything except for a
hashcode for the two @code{void*} parameters of this function:

@example
void view_foo_and_bar(void* f, void* b);
@end example

With type coercion, though, Kvasir treats @code{f} as a @code{foo*} and
@code{b} as @code{bar*} and can traverse inside of them.  Of course, if
those are not the true runtime types of the variables, then Kvasir's
output will be meaningless.

Due to the use of typedefs, there may be more than one name for a
particular struct type.  The exact name that you need to write in the
@file{.disambig} file is the one that appears in that file after the
@code{usertype} prefix.  Note that if a struct does not have any pointer
fields, then there will be no @code{usertype} section for it in the
@file{.disambig} file.  In that case, try different names for the struct
if necessary until Kvasir accepts the name (names are all one word long;
you will never have to write @code{struct foo}).  There should only be
at most a few choices to make.  If the coercion if successful, Kvasir
prints out a message in the following form while it is processing the
@file{.disambig} file:

@example
  .disambig: Coerced variable f into type 'foo'
  .disambig: Coerced variable b into type 'bar'
@end example

One more caveat about type coercion is that you can currently only
coerce pointers into types that at least one variable in the program
(e.g., globals, function parameters, struct fields) belongs to.  It is
not enough to merely declare a struct type in your source code; you must
have a variable of that type somewhere in your program.  This is a
limitation of the current implementation, but it should not matter most
of the time because programs rarely have struct declarations with no
variables that belong to that type.  If you encounter this problem, you
can simply create a global variable of a certain type to make type
coercion work.

@node    Pointer type disambiguation example, Using pointer type disambiguation with partial program tracing, Pointer type coercion, Pointer type disambiguation
@subsubsection Pointer type disambiguation example

This example demonstrates the power of pointer type disambiguation in creating 
more accurate Daikon output.  Consider this file:

@example
struct record @{
  char* name;     // Initialize to: "Daikon User"
  int numbers[5]; // Initialize to: @{5, 4, 3, 2, 1@}
@};

void foo(struct record* bar) @{
  int i;
  for (i = 0; i < 5; i++) @{
    bar->numbers[i] = (5 - i);
  @}
@}
     
int main() @{
  char* myName = "Daikon User";
  struct record baz;
  baz.name = myName;
  foo(&baz);
@}
@end example

In @code{foo()}, @code{bar} is a pointer to a  @code{record} struct.  By inspection, it is 
evident that in this program, @code{bar} only refers to one element: @code{&baz} 
within @code{main}.  However, by default, Kvasir assumes that @code{bar} is an 
array of @code{record} structs since a C pointer contains no information about 
how many elements it refers to.  Because Kvasir must output @code{bar} as an 
array and @w{@code{bar->numbers}} is an array of integers, it ``flattens'' 
@w{@code{bar->numbers}} into 5 separate arrays named @w{@code{bar->numbers[0]}}
through @w{@code{bar->numbers[4]}} 
and creates fairly verbose output.  This is a direct 
consequence of the fact that Daikon can only handle one layer of sequences 
(it cannot handle arrays within arrays, i.e., multi-dimensional arrays).

Here is part of the Daikon output for this program:

@example
===========================================================================
..foo():::ENTER
bar has only one value
bar[].name == [Daikon User]
bar[].name elements == "Daikon User"
===========================================================================
..foo():::EXIT
size(bar[]).numbers[0] == size(bar[]).numbers[0][0]
size(bar[]).numbers[0] == size(bar[]).numbers[1]
size(bar[]).numbers[0] == size(bar[]).numbers[1][0]
size(bar[]).numbers[0] == size(bar[]).numbers[2]
size(bar[]).numbers[0] == size(bar[]).numbers[2][0]
size(bar[]).numbers[0] == size(bar[]).numbers[3]
size(bar[]).numbers[0] == size(bar[]).numbers[3][0]
size(bar[]).numbers[0] == size(bar[]).numbers[4]
size(bar[]).numbers[0] == size(bar[]).numbers[4][0]
bar[].name == [Daikon User]
bar[].name elements == "Daikon User"
bar[].numbers[0] contains no nulls and has only one value, of length 1
bar[].numbers[0] elements has only one value
bar[].numbers[0][0] == [5]
bar[].numbers[0][0] elements == 5
bar[].numbers[1] contains no nulls and has only one value, of length 1
bar[].numbers[1] elements has only one value
bar[].numbers[1][0] == [4]
bar[].numbers[1][0] elements == 4
bar[].numbers[2] contains no nulls and has only one value, of length 1
bar[].numbers[2] elements has only one value
bar[].numbers[2][0] == [3]
bar[].numbers[2][0] elements == 3
bar[].numbers[3] contains no nulls and has only one value, of length 1
bar[].numbers[3] elements has only one value
bar[].numbers[3][0] == [2]
bar[].numbers[3][0] elements == 2
bar[].numbers[4] contains no nulls and has only one value, of length 1
bar[].numbers[4] elements has only one value
bar[].numbers[4][0] == [1]
bar[].numbers[4][0] elements == 1
size(bar[]).numbers[0] == 1
bar[].numbers[4][0] elements == size(bar[]).numbers[0]
size(bar[]).numbers[0] in bar[].numbers[4][0]
@end example

This is a bit verbose due to the fact that Kvasir treats @code{bar} like an array 
by default when it actually only points to one element.  However, by running 
Kvasir with the @option{--disambig} option, we create the 
@file{@var{myprog}.disambig} file, which we can then edit and feed back to 
Kvasir to change how the pointer is treated.  (We run Kvasir twice on the same
program, but we edit the @file{.disambig} file in between the runs.)
@example
kvasir-dtrace @var{...options...} --disambig --smart-disambig @var{myprog}.c
@end example

This creates the @file{@var{myprog}.disambig} file.  It contains, at the top:

@example
----SECTION----
function: ..foo()
bar
P
@end example

This means that at the program points corresponding to the entry and
exit of @code{foo()}, the variable @code{bar} is treated as a
@samp{P}ointer type. 
Since we have used the @option{--smart-disambig} option,
Kvasir automatically inferred Pointer instead of Array for @code{bar} 
because it observed that @code{bar} only pointed to one element during the 
execution of the target program which generated the @file{.disambig} file. 
This heuristic allows users to use 
@file{.disambig} files more effectively with less manual editing.
Without @option{--smart-disambig}, Kvasir does not execute the program
to make such inferences, which allows .disambig files to be generated
faster, but leaves the default disambiguation types for all entries (in
this case, @code{bar} would have the default array type of
@code{'A'}).

Then, running Kvasir again with the @option{--disambig}
option causes Kvasir to open the existing
@file{@var{myprog}.disambig} file, read the definitions, and alter 
the output accordingly:
@example
kvasir-dtrace @var{...options...} --disambig @var{myprog}.c
@end example

This tells Kvasir to output @code{bar} as a @samp{P}ointer to a single
element, which in turn causes Daikon to generate a much more concise
set of invariants. Notice that @w{@code{bar->numbers}} no longer has to be
``flattened'' because @code{bar} is now a pointer to one struct, so
Daikon can recognize @w{@code{bar->numbers}} as a single-dimensional
array (Daikon uses a Java-like syntax, replacing the arrow '->' symbol
with a dot, so it actually outputs @code{bar.numbers}).

@example
===========================================================================
..foo():::ENTER
bar has only one value
bar.name == "Daikon User"
===========================================================================
..foo():::EXIT
bar.name == "Daikon User"
bar.numbers has only one value
bar.numbers[] == [5, 4, 3, 2, 1]
size(bar.numbers[]) == 5
bar.name == orig(bar.name)
size(bar.numbers[]) in bar.numbers[]
size(bar.numbers[])-1 in bar.numbers[]
@end example

@node    Using pointer type disambiguation with partial program tracing,  , Pointer type disambiguation example, Pointer type disambiguation
@subsubsection Using pointer type disambiguation with partial program tracing

It is possible to use pointer type disambiguation while only tracing
selected program points and/or variables in a target program, combining
the functionality described in the @ref{Pointer type disambiguation} and
@ref{Tracing only part of a program} sections.  This section describes
the interaction of the @file{ppt-list-file}, @file{var-list-file}, and
.disambig files.

The interaction between selective program point tracing (via
the @file{ppt-list-file}) and pointer type disambiguation is fairly
straightforward:  If the user creates a .disambig file while running
Kvasir with a @file{ppt-list-file} that only specifies certain program
points, the generated .disambig file will only contain sections for
those program points (as well as the global section and sections for
each struct type).  If the user reads in a .disambig file while running
Kvasir with a @file{ppt-list-file}, then disambiguation information is
applied for all variables at the program points to be traced.  This can
be much faster and generate a much smaller disambiguation file, one that
only contains information about the program points of interest.

The interaction between selective variable tracing (via the
@file{var-list-file}) and pointer type disambiguation is a bit more
complicated.  This is because the @file{var-list-file} lists variables
as they appear in the .decls and .dtrace files, but using a .disambig
file can actually change the way that variable names are printed out in
the .decls and .dtrace files.  For example, consider the test program
from the @ref{Pointer type disambiguation example}.  The @code{struct
record* bar} parameter of @code{foo()} is treated like an array by
default.  Hence, the .decls, .dtrace, and @file{var-list-file} will list
the following variables derived from this parameter:

@example
----SECTION----
..foo()
bar
bar[].name
bar[].numbers[0]
bar[].numbers[0][0]
bar[].numbers[1]
bar[].numbers[1][0]
bar[].numbers[2]
bar[].numbers[2][0]
bar[].numbers[3]
bar[].numbers[3][0]
bar[].numbers[4]
bar[].numbers[4][0]
@end example

However, if we use a disambiguation file to denote @code{bar} as a
pointer to a single element, then the .decls and .dtrace files will
instead list the following variables:

@example
----SECTION----
..foo()
bar
bar->name
bar->numbers
bar->numbers[]
@end example

Notice how the latter variable list is more compact and reflects the
fact that @code{bar} is a pointer to a single struct.  Thus, the
flattening of the @code{numbers[5]} static array member variable is no
longer necessary (it was necessary without disambiguation because Daikon
does not support nested arrays of arrays, which can occur if @code{bar}
were itself an array since @code{numbers[5]} is already an array).

Notice that, with the exception of the base variable @code{bar}, all
other variable names differ when running without and with
disambiguation.  Thus, if you used a @file{var-list-file} generated on a
run without the disambiguation information while running Kvasir with the
disambiguation information, the names will not match up at all, and you
will not get the proper selective variable tracing behavior.

The suggested way to use selective variable tracing with pointer type
disambiguation is as follows:

@enumerate
@item First create the proper .disambig file by using either
@option{--disambig} or @option{--disambig-file}.
You can use @option{--ppt-list-file} as well to only create the
.disambig file for certain program points, but do NOT use
@option{--var-list-file} to try to create a .disambig only for certain
variables; this feature does not work yet.
Modify the variable
entries in the Kvasir-generated .disambig file to suit your needs.
@item Now create a @file{var-list-file} by using
@option{--dump-var-file} while running Kvasir with the .disambig file
that you have just created.  This ensures that the variables listed in
@file{var-list-file} will have the proper names for use with that
particular .disambig file.  Modify the Kvasir-generated
@file{var-list-file} to suit your needs.
@item Finally, run Kvasir with the @option{--var-list-file} option using
the @file{var-list-file} that you have just created and either the
@option{--disambig} or @option{--disambig-file} option with the proper
.disambig file.  This will perform the desired function: selective
variable tracing along with disambiguation for all of the traced
variables. 
@end enumerate

For maximum control of the output, you can use selective program point
tracing, variable tracing, and disambiguation together all at once.

@node Online execution, Installing Kvasir, Pointer type disambiguation, Kvasir
@subsection Online execution

@cindex online execution, for C programs
@cindex on-the-fly execution, for C programs

The term ``online execution'' refers to running Daikon at the same time
as the target program, without writing any information to a file.  This
can avoid some I/O overhead, prevent filling up your disk with
files, and in the future Daikon may be able to produce partial results
as the target program is executing.

@cindex pipe, as data trace file

To use regular pipes in lieu of a disk file, simply use @file{-} as the
name of the @file{.dtrace} file, and run the target program and Daikon
in a Unix pipeline.
When the @option{--dtrace-file=-} option is used to redirect
the .dtrace output to stdout, the target program's stdout is redirected
to the terminal (@file{/dev/tty}) so that it does not intermix with the
.dtrace output.

@example
kvasir-dtrace --dtrace-file=- ./bzip2 --help | $DAIKON -
@end example

Of course, you could also replace @option{--help} with @option{-vv1
file.txt} to compress a text file (but start with a small one first).

@noindent
(This example assumes that you have compiled the bzip2 example (in
@file{$DAIKONDIR/examples/kvasir-examples/bzip2} of the distribution) by
saying @command{gcc -gdwarf-2 bzip2.c -o bzip2}, and that
@command{$DAIKON} stands for the command that invokes Daikon, for
instance @command{java -Xmx512m daikon.Daikon --config_option
daikon.Daikon.disable_derived_variables=true}.)

@cindex named pipe, as data trace file
@cindex FIFO, as data trace file

Instead of a regular pipe, you can use a named pipe, also known as a
FIFO, which is a special kind of file supported by most Unix-compatible
systems.  When one process tries to open a FIFO
for reading, it blocks, waiting for another process to open it for
writing (or vice-versa).  When both a reader and a writer are ready, the
FIFO connects the reader to the writer like a regular Unix pipe.

The @option{--output-fifo} option causes Kvasir to create its output
@file{.dtrace} file as a named pipes.  When Kvasir is
run with this option, Daikon needs to be run at the same time to read
from the FIFOs, such as from another terminal or using the shell's
@code{&} operator.

For instance, the following two commands have the same effect as the
pipeline above that used ordinary pipes.  The FIFO is named
@file{bzip2.dtrace}.

@example
kvasir-dtrace --output-fifo ./bzip2 --help &
$DAIKON bzip2.dtrace
@end example

The two commands (before and after the ampersand) could also be run in
two different terminals.

When running Kvasir with DynComp (using the @file{--with-dyncomp}
option), Kvasir generates the .decls file after it generates the .dtrace
file, so it is not possible to perform online execution using one run.
The recommended way to perform online execution with DynComp is to run
it once and only generate a .decls file with comparability information,
then run Kvasir again without DynComp and pipe the .dtrace data directly
into Daikon while using the .decls file generated from the previous run:

@example
kvasir-dtrace --with-dyncomp --decls-only ./foo
@end example

This should generate a .decls file with comparability information
named @file{daikon-output/foo.decls}.

@example
kvasir-dtrace --dtrace-no-decs --dtrace-file=- ./foo | java daikon.Daikon daikon-output/foo.decls -
@end example

When you run Kvasir the second time, you don't need to run DynComp
again since you are only interested in the .dtrace file.  Notice that
the .dtrace output
is directed to standard out (@file{--dtrace-file=-}) and does not
contain any declarations (@option{--dtrace-no-decs}) because the .decls
file already contains the declarations.  You can simply
pipe that .dtrace output out to Daikon, which is invoked using the
.decls file (with comparability information) generated during your
previous run.

@node    Installing Kvasir, Kvasir limitations, Online execution, Kvasir
@subsection Installing Kvasir

@cindex installing Kvasir
@cindex Kvasir installation

@c Kvasir is the recommended C front end for use on Linux/x86.
The source
code for Kvasir is included in the main Daikon distribution, and is
compiled by default on Linux/x86 based systems.

To compile and install Kvasir, give the command @command{make kvasir}
from the top-level Daikon directory:

@example
cd $DAIKONDIR
make kvasir
@end example

This will check that you have the appropriate prerequisites (such as
GCC), configure Kvasir for your machine, compile it, and install
it in the directory @file{kvasir/inst}.

Once Kvasir has been installed, it can be used via the
@file{kvasir-dtrace} script in the @file{$DAIKONDIR/bin} directory; if
you have set up the Daikon environment according to the instructions
above, it should already be in your @env{PATH}.  For instructions on using
Kvasir, see @ref{Kvasir}.


@node Kvasir limitations,  , Installing Kvasir, Kvasir
@subsection Kvasir implementation and limitations

Kvasir is based on the Valgrind dynamic program supervision framework
(which is best known for its memory error detection tool).  Using
Valgrind allows Kvasir to interrupt your program's execution, read its
variables, and examine its memory usage, all transparently to the
program.  Also, rather than using your program's source code to find
the names and types of functions and variables, Kvasir obtains them
from debugging information included in the executable in a standard
format (DWARF-2).

However, Kvasir has some limitations of its own.  Because Kvasir uses
Valgrind, it shares Valgrind's limitation of working only under the
Linux operating system, and only on Intel 386-compatible processors
(the so-called IA-32 architecture) such as the Intel Pentium and the
AMD Athlon.  Furthermore, Kvasir requires that your program have debugging
information available in the DWARF-2 format, as produced by recent
versions of GCC@.  Furthermore, the programs used by Kvasir should be
compiled without optimization.

This subsection lists some of the known limitations of the
current Kvasir release; if you encounter any problems other than listed
here, please report them as bugs (@pxref{Reporting bugs}).  The
limitations are listed roughly in decreasing order of severity.

@itemize @bullet

@item
Kvasir-traced programs take a while to start (often a good fraction of a
second).  When tracing short-lived programs, this overhead can
dominate Kvasir's per-instruction runtime overhead.  In order to make Kvasir 
run faster, try the @option{--ignore-globals} or @option{--limit-static-vars} 
options in order to limit the amount of generated output.
However, please keep in mind that, when running simultaneously with
Daikon using the @option{--output-fifo} option (see @ref{Online execution}), Kvasir can generate
output data much faster than Daikon can process it.  Thus, it is not the
performance bottleneck in the entire invariant detection system.

@item
Kvasir currently has moderate support for C++.  It outputs C++ classes
like C structs, generates @code{:::OBJECT} invariants (@pxref{Program points}), treats member functions like regular 
functions with an extra @code{this} pointer parameter, and
correctly outputs static class member variables.  However, 
it cannot print out the contents of classes which are defined in external 
libraries rather than in the 
user's program (e.g., it can properly output a C-string represented as 
@code{char*} but not the contents of the C++ @code{string} class).
If further support for specific C++ features is important to you,
please send email to @email{daikon-developers@@lists.csail.mit.edu},
so that we can increase its priority on our to-do list.

@item
Kvasir's support for outputting arrays is not yet complete. 
It still does not have the functionality to print out multidimensional 
arrays with all of their elements or the option to flatten 
multidimensional arrays into multiple single-dimensional arrays.

@item
Kvasir behaves somewhat differently with different versions of GCC@.
We have had the best results with GCC versions 3.3 (which we use for
testing) and 3.4.  If feasible, we recommend that you use
Kvasir with such a relatively recent version of GCC@.  Incompatibilities
between Kvasir and the debugging information produced by older GCC
versions can lead to incorrect output and, in some cases for version
2.95, can cause Kvasir to crash.

@item
On some platforms (including, as of December 2004, recent versions of
Debian), Kvasir crashes if run on statically-linked binaries.  To avoid
this problem, do not use the @option{-static} flag when linking programs
for use Kvasir.  If you want to link statically with a particular
library, supply the path to its static version (@file{libfoo.a})
directly to GCC instead.

@item
Kvasir is incompatible with some compiler optimizations.  It is
definitely incompatible with the @option{-fomit-frame-pointer}
optimization, and it may have trouble with other optimizations as
well.  We recommend that you compile programs for Kvasir without
optimization.

@item
Kvasir always prints the contents of structures according to their
compile-time type.  Programs that use generic pointers and structural
equivalence to simulate object-orientation will have derived-class
fields missing when a structure is passed via a base-class pointer.
This limitation can now be overcome by manually coercing a pointer to a
particular type (@pxref{Pointer type coercion}).

@end itemize



@node Mangel-Wurzel, dfepl, Kvasir, Front ends
@section Source-based C/C++ front end Mangel-Wurzel

@cindex Mangel-Wurzel (source-based front end for C)
@cindex front end for C
@cindex C front end

In addition to the binary-based front end Kvasir (@ref{Kvasir}), there
is also a source-based front end, Mangel-Wurzel.
Unlike Kvasir, which runs only on Linux/x86 platforms,
Mangel-Wurzel will run on nearly any platform.
Mangel-Wurzel is missing a few features of Kvasir; for instance,
Mangel-Wurzel outputs fewer variables.
Mangel-Wurzel requires the source code for your program, and 
it also requires the
Purify program analysis tool from Rational Software.  You must purchase
and install Purify before you can use Mangel-Wurzel.

Mangel-Wurzel is based on the EDG C/C++ front end, which is also commercial
software.  For this reason, Mangel-Wurzel is distributed in precompiled 
binary form only.  See @ref{Installing Mangel-Wurzel}, for more information
about installation.  If you have an EDG source license and would like to build
or modify Mangel-Wurzel, we can provide source code on request.

Mangel-Wurzel is named after a root vegetable grown as cattle fodder.
It ``mangles'' the source code into a form that is not fit for human
consumption before compiling it.  


@menu
* Using Mangel-Wurzel::         
* Mangel options::              
* Pointer/array disambiguation in Mangel-Wurzel::  
* Mangel-Wurzel usage notes::   
* Interaction with Purify::     
* Installing Mangel-Wurzel::    
@end menu

@node Using Mangel-Wurzel, Mangel options, Mangel-Wurzel, Mangel-Wurzel
@subsection Using Mangel-Wurzel

@cindex mangel driver
@cindex wurzel preprocessor

Mangel-Wurzel consists of three parts: a driver program called
@command{mangel}, the preprocessor @command{wurzel} which
adds annotations to the source code,
and a small runtime library.  Mangel is a replacement for the
@command{cc} command:  it produces an
instrumented executable that behaves like the original program, but that
also produces a @file{.dtrace} data trace file for Daikon to analyze.
Mangel operates by in turn invoking
the source preprocessor wurzel, the host compiler and linker, and the
object code instrumenter Purify.


To use Mangel-Wurzel in conjunction with Daikon, follow these steps
(after installing Mangel-Wurzel, @pxref{Installing Mangel-Wurzel}):

@enumerate

@item 
Compile and link the program, using @command{mangel} in place of
@command{cc}.  This produces both an
instrumented executable and also a @file{.decls} file
for each compilation unit.

If you use a makefile to compile your program, simply substitute
@command{mangel} for @command{cc}.

Alternately, you may issue the compilation commands directly.
For example, suppose you have a program that consists of three input files,
@file{foo.c}, @file{bar.c}, and @file{baz.c}.  You can compile
and link in one step:

@example
mangel -o foo foo.c bar.c baz.c
@end example

@noindent
Or, you can compile each file individually and then invoke mangel again to
link:

@example
mangel -c foo.c
mangel -c bar.c
mangel -c baz.c
mangel -o foo foo.o bar.o baz.o
@end example

As a side-effect, the wurzel preprocessor invoked by mangel 
produces a @file{.decls} file for each source file
it processes, in this case @file{foo.decls}, @file{bar.decls}, and
@file{baz.decls}.

@item
Run the instrumented program.  This creates a single @file{.dtrace} file 
(in addition to anything else the program does).
Assuming @file{foo.c} contains the @code{main} routine, the
trace output for this example will be in @file{foo.dtrace}.


@item
Invoke Daikon, passing all of the @file{.decls} files and the @file{.dtrace} 
file as inputs.

@example
java daikon.Daikon foo.decls bar.decls baz.decls foo.dtrace
@end example


@item
Examine the invariants.  As described in @ref{StackAr example}, there are
several ways to do this.

@end enumerate

@node Mangel options, Pointer/array disambiguation in Mangel-Wurzel, Using Mangel-Wurzel, Mangel-Wurzel
@subsection Mangel options

Mangel acts as a replacement for the host @command{cc} command.  It
supports most of the common C compiler command-line options
(@pxref{Standard compiler options for Mangel}).  It also has options
that control how the wurzel preprocessor, compiler, and linker programs
are invoked (@pxref{Mangel configuration options}), and options that are
specific to controlling the program annotations added by wurzel
(@pxref{Mangel annotation options}).

Mangel is invoked as:

@example
mangel @var{[options] inputfile1 ...}
@end example

You can specify multiple @var{inputfile}s on the command line.  Mangel will
compile source files individually and then link them together (unless you have
specified one of the command-line options that suppresses linking).  You
can also include object and archive files on the command line, which are
passed directly to the linker.

@menu
* Standard compiler options for Mangel::  
* Mangel configuration options::  
* Mangel annotation options::   
* Options files for Mangel::    
@end menu

@node Standard compiler options for Mangel, Mangel configuration options, Mangel options, Mangel options
@subsubsection Standard compiler options for Mangel

Mangel supports most of the common C compiler command-line options.  

@table @option

@item -o @var{filename}
Specify @var{filename} as the output file.  

@item -c
Stop after compilation, producing a @file{.o} file; do not link.

@item -E
Stop after preprocessing with wurzel, producing a @file{.int.c} file; 
do not compile or link.  You might want to use this option for debugging
if you are having problems getting the instrumented code to compile with 
the host C/C++ compiler.

@item -S
Produce an assembly language @file{.s} file; do not assemble or link.
(This option is not particularly useful in conjunction with Mangel-Wurzel.)

@item -D@var{symbol}
@itemx -D@var{symbol}=@var{value}
Define preprocessor symbols.

@item -U@var{symbol}
Undefine preprocessor symbols.

@item -I@var{pathname}
Add @var{pathname} to the list of places searched for include files.  

@cindex MANGEL_DIR environment variable
If the environment variable @env{MANGEL_DIR} is set, mangel implicitly
adds its @file{include} subdirectory to the list of directories searched 
for system include
files.  Otherwise you must explicitly use @option{-I} to specify where to
find Mangel-Wurzel's system include files, or include this information in
the options list passed directly to the wurzel preprocessor.  See the 
@option{--preprocessor_opts} option (@pxref{Mangel configuration options}).

@item -O
@itemx -O@var{value}
Enable optimization in the compiler.  This might interact badly with Purify, so
be careful.

@item -g
Enable debugging in the compiler.  Since Purify expects code it processes
to be compiled with @option{-g}, this is typically configured as one of the
default host compiler options (@pxref{Installing Mangel-Wurzel}) and
need not be supplied explicitly on the command line.

@item -L@var{pathname}
Add @var{pathname} to the list of places searched for system libraries.

If the environment variable @env{MANGEL_DIR} is set, mangel implicitly adds
its @file{lib} directory to the list of directories searched for system 
libraries.
Otherwise you must explicitly use @option{-L} to specify where to
find Mangel-Wurzel's system libraries, or include this information in
the options list passed directly to the linker.  See @option{--linker_opts}
(@pxref{Mangel configuration options}).

@cindex PURIFY_DIR environment variable
Also, if the environment variable @env{PURIFY_DIR} is set, mangel
implicitly adds this directory to the list of directories searched for
system libraries.  Otherwise you must explicitly use @option{-L} to
specify where to find the library for the Purify API, or include this
information in the options list passed directly to the linker.  See
@option{--linker_opts} (@pxref{Mangel configuration options}).


@item -l@var{name}
Link with library @var{name}.

@item --c
@itemx --c99
@itemx --c++
Interpret the input source file as old standard C (C89), C99, or C++, 
respectively.  If none of these options are specified, mangel attempts
to infer the source language from the filename extension.

@item --ansi
@itemx --gcc
@itemx --microsoft
Enable strict ANSI, gcc, and Microsoft compatibility modes (respectively)
in the wurzel preprocessor.  If none of these options are specified, wurzel 
accepts ANSI C/C++ with a few common extensions and anachronisms.

@item -h
@itemx --help
Print a usage message and exit.
@end table

@node Mangel configuration options, Mangel annotation options, Standard compiler options for Mangel, Mangel options
@subsubsection Mangel configuration options

You can use either command-line options or an options file
to override Mangel's default behavior
regarding how Mangel invokes wurzel, the host
compiler, and the linker.  
Options files are discussed in @ref{Options files for Mangel}.

When you use command-line options from the shell or makefile to
specify these configuration parameters, be careful to quote the entire
option value string so that mangel interprets it as a single argument.

@table @option
@item --preprocessor @var{command}
Use @var{command} to invoke the wurzel preprocessor.  If this option is not
specified on the command line or in an options file,
it defaults to @samp{wurzel}.

@item --preprocessor_opts @var{option_string}
Use @var{option_string} as additional options to the wurzel preprocessor.  If
this option is not specified on the command line or in an options file, it
defaults to a system-specific value.

@item --compiler @var{command}
Use @var{command} to invoke the host C/C++ compiler.  If this option is not
specified on the command line or in an options file,
it defaults to @samp{cc}.

@item --compiler_opts @var{option_string}
Use @var{option_string} as additional options to the host compiler.  If
this option is not specified on the command line or in an options file,
it defaults to a system-specific value.

@item --linker @var{command}
Use @var{command} to invoke the host linker.  If this option is not
specified on the command line or in an options file,
it defaults to @samp{cc}.  

@item --linker_opts @var{option_string}
Use @var{option_string} as additional options to the host linker.  If
this option is not specified on the command line or in an options file,
it defaults to a system-specific value.

@item --purify @var{command}
Use @var{command} to invoke Rational Purify.  If this option is not
specified on the command line or in an options file,
it defaults to @samp{purify}.
@xref{Interaction with Purify}, for more information about Purify options.

@item --purify-opts @var{option-string}
Use @var{option-string} as additional options to Rational Purify.  
If this option is not specified on the command line, it defaults to
a system-specific value.
@xref{Interaction with Purify}, for more information about Purify options.

@item --tmpdir @var{pathname}
Put temporary files (the annotated @file{.int.c} files and temporary 
object files created prior to linking) in the indicated directory.  
If this option is not specified on the command line or in an options file, 
it defaults to a system-specific default, @file{/tmp/} on Unix platforms.  The
directory must exist and be writable.

@item -v
@itemx --verbose
Print commands (to @code{stderr}) before executing them.

@item -n
Print commands (to @code{stderr}), but don't execute them.
@end table


@node Mangel annotation options, Options files for Mangel, Mangel configuration options, Mangel options
@subsubsection Mangel annotation options

Mangel passes these options to the wurzel preprocessor, which adds
instrumentation to the code and produces a @file{.decls} file for each
source file.

@table @option

@item --decls-file @var{filename}
Specify @var{filename} as the name of the @file{.decls} file for this
compilation unit.  If this option is not specified, declarations are
written to a file in the current directory with a name derived from
the current compilation unit.

@item --dtrace-file @var{filename}
Specify @var{filename} as the name of the @file{.dtrace} file for this
program.  This option is only used if the compilation unit contains a
definition for @code{main}.  If this option is not specified, trace
output is written to a file in the current directory when the executable
is run, with a name derived from the file containing the definition of
@code{main}.  

@item --dtrace-append
Specify that output should be appended to an existing @file{.dtrace} file, 
rather than overwriting it.
This option is only used if the compilation unit contains a
definition for @code{main}.

@item --dtrace-gzip
Produce gzipped (compressed) trace output.
This is implemented by filtering the trace output through @command{gzip}.
This option is only used if the compilation unit contains a
definition for @code{main}.

@item --ignore-globals
Ignore global, file-scope static, and function-scope static 
variables when emitting program point state.
The default behavior is to emit declarations and trace information for
static variables and global variables
that are defined (not just declared as @code{extern}) in the compilation
unit and are in scope at the given program point, 
as well as (for C++ class member functions) static member variables of 
the containing class.

@item --ignore-static-vars
Ignore file-scope and function-scope static variables when emitting
program point state, but include global variables defined in the compilation
unit.

@item --nesting-depth @var{depth}
Specify the recursion depth for examining fields of nested @code{struct},
@code{union}, and @code{class} types.  The default value is 2.

@item --ppt-select-pattern @var{regex}
Only emit program points that match @var{regex}.  
Specifically, a program point is considered to match @var{regex} if any of
the function name, program point name, or containing class name (for C++)
match @var{regex}.

This option can be specified multiple times, but cannot be used in
conjunction with @option{--ppt-omit-pattern}.

@item --ppt-omit-pattern @var{regex}
Suppress program points that match @var{regex}.
Specifically, a program point is considered to match @var{regex} if any of
the function name, program point name, or containing class name (for C++)
match @var{regex}.

This option can be specified multiple times, but cannot be used in
conjunction with @option{--ppt-select-pattern}.

@end table

@node Options files for Mangel,  , Mangel annotation options, Mangel options
@subsubsection Options files for Mangel

In addition to specifying mangel options on the command line, you can
also put them in an options file.  This is most useful for customizing the
defaults for the configuration options (@ref{Mangel configuration
options}) which control how wurzel and the host compiler and linker
should be invoked, but you can put any command-line options in the file.

Mangel looks for an options file in the following places, and will use
the first one it finds.

@enumerate
@item @file{.mangelrc}
@item @file{$HOME/.mangelrc}
@item @file{$MANGEL_DIR/.mangelrc}
@end enumerate

Option files are formatted with one option, or option/value pair, per
line.  Everything following the option keyword on the same line is
considered to be a value.  Value strings should not be quoted (even if they
contain embedded spaces).  Blank lines are ignored.

Here is an example of an options file:

@example
--preprocessor wurzel
--preprocessor_opts --sys_include=/usr/include

--compiler cc
--compiler_opts -g -Dsetjmp=_setjmp -Dva_copy=__va_copy

--linker cc
--linker_opts -lmangelwurzel -lstdc++ -lpurify_stubs

--purify purify
--purify_opts -log-file=/dev/null -append-logfile
@end example


@node Pointer/array disambiguation in Mangel-Wurzel, Mangel-Wurzel usage notes, Mangel options, Mangel-Wurzel
@subsection Pointer/array disambiguation in Mangel-Wurzel

Wurzel currently does not support any form of pointer/array
disambiguation.  In other words, an object of type @samp{int *} is
treated as a pointer to a single integer, not as the address of an array
of @code{int}.  This is in contrast to the default behavior of Kvasir
(@ref{Kvasir}), which assumes the more general case that pointers point to
arrays rather than single objects.  The difference in behavior is due
to differences in the underlying runtime support; Purify does not track
the length of arrays or provide an API for querying this information.

Wurzel does, however, make use of static type information to emit trace
information for function arguments and global and static variables with 
fully-defined array types as arrays.  Note that a ``fully-defined'' array type
includes a complete set of (constant) dimensions.

Wurzel also assumes that variables with type @code{char *}, or arrays of
@code{char}, are likely to be null-terminated strings rather than pointers to
a single @code{char} object.  The runtime code which prints strings
first performs a ``sanity check'' to make sure the string is of
reasonable length and contains only printable characters (as determined by
the C library functions @code{isprint} and @code{isspace}) rather than
arbitrary byte values.  If these conditions are not met, the string is
printed as its first character (with appropriate escape codes) followed
by @samp{...}.  For example, a @code{char *} variable which points to a
byte value of 1 prints as the string @samp{"\001..."}.

On the other hand, variables with type @code{signed char *} or
@code{unsigned char *}, or arrays of explicitly @code{signed} or
@code{unsigned char}, are treated as byte pointers or byte arrays,
respectively, and the elements print as normal integer values rather than
as strings.


@node Mangel-Wurzel usage notes, Interaction with Purify, Pointer/array disambiguation in Mangel-Wurzel, Mangel-Wurzel
@subsection Mangel-Wurzel usage notes

You do not need to instrument all compilation units in a program with
Mangel-Wurzel if you are only interested in analyzing certain parts of it with
Daikon; you can simply compile the ``uninteresting'' files in the normal
way with your usual C compiler.  However, you must either instrument the
compilation unit including the definition of @code{main} with so that the
necessary runtime initialization is performed when the program starts, or
insert an explicit call to @code{mw_init} in your program before any of the
instrumented code is executed.  You should also use mangel to link 
your program.

The wurzel preprocessor produces the same dialect of code that it receives as
input, that is C, C99, or C++.  It does not translate C++ to C.  This ensures
that preprocessed code is link-compatible with system C++ libraries and other
code that is not processed with wurzel.

If you are using the C++ libraries that came with your host C++
compiler, you will probably have to add the locations of the include
files to the search path passed to wurzel, either by explicitly passing
@option{--preprocessor-opts} or @option{-I} to mangel, or by using an
options file (@ref{Options files for Mangel}).

While wurzel recognizes standard C++, its support of instrumentation for
C++ programs is rather rudimentary at this point.  In particular, it
ignores anything having to do with templates.  Wurzel is smart enough to
only generate references to class fields that are accessible at a given
program point, to avoid errors in the compilation phase, but at this
time it will not also generate references to accessible base classes and
their members.  (This should be optional in any case because it will
greatly increase the number of variables at a given program point.)

If your source code uses extensions specific to a particular host compiler,
you may need to use the @samp{--gcc} or @samp{--microsoft} flags to enable
the appropriate compatibility mode.  
Wurzel recognizes many other command-line options supported by the
underlying EDG front end to customize the language dialects it accepts,
as described in the EDG documentation.  You can set these options using
the @samp{--preprocessor-opts} flag to mangel.  

If you are having compatibility problems getting your code to compile with
Mangel-Wurzel, you can try these approaches:

@enumerate

@item If you are getting compilation errors from wurzel that can't be resolved
with one of the above compatibility flags or with appropriate defines, a
possible workaround is to preprocess the code with the host compiler's
preprocessor before running it through Mangel-Wurzel.  

@item If you are getting compilation errors from the host C compiler, you can
use the @samp{-E} option to mangel to produce a @file{.int.c} file
containing the code as preprocessed by wurzel, which you can examine to track
down the cause of the errors.

@end enumerate

Note that since the output of wurzel is compilable source code, it is possible
to perform the preprocessing on one machine and then compile, link, and run
on another platform supported by Rational Purify.


@node Interaction with Purify, Installing Mangel-Wurzel, Mangel-Wurzel usage notes, Mangel-Wurzel
@subsection Interaction with Purify

If you are interested in obtaining Purify diagnostics for your code, you
should run Purify on the uninstrumented program.  The remainder of this
section explains why this is the case.  It is not necessary to fix all
the problems that Purify diagnoses before running Mangel-Wurzel.
However, fixing them is likely to correct bugs and make your code more
robust, so it is recommended.

Mangel-Wurzel's runtime library relies on the Purify API to test the
validity of pointers --- in particular, to check for pointers to
unallocated memory and pointers to memory that has been allocated but
not initialized.  It performs these checks so that it can avoid
dereferencing bad pointers and uninitialized variables when printing
values at program points to the @file{.dtrace} file.  (Instead,
it prints a value of ``nonsensical'' for those variables, which has a
special meaning to Daikon.)

Normally, mangel is configured to tell Purify to discard all of its
diagnostic messages.  This is because, due to limitations of the Purify
API, it isn't possible for the Mangel-Wurzel runtime to run Purify
completely silently, and the diagnostics will contain bogus messages
generated by the Mangel-Wurzel runtime as well as genuine diagnostics
about the program that has been instrumented.  

Specifically, since Purify doesn't provide any API functions for
checking pointers without generating messages, the Mangel-Wurzel runtime
works around this by enabling message batching and by discarding the
batched messages as processing of each program point is completed.


@node Installing Mangel-Wurzel,  , Interaction with Purify, Mangel-Wurzel
@subsection Installing Mangel-Wurzel

Since Mangel-Wurzel is based on the proprietary EDG C/C++ front end, we
distribute it, at @uref{http://pag.csail.mit.edu/daikon/download/}, in
binary rather than source format.  (If the web page does not currently
contain a binary for your architecture, send mail to
@email{daikon-developers@@lists.csail.mit.edu} and we may be able to
produce one for you.)  The distribution does not include Purify, which
you must purchase and install separately.

Installation requires unpacking the distribution, setting the 
@env{MANGEL_DIR} and @env{PURIFY_DIR} environment
variables, optionally customizing the defaults for how mangel operates,
and optionally running its tests.

@enumerate
@item  
Download the archive from
@uref{http://pag.csail.mit.edu/daikon/download} and unpack it in the
parent of the directory where you wish to install Mangel-Wurzel.
Unpacking creates a directory named @file{mangel-wurzel}.
For example, on the Linux/x86 platform, execute these two commands:
@smallexample
wget http://pag.csail.mit.edu/daikon/download/binaries/mangel-wurzel-linux-x86.tar.gz
tar xvzf mangel-wurzel-linux-x86.tar.gz
@end smallexample

@item
Set these environment variables:

@table @env
@item PATH
Add @file{mangel-wurzel/bin} to your path.
@item MANGEL_DIR
@cindex MANGEL_DIR environment variable
Set to the full pathname of the @file{mangel-wurzel} directory.
@item PURIFY_DIR
@cindex PURIFY_DIR environment variable
Set to the directory in your Purify distribution containing
@file{libpurify_stubs.a}.
@end table

@item
Optionally, change the default commands and options mangel uses to
invoke the wurzel preprocessor, the host compiler and linker, and
Purify.  Make these changes in the system options file
@file{mangel-wurzel/.mangelrc}; see @ref{Options files for Mangel} for
details about the format of this file.

A default version of @file{.mangelrc} is included with the distribution.
The most likely things you may need to change are:

@itemize
@item Make sure that the @samp{--compiler} and @samp{--linker} commands are
correct.  For example, if you want to use gcc, on some systems you may
need to specify @samp{gcc} explicitly instead of @samp{cc}, or use a
full pathname.

@item You may need to alter the default system include paths, specified with
@samp{--sys_include} in the @samp{--preprocessor_opts} option.  On Unix
systems, you probably need to specify both @file{/usr/local/include} and
@file{/usr/include}.  If you are using gcc, you should also specify the
include directory for the particular version of gcc you are using ahead
of @file{/usr/include}; you can find the full pathname by doing
@samp{gcc -print-libgcc-file-name} and substituting @samp{include} for
@samp{libgcc.a}.

@item You might also want to add some additional options, such as specifying
@samp{--gcc} or @samp{--microsoft} to enable the appropriate compatibility
mode for your normal C compiler by default.
@end itemize

For debugging the options file, you can use the @option{-n} or 
@option{-v} options to see the actual commands mangel is generating to 
invoke each phase.

@item
Optionally (but recommended), run Mangel-Wurzel's tests.
@example
cd tests
make
@end example

@end enumerate



@node dfepl, convertcsv.pl, Mangel-Wurzel, Front ends
@section Perl front end dfepl

@cindex front end for Perl
@cindex Perl front end
@cindex dfepl (Daikon front end for Perl)

This section contains details about dfepl, the Daikon front end for
Perl.  For a brief introduction to dfepl, see @ref{Perl examples} and
@ref{Instrumenting Perl programs}.

dfepl works with Perl versions 5.8 and later. (To be precise, Perl
programs instrumented with dfepl can also be run with Perl 5.6, but
the instrumentation engine, which is itself written in Perl, requires
version 5.8).  dfepl reads the source code for Perl modules or
programs, and writes out instrumented versions of that code that
keep track of function parameters, and make calls to routines in the
@file{daikon_runtime} package whenever an instrumented subroutine is
entered or exited.

The instrumentation engine recognizes parameters as those variables
that are declared with @code{my(...)} or @code{local(...)} and, in the
same expression, assigned to from a value related to the argument
array @code{@@_}, but only among the first contiguous series of such
assignments in the body of a subroutine.  This will capture the most
common assignment idioms, such as @code{my $self = shift;} (where
@code{shift} is short for @code{shift @@_}), @code{my $x = $_[0];}, and
@code{my($x, $y, @@a) = @@_;}, but the arguments to subroutines which
access them only directly through @code{@@_}, or that perform other
operations before reading their arguments, will not be recognized.

If the uninstrumented code requested warnings via the @code{use
warnings} pragma or by adding the @option{-w} flag on the @code{#!}
line, the instrumented code will also request warnings.  In this case,
or if @option{-w} is specified on the command line when running it, the
instrumented code may produce warnings that the original code did
not.  There are several situations in which the instrumented code
produced by dfepl, while functionally equivalent to the original,
generates more warnings.  The most common such problem, which arises
from code that captures the scalar-context return value of a
subroutine that returns a list, has been avoided in the current
version by disabling the warning in question.  Other warnings which
are known to be produced innocuously in this way include
@samp{Ambiguous call resolved as CORE::foo(), qualify as such or use
&} (caused by code that uses @code{CORE::} to distinguish a built-in
function from a user subroutine of the same name), and @samp{Constant
subroutine foo redefined} (caused by loading both instrumented and
uninstrumented versions of a file).  Though some such warnings
represent deficiencies in the instrumentation engine, they can be
safely ignored when they occur.

Because Perl programs do not contain static type information to
distinguish, for instance, between strings and numbers, the Perl
front end incorporates an additional dynamic analysis to infer these
types.  This type guessing, which occurs as a first pass before the
program can be instrumented to produce output for Daikon, operates in
a manner somewhat analogous to Daikon itself: watching the execution
of a program, the runtime system chooses the most restrictive type for
a variable that is not contradicted during that execution.  These
types indicate, for instance, whether a scalar value always holds an
integer, a possibly fractional numeric value, or a reference to
another object.  It should not be necessary to examine or modify this
type information directly, but for the curious, the syntax of the type
information is described in comments in the @file{Daikon::PerlType}
module.

The safest course is to infer types for variables using exactly the
same program executions (e.g., test cases) which will later be used to
generate traces for Daikon, as this guarantees that the type
information will match the actual data written to the trace file.
However, because the type-guessing-instrumented versions of programs
run fairly slowly in the current version, you may be tempted to use a
subset of the input data for type guessing.  Doing so is possible, but
it will only work correctly if the smaller tests exercise all of the
instrumented subroutines and exit points with all the types of data
they will later be used with.  If the trace runtime tries to output a
data value that doesn't match the inferred type, the value may
silently be converted according to Perl's usual conventions (for
instance, a non-numeric string may be treated as the number zero), or
it may cause an error during tracing (for instance, trying to
dereference a supposed array reference that isn't).  Also, if a
subroutine exit point is traced but was never encountered during type
guessing, the generated @file{.decls} and @file{.dtrace} files will be
incompatible in a way that will cause Daikon to abort with an error
message of the form @samp{Program point foo():::EXIT22 appears in dtrace
file but not in any decl file}.

@float Figure,dfepl-flow
@center @image{images/dfepl-flow,4in,}
@caption{Workflow of instrumenting Perl code with dfepl.}
@end float

dfepl works by reading one or more Perl programs
or modules, and writing out new versions of those files, instrumented
to capture information about their execution, by default to another
directory.  dfepl is used in two passes: first, before type
information is available, instrumented versions are written to a
directory @file{daikon-untyped}.  These untyped programs, when run,
will write
files containing dynamically inferred type information (with the
extension @file{.types}), by default to the @file{daikon-instrumented}
directory.  When dfepl is rerun with this type information, it
produces type-aware instrumented code in the
@file{daikon-instrumented} directory, which when run produces
execution traces in files with the extension @file{.dtrace} in the a
directory @file{daikon-output}.

@menu
* dfepl options::               
@end menu

@node dfepl options,  , dfepl, dfepl
@subsection dfepl options

@table @option
@item --absolute
@itemx --no-absolute
@option{--absolute} stores the absolute path to the output directories
(by default named @file{daikon-untyped}, @file{daikon-instrumented} or
@file{daikon-output}) in the instrumented programs, so that no matter
where the instrumented program is run, the output will go to a fixed
location.  Even if these directories are given as relative paths (as is
the default), @option{--absolute} specifies that they should always be
taken as relative to the directory that was the working directory when
dfepl was run.

@option{--no-absolute} specifies the opposite, causing the output paths
to be interpreted relative to the current working directory each time
the instrumented program is invoked.  The default, when neither option
is specified, is for @file{.types} files to use an absolute path, but
all others to use relative path, so that the @file{.types} files will
always be in the same place as the instrumented source files that
generated them, but the @file{daikon-output} directory will be created
in the current directory when the program runs.

@item --accessor-depth=@var{num}
Controls the number of nested invocations of object accessor methods
to examine.  For instance, suppose that the @code{Person} class has a
method @code{mother()} that returns another person (and has been
specified to dfepl as an accessor), and that @code{$me} is
an instrumented variable.  If the accessor depth is 1, only
@code{$me->mother()} will be examined.  If the depth is 2,
@code{$me->mother()->mother()} will also be examined.  Specifying large
accessor depths is generally not advisable, especially with many
accessor methods, as the number of variables examined can be too many
for Daikon to process efficiently.

By default, the Daikon Perl trace runtime will examine at most a
single level of accessors.

@item -A
@itemx --accessors-dir=@var{directory}
Look for files containing accessor lists in @var{directory}, or the
current directory if @var{directory} is omitted.  For a class
@code{Acme::Foo}, accessors are methods that return information about
an object but do not modify it.  dfepl cannot determine on
its own which methods are accessors, but when a list of them is
provided, it can call an object's accessors when examining a variable
of that class to obtain more information about the object.  To tell
dfepl about the accessors for @code{Acme::Foo}, make a file
listing the names of each accessor method, one per line with no other
punctuation, named @file{Acme/Foo.accessors} in the same directory as
@file{Acme/Foo.pm}.

@item --decls-dir=@var{directory}
Put generated declaration files in @var{directory} and its
subdirectories.  The default is @file{daikon-output}.

@item --decls-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}.  A style of @option{combined} specifies that the
declarations for all packages should be merged, in a file named
@file{prog-combined.decls} where @file{prog} is the name of the
program.  A style of @option{flat} specifies that the declarations for
each package should be in a separate file named after the package, but
that these files should go in a single directory; for instance, the
declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.decls} and @file{Acme::Skates::Rocket.decls}.  A
style of @option{tree} specifies that each package should have its own
declarations file, and that those files should be arranged in
directories whose structure matches the structure of their package
names; in the example above, the files would be
@file{Acme/Trampoline.decls} and @file{Acme/Skates/Rocket.decls}.

The default is @option{tree}.  Note that @option{--decls-style} and
@option{--types-style} are currently constrained to be the same; if
one is specified, the other will use the same value.

@item --dtrace-append
@itemx --no-dtrace-append
When @option{--dtrace-append} is specified, the instrumented program
will append trace information to the appropriate
@file{.dtrace} file each time it runs.  When
@option{--no-dtrace-append} is specified, it will overwrite the file
instead. 

The default behavior is to overwrite.  This choice can also be
overridden, when the program is run, to always append by setting the
environment variable @env{DTRACEAPPEND} to 1.

When appending to a @file{.dtrace} file, no declaration information is
ever produced, because it would be redundant to do so and Daikon does
not permit re-declarations of program points.

@item --dtrace-dir=@var{directory}
Put generated trace files in @var{directory} and its
subdirectories.  The default is @file{daikon-output}.

@item --dtrace-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}.  A style of @option{combined} specifies that the traces
for all packages should be merged, in a file named
@file{prog-combined.dtrace}, where @file{prog} is the name of the
program.  A style of @option{flat} specifies that the
traces for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.dtrace} and
@file{Acme::Skates::Rocket.dtrace}.  A style of @option{tree} specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be @file{Acme/Trampoline.dtrace} and
@file{Acme/Skates/Rocket.dtrace}.

The default is @option{combined}.

@item --help
Print a short options summary.

@item --instr-dir=@var{directory}
@c dfec option -- do not rename (yet)
@itemx --instrsourcedir=@var{directory}
Put instrumented source files in @var{directory} and its
subdirectories.  The default is @file{daikon-untyped}, or
@file{daikon-instrumented} if type information is available.

@item --list-depth=@var{DEPTH}
Consider as many as @var{DEPTH} of the first elements of a list to be
distinct entities, for the purpose of guessing their types.  When
subroutines return a list of values, each value may have a distinct
meaning, or the list may be homogeneous.  When trying to assign types
to the elements of a list, the Daikon Perl trace runtime will try
making separate guesses about the types of the elements of a short
list, but it would be inefficient to make retain this distinction for
many elements.  This parameter controls how many elements of a list
will be examined individually; all the others will be treated
uniformly.

The default is 3.

@item --output-dir=@var{directory}
Put all of the files that are the output of the tracing process (and
therefore input to the Daikon invariant detection engine) in
@var{directory} and its subdirectories.  This option is a shorthand
equivalent to setting both @option{--decls-dir} and
@option{--dtrace-dir} to the same value.

The default behavior is as if @option{--output-dir=daikon-output} had
been specified.

@item --perl=@var{path}
Use @var{path} as the location of Perl when calling the annotation
back end (a module named @code{B::DeparseDaikon}), rather than the
version of Perl under which @command{dfepl} itself is running, which
is probably the first @command{perl} that occurs on your path.  For
instance, if the first version of @command{perl} on your path isn't
version 5.8 or later, you should this option to specify another
@command{perl} program that is.

@item --nesting-depth=@var{num}
When examining nested data structures, traverse as many as @var{num}
nested references.  For instance, suppose that @code{@@a} is the array

@example
@@a = (@{1 => [2, 3]@}, @{5 => [4, 2]@})
@end example

If the depth is 0, then when examining @code{@@a}, Daikon's Perl trace
runtime will consider it to be an array whose elements are references,
but it won't examine what those references point to.  If the depth is
1, it will consider it to be an array of references to hashes whose
keys are integers and whose values are references, but it won't
examine what @emph{those} references point to.  Finally, if the depth
is 2 or more, it will consider @code{@@a} to be an array of references
to hashes whose keys are integers and whose values are references to
arrays of integers.

The default nesting depth is 3.

When referenced objects have accessor methods, or when accessors
return references, the @option{--accessor-depth} and
@option{--nesting-depth} options interact.  Specifically, if these
depths are A and R, the behavior is as if the runtime has a budget of
1 unit, which it can use either on accessors which cost 1/A or
references which cost 1/R@.  It may thus sometimes be useful to specify
fractional values for @option{--accessor-depth} and
@option{--nesting-depth}; in fact, the default accessor depth is
1.5.

@item --types-append
@itemx --no-types-append
When @option{--types-append} is specified, the instrumented program
will append type information to the appropriate
@file{.types} file each time it runs.  When
@option{--no-types-append} is specified, it will overwrite the file
instead. 

The default behavior is to append.  If @option{--no-types-append} is
specified, however, this choice can also be overridden, when the
program is run, to append by setting the environment variable
@env{TYPESAPPEND} to 1.  There is no way to use environment variables
to force the runtime to overwrite a types file, but an equivalent
effect can be obtained by simply removing the previous types file
before each run.

@item -T
@itemx --types-dir=@var{directory}
Look for @file{.types} files in @var{directory}, or
@file{daikon-instrumented} if @var{directory} is omitted.  When
instrumenting a module @code{Acme::Trampoline}, used in a program
@file{coyote.pl},  dfepl will look for
files named @file{coyote-combined.types}, @file{Acme::Trampoline.types}, and
@file{Acme/Trampoline.types}, corresponding to the possible choices of
@option{--types-style}.  Once discovered, the files are used in the
same way as for @option{-t}.

@item --types-file=@var{file}
@itemx -t @var{file}
Include type information from @var{file} when instrumenting programs
or modules.  Since Daikon needs to know the types of variables when
they are declared, useful @file{.decls} and @file{.dtrace} files can
only be produced by source code instrumented with type
information.  Since Perl programs don't include this information to
begin with, and it would be cumbersome to produce by hand, type
information must usually be produced by running a version of the
program that has itself been annotated, but without type
information.  The Daikon Perl trace runtime will automatically decide
whether to output types, or declarations and traces, depending on
whether the source was instrumented without or with types.  This option
may occur multiple times, to read information from multiple types
files (irrelevant type information will be ignored).

@item --types-basedir=@var{directory}
Put files containing type information in @var{directory} and its
subdirectories.  By default, this is whatever @option{--instr-dir}
is, usually @file{daikon-instrumented}.

@item --types-style=@var{style}
@var{style} should be one of @option{combined}, @option{flat}, or
@option{tree}.  A style of @option{combined} specifies that the types
for all packages should be merged, in a file named
@file{prog-combined.types}, where @file{prog} is the name of the
program.  A style of @option{flat} specifies that the
types for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for @code{Acme::Trampoline} and
@code{Acme::Skates::Rocket} would go in files named
@file{Acme::Trampoline.types} and
@file{Acme::Skates::Rocket.types}.  A style of @option{tree} specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be @file{Acme/Trampoline.types} and
@file{Acme/Skates/Rocket.types}.

The default is @option{tree}.  Note that @option{--types-style} and
@option{--decls-style} are currently constrained to be the same; if
one is specified, the other will use the same value.

@item --verbose
@itemx -v
Print additional information about what dfepl is doing,
including external commands invoked.
@end table


@node convertcsv.pl, Other front ends, dfepl, Front ends
@section Comma-separated-value front end convertcsv.pl

@cindex csv files
@cindex comma-delimited files
@cindex comma-separated-value files
@cindex tab-separated files
@cindex Excel files
@cindex spreadsheet files

Daikon can process data from spreadsheets such as Excel.  In order to
use such files, first save them in comma-separated-value, also known
as csv or comma-delimited, format.
Then, convert the @file{.csv} file into a @file{.dtrace} file (and a
@file{.decls} file) to be used by Daikon by running the
@command{convertcsv.pl} program found in the @file{$DAIKONDIR/bin}
directory.  For example,
@example
convertcsv.pl myfile.csv
@end example
@noindent
produces files @file{myfile.decls} and @file{myfile.dtrace}.  Run
@command{convertcsv.pl} without any arguments in order to see a usage
message.


@node    Other front ends,  , convertcsv.pl, Front ends
@section Other front ends

@cindex front end for IOA
@cindex IOA front end
@cindex front end for Lisp
@cindex Lisp front end

A front end for the IOA programming language is distributed separately
(see @uref{http://theory.csail.mit.edu/tds/ioa.html}).

An earlier version of Daikon included a Lisp front end, but it is no
longer supported.

An earlier version of Daikon provided a source-based front end for Java
named dfej.  It has been superseded by Chicory.

An earlier version of Daikon provided a source-based front end for C
named dfec.  It has been superseded by Kvasir (binary-based, for Linux/x86) and
Mangel-Wurzel (source-based, for all other platforms).


@node    Tools, Troubleshooting, Front ends, Top
@chapter Tools for use with Daikon

This chapter describes various tools that are included with the Daikon
distribution.
@menu
* Tools for manipulating invariants::  
* DtraceDiff utility::          
@end menu

@node Tools for manipulating invariants, DtraceDiff utility, Tools, Tools
@section Tools for manipulating invariants

@cindex .inv files, tools for manipulating
@cindex inv files, tools for manipulating

This section gives information about tools that manipulate invariants
(in the form of @file{.inv} files).


@menu
* Printing invariants::         
* Invariant Diff::              
* Annotate::                    
* Runtime-check instrumenter::  
* InvariantChecker::            
* LogicalCompare::              
@end menu


@node    Printing invariants, Invariant Diff, Tools for manipulating invariants, Tools for manipulating invariants
@subsection Printing invariants

@cindex printing invariants
@cindex PrintInvariants program

Daikon provides many options for controlling how invariants are printed.
Often, you may want to print the same set of invariants several
different ways.  However, you only want to run Daikon once, since it may
be very time consuming.  The PrintInvariants utility prints a set of
invariants from a @file{.inv} file.

PrintInvariants is invoked as follows:
@example
java daikon.PrintInvariants @i{[@var{flags}]} @var{inv-file}
@end example

PrintInvariants shares many flags with Daikon.
These flags are only briefly summarized here.
For more information about these flags, see @ref{Daikon configuration options}.

@table @option
@item --help
Print usage message.

@item --format @var{name}
Produce output in the given format.  See @ref{Invariant syntax}.

@item --output_num_samples
Output numbers of values and samples for invariants and program points;
for debugging.

@item --config @var{filename}
Load the configuration settings specified in the given file.
@xref{Configuration options}, for details.

@item --config_option @var{name}=@var{value}
Specify a single configuration setting.
@xref{Configuration options}, for details.

@item --dbg @var{category}
@itemx --debug
Enable debug loggers.

@item --track @var{class}<@var{var1},@var{var2},@var{var3}>@@@var{ppt}
Track information on specified invariant class, variables and program point.
For more information, also see @ref{Track logging,,,./developer,Daikon
Developer Manual}.

@end table


@node    Invariant Diff, Annotate, Printing invariants, Tools for manipulating invariants
@subsection Invariant Diff

@cindex invariant diff
@cindex diff, over invariants
@cindex comparing invariants

The invariant diff utility is designed to output the differences between
two sets of invariants.  This is useful, for example, if you want to
compare the invariants generated by two versions of the same program.

Invariant diff is invoked as follows:
@example
java daikon.diff.Diff @i{[@var{flags}]...} @var{file1} [@var{file2}] 
@end example

@var{file1} and @var{file2} are files containing serialized invariants 
produced by running Daikon or Diff
with the @option{-o} flag.  If @var{file2} is not specified,
@var{file1} is compared with the empty set of invariants.

This section describes the optional flags.

@table @option
@item --help
Print usage message.

@item -d
Display the tree of differing invariants (default).  Invariants that are
the same in @var{file1} and @var{file2} are not printed.  At least one of the
invariants must be justified.  Does not print ``uninteresting'' invariants
(currently some OneOf and Bound invariants).

@item -u
Include ``uninteresting'' invariants in the tree of differing invariants.

@item -y
@itemx --ignore_unjustified
Include (statistically) unjustified invariants. 

@item -a
Display the tree of all invariants.  Includes invariants that are the
same in file1 and file2, and unjustified invariants.

@item -s
For internal use only.  Display the statistics between two sets of
invariants.  The pairs of invariants are placed in bins according to the
type of the invariant and the type of the difference.

@item -t
For internal use only.  Display the same statistics as @option{-s}, but as a
tab-separated list.

@item -m
Compute (@var{file1} - @var{file2}).  This is all the invariants that appear in
@var{file1} but not @var{file2}.  Unjustified invariants are treated as if they
don't exist.  Output is written as a serialized InvMap to the file
specified with the @option{-o} option.  To view the contents of the serialized
InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -x
Compute (@var{file1} XOR @var{file2}).  
This is all the invariants that appear in
one file but not the other.  Unjustified invariants are treated as if
they don't exist.  Output is written as a serialized InvMap to the file
specified with the @option{-o} option.  To view the contents of the serialized
InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -n
Compute (@var{file1} UNION @var{file2}).  
This is all the invariants that appear in
either file.  If the same invariant appears in both files, the one with
the better justification is chosen.  Output is written as a serialized
InvMap to the file specified with the @option{-o} option.  To view the contents
of the serialized InvMap, run @command{java daikon.diff.Diff @var{file}}.

@item -o @var{inv_file}
Used in combination with the @option{-m} or @option{-x} option.  Writes
the output as a serialized InvMap to the specified file.

@item -j
For internal use only.  Treat justification as a continuous value when
gathering statistics.  By default, justification is treated as
a binary value --- an invariant is either justified or it is not.  For
example, assume invariant I1 has a probability of .01, and I2 has a
probability of .5.  By default, this will be a difference of 1,
since I1 is justified but I2 is not.  With this option, this will be a
difference of .49, the difference in the probabilities.  This only
applies when one invariant is justified, and the other is unjustified.

@item -p
Examine all program points.  By default, only procedure entries and
combined procedure exits are examined.  This option also causes
conditional program points to be examined.

@item -e
Print empty program points.  By default, program points are not printed
if they contain no differences.

@item -v
Verbose output.  Invariants are printed using the @code{repr()} method, instead
of the @code{format()} method.

@item -l
For debugging use only.  Prints logging information describing the state
of the program as it runs.

@item --invSortComparator1 @var{classname}
@itemx --invSortComparator2 @var{classname}
@itemx --invPairComparator @var{classname}
Use the specified class as a custom comparator.  A custom comparator can
be used for any of 3 operations: sorting the first set of invariants,
sorting the second set of invariants, and combining the two sets into
the pair tree.  The specified class must implement the Comparator
interface, and accept objects of type Invariant.

@end table

@c @node    GUIs, Front ends, Daikon output, Top
@c @chapter GUIs for displaying invariants
@c 
@c By default, Daikon outputs a textual list of invariants; this list may
@c be very long.  Daikon's graphical user interfaces (GUIs) are designed to
@c make the task of browsing invariants easier.  However, we recommend
@c viewing the textual output or using one of the other Daikon tools
@c (@pxref{Tools}) rather than using one of the GUIs.
@c @c There are two GUIs to choose from.  The Tree GUI that lets users browse
@c @c the hierarchy of invariants directly.
@c The Context GUI lets users browse
@c the code in a text editor; the Context GUI concurrently displays the
@c invariants for the browsed code.
@c 
@c The Eclipse plug-in is not a GUI per se; rather, it helps to automate
@c various Daikon-related tasks such as instrumenting programs, running
@c them, and inserting invariants into source code as comments.
@c 
@c 
@c @menu
@c * Eclipse plug-in::             
@c * Context GUI::                 
@c @end menu


@c @node    Tree GUI, Context GUI, Eclipse plug-in, GUIs
@c @section Tree-structured invariant browser
@c @cindex Tree GUI
@c @cindex GUI, tree
@c 
@c The Tree GUI contains a tree that
@c hierarchically organizes program points according to their class and
@c method.  Using the Tree GUI, you can look at invariants for only the methods
@c and program points you care about.  You can also sort invariants by a
@c property (e.g., probability) or filter invariants (e.g., only look at
@c invariants containing a certain variable).
@c 
@c This invariant browser consists of two windows.  The main window is the
@c Invariants Display, which gives a tree-structured view of program
@c points; you can navigate through the program points and view invariants.
@c The other window is the Filter Control Panel, where you can control
@c which invariants from each program point are displayed in the Invariants
@c Display.
@c 
@c @menu
@c * Invoking Tree GUI::           
@c * Invariants Display::          
@c * Control panel::               
@c @end menu
@c 
@c @node    Invoking Tree GUI, Invariants Display, Tree GUI, Tree GUI
@c @subsection Starting the invariant browser
@c 
@c To use the Tree GUI, first make a @file{.inv} file by invoking Daikon with
@c the @option{-o} option; for instance, to create @file{foo.inv}, run
@c @example
@c java daikon.Daikon -o foo.inv @var{decl-files...} @var{trace-files...}
@c @end example
@c 
@c Then, run the Tree GUI with the @file{.inv} file as an argument:
@c @example
@c java daikon.gui.treeGUI.InvariantsGUI foo.inv
@c @end example
@c 
@c If you run the Tree GUI with no arguments, it presents a file browser that
@c asks you to choose a @file{.inv} file for viewing.
@c 
@c 
@c @node    Invariants Display, Control panel, Invoking Tree GUI, Tree GUI
@c @subsection Invariants Display
@c 
@c @ifnotinfo
@c @image{images/gui-InvariantsDisplay-small,3in,}
@c @end ifnotinfo
@c 
@c @table @strong
@c @item File menu
@c 
@c The @command{Load file} menu option brings up a file browser that you
@c can use to select another @file{.inv} file.  The @command{Quit} menu
@c options lets you quit the Tree GUI@.
@c 
@c @item Program point tree
@c The top part of the Invariants Display consists of the Program point
@c tree --- a hierarchy of program points broken down by class and method.
@c Click on various program points in the tree to see tables of invariants
@c for those program points.  You may use the @key{Ctrl} and @key{Shift}
@c keys to make an arbitrary selection of program points.  Selecting a
@c class or method automatically selects all the program points
@c associated with that method or class.
@c 
@c @item Invariant tables
@c Invariant tables that display the actual invariants appear at the bottom
@c of the Invariants Display.
@c 
@c @itemize @bullet
@c @item
@c Use @key{Alt} along with the @key{up} or @key{down} arrow keys to scroll
@c by a table at a time.
@c @item
@c Sort a column in a table by clicking on the column header.  Shift-click
@c to sort the column in reverse order.
@c @end itemize
@c 
@c @end table
@c 
@c @node    Control panel,  , Invariants Display, Tree GUI
@c @subsection Control panel
@c 
@c The Control Panel determines which invariants are displayed.
@c @c As of 2/2002
@c (This picture of the Control Panel is slightly out of date; it needs to
@c be updated.)
@c 
@c @c Force a paragraph break so the image is on its own line.
@c @*
@c 
@c @ifnotinfo
@c @image{images/gui-ControlPanel,3in,}
@c @end ifnotinfo
@c 
@c 
@c @menu
@c * Property filters::            
@c * Variable filters::            
@c @end menu
@c 
@c @node    Property filters, Variable filters, Control panel, Control panel
@c @subsubsection Property filters
@c @cindex property filters
@c 
@c Property filters narrow down the list of invariants that are displayed.
@c You can adjust which Property filters are being applied.  By default,
@c all Property filters are enabled.
@c 
@c For information about property filters, see @ref{Invariant filters}.
@c 
@c @node    Variable filters,  , Property filters, Control panel
@c @subsubsection Variable filters
@c @cindex variable filters
@c 
@c Variable filters let you display only the invariants that contain
@c certain variables.  The left-hand box displays the variables that you
@c are interested in.  By default, the box is empty and invariants containing
@c any variables are displayed.  There are two ways to add variables to the
@c variables list:
@c @enumerate
@c @item 
@c Type the name of the variable into the @command{Add variable}
@c text field, and click the @command{Add variable} button (or just press
@c @key{enter}).
@c @item
@c Each Invariant table in the Invariants Display has a @command{Show
@c variables} button.  Click on that button to see a list of variables for
@c that program point.  Select any set of variables and click the
@c @command{Filter on selected variables} button.
@c @end enumerate
@c 
@c To remove variables from the variables list, select the variables in
@c question and click on the @command{Remove selected
@c variables} button.
@c 
@c If you click on the @command{any variable} checkbox,
@c invariants are displayed if they contain any of the variables in the
@c variables list.  If you click on the @command{all
@c variables} checkbox, invariants are displayed if they contain all
@c of the variables in the variables list.



@c @node    Context GUI,  , Eclipse plug-in, GUIs
@c @section Context GUI
@c @cindex Context GUI
@c @cindex GUI, context
@c 
@c The Daikon Context GUI displays invariants for the Java or C code displayed
@c in a text editor or code browser; as the cursor moves, the invariant
@c display is updated.
@c (Before using the Context GUI, you must follow the installation
@c instructions; see @ref{Installing the Context GUI}.)
@c 
@c @c Force a paragraph break so the image is on its own line.
@c @*
@c 
@c @ifnotinfo
@c @image{images/context-gui,5in,}
@c @end ifnotinfo
@c 
@c Currently, the Context GUI is integrated with the Emacs text editor.
@c However, users can extend it to other Java or C editors.  The Context GUI can
@c also be run stand-alone.  This provides the user the ability to browse
@c the invariants without having to load up the text editor in case the
@c user wants to do a quick lookup on invariants.
@c 
@c @menu
@c * Context GUI with Emacs::      
@c * Installing the Context GUI::  
@c @end menu
@c 
@c @node    Context GUI with Emacs, Installing the Context GUI, Context GUI, Context GUI
@c @subsection Running the Context GUI with Emacs
@c @cindex Emacs, with Context GUI
@c 
@c In order to use the Context GUI, perform the following steps:
@c @enumerate
@c @item
@c Use the Daikon invariant detector to create a @file{.inv} file containing the
@c invariants.
@c @example
@c   java daikon.Daikon -o foo.inv decl-files... trace-files...
@c @end example
@c 
@c 
@c 
@c @item
@c 
@c Start the Context GUI by typing @kbd{M-x daikon-context-gui}
@c while visiting a Java or C file in Emacs.  When prompted, select the
@c appropriate @file{.inv} file, containing the invariants.
@c 
@c @item
@c Stop the Context GUI by typing @kbd{M-x daikon-context-gui-end}
@c 
@c @end enumerate
@c 
@c 
@c 
@c @node    Installing the Context GUI,  , Context GUI with Emacs, Context GUI
@c @subsection Installing the Context GUI
@c 
@c If you wish to run the Daikon Context GUI (@pxref{Context GUI}), perform
@c the following two steps:
@c 
@c @enumerate
@c @item
@c If you wish to use the Context GUI with Java code, then
@c download and install JDE, the Java Development Environment for Emacs,
@c from @uref{http://jdee.sunsite.dk/}.
@c If you wish to use the Context GUI with C code, no extra packages are needed.
@c @item
@c Add the Emacs Lisp code for the Daikon Context GUI to your Emacs load
@c path.  Add the following to your @file{.emacs} or @file{prj.el} file:
@c @example
@c   ;; Daikon Context GUI
@c   (add-to-list 'load-path
@c                (substitute-in-file-name "$DAIKONDIR/emacs"))
@c   (autoload 'daikon-context-gui "daikon-context-gui"
@c             "Daikon Context GUI" t)
@c   (custom-set-variables '(jde-global-classpath '("$CLASSPATH")))
@c @end example
@c @end enumerate


@menu
* Annotate::                    
* Runtime-check instrumenter::  
* InvariantChecker::            
* LogicalCompare::              
@end menu

@node    Annotate, Runtime-check instrumenter, Invariant Diff, Tools for manipulating invariants
@subsection Annotate

@cindex Annotate tool
@cindex MergeESC tool, see Annotate tool

The Annotate program inserts Daikon-generated invariants into Java
source code as  annotations in  DBC, ESC, Java or JML format.
These annotations are comments that can be automatically verified or
otherwise manipulated by other tools.

Invoke Annotate like this:
@example
java daikon.tools.jtb.Annotate Myprog.inv Myprog.java Myprog2.java ...
@end example

The first argument is a Daikon @file{.inv} or @file{.inv.gz} file 
produced by running
Daikon with the @option{-o} command-line argument.  All subsequent
arguments are @file{.java} files.  The original @file{.java} files are left
unmodified, but Annotate produces new versions of the @file{.java} files
(with names suffixed as @file{-escannotated}, @file{-jmlannotated}, or 
@file{-dbcannotated}) that include the Daikon invariants as comments.

The options are:
@table @option

@item --format @var{name}
Produce output in the given format.  See @ref{Invariant syntax}.

@item --no_reflection
Do not use reflection to find information about the classes being
instrumented.  This allows Annnotate to run without having access
to the class files.  Since the class files are necessary to generate ``also''
tags, those tags will be left out when this option is chosen.

@item --max_invariants_pp @var{count}
Output at most @var{count} invariants per program point (which ones are chosen
is not specified).

@item --wrap_xml
Each invariant is printed using the given format (ESC, JML or DBC),
but the invariant expression is wrapped inside XML tags, along with other
information about the invariant.

For example, if this switch is set, the output format is ESC,
and an invariant for method @code{foo(int x)} normally prints as

@example
/*@ requires x != 0; */
@end example

Then the resulting output will look something like this (all
in one line; we break it up here for clarity):

@example
/*@ requires <INVINFO>
<INV> x != 0 </INV>
<SAMPLES> 100 </SAMPLES> 
<DAIKON> x != 0 </DAIKON>
<DAIKONCLASS> daikon.inv.unary.scalar.NonZero </DAIKONCLASS>
<METHOD> foo() </METHOD>
</INVINFO> ; */
@end example

Note that the comment will no longer be a legal ESC/JML/DBC
comment.  To make it legal again, you must replace the XML tags with
the string between the <INV> tag.

Also note the extra information printed with the invariant: the number
of samples from which the invariant was inferred, the Daikon
representation (i.e., the Daikon output format), the Java class that
the invariant corresponds to, and the method that the invariant
belongs to (@code{null} for object invariants).

@end table

@strong{Known bug (logical shift in Java).}
Daikon's Java parser (adopted from javacc and JTB) accepts Java 1.5 syntax.
An error in the new parser
may produce illegal Java in the annotated file, if the source file to be
annotated includes logical shift operators. @xref{Known bugs}.


@node    Runtime-check instrumenter, InvariantChecker, Annotate, Tools for manipulating invariants
@subsection Runtime-check instrumenter (runtimechecker)

@cindex runtime-check instrumenter
@cindex runtimechecker instrumenter

The runtimechecker instrumenter inserts, into a Java file,
instrumentation code that checks invariants as the program executes.
For a full list of options, run:

@example
java daikon.tools.runtimechecker.Main help
@end example

The @code{instrument} command to runtimechecker creates a new directory
@file{instrumented-classes} containing a new version of the
user-specified Java files, instrumented to check invariants at runtime
and to record a list of invariant violations in a Java data structure.

Note that the instrumented program does not do anything with the list of
violations; it merely creates the list.  You will need to write your own
code to process that list; see @ref{Accessing violations}.


Here is an example of use of the runtime-check instrumenter.
To create a version of file
@file{ubs/BoundedStack.java} that checks the invariants in 
invariant file @file{BoundedStack.inv.gz}, do:
@example
java daikon.tools.runtimechecker.Main instrument BoundedStack.inv.gz \
    ubs/BoundedStack.java
@end example
@noindent
The instrumented Java code references classes in the
@code{daikon.tools.runtimechecker} package, so those classes must be
present in the classpath when the instrumented classes are compiled and
executed.

Invariants are evaluated at the program points at which they should
hold. Three things can happen when evaluating an
invariant:

@itemize @bullet
@item
It evaluates to true, which means that the invariant holds.
Program execution continues normally.

@item
It evaluates to false, which means that the invariant doesn't
hold. In this case the corresponding
@code{daikon.tools.runtimechecker.Property} is added to a list in the
class @code{daikon.tools.runtimechecker.Runtime}. A programmer can
obtain the growing list of violated invariants through the method
@code{daikon.tools.runtimechecker.Runtime.getViolations()}. (See
that class for other useful methods.)

@item
A @code{Throwable} (exception) is thrown when evaluating the
invariant.  In this case, the throwable is added to the list
@code{daikon.tools.runtimechecker.Runtime.internalInvariantEvaluationErrors}.
The throwable is not rethrown.

@end itemize


@menu
* Accessing violations::        
@end menu

@node    Accessing violations,  , Runtime-check instrumenter, Runtime-check instrumenter
@subsubsection Accessing violations

The instrumented class handles violations silently:
it simply adds them to a list in the class
@code{daikon.tools.runtimechecker.Runtime.}  
No ``invariant violation'' exceptions are thrown, and the violated
invariants can only be obtained dynamically from class
@code{daikon.tools.runtimechecker.Runtime}.

A future release of Daikon will provide tools that process the list in
the following ways:
@enumerate
@cindex WriteViolationFile tool
@item To write a file of all the violations for a program execution.
A prototype of such a tool is provided in the Daikon distribution, as
program @code{daikon.tools.runtimechecker.WriteViolationFile}.  If you
would ordinarily run your program as @samp{java MyProg arg1 arg2},
then running @samp{java daikon.tools.runtimechecker.WriteViolationFile
MyProg arg1 arg2} creates a file called @file{violations.txt} in the
current directory.  If the program under test calls
@code{System.exit}, then no @file{violations.txt} file is created.
@item Throw an exception when any violation occurs.
@end enumerate


The following code snippet contains a method @code{callMethod()} which
presumably calls one of the methods in the instrumented class.
The code detects if any violations occurred, and if so, prints 
a message.

@example
daikon.tools.runtimechecker.Runtime.resetViolations();
daikon.tools.runtimechecker.Runtime.resetErrors();

callMethod();

List<Violation> vs = daikon.tools.runtimechecker.Runtime.getViolations();

if (!vs.isEmpty())
  System.out.println("Violations occurred.");
@end example

In addition, the instrumenter adds the following two methods to the
instrumented class:

@itemize @bullet
@item
@code{isDaikonInstrumented()}.  Returns true (you could calling
this method to see if the class has been instrumented).

@item
@code{getDaikonInvariants()}.  Returns the array of properties being checked.
@end itemize

@strong{Known bug (logical shift in Java).}
Daikon's Java parser (adopted from javacc and JTB) accepts Java 1.5 syntax.
An error in the new parser
may produce illegal Java in the instrumented file, if the source file to
be instrumented includes logical shift operators. @xref{Known bugs}.

@node    InvariantChecker, LogicalCompare, Runtime-check instrumenter, Tools for manipulating invariants
@subsection InvariantChecker

@cindex InvariantChecker tool

The InvariantChecker program takes a set of invariants found by Daikon
and a set of data trace files.  It checks each sample in the data trace
files against each of the invariants.  Any sample that violates an invariant
is noted, via a message printed to standard output or to a specified
output file.

InvariantChecker is invoked as follows:
@example
java daikon.tools.InvariantChecker [@var{options}] @var{invariant-file} @var{dtrace-files} 
@end example

The @var{invariant-files} are invariant files (@file{.inv}) created by
running Daikon.  The @var{dtrace-files} are data trace (@file{.dtrace})
files created by running the instrumented program.  The files may appear
in any order; the file type is determined by whether the file name
contains @file{.dtrace}, or @file{.inv}.

The options are:
@table @option

@item --help
Print usage message.

@item --output @var{output-file}
Write any violations to the specified file.

@item --config_option @var{name}=@var{value}
@itemx --dbg @var{category}
@itemx --track @var{class}<@var{var1},@var{var2},@var{var3}>@@@var{ppt}
These switches are the same as for Daikon.  They are described in
@ref{Running Daikon}.

@end table

@node LogicalCompare,  , InvariantChecker, Tools for manipulating invariants
@subsection LogicalCompare

@cindex LogicalCompare tool
@cindex implication checking tool
@cindex comparison tool, logical

Given two sets of invariants describing the operation of a software
module, or describing two implementations of a module with the same
interface, we can define one set of invariants to be ``stronger'' than
another roughly if in any situation where the ``stronger'' invariants
hold, the ``weaker'' invariants also hold.  The LogicalCompare tool
examines two sets of invariants, and checks using the Simplify
automatic theorem prover whether they satisfy a precise version of
this relationship.

Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed in
order to use this program.

The LogicalCompare program takes two mandatory arguments, which are
@file{.inv} files containing invariants; the invariants will be
checked to verify if the invariants in the first file are weaker
(implied by) the invariants in the second file, and exceptions to this
implication are printed.  If no other regular arguments are supplied,
all the method or function program points that exist in both files
will be compared, with a exception message reported for each method
that exists in the ``weaker'' set but not the ``stronger''.
Alternatively, one or two additional arguments may be supplied, which name an 
@code{:::ENTER} program point and an @code{:::EXIT} program point to examine
(if only an @code{:::ENTER} program point is supplied,
the corresponding combined @code{:::EXIT} point
is selected automatically).  To be precise, for each
pair of program points representing a single method or function,
LogicalCompare will check that each precondition (@code{:::ENTER} point
invariant) in the ``stronger'' invariant set is implied by some
combination of invariants in the ``weaker'' invariant set, and that
each postcondition (@code{:::EXIT} point invariant) in the ``weaker'' invariant
set is implied by some combination of postconditions in the
``stronger'' set and preconditions in the ``weaker'' set.  In summary,
the syntax of an invocation of LogicalCompare will have the following
form:

@example
java daikon.tools.compare.LogicalCompare [@var{options}] \
      @var{weak-invs} @var{strong-invs} [@var{enter-ppt} [@var{exit-ppt}]]
@end example

LogicalCompare accepts the following options:

@table @option
@item --assume @var{file}
Read additional assumptions about the behavior of compared routines
from the file @var{file}.  The assumptions file should consist of lines
starting with @samp{PPT_NAME}, followed by the complete name of an
@code{:::ENTER} program point, followed by lines each consisting of a Simplify
formula, optionally followed by a @code{#} and a human-readable
annotation.  Blank lines and lines beginning with a @code{#} are
ignored.  The assumption properties will be used as if they were
invariants true at the strong @code{:::EXIT} point when checking 
weak @code{:::EXIT} point invariants.

@item --cfg @var{option}=@var{value}
Specify a single configuration setting.  The available settings are the
same as can be passed to Daikon's @option{--config_option} option,
though because the invariants have already been generated, some will
have no effect.  For a list of
available options, see @ref{Configuration options}.

@item --config-file=@var{file}
Read configuration options from the file @var{file}.  This file should
have the same format as one passed to Daikon's @option{--config}
option, though because the invariants have already been generated,
some will have no effect.

@item --debug-all
@itemx --dbg @var{category}
These options have the same effect as the @option{--debug} and
@option{--dbg} options to Daikon, causing debugging logs to be
printed.

@item --filters=[bBoOmjpi]
Control which invariants are removed from consideration before
implications are checked.  Note that except as controlled by this
option, LogicalCompare does not perform any of the filters that
normally control whether invariants are printed by Daikon.  Also,
invariants that cannot be formatted for the Simplify automatic theorem
prover will be discarded in any case, as there would be no other way
to process them.  Each letter controls a filter: an invariant is reject
if it is reject by any filter (or, equivalently, kept only if it
passes through every filter).

@table @option
@item b
Discard upper-bound and lower-bound invariants
(such as ``x <= c'' and ``x >= c'' for a
constant c), when Daikon considers the constant to be uninteresting.
Currently, Daikon has a configurable range of interesting constant: by
default, -1, 0, 1, and 2 are interesting, and no other numbers are.

@item B
Discard all bound invariants, whether or not the constants in them are
considered interesting.

@item o
Discard ``one-of'' invariants (which signify that a variable always
had one of a small set of values at runtime), when the values that the
variable took are considered uninteresting by Daikon.

@item O
Discard all ``one-of'' invariants, whether or not the values involved
are interesting.

@item m
Discard invariants for which it was never the case that all the
variables involved in the invariant were present at the same time.

@item j
Discard invariants that Daikon determines to be statistically
unjustified, according to its tests.

@item p
Discard invariants that refer to the values of pass-by-value
parameters in the postcondition, or to the values of objects pointed
to by parameters in postconditions, when the pointer is not
necessarily the same as at the entrance to the method or function.
Usually such invariants reflect implementation details that would not
be visible to the caller of a method.

@item i
Discard implication invariants when they appear in @code{:::ENTER} program
points.
@end table

The default set of filters corresponds to the letters @option{ijmp}.

@item --help
Print a brief summary of available command-line options.

@item --no-post-after-pre-failure
If implication is not verified between two invariant sets after
examining the preconditions, do not continue to check the implication
involving postconditions.  Because the postconditions aren't formally
meaningful outside the domain specified by the preconditions, this is
the safest behavior, but in practice trivial precondition mismatches
may prevent an otherwise meaningful postcondition comparison.  See also
@option{--post-after-pre-failure}.

@item --proofs
For each implication among invariants that is verified, print a
minimal set of conditions that establish the truth of the conclusion.
The set is minimal, in the sense that if any condition were removed,
the conclusion would no longer logically follow according to Simplify,
but it is not the least such set: there may exist a smaller set of
conditions that establish the conclusion, if that set is not a subset
of the set printed.  Beware that because this option uses a naive
search technique, it may significantly slow down output.

@item --post-after-pre-failure
Even if implication is not verified between two invariant sets after
examining the preconditions, continue to check the implication
involving postconditions.  This is somewhat dangerous, in that if the
implication does not hold between the preconditions, the invariant
sets may be inconsistent, in which case reasoning about the
postconditions is formally nonsensical, but the tool will attempt to
ignore the contradiction and carry on in this case.  This is now the
default behavior, so the option has no effect, but it is retained for
backward compatibility.  See also @option{--no-post-after-pre-failure}.

@item --show-count
Print a count of the number of invariants checked for implication.

@item --show-formulas
For each invariant, show how it is represented as a logical formula
passed to Simplify.

@item --show-sets
Rather than testing implications among invariants, simply print the
sets of weak and strong @code{:::ENTER} and @code{:::EXIT} point invariants that would
normally be compared.  The invariants are selected and filtered as
implied by other options.

@item --show-valid
Print invariants that are verified to be implied (``valid''), as well
as those for which the implication could not be verified (``invalid''
invariants, which are always printed).

@item --timing
For each set of invariants checked, print the total time required for
the check.  This time includes both processing done by LogicalCompare
directly, and time spent waiting for processing done by Simplify, but
does not include time spent de-serializing the @file{.inv} input
files.

@end table


@node  DtraceDiff utility,  , Tools for manipulating invariants, Tools
@section DtraceDiff utility

DtraceDiff is a utility for comparing data trace (@file{.dtrace}) files.
It checks that the same program points are visited in the same order in
both files, and that the number, names, types, and values of variables
at each program point are the same.  The differences are found using a
content-based, rather than text-based, comparison of the two files.

DtraceDiff stops by signalling an error when it finds a difference
between the two data trace files.  (Once execution paths have
diverged, continuing to emit record-by-record differences is likely to
produce output that is far too voluminous to be useful.)  It also
signals an error when it detects incompatible program point
declarations or when one file is shorter than the other.

DtraceDiff is invoked as follows:
@example
java daikon.tools.DtraceDiff [@var{flags}] \
   [@var{declsfiles1}] @var{dtracefile1}  [@var{declsfiles2}] @var{dtracefile2}
@end example

Corresponding declarations (@file{.decls}) files can optionally be
specified on the command line before each of the two @file{.dtrace}
files.  Multiple @file{.decls} files can be specified.  If no
@file{.decls} file is specified, DtraceDiff assumes that the
declarations are included in the @file{.dtrace} file instead.

DtraceDiff supports the following Daikon command-line flags:

@table @option
@item --help
Print usage message.

@item --config @var{filename}
Load the configuration settings specified in the given file.
@xref{Configuration options}, for details.

@item --config_option @var{name}=@var{value}
Specify a single configuration setting.
@xref{Configuration options}, for details.

@item --ppt-select-pattern=@var{ppt_regexp}
Only process program points whose names match the regular expression,
which uses Perl syntax.

@item --ppt-omit-pattern=@var{ppt_regexp}
Do not process program points whose names match the regular expression,
which uses Perl syntax.  This takes priority over the
@option{--ppt-select-pattern} argument.

@item --var-select-pattern=@var{ppt_regexp}
Only process variables (whether in the trace file or derived) whose
names match the regular expression, which uses Perl syntax.

@item --var-omit-pattern=@var{var_regexp}
Ignore variables (whether in the trace file or derived) whose names
match the regular expression, which uses Perl syntax.  This takes
priority over the @option{--var-select-pattern} argument.

@end table

DtraceDiff uses appropriate comparisons for the type of the variables in
each program point being compared.  In particular:

@itemize @bullet
@item Hashcode (pointer or address) values may differ from one run of
the same program to the next, and there may not be a one-to-one mapping
of hashcode values between different program executions, so the
comparison function only looks for null versus non-null pointer values.

@item Floating-point values are subject to roundoff error from printing and
reading, so they are compared with a ``fuzzy'' rather than exact equality test.
@end itemize

@node    Troubleshooting, Details, Tools, Top
@chapter Troubleshooting

@cindex troubleshooting
@cindex warning messages
@cindex error messages

This chapter gives solutions for certain problems you might have with
Daikon; it also tells you how to report bugs in a useful manner.


@menu
* Daikon problems::             
* Large dtrace files::          
* Parsing Java 5.0 code::       
* Chicory problems::            
* Reporting bugs::              
* Known bugs::                  
* Further reading::             
@end menu


@node    Daikon problems, Large dtrace files, Troubleshooting, Troubleshooting
@section Problems running Daikon

You may find the debugging flags @option{--debug} and @option{--dbg
@var{category}} useful if you wish to track down bugs or better
understand Daikon's operation; @xref{Daikon debugging options}.
@xref{Configuration options}, for another way to adjust Daikon's output.


@menu
* Too much output::             
* No samples::                  
* No return from procedure::    
* Unsupported class version::   
* Out of memory::               
* Simplify errors::             
* Contradictory invariants::    
* Method needs to be implemented::  
* Daikon runs slowly::          
@end menu


@node    Too much output, No samples, Daikon problems, Daikon problems
@subsection Too much output

@cindex too much output from Daikon

Sometimes, Daikon may produce a very large number of seemingly
irrelevant properties that obscure the facts that you were hoping to
see.  Usually, such output indicates a deficiency in your test suite:
your test suite is so small that many arbitrary properties hold over it.
This happens when the test suite does not execute the code with a broad
distribution of values, but only executes the code with a few specific
values.  This problem disappears if you augment your test suite so that
it exercises the code with more different values.

Each property that Daikon produces is a true fact about how the target
program behaved.  However, some of these facts would be true for any
execution of the target program, and others are accidents of the
particular executions that Daikon observed.  Both types of facts are
useful:  the former tell you about your program, and the latter tell you
about your test suite (and how to improve it!).


@node    No samples, No return from procedure, Too much output, Daikon problems
@subsection No samples and no output

@cindex no output from Daikon

When Daikon produces no output, that is usually a result of it having no
samples from which to generalize.  Use the @option{--output_num_samples}
flag to Daikon to find out how many samples it is observing.  This
section tells you how to debug your problem if the
answer is 0, but you believe that there are samples in the file you are
feeding to Daikon.

Daikon processes only @code{:::ENTER} program points that have a 
matching @code{:::EXIT}
program point.  (You can disable this behavior with the
@option{--nohierarchy} switch to Daikon; 
see @xref{Options to control invariant detection}.)  
If no @code{:::EXIT} program points are present (perhaps every
execution threw an exception, or you filtered out all the 
@code{:::EXIT} program points), 
then Daikon will not process any of the @code{:::ENTER} program points.
You can make Daikon print information about unmatched procedure entries
via the @samp{daikon.FileIO.unmatched_procedure_entries_quiet}
configuration option (@pxref{General configuration options}).


@node    No return from procedure, Unsupported class version, No samples, Daikon problems
@subsection No return from procedure

@cindex no return from procedure, warning
@cindex return from procedure, warning

Daikon sometimes issues a warning that a procedure in the target program
was entered but never exited (that is, the target program abnormally
terminated).  In other words, the @file{.dtrace} file contains more
entry records
than exit records for the given procedure.  Some procedures that were
entered were never recorded to have exited: either they threw an
exception, skipping the instrumentation code that would have recorded
normal termination, or the target program's run was interrupted.
When this happens, the entry sample is ignored; the rationale is that
the particular values seen led to exception exit, were probably
illegal, and so should not be factored into the method preconditions.

@cindex invocation nonce
@cindex nonce, invocation
@cindex this_invocation_nonce

In some cases, exceptional exit from a procedure can cause procedure
entries and exits (in the trace file) to be incorrectly matched up; if
they are incorrectly matched, then the @code{orig(@var{x})} values may
be incorrect.  Daikon has two techniques for associate procedure exits
with entries --- the nonce technique and the stack technique.  If a
@file{.dtrace} file uses the nonce technique, @code{orig(@var{x})}
values are guaranteed to be correct.  If a @file{.dtrace} file uses
the stack technique, then incorrect @code{orig(@var{x})} values are
likely to occur.  You can tell which technique Daikon will use by
examining the @file{.dtrace} file.  If the second line of each entry
in the @file{.dtrace} file is @samp{this_invocation_nonce}, then Daikon
uses the nonce technique.  Otherwise, it uses the stack technique.
Which technique is used is determined by the front end, which creates
the @file{.dtrace} file, and typically cannot be controlled by the
user.


@node    Unsupported class version, Out of memory, No return from procedure, Daikon problems
@subsection Unsupported class version

@cindex UnsupportedClassVersionError
@cindex java.lang.UnsupportedClassVersionError
@cindex major.minor version error

Daikon requires a Java 5 JVM (@pxref{Requirements}).
An error such as 
@example
Exception in thread "main" java.lang.UnsupportedClassVersionError:
daikon/Daikon (Unsupported major.minor version 49.0)
@end example
@noindent
indicates that you are trying to run Daikon on an older JVM.  You need to
install a newer version of Java in order to run Daikon.


@node    Out of memory, Simplify errors, Unsupported class version, Daikon problems
@subsection Out of memory

@cindex out of memory error
@cindex java.lang.OutOfMemoryError
@cindex memory exhaustion
@cindex HotSpot JVM
@cindex JVM memory management
@cindex permanent generation (in HotSpot JVM)

If Daikon runs out of memory, generating a message like
@example
Exception in thread "main" java.lang.OutOfMemoryError
        <<no stack trace available>>
@end example
@noindent
then it is likely that it has created more invariants than will fit
in memory.  The number of invariants created depends on the number of
program points and the number of variables at each program point.
In addition to the solutions discussed in @ref{Reducing program points}, 
you can try increasing the amount of memory available to Java
with the @option{-mx} argument to @command{java}.  (This flag is
JVM-specific; see your JVM documentation for details.  For instance,
its correct name in JDK versions 1.3 and later is @option{-Xmx}.)
However, the value you use should be less your system's total amount
of physical memory.  
The default may be 64 megabytes or less; to permit use of up to 256
megabytes, you would run Java like so:
@example
java -mx256m ...
@end example

When using the Java HotSpot JVM, an additional parameter may need to
be increased.  HotSpot uses a separately-limited memory region, called
the ``permanent generation'', for several special kinds of allocation,
one of which (interned strings) Daikon sometimes uses heavily.  It may
be necessary to increase this limit as well, with the
@option{-XX:MaxPermSize=} option.  For instance, to use 512 megabytes,
of which at most 256 can be used for the permanent generation, you
would run Java like so:
@example
java -Xmx512m -XX:MaxPermSize=256m
@end example

Another possible problem is the creation of too many derived variables.
If you supply the @option{--output_num_samples} option to Daikon
(@pxref{Options to control Daikon output}), then it will list all
variables at each program point.  If some of these are of no interest,
you may wish to suppress their creation.  For information on how to do that,
see @ref{Options to enable/disable derived variables}.  Also see 
@ref{Reducing variables} for other techniques.

Any output generated before the out-of-memory error is perfectly valid.


@node    Simplify errors, Contradictory invariants, Out of memory, Daikon problems
@subsection Simplify errors

@cindex Simplify, could not utilize

The warning ``Could not utilize Simplify'' indicates that the Simplify
theorem-prover could not be run; this usually indicates that the
Simplify binary was not found on the user's path.
Simplify must be separately obtained (from
@uref{http://research.compaq.com/SRC/esc/Simplify.html}) and installed.

If Simplify is not used, certain redundant (logically implied)
invariants may appear in Daikon's output.  The output is
correct, but more verbose than it would be if you used Simplify.

@node Contradictory invariants, Method needs to be implemented, Simplify errors, Daikon problems
@subsection Contradictory invariants

@cindex contradictory invariants
@cindex inconsistent invariants
@cindex invariants, inconsistent
@cindex invariants, contradictory

The invariants Daikon produces are all true statements about the
supplied program executions, so they should be mutually consistent.
Sometimes, however, because of a bug or a limitation in Daikon,
contradictory invariants are produced.

One known problem involves object invariants.  Daikon infers object
invariants by observing the state of an object when its public methods
are called.  However, if an object has publicly accessible fields that
are changed by code outside the class, after which no public methods
are called, invariants about the state of the object as seen by other
code can contradict the class's object invariants.  A workaround is to
allow changes to an object's state from outside the class only by
way of public methods.

Besides confusing the user, contradictory invariants also cause
trouble for the Simplify theorem prover that implements the
@option{--suppress_redundant} option.  When the invariants at a
particular program point contradict each other or background
information (such as the types of objects), Simplify becomes unable to
distinguish redundant invariants from non-redundant ones.

The best solution in such cases is to fix the underlying cause of the
contradictory invariants, but since that is sometimes not possible,
Daikon will try to work around the problem by avoiding the invariants
that cause a contradiction.  Daikon will attempt to find a small subset
of the invariants that aren't mutually consistent, and remove one,
repeating this process until the remaining invariants are consistent.
(Note that the invariants are removed only for the purposes of
processing by Simplify; this does not affect whether they will be
printed in the final output).  While this technique can allow
redundant invariants to be found when they otherwise wouldn't be, it
has some drawbacks: the choice of which invariant to remove is
somewhat arbitrary, and the process of finding contradictory subsets
can be time consuming.  The removal process can be disabled with the
@option{daikon.simplify.LemmaStack.remove_contradictions}
configuration option.

@node    Method needs to be implemented, Daikon runs slowly, Contradictory invariants, Daikon problems
@subsection Method needs to be implemented

@cindex method needs to be implemented warning
@cindex needs to be implemented warning

Daikon may produce output like the following (but all on one line):
@example
method daikon.inv.binary.twoSequence.SubSequence.format_esc()
needs to be implemented:
this.theArray[0..this.topOfStack] is a subsequence of
orig(this.theArray[0..this.topOfStack])
@end example
@noindent
This indicates that a particular invariant (shown on the last two lines
above) cannot be formatted using the current formatting.  In this example,
the invariant can be formatted using Daikon's default
formatting (which is how it is shown above), but (as of April 2002)
Daikon cannot output it in ESC format, so Daikon prints the above
message instead.  The message also shows exactly what Java method needs
to be implemented to correct the problem.  You can ignore such messages,
or else use an output formatting that can handle those invariants.
Annotate (@pxref{Annotate}) automatically ignores unformattable invariants.


@node    Daikon runs slowly,  , Method needs to be implemented, Daikon problems
@subsection Daikon runs slowly

@cindex slow operation, of Daikon
@cindex runtime, of Daikon

Daikon's runtime and space depend on the particular data that it analyzes.
Informally, invariant detection time can be characterized as 
@example
O((@var{vars}^3 * @var{falsetime} + @var{trueinvs} * @var{testsuite}) * @var{procedures})
@end example
@noindent
where @var{vars} is the number of variables @emph{at a program point}, 
@var{falsetime} is the (small constant) 
time to falsify a potential invariant, 
@var{trueinvs} is the (small) number of
true invariants at a program point, 
@var{testsuite} is the size of the test
suite, and
@var{procedures} is the number of instrumented program points.  The first
two products multiply a number of invariants by the time to test each
invariant.

If there are many true invariants over an input, then Daikon continues
to check them all over the entire input.  By contrast, if not many
invariants are true, then Daikon need no longer check them once they
are falsified (which in practice happens quickly).  Daikon processes
each procedure independently.

Another important factor affecting Daikon's runtime is the number of
variables.  Because invariants involve up to three variables each, the
number of invariants to check is cubic in the number of variables at a
single program point.  Derived variables (such as @code{a[i]},
introduced whenever there is both an array @code{a} and an integer
@code{i}) can increase the number of variables substantially.
The @option{daikon.Daikon.disable_derived_variables} and individual
@option{daikon.derive.*.*.enabled} configuration variables 
(@pxref{Options to enable/disable derived variables}) may be used
to disable derived variables altogether or selectively, at the cost of
detecting fewer invariants, especially over sequences.

For details on improving Daikon's performance, see @ref{Out of
memory}, and @ref{Large dtrace files}.

@node    Large dtrace files, Parsing Java 5.0 code, Daikon problems, Troubleshooting
@section Large data trace (.dtrace) files


@cindex data trace files, too large
@cindex large data trace files

Running instrumented code can create very large @file{.dtrace} files.
This can be a problem because writing the large files can slow the
target programs substantially, or because the large files may fill up
your disk.  The solution is to create smaller data trace files, by 
computing invariants over fewer program
points (procedures), computing invariants over fewer variables, or
computing invariants over fewer samples (executions).

It is usually possible to create an @file{.inv} file equivalent to
the one that Daikon would have computed, had Daikon been able to
process your entire program over its full test suite.  First, use the
techniques below (@pxref{Reducing program points}) to split your
@file{.dtrace} file into parts.  Next, run Daikon on each resulting
@file{.dtrace} file.  Finally, use the union function of @ref{Invariant
Diff} to combine the resulting @file{.inv} files into one.
@c A more correct way to merge the resulting .inv files would be with
@c the MergeInvariants tool, but it is not yet documented,

Independently from the above techniques, you can run Daikon online.  
The term ``online execution'' refers to running Daikon at the same time
as the target program, without writing any information to a file.  This
can avoid some I/O overhead, it prevents filling up your disk with
files, and in the future Daikon may be able to produce partial results
as the target program is executing.
@c The Chicory front end supports online execution via use of the
@c @option{--daikon} flag.
The Kvasir front end supports online execution via use of (normal or
named) Unix pipes (@pxref{Online execution}).

@menu
* Reducing program points::     
* Reducing variables::          
* Reducing executions::         
@end menu


@node    Reducing program points, Reducing variables, Large dtrace files, Large dtrace files
@subsection Reducing program points (functions)

Here are ways to compute invariants over a subset of the program
points (functions) in your program.
@enumerate
@item 
You can make Daikon ignore some program points.  With the
@option{--ppt-select-pattern=@var{ppt_regexp}}
flag (@pxref{Processing only part of the trace file}), 
only program points matching
the regular expression are processed.  Likewise, the
@option{--ppt-omit-pattern=@var{ppt_omit_regexp}} option causes program points
matching the regular expression to be ignored.

Also, the configuration variable @option{daikon.Daikon.ppt_perc}
allows a percentage of the program points to be processed. 
@xref{General configuration options}, for details.

@item 
@cindex trace-purge-fns.pl script
You can remove some program points (functions) from your
@file{.dtrace} file.  The @command{trace-purge-fns.pl} script takes as
arguments a (Perl) regular expression and a list of files.  It
modifies each file in place, removing every program point (function)
whose name matches the regular expression.  The @option{-v} flag means
to retain rather than discard matching program points.  For instance,
to create two subparts of a @file{.dtrace} file --- one containing the
getters and setters, and the other containing all other functions ---
use the following commands:
@example
cp myprog.dtrace myprog-setters.dtrace
trace-purge-fns.pl -v 'set|get' myprog-setters.dtrace
cp myprog.dtrace myprog-non-setters.dtrace
trace-purge-fns.pl 'set|get' myprog-non-setters.dtrace
@end example

@item 
You can instrument fewer methods, creating smaller @file{.dtrace}
files in the first place (rather than cutting the @file{.dtrace} files
down afterward).
@itemize
@item With Chicory, use the @option{--ppt-omit-pattern} or
@option{--ppt-select-pattern} options (see @ref{Processing only part of
the trace file}, @ref{Chicory options}) to
restrict which program points are traced.  Running the
instrumented program will result in a smaller @file{.dtrace} file that
contains fewer records.
@item With Kvasir, use the @option{--ppt-list-file} option to specify a list
of program points that should be traced (@pxref{Tracing only part of a
program} section for more details).
@c @item With dfec, split your program into multiple files, then
@c instrument only some of them (see below).
@end itemize

@item
If you are using a source-based front end, you can instrument fewer files.

@end enumerate

@node    Reducing variables, Reducing executions, Reducing program points, Large dtrace files
@subsection Reducing variables

Here are ways to compute invariants over a subset of the variables in
your program.  This changes the resulting invariants, because
invariants over the missing variables (including any relationship
between a missing variable and a retained variable) are not detected
or reported.  For instance, you might remove uninteresting variables
(or ones that shouldn't be compared to certain others) or variables
that use a lot of memory (such as some arrays).

@enumerate
@item
You can make Daikon ignore certain variables rather than modifying
the @file{.dtrace} file directly.  Analogously with the
@option{--ppt-select-pattern} and @option{--ppt-omit-pattern} flags, the
@option{--var-select-pattern} and @option{--var-omit-pattern} flags
restrict which variables Daikon processes
(see @ref{Processing only part of
the trace file}, and @ref{Chicory options}).

@item
You can reduce the number of variables that are output by instrumented
code --- for instance, output @samp{a} and @samp{a.b} but not
@samp{a.b.c}.  Do this by reducing the class/structure instrumentation
depth.
@itemize
@item With Chicory, use the @option{--nesting-depth=@var{N}} option.
@item With Kvasir, use the @option{--struct-depth=@var{N}} or the 
@option{--nesting-depth=@var{N}} option.
@item With Mangel-Wurzel, use the @option{--struct-depth=@var{N}} or the 
@option{--nesting-depth=@var{N}} option.
@end itemize

@item
With Kvasir, you can either ignore all global and/or static variables with the
@option{--ignore-globals} and @option{--ignore-static-vars} options or manually
specify a subset of variables to trace using the
@option{--var-list-file} option (@pxref{Tracing only part of a program}
section for details)

@item 
You can pare down an existing @file{.dtrace} file using the
@command{trace-purge-vars.pl} script.  Analogously to the 
@command{trace-purge-fns.pl} script, it removes certain variables from
all program points in a function (or retains them, with the
@option{-v} flag).  After running this command, you will need
to edit the corresponding @file{.decls} file by hand to remove the
same variables.

@end enumerate

@node    Reducing executions,  , Reducing variables, Large dtrace files
@subsection Reducing executions

Here are ways to run Daikon over fewer executions of each program
point.  (You cannot combine the resulting invariants in order to
obtain the same result as running Daikon over all the executions.)

@enumerate
@item
If you have multiple @file{.dtrace} files (perhaps resulting from 
multiple program runs), you can run Daikon on just some of them.

@item 
@cindex trace-untruncate program
You can terminate the instrumented program when it has created a
sufficiently large @file{.dtrace} file.  If you interrupt the program
while it is in the middle of writing a record to the @file{.dtrace}
file, the last record may be only partially written.  Use the
@command{daikon/bin/trace-untruncate} program to remove the last,
possibly partial, record from the file:
@example
trace-untruncate myfile.dtrace
@end example
@noindent
modifies @file{myfile.dtrace} in place to remove the last record.

Alternately, you can use the
@command{daikon/bin/trace-untruncate-fast} program.  It operates much
faster on very large files.  In order to use
@command{trace-untruncate-fast}, you must have already compiled it
(@pxref{Installing Daikon}).

@end enumerate


@node    Parsing Java 5.0 code, Chicory problems, Large dtrace files, Troubleshooting
@section Parsing Java 5.0 code

The Annotate (@pxref{Annotate}) and runtimechecker (@pxref{Runtime-check
instrumenter}) tools use an external library (JTB,
@uref{http://compilers.cs.ucla.edu/jtb/}) for parsing Java code.  That
external library has an error in parsing logical shift operators such as
@code{x << y} or @code{x >> y}.  Therefore, such invariants (along with
a few other invariants that cannot be properly formatted as Java code)
are suppressed from the output of these tools.  (Annotate inserts them
as comments, and runtimechecker silently ignores them.)


@c @node    Tree GUI font errors, Reporting bugs, Parsing Java 5.0 code, Troubleshooting
@c @section Tree GUI font errors
@c 
@c @cindex font not found
@c 
@c When running the Tree GUI on Linux, you may get font errors such as the following:
@c 
@c @example
@c Font specified in font.properties not found
@c   [--symbol-medium-r-normal--*-%d-*-*-p-*-adobe-fontspecific]
@c @end example
@c 
@c These errors are harmless; the Tree GUI will still run correctly.  To
@c prevent these errors from appearing in the future, take the following
@c steps:
@c 
@c @itemize @bullet
@c @item
@c Find out where your JDK root directory is.  In general, the JDK root directory
@c is where you run java from: @file{@var{JDK_ROOT}/bin/java}.
@c @item
@c Edit @file{@var{JDK_ROOT}/jre/lib/font.properties}, and comment out all lines
@c with the offending fonts.  For example, to eliminate the error messages
@c shown above, one would comment out all lines containing "fontspecific".
@c @end itemize
@c 
@c If you don't have permission to edit @file{font.properties}, ask
@c your system administrator to do so.


@node    Chicory problems, Reporting bugs, Parsing Java 5.0 code, Troubleshooting
@section Problems with Chicory

Before reporting or investigating a problem with Chicory, always check
that the program executes properly when not being run under Chicory's
control.

For example, if a command such as 
@example
java daikon.Chicory DataStructures.StackArTester
@end example
@noindent
fails with an error, then first try
@example
java DataStructures.StackArTester
@end example
@noindent
which is likely to fail with the same error.

If the latter command also fails, the problem is not with Chicory.
First solve your Java problem, then once again attempt to use Chicory.

If the latter command does not fail, then you have found a bug in
Chicory; please report it if it is not already explained in this manual.


@menu
* VerifyError constant pool index error::  
@end menu

@node    VerifyError constant pool index error,  , Chicory problems, Chicory problems
@subsection VerifyError constant pool index error

@cindex VerifyError, when running Chicory
@cindex java.lang.VerifyError, when running Chicory
@cindex illegal constant pool index error, when running Chicory
@cindex constant pool index error, when running Chicory

If Chicory throws an error such as the following:
@example
Exception in thread "main" java.lang.VerifyError: 
  (class: ps1/PublicTest, method: <init> signature: (Ljava/lang/String;)V)
  Illegal constant pool index
@end example
@noindent
then the problem is most likely that your classpath contains a version
of the BCEL library (@file{bcel.jar}) that is not compatible with Java
5.  You should either remove that version of BCEL from your classpath,
or you should ensure that it appears after @file{daikon.jar}.  (If you
are running Daikon from sources rather than from @file{daikon.jar}, then
ensure that @file{$DAIKONDIR/java/lib/bcel.jar} is the first version of
BCEL on your classpath.)


@c @node    Eclipse plug-in problems, Reporting bugs, dfej problems, Troubleshooting
@c @section Problems with Eclipse plug-in
@c 
@c @cindex Eclipse plug-in, troubleshooting
@c 
@c If you have trouble with the Eclipse plug-in, one good way to debug the
@c difficulty is to run the command-line tools (because the plug-in does
@c nothing more than run those tools for you).  If the command-line
@c versions work properly, then you have isolated the bug to the plug-in.
@c If the command-line versions do not work properly, then you can submit a
@c more specific bug report that is easier for the developers to reproduce
@c and correct.


@node    Reporting bugs, Known bugs, Chicory problems, Troubleshooting
@section Reporting bugs

@cindex reporting bugs
@cindex bugs, reporting

If you have any questions, can suggest ways to improve the
documentation, find bugs in the system, or have suggestions for its
improvement, please send email to
@email{daikon-developers@@lists.csail.mit.edu}.  (If you can't figure
out how to do something or do not understand why Daikon works the way it
does, that is a bug, too --- in the Daikon documentation.  Please report
those as well.)
We will try to assist you and to correct any
problems, so please don't hesitate to ask for help or report
difficulties.  Additionally, if you can contribute enhancements or bug
fixes, those will be gratefully accepted.

In order for us to assist you, please provide a complete and useful bug
report.  Your bug report must provide all the information that is
required in order to replicate the bug and verify that our fix corrects
the problem.  If you do not provide complete information, we will not be
able to assist you.

Your bug report should include:
@itemize @bullet
@item
the version of Daikon, which appears in the file @file{daikon/README}
and is also printed when you run Daikon.
@c ; also, whether you are running
@c from the @file{.class} files or from the @file{.jar} file.
If you are not using the most recent version, download a newer version
from @uref{http://pag.csail.mit.edu/daikon/} to see whether your problem
has already been corrected.
If you are using a modified version of Daikon, you should verify that
the problem exists in Daikon as distributed.
@item
a description of exactly what you did (in sufficient detail for others
to reproduce the problem), exactly what happened, and what
you expected to happen instead.
For instance, a transcript of your commands and the system's output
may provide this information.  (A transcript is @strong{much} more
useful than a vague description; don't just give English when you can
give a more precise specification instead.)
It is crucial that you not omit steps in your report.  Do not force the
developers to speculate about what you did; that is a waste of their
time, since you already have the knowledge.
@item
input files that permit the problem to be replicated (by following the
detailed steps in your bug report).  The
most important thing is the original, uninstrumented source files.
It is also helpful to include instrumented source files,
@file{.decl} files, and @file{.dtrace} files.
@item
any other information that you consider relevant.
@end itemize

When users provide an inadequate bug report, 
it is frequently more difficult for us to reproduce an error than to correct
it.  If you make it easy for us to reproduce and verify the problem, then it is
much more likely to be corrected.

You may also wish to take advantage of the Daikon mailing lists
(@pxref{Mailing lists}).


@node    Known bugs, Further reading, Reporting bugs, Troubleshooting
@section Known bugs

@c @c Use the following if there are no known problems.
@c There are no outstanding user-reported problems at this time.

@c The following problems are already known.  (You may report them again,
@c to encourage us to fix them faster, if the problems are important to you.)

@itemize @bullet
@item
This problem affects @ref{Annotate} and the @ref{Runtime-check
instrumenter}, which output Java source code. If
the java file to be annotated/instrumented uses logical
shift operators (@code{>>}, @code{<<}, and @code{>>>}), the 
annotated/instrumented java may contain extra brackets in these
operators. For example, the expression @code{x << y} in the input source
file may erroneously be translated as @code{x <<<<<< y} in the
annotated/instrumented file.

This error's presence will be immediately apparent if you try to compile
the annotated/instrumented file and it fails to compile because the
extra brackets make it syntactically illegal. In this case, the best
solution we can recommend is that you manually fix the occurrence of the
logical shift operator.

This error is caused by a bug in the parser generator that generates
Daikon's Java parser. We expect it will be fixed by the next release.
@end itemize

@node    Further reading,  , Known bugs, Troubleshooting
@section Further reading

More information on Daikon can be found in the Daikon Developer Manual
(@pxref{Top,,,./developer,Daikon Developer Manual}).
For instance, the Daikon Developer Manual indicates how to extend
Daikon with new invariants, new derived variables, and front ends for
new languages.  It also contains information about the implementation
and about how to debug.

You may find discussions on the mailing lists (@pxref{Mailing lists})
helpful.  The mailing list archives may contain helpful information, but
we strive to incorporate that information in this manual so that you
don't have to search the archives as well.

For further reading, see the list of publications at the 
Daikon homepage, @uref{http://pag.csail.mit.edu/daikon/pubs/}.


@node    Details, File formats, Troubleshooting, Top
@chapter Details

The Daikon invariant detector is named after an Asian radish.
``Daikon'' is pronounced like the combination of the two one-syllable
English words ``die-con''.

More information on Daikon can be found in the Daikon Developer Manual
(@pxref{Top,,,./developer,Daikon Developer Manual}).
For instance, the Daikon Developer Manual indicates how to extend
Daikon with new invariants, new derived variables, and front ends for
new languages.  It also contains information about the implementation
and about debugging flags.


@menu
* History::                     
* License::                     
* Mailing lists reminder::      
* Credits::                     
* Citing Daikon::               
@end menu

@node    History, License, Details, Details
@section History
@cindex history of Daikon

This manual describes Daikon version 4.1.7, released November 1, 2005.
A more detailed list of revisions since mid-2001 can be found in file
@file{daikon/doc/CHANGES} in the distribution; this section gives a
high-level view of the package's history.

There have been four major releases of Daikon, with different features
and capabilities.  User experiences and technical papers should be
judged based on the version of Daikon current at the time of use.

@cindex Lisp front end
@cindex front end for Lisp
@c @cindex loop heads, instrumenting
@c @cindex instrumenting loop heads
@cindex Python implementation of Daikon
@cindex Daikon version 4.1.7

Daikon 1 was written in the Python programming language in 1998.  It included
front ends for C, Java, and Lisp.  The C front end was extremely limited
and failed to operate correctly on all C programs:  sometimes it
suffered a segmentation fault while instrumenting a target program, and even
when that did not happen, sometimes the instrumented program
segmentation-faulted while running.  The Lisp front end operated
correctly on all Lisp programs, but only instrumented certain common
constructs, leaving other language features uninstrumented.  The Java front
end was reasonably reliable.  The Lisp front end instrumented procedure
entries, exits, and loop heads; the C front ends instrumented only
procedure entries and exits; and the Java front end instrumented program
points for object invariants as well as procedure entries and exits.

Daikon 2 was a complete rewrite in the Java programming language and was
the first version to contain a substantive manual.  Daikon 2 uses the
same source-based Java front end as did Daikon 1, though with certain
enhancements.  Its C front end was rewritten from scratch; it
instruments only procedure entries and exits.  A front end also exists
for the IOA programming language, but is not included in the Daikon
distribution.

Daikon 3 is a redesign of the invariant detection engine to work
incrementally --- that is, to examine each sample (execution of a
program point) once, then discard it.  By contrast, Daikon 1 and
Daikon 2 made multiple passes over the data.  This simplified their
algorithms but required storing all the data in memory at once, which
was prohibitive, particularly since data trace files may be gigabytes
in size.  Daikon 3 also introduces the idea of a @emph{dataflow
hierarchy}, a way to relate and connect program points based on their
variables.

Daikon 4 includes new binary front ends for Java and for C.  These front
ends make Daikon much easier to use.  Daikon 4 makes @file{.decls} files
optional; program point declarations are permitted to appear in
@file{.dtrace} files.  Daikon 4 is released under more liberal licensing
conditions that place no restrictions on use.


@node    License, Mailing lists reminder, History, Details
@section License

@cindex license

Copyright @copyright{} 1998-2005 Massachusetts Institute of Technology

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

The names and trademarks of copyright holders may not be used in
advertising or publicity pertaining to the software without specific prior
permission. Title to copyright in this software and any associated
documentation will at all times remain with the copyright holders.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT@.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE@.


@c As a condition of use, you agree to promptly communicate any changes,
@c improvements, or enhancements to the authors for inclusion in a
@c future release, and to promptly report any errors, problems, or
@c bugs. 
@c Other licensing terms are available;
@c send mail to @email{mernst@@csail.mit.edu}.

@sp 1

Daikon uses the Java port of the GNU getopt library, which is
copyright 1998 Aaron M.@: Renn.  The getopt library is free software, and
may be redistributed or modified under the terms of the GNU Library
General Public License version 2.  A copy of this license is included
with the Daikon distribution as the file
@file{java/gnu/getopt/COPYING.LIB}.

Daikon's unit tests use the JUnit testing framework, which is governed
by the Common Public License, version 1.0.  JUnit is provided on an
``as is'' basis, without warranties or conditions of any kind, either
express or implied including, without limitation, any warranties or
conditions of title, non-infringement, merchantability or fitness for
a particular purpose.  Neither the Daikon developers nor the authors of
the JUnit framework shall have any liability for any direct, indirect,
incidental, special, exemplary, or consequential damages (including
without limitation lost profits), however caused and on any theory of
liability, whether in contract, strict liability, or tort (including
negligence or otherwise) arising in any way out of the use or
distribution of JUnit or the exercise of any rights granted in
the Common Public License, even if advised of the possibility of such
damages.  Those portions of JUnit that appear in the Daikon
distribution may be redistributed under the same terms as Daikon
itself; this offer is made by the Daikon developers exclusively and
not by any other party.  The Common Public License is included with the
Daikon distribution as the file @file{java/junit/cpl-v10.html}.

Note that the front ends discussed in this manual are separate
programs, and some are made available under different licenses.
@c All
@c of the software in the main Daikon distribution is made available
@c under the same license as the Daikon tool proper, or a less
@c restrictive license.  However, 
Because the front ends are separate
programs not derived from the Daikon invariant detection tool, you are
neither required nor entitled to use the Daikon invariant detector
itself under these other licenses.

The Daikon Perl front end dfepl may be used and distributed under the
regular Daikon license or, at your option, either the GNU General
Public License or the Perl Artistic License (that is, under the same
terms as Perl itself).

The Daikon dynamic C front end Kvasir is based in part on the Valgrind
dynamic program supervision framework, copyright 2000-2004 Julian
Seward, the Sparrow Valgrind tool, copyright 2002 Nicholas Nethercote,
the MemCheck Valgrind tool, copyright 2000-2004 Julian Seward, and the
readelf program of the GNU Binutils, copyright 1998-2003 the Free
Software Foundation, Inc.  Kvasir is free software; you can
redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
Kvasir is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE@.  See the GNU General Public License
for more details.  You should have received a copy of the GNU General
Public License along with Kvasir, in a file kvasir/COPYING;
if not, write to the Free
Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA@.


@node    Mailing lists reminder, Credits, License, Details
@section Mailing lists reminder

If you use Daikon, please subscribe to the daikon-announce and
daikon-discuss mailing lists (@pxref{Mailing lists}).  The
daikon-announce list will inform you of new versions, enhancements,
and bug fixes.  On the daikon-discuss mailing list, you can obtain
help from, and offer help to, other users.  We would also appreciate a
brief description of how you are using Daikon, sent to
@email{daikon-developers@@lists.csail.mit.edu}.  We are curious about how
users exploit Daikon, and we are eager for anecdotes about its
successes and failures, so that we can make Daikon more effective for
its users.


@node    Credits, Citing Daikon, Mailing lists reminder, Details
@section Credits

@cindex contributors to Daikon

The following individuals have contributed to Daikon:
Yuriy Brun,
Jake Cockrell,
David Cok,
Adam Czeisler,
Brian Demsky,
Alan Donovan,
Nii Dodoo,
Alan Dunn,
Michael Ernst,
Eric Fellheimer,
William Griswold,
Philip Guo,
Melissa Hao,
Michael Harder,
Lee Lin,
Greg Jay,
Josh Kataoka,
Sandra Loosemore,
Vikash Mansinghka,
Stephen McCamant,
Samir Meghani,
Benjamin Morse,
Jelani Nelson,
Ryan Newton,
Jeremy Nimmer,
Toh Ne@w{ }Win,
David Notkin,
Carlos Pacheco,
Kathryn Shih,
Matthew Tschantz,
Iuliu Vasilescu,
Chen Xiao,
Tao Xie.

Craig Kaplan carved the Daikon logo.

The feedback of Daikon users has been very valuable.  We are
particularly grateful to
B. Thomas Adler,
Rich Angros,
Tadashi Araragi,
Seung Mo Cho,
Christoph Csallner,
Dorothy Curtis,
Diego Garbervetsky,
Madeline Hardojo,
Engelbert Hubbers,
Scott McMaster,
Alex Orso,
Manos Renieris,
Rosie Wacha.
Many others have also been generous with their feedback, for which we
are also grateful.

If your name has been inadvertently omitted from this section, please
let us know so we can correct the oversight.

Financial support has been provided by:
National Science Foundation (NSF),
Defense Advanced Research Projects Agency (DARPA),
Edison Design Group,
IBM,
NTT,
MIT Oxygen Project,
Raytheon,
Toshiba.


@node    Citing Daikon,  , Credits, Details
@section Citing Daikon

If you wish to cite Daikon in a publication, we recommend that you
reference one of the following papers in lieu of, or in addition to,
referencing this manual and the Daikon website
(@uref{http://pag.csail.mit.edu/daikon/pubs/}):

``Dynamically discovering likely program invariants to support program
evolution'' by Michael D. Ernst, Jake Cockrell, William G. Griswold, and
David Notkin.  IEEE Transactions on Software Engineering, vol. 27,
no. 2, Feb. 2001, pp. 1-25.  See
@uref{http://pag.csail.mit.edu/daikon/pubs/invariants-tse2001-abstract.html}[

``Efficient incremental algorithms for dynamic detection of likely
invariants'' by Jeff H. Perkins and Michael D. Ernst. In Proceedings of
the ACM SIGSOFT 12th Symposium on the Foundations of Software
Engineering (FSE 2004), (Newport Beach, CA, USA), November 2-4, 2004,
pp. 23-32.  See
@uref{http://pag.csail.mit.edu/daikon/pubs/invariants-incremental-fse2004-abstract.html}.


@node     File formats, Index, Details, Top
@appendix File formats

@cindex file formats

This chapter contains information about the file format of Daikon's input
files.  It is of most information to those who
wish to write a front end (@pxref{Front ends}), enabling Daikon to
detect invariants in another programming language.

Daikon's input is conventionally one or more @file{.dtrace} data trace
files.  There are two basic types of records that can appear in Daikon's
input:  program point declarations, and trace records.

A declaration describes the structure of the trace records.  One
declaration is required for each instrumented program point --- that is,
each program point for which a trace record may appear.  Each
declaration names a program point and lists the variables at that
program point.

A data trace record (also known as a ``sample'')
represents one execution of a program point.  The
record names the program point and gives the runtime values of each
variable.  The list of variables in the data trace record must be
identical to that in the corresponding declaration.  The program point
declaration must precede the first data trace record for the program
point, but it is not required that all the program point declarations
appear before any of the data trace records.  Each program point may be
declared only once; re-declarations (even identical ones) are not
currently permitted.

Instead of placing both declarations and data trace records in a single
file, it is permitted to place the declarations in one or more
@file{.decls} ``declaration files'' while leaving the data trace records
in the @file{.dtrace} file.  This can be convenient for tools that
perform a separate instrumentation step, such as dfepl (@pxref{dfepl})
and Mangel-Wurzel (@pxref{Mangel-Wurzel}).  Such a tool takes as
input a target program to be analyzed, and produces two outputs:  a
@file{.decls} file and an instrumented program.  Executing the
instrumented program produces a @file{.dtrace} file containing data
trace records for all the program points that appear in the
@file{.dtrace} file.  This approach works fine and is easier to
implement in certain situations, but has a few disadvantages.  It
requires the user to perform at least two steps --- instrumentation and
execution --- and the existence of two versions of the program
(instrumented and uninstrumented) can lead to confusion or extra work.
It is also more convenient to have a single file that contains all
information about a program, rather than multiple @file{.decls} files
that must be associated with the @file{.dtrace} file.


@menu
* Conventions::                 
* Declarations::                
* Data trace records::          
* Example files::               
@end menu

@node    Conventions, Declarations, File formats, File formats
@section File format conventions


Daikon files are textual, to permit easier viewing and editing by humans.
Each record is separated by one or more blank lines.
To permit easier parsing by programs, each piece of information in a record
appears on a separate line.

Outside a record, any line starting with a pound sign (#) is ignored as
a comment.  Comments are not permitted inside a record.


@node    Declarations, Data trace records, Conventions, File formats
@section Declarations

@cindex declaration format
@cindex .decls file

A declarations file can contain program point declarations,
@code{VarComparability} declarations, and @code{ListImplementors declarations}.

@menu
* Program point declarations::  
* pptname format::              
* VarComparability declaration::  
* ListImplementors declaration::  
@end menu

@node    Program point declarations, pptname format, Declarations, Declarations
@subsection Program point declarations

The format of a program point declaration is:
@example
DECLARE
program-point-name
varname1
declared-type1 [# auxiliary-information1]
representation-type1 [= constant-value1]
comparable1
varname2
declared-type2 [# auxiliary-information2]
representation-type2 [= constant-value2]
comparable2
...
@end example

Program point information includes:
@itemize @bullet
@item
name (``tag'') of this program point, an arbitrary string containing no
tab or newline characters.  This name contains information such as the
class name or method name; what information is contained depends on
which instrumenter is being used.  @xref{pptname format}, for a full
specification of the naming format.


@item
for each variable:
@itemize @bullet
@item
name: a string containing no tabs or newlines.  @xref{Variable names}.

@item
declared type: this is what the programmer used in the declaration of
the variable.  Array types must be suffixed by the proper number of
@samp{[]} to indicate their dimensionality.  Names for standard types
should use Java's names (e.g., @code{int}, @code{boolean}, etc.), but names for
user-defined or language-specific types can be arbitrary strings.

@item
auxiliary information: optionally, Daikon can be given information
about the meaning of the variable to help it better interpret the
values it later sees.  Information is provided as a comma-separated
list of items, with each item in the form of @samp{key = value}.  Unrecognized
keys are silently ignored.  All values are
either @samp{true} or @samp{false}.  Mainly, this information is used for
collections, which are presented to Daikon as arrays.  Valid keys are:

@table @code

@item hasDuplicates 
Whether a collection can contain duplicates.  If it
cannot, Daikon does not check for some invariants that only have
meaning for collections that can contain duplicate elements.

@item hasOrder
Whether order has meaning for a collection.  If order does
not have meaning in a collection, then Daikon does not check for
element-wise comparisons between it and other collections.  

@item hasNull 
Whether zero has the special meaning null for the variable or
collection.  If it does, then Daikon checks for whether a value or the
elements in a collection are null.

@item nullTerminated
Whether a collection has a value (usually null) that
ends its representation.  If it does, then Daikon looks at the
collection's size and at the collection's size-1 as ``interesting''
values.  If it does not, then Daikon only looks at the collection's
size.

@item isParam
Whether a given variable is a parameter to a method.  If a
variable is a parameter, Daikon avoids printing some information that
would be considered uninteresting for parameters.  First, invariants
that use the parameter variable @code{p} in its post-state form are not
printed.  Second, invariants that use fields of @code{p} (such as @code{p.x}) 
are printed only if @code{p} has not changed.  Lastly, some immutable
characteristics, such as the size of arrays and data types are not
printed (both can be changed if @code{p} is changed, but then, @code{p} 
would no longer be interesting).

@end table

@item
representation type:  this describes what will appear in the data
trace file.  For instance, the declared type might be @code{char[]} but
the representation type might be @code{java.lang.String}.  Or, the declared
type might be @code{Object} but the representation type might be
@code{hashcode}, if the address of the object is written to the data trace
file.

The representation type should be one of @code{boolean}, @code{int},
@code{hashcode}, @code{double}, or @code{java.lang.String}; or an
array of one of those (indicated by a @code{[]} suffix, as in Java).
Hashcodes are treated like integers, except that their actual values
are considered uninteresting for the purposes of output; they are
intended for unique object identifiers like memory addresses or the
return value of Java's @code{Object.hashCode} method.

The representation type may optionally be followed by an equals
sign and a value; in that case, the variable is known to have a
compile-time constant value and should be omitted from the data
trace file.
@end itemize
@item
@cindex comparability, for variables
@cindex variable comparability
comparable variables.  This information indicates
which other variables are comparable to this one.
This may be obtained dynamically, via type-inference based analysis, or
in some other manner.

A comparability for a non-array type is a signed integer.  Two variables
at the same program point
are considered comparable if both integers are the same, or if either
integer is negative.
A comparability for an array type must contain an
integer for each index and for the contents; for instance, @samp{5[22][17]}
for a two-dimensional array.  Comparisons succeed if comparisons over
each component succeed.

Variables at different program points are never compared to one another.
Use of the same number at different program points does not indicate any
relationship between the variables, and a given variable may have a
different comparability integer at different program points.

If no comparability information is supplied (i.e., this line is blank), then
the variable is considered comparable to all other variables of the same type.

As an example, in the following code:
@example
int sum(int len, int[] a) @{
  int sum=0;
  for (int i=0; i++; i<len)
    sum += a[i];
  return sum;
@}
@end example
variables @code{i} and @code{len} are comparable to one another (and
to indices of array @code{a}).  Furthermore, the result is comparable
to the elements of array @code{a}.  A declaration file for these
variables might look like
@example
len
int
int
5
a
int[]
int[]
8[5]
return
int
int
8
@end example

@end itemize

@c Future enhancements may include:
@c @itemize @bullet
@c @item
@c permit variables to be omitted if they haven't changed (but always
@c outputting the bit permits us to write a sanity checker)
@c @item
@c permit variables to appear in any order (not sure this is so worthwhile)
@c @item
@c specify which @file{.decl} files should be used (including their pathnames
@c and/or MD5 hashes)
@c @end itemize

@node    pptname format, VarComparability declaration, Program point declarations, Declarations
@subsection Program point name format specification

Instrumenting code creates a @file{.decls} file that contains program
point names such as:

@example
DataStructures.StackAr.push(java.lang.Object):::ENTER
DataStructures.StackAr.push(java.lang.Object):::EXIT99
PolyCalc.RatNum.RatNum(int, int):::ENTER
PolyCalc.RatNum.RatNum(int, int):::EXIT55
PolyCalc.RatNum.RatNum(int, int):::EXIT67
@end example

This section describes the format of these program point names.  Someone
writing an instrumenter for a new language must be sure to follow this
format specification.

A program point name is a string with no tabs or newlines in it.  The basic
format is @samp{@var{topLevel}.@var{bottomLevel}:::@var{pptInfo}}.
For the first example given above, the top level of the hierarchy would
be @code{DataStructures.StackAr}, the bottom level would be
@code{push(java.lang.Object)}, and the
program point information would be @code{ENTER}.

@var{topLevel} may contain any number of periods (@samp{.}). @var{bottomLevel}
and @var{pptInfo} may not contain any periods.  The string @samp{:::} may only
appear once.

@var{topLevel} and @var{pptInfo} are required (i.e., they must be non-empty),
as are the period to the right of @var{topLevel} and the colons to the
left of @var{pptInfo}.  However, @var{bottomLevel} is optional.

By convention, for Java @var{topLevel} consists of the class name, and
@var{bottomLevel} consists of the method name and method signature.

For C, @var{topLevel} consists of a filename (or a single period for
global functions), and @var{bottomLevel}
could consist of a function name and signature.
More precisely, names of C program points follow these conventions:

@itemize @bullet
@item 
Names of program points for file-static functions are prefixed with the name
of the source file, with @samp{.} characters mapped to @samp{_}, 
followed by a @samp{.}.

@item Names of program points for
file-scope functions with external linkage are prefixed with @samp{..}.
For example, a global function program point might be named 
@samp{..main():::ENTER}., the first period denoting that it is global in
scope and the second denoting the separator between the @var{toplevel}
and @var{bottomlevel} parts of the name.

@item
Names of C++ functions that are class or namespace members are prefixed
with the name(s) of their classes or namespaces, with the C++ @samp{::} 
syntax mapped onto the Java @samp{.} syntax used by Daikon.
@end itemize

For IOA, @var{topLevel} consists of an Automaton name and
@var{bottomLevel} consists of information for a transition state.



By convention, the entry and exit points for a function have names of
a special form so that they can be associated with one another.
(Currently, those names end with @code{:::ENTER} and @code{:::EXIT}.)  This
convention permits Daikon to generate pre-state variables 
(@pxref{Variable names}) automatically at procedure exit points, so 
front ends need not output them explicitly.  When there
are multiple exit points, then each one should be suffixed by a number
(such as a line number, for example, @code{foo::EXIT22}).  Daikon produces
the main (non-numbered) @code{:::EXIT} point automatically.  All the
numbered exits should contain the same set of variables; in general,
this means that local variables are not included at exit points.
Daikon currently requires that declarations for @code{:::ENTER} program
points appear before any declarations for matching @code{:::EXIT} program
points.

Another convention is to have another program point whose
@var{bottomLevel} is empty and whose @var{pptInfo} is  @code{OBJECT}:
for example, @code{StackAr:::OBJECT}.  This contains the
representation invariant (sometimes called the object invariant) of a
class.  This program point is created automatically by Daikon; it need
not appear in a trace file.

@c This program point is not created automatically by Daikon, because
@c there isn't a way to know whether a particular method is a private
@c helper method or not --- that is, whether the representation
@c invariants should hold on entry to and exit from it.



@node VarComparability declaration, ListImplementors declaration, pptname format, Declarations
@subsection VarComparability declaration

There is a special @code{VarComparability} declaration that controls how
the comparability field in program point declarations is interpreted.
The default @code{VarComparability} is @code{implicit}, which means
ordinary comparability as described in @ref{Program point declarations}.
(The name @code{implicit} is retained for historical reasons.)
You can override it as
follows:
@example
VarComparability
none
@end example
@noindent
As with all records in Daikon input files, a
blank line is required between this record and the next one.

@node ListImplementors declaration,  , VarComparability declaration, Declarations
@subsection ListImplementors declaration

This declaration can be used to indicate classes that implement the
@code{java.util.List} interface, and should be treated as sequences
for the purposes of invariant detection.  The syntax is as follows:

@example
ListImplementors
classname1
classname2
...
@end example

The @samp{--list_type} command-line option to Daikon can also be used to
specify classes which implement lists; see
@ref{Options to control invariant detection}, for information.


@node    Data trace records, Example files, Declarations, File formats
@section Data trace records

@cindex data trace format
@cindex .dtrace file

The format of the value information in a data trace record (also known
as a ``sample'') is:
@example
program-point-name
varname1
var-value-1
var-modified-1
varname2
var-value-2
var-modified-2
...
@end example

Value information includes:
@itemize @bullet
@item name of the program point

@item for each variable:
@itemize @bullet
@item name
@item value
@itemize @bullet
@item    integer: sequence of digits, optionally preceded by a minus sign.
Boolean values are written as the number 0 (for false) or the number 1
(for true).
@item    string: characters surrounded by double-quotes; internal
double-quotes and backslashes are escaped by a backslash; newlines and
carriage returns are represented as @samp{\n} and @samp{\r}, respectively
@item    array: elements are listed on one line, separated by spaces.
The entire array contents are in square brackets.  (Also, the array name
should end in @samp{[]}; use @samp{a[]} for array contents, 
but @samp{a} for the identity of the array itself.)
@end itemize

@cindex nonsensical values for variables
The value may also be the string @code{nonsensical}.
That means that the variable does not have a value because
the expression that computes it cannot be evaluated.  For instance, if
variable @code{a} has value @code{null}, then variable @code{a.b} would
have value @code{nonsensical}.  When the value is @code{nonsensical}, the
modified field should be 2.

@item modified? (0, 1, or 2).
@cindex modified bit
This value is 0 if the variable has not been assigned to since the
last time this program point was executed, and 1 if the variable has
been assigned to since then.  It is safe for an implementation to
always set it to 1.  It is also safe to always set it to 0, because
Daikon corrects obviously incorrect modification bits (such as 0 for a
never-before-seen value).

The special value 2 should be used only (and always) when the value
field is @code{nonsensical}.

@end itemize

The variables should appear in the same order as they did in the
declaration of the program point, without omissions or additions.
@end itemize

@cindex nonce, invocation
@cindex this_invocation_nonce

As a special case, the first variable in a record may be
@code{this_invocation_nonce}, in which case there is no modification
information, only a value.  The nonce is used to match up procedure entries
(whose names end with @code{:::ENTER}) with procedure exits (whose names end
with @code{:::EXIT}); this is necessary in concurrent systems because there may
be several invocations of a procedure active at once and they do not
necessarily follow a stack discipline, being exited in the reverse order of
entry.  For non-concurrent systems, this nonce is not necessary and may be
omitted.


@node    Example files,  , Data trace records, File formats
@section Example files

Here are portions of two files @file{StackAr.decls} and
@file{StackAr.dtrace}, for a Java class that implements a stack of
integers using an array as the underlying data structure.  You can see
many more examples by simply running an existing front end on some Java,
C, or Perl programs and viewing the resulting files.

@menu
* Example declaration file::    
* Example data trace file::     
@end menu


@node    Example declaration file, Example data trace file, Example files, Example files
@subsection Example declaration file

This is part of the file @file{StackAr.decls}, a declaration file for
the @file{StackAr.java} program (@pxref{StackAr example}).

@example
DECLARE
StackAr.push(java.lang.Object):::ENTER
x
Object
int
1
x.getClass()
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.getClass()
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].getClass()
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr.push(java.lang.Object):::EXIT96
x
Object
int
1
x.getClass()
Class
String
-1
this.theArray
Object[]
int
-2
this.theArray.getClass()
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].getClass()
Class[]
String[]
-1
this.topOfStack
int
int
0

DECLARE
StackAr:::OBJECT
this.theArray
Object[]
int
-2
this.theArray.getClass()
Class
String
-1
this.theArray[]
Object[]
int[]
1
this.theArray[].getClass()
Class[]
String[]
-1
this.topOfStack
int
int
0
@end example


@node    Example data trace file,  , Example declaration file, Example files
@subsection Example data trace file

This is part of file @file{StackAr.dtrace}, which you can create by
running the instrumented @file{StackAr.java} program (@pxref{StackAr
example}).  This excerpt contains only the first two calls to
@code{push} and the first return from @code{push}, along with the
associated object program point records; omitted records are indicated
by ellipses.


@example
...

StackAr.push(java.lang.Object):::ENTER
this_invocation_nonce
55
x
1217030
1
x.getClass()
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].getClass()
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].getClass()
[null]
1
this.topOfStack
-1
1

...

StackAr.push(java.lang.Object):::EXIT96
this_invocation_nonce
55
x
1217030
1
x.getClass()
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[1217030]
1
this.theArray[].getClass()
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[1217030]
1
this.theArray[].getClass()
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

...

StackAr.push(java.lang.Object):::ENTER
this_invocation_nonce
94
x
1482257
1
x.getClass()
"DataStructures.StackAr"
1
this.theArray
350965
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].getClass()
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
350965
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].getClass()
[null]
1
this.topOfStack
-1
1

...
@end example



@node     Index,  , File formats, Top
@unnumbered Index

@printindex cp


@bye

@c  LocalWords:  texinfo setfilename daikon settitle MDE texi html daikonurl sp
@c  LocalWords:  inlined makeinfo daikonemail setchapternewpage ifinfo hboxes
@c  LocalWords:  finalout titlepage titlefont eps pdf txt png jpg vskip pt img
@c  LocalWords:  filll src alt ifnothtml dir ifnottex GUIs ifhtml detailmenu pl
@c  LocalWords:  Cygwin StackAr Diff orig dfepl CSV convertcsv dfej dfec gcc cd
@c  LocalWords:  applets EDG spinfo InvariantChecker LogicalCompare dtrace inv
@c  LocalWords:  runtimechecker javac Lackwit pptname uref abs lst treenode IOA
@c  LocalWords:  myArray PathFinder pxref cindex samp classpath xref var wget
@c  LocalWords:  daikonparent zxvf noindent csh tcsh cshrc setenv zxf DAIKONDIR
@c  LocalWords:  DAIKONCLASS bashrc java cpp daikonenv HKEY AutoRun pathlists
@c  LocalWords:  CompletionChar PathCompletionChar subsubsection MYDOCU ENV arg
@c  LocalWords:  DataStructures dotfiles ActiveState mypackage MyClass emph Xmx
@c  LocalWords:  StackArTester PrintInvariants theArray topOfStack Ljava gdwarf
@c  LocalWords:  kvasir decls Valgrind config Rijndael rijndaeltest perl bday
@c  LocalWords:  dtype standalone decl asis noversion num conf nohierarchy ppt
@c  LocalWords:  dbg mem stat postprocessed itemx mux pre val classname regexp
@c  LocalWords:  ListImplementors dataflow getLogger JML jml hashcode DBC Jtest
@c  LocalWords:  Parasoft's Quant ESC prestate int seq elt Javadoc JVML param
@c  LocalWords:  DerivedParameterFilter ObviousFilter args ParentFilter isEmpty
@c  LocalWords:  OnlyConstantVariablesFilter SimplifyFilter UnjustifiedFilter
@c  LocalWords:  UnmodifiedVariableEqualityFilter diff OneOf InvMap repr gui td
@c  LocalWords:  invSortComparator invPairComparator daikonHelp ifnotinfo gif
@c  LocalWords:  InvariantsDisplay Ctrl ControlPanel checkbox kbd JDE prj jde
@c  LocalWords:  autoload myA myList hashcodes MyA HashSetLinear HslIterator IA
@c  LocalWords:  topAndPop init util DTRACEFILE DTRACEAPPEND Valgrind's AMD gz
@c  LocalWords:  Athlon fomit Kvasir's programname vars gzip fifo FIFOs AFS csv
@c  LocalWords:  stdout stderr disambig myprog Debian libfoo inst pragma prog
@c  LocalWords:  workflow accessor instr instrsourcedir TYPESAPPEND basedir cp
@c  LocalWords:  myfile dfej's classfiles jikes QueueAr QueueArTester ln nn
@c  LocalWords:  classhier decldir instrdir uninst csal apdir cpdir Mangel's
@c  LocalWords:  ComparablePairsDescFileReader runnables dumpdir rm isprint
@c  LocalWords:  DTRACELIMIT DTRACELIMITTERMINATE DDTRACELIMIT applet xargs mv
@c  LocalWords:  DDTRACELIMITTERMINATE javaPolicy appletviewer MyProgram exe lw
@c  LocalWords:  datatypes intValue ListNode theElement precompiled Solaris cc
@c  LocalWords:  libw LDFLAGS xname textfile nogui daikonarg nocleanup tarfile
@c  LocalWords:  TODO DFECDIR exefile tracefilename stdc dfec's preprocessed wc
@c  LocalWords:  ctype sed declsfiledir declsfiledirflat searchpath includepath
@c  LocalWords:  GNUG disambigfilename mdas memset subarrays lackwit unsetting
@c  LocalWords:  postprocessing structs pcc gzipped zlib baz ints std min rray
@c  LocalWords:  ointer ifdef endif DaikonSmartPointer DaikonSmartArray malloc
@c  LocalWords:  mystring strcpy strcat smartpointers basemap namespace ansi eq
@c  LocalWords:  protoize fallback fixups const asm inline typeid typename bool
@c  LocalWords:  bitand bitor compl wchar xor unportable enums enum stdlib env
@c  LocalWords:  getenv bitfields bitfield realloc memcpy textutils pos lseek
@c  LocalWords:  fd Linux's GNUC mkdir tmp gunzip xf li dkconfig CreateSpinfo
@c  LocalWords:  ParameterDoclet CreateSpinfoC un biconditional addAll isFull
@c  LocalWords:  smallexample simpleStack currentSize jtb ParseException kmeans
@c  LocalWords:  runcluster xm ALG xmeans TraceSelect NOCLEAN DIFFS MergeESC pp
@c  LocalWords:  escannotated jmlannotated dbcannotated Annnotate xml INVINFO
@c  LocalWords:  ubs Throwable throwable rethrown WriteViolationFile MyProg cfg
@c  LocalWords:  callMethod isDaikonInstrumented getDaikonInvariants INVS ijmp
@c  LocalWords:  bBoOmjpi de iconv undefine DHAVE Xie Ast rt JDKDIR MyPackage
@c  LocalWords:  superdirectory SOURCEPATH InvalidClassDataError strace lstat
@c  LocalWords:  RuntimeException IFLNK interconvert interconvertible strdup ld
@c  LocalWords:  lwpp ine runtime's malloced MaxPermSize JVM's MyVector perc vv
@c  LocalWords:  falsetime trueinvs testsuite MergeInvariants fns untruncate mx
@c  LocalWords:  subsubheading bzip fontspecific sublicense NONINFRINGEMENT Cok
@c  LocalWords:  getopt Renn Nethercote MemCheck readelf Binutils Yuriy Brun ps
@c  LocalWords:  Cockrell Czeisler Demsky Nii Dodoo Fellheimer Griswold Guo Hao
@c  LocalWords:  Kataoka Loosemore Vikash Mansinghka Samir Meghani Jelani Toh
@c  LocalWords:  Nimmer Shih Iuliu Vasilescu Xiao Kaplan Angros Tadashi Araragi
@c  LocalWords:  Seung Cho Hardojo Engelbert Hubbers McMaster Orso Manos Wacha
@c  LocalWords:  Renieris NTT varname VarInfoName hasDuplicates hasOrder len gc
@c  LocalWords:  hasNull nullTerminated isParam hashCode VarComparability IDE
@c  LocalWords:  makeEmpty topLevel bottomLevel pptInfo MyInteger printindex mw
@c  LocalWords:  cygwin basename globalVar staticVar funcStaticVar myName foo
@c  LocalWords:  TerminationMessage HotSpot daikonPrintArrayMissing javacc invs
@c  LocalWords:  sourcing toString struct uninstrumented Garbervetsky classfile
@c  LocalWords:  UnsupportedClassVersionError DtraceDiff VerifyError procedurei
@c  LocalWords:  replacementi junit declsfiles dtracefile PublicTest BCEL bcel
@c  LocalWords:  Mangel Wurzel premain ChicoryPremain configs radiusSquared vol
@c  LocalWords:  dyncomp DynComp metadata comp firstFileFunctioni ppts argc
@c  LocalWords:  firstFileFunction secondFileFunctionv secondFileFunction argv
@c  LocalWords:  FunctionNamesTest globalIntArray anotherGlobalIntArray diffs
@c  LocalWords:  mangel wurzel Wurzel's libpurify inputfile frontend logfile
@c  LocalWords:  tmpdir regex namespaces fieldname microsoft Christoph Csallner
@c  LocalWords:  isspace xvzf toplevel bottomlevel
