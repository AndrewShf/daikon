\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename developer.info
@settitle The Daikon Invariant Detector Developer Manual
@c %**end of header

@c To update all the nodes and menus all at once:   C-u C-c C-u m
@c You shouldn't need to do that, though; the Makefile does it for you.

@macro daikonemail{}
@email{daikon-developers@@lists.csail.mit.edu}
@end macro

@c @setchapternewpage odd

@c avoid black boxes marking overfull hboxes in TeX output
@finalout

@titlepage
@sp 10
@c Could also use @title, @subtitle, @author here.
@center @titlefont{Daikon Invariant Detector Developer Manual}

@sp 2
@center Daikon version 3.1.7

@sp 1
@c Daikon version 3.1.7 date
@center January 1, 2005

@sp 5
@c reads daikon-logo.{eps,pdf} (not .txt, .png, or .jpg, because info
@c and HTML don't get the title page)
@image{images/daikon-logo,4in,}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998-2003
@c Copyright @copyright{} 1998-2001 Michael Ernst
@end titlepage

@html
<img src="images/daikon-logo.gif" alt="Daikon logo">
@end html
@c Why is this here? It duplicates the stuff further down.
@c @html
@c <h1>Daikon Invariant Detector User Manual</h1>
@c
@c This is the developer manual for the Daikon invariant detector.
@c It describes Daikon version 3.1.7, released January 1, 2005.
@c @end html

@c Putting this lower in the HTML version looks a little bit strange,
@c but it's acceptable. 
@ifnothtml
@contents
@end ifnothtml

@node    Top, Introduction, (dir), (dir)
@comment node-name, next,          previous, up

@ifnottex
@c Unfortunately, the Daikon logo doesn't look good in ASCII.
@c @ifinfo
@c @image{images/daikon-logo,4in,}
@c 
@c @end ifinfo
This is the developer manual for the Daikon invariant detector.
It describes Daikon version 3.1.7, released January 1, 2005.
@end ifnottex

@menu
* Introduction::                
* Extending Daikon::            
* Debugging Daikon::            
* Daikon internals::            
* Testing::                     
* Historical::                  
* Index::

@ifhtml
@contents
@end ifhtml
@ifnothtml

@detailmenu
 --- The Detailed Node Listing ---

Extending Daikon

* Compiling Daikon::            
* New invariants::              
* New derived variables::       
* New formatting for invariants::  
* New front ends::              
* New suppressors::             

Debugging Daikon

* Track logging::               

Track logging

* Adding track logging::        
* Track log output::            

Daikon internals

* Avoiding work for redundant invariants::  
* Dataflow hierarchy::          
* Equality optimization::       

Avoiding work for redundant invariants

* Suppression optimization::    

Testing

* Unit Testing::                

Unit Testing

* Invariant Format Testing::    
* Sample Testing::              

Sample Testing

* Assertions::                  
* Example File::                

Analyzing historical versions of Daikon

* Branches::                    

@end detailmenu
@end ifnothtml
@end menu

@node    Introduction, Extending Daikon, Top, Top
@chapter Introduction

This is the developer manual for the 
@uref{http://pag.csail.mit.edu/daikon/, ,Daikon invariant detector}.
For information about Daikon, see its user manual.
This manual is intended for those who are already familiar with the use
of Daikon, but wish to customize or extend it.

Additional information can be found in technical papers available from
@uref{http://pag.csail.mit.edu/pubs/}.


@node    Extending Daikon, Debugging Daikon, Introduction, Top
@chapter Extending Daikon

@cindex extending Daikon
@cindex changing Daikon
@cindex customizing Daikon
@cindex modifying Daikon

This chapter describes how to customize or modify Daikon.


@menu
* Compiling Daikon::            
* New invariants::              
* New derived variables::       
* New formatting for invariants::  
* New front ends::              
* New suppressors::             
@end menu

@node    Compiling Daikon, New invariants, Extending Daikon, Extending Daikon
@section Compiling Daikon
@cindex compiling daikon

To compile Daikon, type @command{make} in any directory under
@file{daikon/java/}.  The distribution includes compiled
@file{.class} files, so you do not need to compile them yourself unless
you make changes.

@cindex .jpp files
@cindex jpp files

In order to compile Daikon, you need the C preprocessor
@command{cpp}, which is used to convert each @file{.jpp} file in the
distribution into multiple @file{.java} files, which are then compiled.
If you do not have @command{cpp} (or @command{gcc}, which can emulate
@command{cpp} via @command{gcc -E}), you may run @command{make avoid-jpp}, in
which case changes to @code{.jpp} files will not be reflected in the
@file{.java} files or the compiled @file{.class} files.  (The purpose
of the @file{.jpp} files is to avoid code duplication by placing
common code in a single file, then generating other files that need to
include that common code.)

@cindex Jikes compiler
@cindex javac compiler, overriding
@cindex Java compiler, specifying
You may wish to create a @file{Makefile.user} file in the @file{daikon/}
directory to set your Java compiler.  For instance, it might contain
@example
  JAVAC ?= jikes -g +E +F
@end example

For more information about compiling Daikon, see the comments in the Makefiles.


@node    New invariants, New derived variables, Compiling Daikon, Extending Daikon
@section New invariants

You can easily write your own invariants and have Daikon check them,
in addition to all the other invariants that are already part of Daikon.
Adding a new invariant to Daikon requires writing one Java class, adding
a line to another file to inform Daikon of the new
class, and recompiling Daikon.

The file @file{java/daikon/inv/unary/scalar/Positive.java} in the
Daikon distribution contains a sample invariant.  This invariant is
true if the variable is always positive (greater than zero).  This
invariant is subsumed by other invariants in the system; it is provided
only as a pedagogical example.  To enable the invariant, uncomment the
appropriate line in @code{Daikon.setup_proto_invs()}, then recompile
Daikon.


A Java class defining an invariant is a concrete subclass of one of
the following abstract classes:
@table @samp
@item SingleScalar
for invariants over a single numeric (scalar) variable,
such as ``x != 0''.
@item TwoScalar
for invariants over two numeric variables, such as ``y
= abs(x)''.
@item ThreeScalar
for invariants over three numeric variables, such as
``z = ax + by + c''.
@item SingleSequence
for invariants over one sequence (array)
variable, such as ``a[] contains no duplicates''.
@item TwoSequence
for invariants over two sequences, such as ``a[] is a
subsequence of b[]''.
@item SequenceScalar
for invariants over a scalar and a sequence, such
as ``x is a member of a[]''.
@end table
@noindent
A complete list of invariants appears in @samp{Daikon.setup_proto_invs()}.

Daikon's invariants are first instantiated, then are presented samples
(tuples of values for all the variables of interest to the invariant;
this might be a 1-tuple, a 2-tuple, or a 3-tuple) in turn.  If any
sample falsifies the invariant, the invariant destroys itself.  All
remaining invariants at the end of the program run can be reported as
likely to be true.

The key methods of the new invariant are
@table @samp
@item @r{protected InvName(PptSlice ppt)}
Creates a new invariant object.  Should only be called from instantiate_dyn.
Its typical implementation is
@example
  super(ppt);
@end example

@item protected Invariant instantiate_dyn (PptSlice slice)
Returns an invariant of this class on the specified slice.  Its implementation
is almost always
@example
  return new InvName(slice);
@end example

@item public static InvName get_proto()
Returns the prototype invariant used to create other invariants.  Its
typical implementation is
@example
     if (proto == null)
      proto = new InvName (null);
    return (proto);
@end example

@item public boolean enabled() 
Returns whether or not this invariant is enabled.  Its implementation is
almost always
@example
  return dkconfig_enabled;
@end example

@item public boolean instantiate_ok (VarInfo[] vis)
Returns whether or not it makes sense to instantiate this invariant
over the specified variables.  If not present, the invariant is
created over all comparable variables of the correct types.

@item check_modified
presents a tuple of values to the invariant.  The @samp{count} variable
indicates how many samples have this value.  For example, three calls to
@samp{check_modified} with a @samp{count} parameter of 1 is equivalent to
one call to @samp{check_modified} with a @samp{count} parameter of 3.
Returns whether or not the sample is consistent with the invariant.
Does not change the state of the invariant.

@item add_modified
similar to @samp{check_modified} except that it can change the state
of the invariant if necessary.  If the invariant doesn't have any
state, then simply calls @samp{check_modified}

@item computeConfidence
returns the probability that the observed data could not have happened by
chance alone.  The result usually falls between 0 and 1, where 0 means
the values seen so far certainly happened by chance and 1 means they
could never have happened by chance.  The method may also return one of
the following constants in the @samp{Invariant} class (see the class for
documentation): @samp{CONFIDENCE_JUSTIFIED},
@samp{CONFIDENCE_UNJUSTIFIED}, @samp{CONFIDENCE_NEVER}.

For example, suppose your new invariant has a 50% chance of being true
by chance for each sample.  (``x is even'' is an example of such an
invariant.)  Then a reasonable body for @samp{computeConfidence} would
be
@example
  return 1 - Math.pow(.5, ppt.num_samples());
@end example
@noindent
If 5 values had been seen, then this implementation would return 31/32,
which is the likelihood that all 5 values seen so far were even purely
by chance.  Invariants are only printed if their probabilities are small
enough (by default, less than .01).
@item format
returns a high-level printed representation of the
invariant, for user output.  The @samp{repr} formatting routines
produces low-level, detailed output for debugging.  When first writing
an invariant, you can make @samp{repr}, @samp{format_esc}, and
@samp{format_simplify} all simply call @samp{format}, then fix up the
implementations later as needed.
@end table

After the invariant is written, add a call to its @samp{get_proto}
method in the @samp{Daikon.setup_proto_invs} method.

@node    New derived variables, New formatting for invariants, New invariants, Extending Daikon
@section New derived variables

@cindex derived variable
@cindex variable, derived

A derived variable is an expression that does not appear in the source
code as a variable, but that Daikon treats as a variable for purposes
of invariant detection.  For instance, if there exists an array
@samp{a} and an integer @samp{i}, then Daikon introduces the derived
variable @samp{a[i]}.  This permits detection invariants over this
quantity.

(Describing how to create new variety of derived variable is still to
be written.  For now, see the derived variables that appear in
@file{$DAIKONDIR/java/daikon/derive/}.)


@node    New formatting for invariants, New front ends, New derived variables, Extending Daikon
@section New formatting for invariants

@cindex output format, defining new

Daikon can print invariants in five formats:  its native format, Java
format, IOA format (for use with the IOA programming language), ESC
format (which is a subset of the JML specification language), and
Simplify format (for use by the Simplify theorem-prover).

To support a new output format, you need to do three things:
@itemize @bullet
@item
@c Add, to every subclass of @samp{Invariant}, a
@c @samp{format_@var{newtype}()} method.  Each subclass of Invariant
@c already has three such methods --- @samp{format()}, @samp{format_esc()},
@c and @samp{format_simplify()} --- for you to crib from.
Add a new static final field to the class
daikon.inv.Invariant.OutputFormat, which acts as an enumeration.
@item
Edit, in every subclass of @samp{Invariant}, the
@samp{format_using} method to handle the new OutputFormat.
@item
Edit @file{PrintInvariants.java} and @file{Daikon.java}
to enable selecting your new output format.
@end itemize


@node    New front ends, New suppressors, New formatting for invariants, Extending Daikon
@section New front ends

@cindex front end, writing

A front end for Daikon converts data into a form Daikon can process,
producing files in Daikon's input format --- @file{.decls} files and
@file{.dtrace} files.
(Typically, Daikon front ends arrange to obtain information from
program executions, though front ends have been also been built for
stock data, weather forecasts, and truck weight data, among others.
In other words, it is possible to produce Daikon input from sources
other than program executions, but this section focuses on the latter.)

A front end for Daikon takes as input a target program to be analyzed.
The front end produces two outputs:  a @file{.decls} file and an
instrumented program.  Executing the instrumented program produces a
@file{.dtrace} file containing records for all the program points that
appear in the @file{.dtrace} file.
For more information about these files, see @ref{File
formats,,,./daikon,Daikon User Manual}.

Conceptually, instrumentation is very simple.
This section gives an example of how an instrumenter for Java might
work; other languages are analogous.
Suppose we wish to instrument file @file{Example.java}.
@example
class Example @{
  // Return either the square of x or the square of (x+1).
  int squar(int x, boolean b) @{
    if (b)
      x++;
    return x*x;
  @}
@}
@end example

The @file{.decls} file might look like the following.
@example
DECLARE
Example.squar:::ENTER
x
int
int
1
b
boolean
int
2

DECLARE
Example.squar:::EXIT
x
int
int
1
b
boolean
int
2
return
int
int
1
@end example

The instrumented @file{.java} file might look like the following.
@example
class Example @{
  static @{
    daikon.Runtime.setDtraceMaybe("daikon-output/StackAr.dtrace");
  @}

  // Return either the square of x or the square of (x+1).
  int squar(int x, boolean b) @{
    synchronized (daikon.Runtime.dtrace) @{
      daikon.Runtime.dtrace.println();
      daikon.Runtime.dtrace.println("Example.squar:::ENTER");
      daikon.Runtime.dtrace.println("x");
      daikon.Runtime.dtrace.println(x);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("b");
      daikon.Runtime.dtrace.println(b ? 1 : 0);
      daikon.Runtime.dtrace.println(1);  // modified bit
    @}

    if (b)
      x++;

    int daikon_return_value = x*x;
    synchronized (daikon.Runtime.dtrace) @{
      daikon.Runtime.dtrace.println();
      daikon.Runtime.dtrace.println("Example.squar:::EXIT");
      daikon.Runtime.dtrace.println("x");
      daikon.Runtime.dtrace.println(x);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("b");
      daikon.Runtime.dtrace.println(b ? 1 : 0);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("return");
      daikon.Runtime.dtrace.println(daikon_return_value);
      daikon.Runtime.dtrace.println(1);  // modified bit
    @}

    return daikon_return_value;
  @}
@}
@end example



@node New suppressors,  , New front ends, Extending Daikon
@section New suppressors

As mentioned in @ref{Daikon internals}, one way to make Daikon more
efficient, and to reduce clutter in output to the user, is to reduce
the number of redundant invariants of various kinds.  This section
describes how to add a new suppressor relation, such that if invariant
A implies B, B is not instantiated or checked as long as A holds,
saving time and space.  Suppression implications use some terminology.
A @emph{suppressor} (defined in the class @var{NISuppressor}) is one
of a set of invariants (@var{NISuppression}) that imply and suppress a
@emph{suppressee} invariant (@var{NISuppressee}).  The set of all of
the suppressions that suppress a particular suppressee is stored in
the class @var{NISuppressionSet}.

Adding a new suppression is straightforward.  Define the suppressee and
each of the suppressions that suppress it using the corresponding
constructors.  Add the method @var{get_ni_suppressions} to the class
of the invariant being suppressed and return the appropriate
suppression set.  Make sure that @var{get_ni_suppressions} always
returns the same suppression set (i.e., that storage to store
the suppressions is only allocated once).  Normally this is
done by defining a static variable to hold the suppression sets
and initializing this variable the first time that @var{get_ni_suppressions}
is called.

The following example defines suppressions for ``x == y'' implies
``x >= y'' and ``x > y'' implies ``x >= y''.

@example
private static NISuppressionSet suppressions = null;

public NISuppressionSet get_ni_suppressions() @{
  if (suppressions == null) @{
    NISuppressee = new NISuppressee (IntGreaterEqual);

    NISuppressor v1_eq_v2 = new NISuppressor (0, 1, IntEqual.class);
    NISuppressor v1_lt_v2 = new NISuppressor (0, 1, IntLessThan.class);

    suppressions = new NISuppressionSet (new NISuppression[] @{
      new NISuppression (v1_eq_v2, suppressee),
      new NISuppression (v1_lt_v2, suppressee),
    @});
  @}
  return (suppressions);
@}
@end example

@node    Debugging Daikon, Daikon internals, Extending Daikon, Top
@chapter Debugging Daikon

@menu
* Track logging::               
@end menu

This chapter describes some techniques that can be used for debugging
Daikon.  Because Daikon processes large amounts of data, using
a debugger can be difficult.  The following logging techniques provide
alternatives to using a debugger.

Daikon's logging routines are based on the java.util.logging utilities
(built into Java 1.4 and later).


@node Track logging,  , Debugging Daikon, Debugging Daikon
@section Track logging

Often it is desirable to print information only about one or more specific 
invariants.  This is distinct from general logging because it concentrates
on specific invariant objects rather than a particular class or portion of Daikon.
This is referred to as @emph{Track} logging because it tracks particular
values across Daikon.

Track logging is specified by three pieces of information: 

   @enumerate
   
   @item The class name of the invariant (e.g., @code{IntEqual})

   @item The program point of interest (e.g., 
   @code{DataStructures.StackAr.makeEmpty()V:::ENTER})

   @item The variables that are used in the invariant (e.g., @code{return},
   @code{size(this.s[])})

   @end enumerate

These items are specified using the --track argument to Daikon.  Each of
the the inputs to track logging can be specified in a single argument.
The basic syntax is:
@example
    class|class|...<var,var,var>@@ppt
@end example
As shown, multiple class arguments can be specified separated by pipe
symbols (|).  The variables are specified in angle brackets (<>) and
the program point is preceded by an at sign (@@).  Each item is optional.
For example:
@example
    IntEqual<x,y>@@makeEmpty()
    LessThan|GreaterThan<return,orig(y)>@@EXIT99
@end example
Multiple --track switches can be specified. The class, program point,
and each of the variables must match one of the specifications in order
for information concerning the invariant to be printed.

Matching is a simple substring comparison.  The specified item must be
a substring of the actual item.  For instance, @code{LessThan} matches
both @code{IntLessThan} and @code{FloatLessThan}.

Program points and variables are specified exactly as they are seen in
normal Daikon invariant output.  Specifically, @code{Ppt.name} and
@code{VarInfo.name.name()} are used to generate the names for comparisons.

Invariants are not the only classes that can be tracked.  Any class name
is a valid entry.  Thus, for example, to print information about derived
sequence variables from sequence @code{this.theArray[]} and scalar
@code{x} at program point @code{DisjSets.find(int):::EXIT}, the tracking
argument would be:

@example
  SequenceScalarSubscriptFactory<x,this.theArray[]>@@DisjSets.find(int):::EXIT
@end example

There are two configuration options that can customize the output.  The
option @code{daikon.Debug.showTraceback} will output a stack trace on
each log statement.  The option @code{daikon.Debug.logDetail} will cause
more detailed (and often voluminous) output to be printed.  For more
information, @ref{Configuration options,,,./daikon,Daikon User Manual}.

Note that all interesting information is not necessarily currently logged.
It will often be necessary to add new logging statements for the specific
information of interest (@pxref{Adding track logging}).
This is covered in the next section.

More detailed information can be found in the Javadoc for
@uref{http://pag.csail.mit.edu/daikon/download/jdoc/daikon/Debug.html,daikon.Debug}
and
@uref{http://pag.csail.mit.edu/daikon/download/jdoc/daikon/inv/Invariant.html,daikon.inv.Invariant}.

@menu
* Adding track logging::        
* Track log output::            
@end menu

@node Adding track logging, Track log output, Track logging, Track logging
@subsection Adding track logging

@emph{Track} logging is based
around the class name, program point name, and variables of interest.
Track logging methods accept these parameters and a string to be printed.
@file{Debug.java} implements the following basic log methods:

@example
    log (String)
    log (Class, Ppt, String)
    log (Class, Ppt, Varinfo[], String)
@end example

The first uses the cached version of the Class, Ppt, and VarInfo that
was provided in the constructor.  The second uses the specified
variables and the VarInfo information from Ppt.  The third specifies
each variable explicitly.

When logging is not enabled, calling the logging functions can take a 
significant amount of time (because the parameters need to be evaluated and
passed).  To minimize this, a function @code{logOn()} is provided to see 
if logging is enabled.  It is recommended that code of the following form
be used for efficiency:

@example
    if (Debug.logOn()) @{
      Debug.log (getClass(), ppt, "Entering routine foo");
    @}
@end example

Track logging also can work with other loggers.  Each of the logging
methods has an alternative version that also accepts a logger as the
first argument.  In this case, normal track logging is performed if
the class, ppt, and vars match.  If they don't match, the same
information is logged via the specified logger.  For example:

@example
    if (Debug.logOn || logger.isLoggable (Level.FINE)) @{
      Debug.log (logger, getClass(), ppt, "Entering routine foo");
    @}
@end example

The above will print if either the tracking information matches or if the
specified logger is enabled.

Convenience methods are available for track logging invariants.  In this
case the class name, ppt, and variable information are all taken from the
invariant.  The available methods are:

@example
    logOn()
    logDetail()
    log (String)
    log (Logger, String)
@end example

These correspond to the @code{Debug} methods described above.  They are
the recommended way to log information concerning invariants.

Track logging also provides one additional level of detail.  The function
@code{logDetail()} returns whether or not more detailed information
should be printed.  This should be used for information which is not
normally interesting or especially voluminous output.  Often statements
using @code{logDetail()} should be commented out when not in active use.


@node Track log output,  , Adding track logging, Track logging
@subsection Track log output

Each call to a track log method will produce output in the same basic
format. Space for three variables is always maintained for consistency:

@example
    @ daikon.Debug: <class>: <ppt>: <var1>: <var2>: <var3>: <msg>
@end example

If @code{showTrackback} is enabled, the traceback will follow each 
line of debug output.

Unfortunately, in ASCII text, the above can be a little difficult to read
because it normally doesn't line up very well.  A simple translator to
HTML exists that can be used to provide HTML formatted output.  This tool
is not completely tested, but seems to work reasonably well in most
situations.  The following instructions only apply to MIT, but the tool
is shipped in the scripts directory and can easily be setup elsewhere
as well.

Use the URL @uref{http://pag/daikon/mit/log2html.php} to access log2html.
It will ask you for a file of daikon output.  One good way to create this
file is to use the tee command.  For example:

@example
    daikon [daikon args] | tee ~/daikon.out
@end example

Then specify that file to log2html.  Note that when supplying a filename
to log2html, you must expand ~ yourself
since the webserver doesn't know who you are.  The result will contain
tables with the log output in them (all other output is unchanged).  Table
columns are based on the ': ' separator in the ASCII output.  If traceback
is enabled, another column is added showing where the log method was
called.  For example, the traceback column might contain:

@example
    +PptSlice1.addInvariant
@end example

If you put your cursor over @code{PptSlice1.addInvariant} it will show
the exact line number in the source file where the log method was
called as part of the href.  If you click on the traceback it will
create an output file of type @samp{application/emacs} that contains an
@command{emacsclient} command to edit the related source file.  Most browsers
can be setup to execute a command to process these files (in Mozilla
this is done in the 'Navigator/Helper Applications' section of
preferences).  The script @command{$inv/scripts/browser_emacs} will
correctly handle files of this type and bring up the appropriate file
in emacs.  This could easily be changed to support other editors.
Note that as currently implemented this creates a possible security
hole (malicious non-editor commands could be executed) as no checking
is done on the validity of the command.

Clicking on the leading plus of the traceback information will show
the entire traceback.  For example:

@example
   -PptSlice1.addInvariant
    PptSlice.flow_and_remove_falsified
    PptSlice1.add
    PptTopLevel.add
    PptTopLevel.add_and_flow
    FileIO.process_sample
    FileIO.read_data_trace_file
    FileIO.read_data_trace_files
    Daikon.process_data
    Daikon.main
@end example

The same capabilities (showing the line number, bringing up the buffer
in emacs) exist on each of the frames in the traceback.  The detailed
traceback can be hidden by clicking on the leading - on the first
frame.  Note that the current state of what tracebacks are expanded is
kept in a file named the same as your Daikon output file with
@file{.state} appended.  For example, the state file for
@file{~/daikon.out} is @file{~/daikon.out.state}.  This file must be
world writable for @command{log2html.php} to work correctly.


@node    Daikon internals, Testing, Debugging Daikon, Top
@chapter Daikon internals

@menu
* Avoiding work for redundant invariants::  
* Dataflow hierarchy::          
* Equality optimization::       
@end menu

This chapter describes some of the techniques used in Daikon to make
it efficient in terms of time and space needed.  These techniques can
be enabled or disabled at the Daikon command line, as described in
@ref{Command line options,,,./daikon,Daikon User Manual}.

@node   Avoiding work for redundant invariants, Dataflow hierarchy, Daikon internals, Daikon internals
@section Avoiding work for redundant invariants

Daikon reduces runtime and memory by avoiding performing work for
redundant invariants that provide no useful information to the user.
There are three basic types of optimization that can be performed for
uninteresting invariants:  non-instantiation, non-checking, and
non-printing.

@emph{Non-instantiation} prevents the creation of an invariant because
the invariant's truth value is statically obvious (from the semantics
of the programming language), no matter what values may be seen at run
time.  Two examples are ``A[i] is an element of A[]'' and ``size(A[])
>= 0''.  Non-instantiation is implemented by the by the
isObviousStatically method.
With the equality sets optimization (@pxref{Equality optimization}),
non-instantiation can only happen if all equality permutations are
statically obvious.

@emph{Non-checking}, also known as ``suppression'', creates invariants
but does not check them; an invariant can be suppressed (not checked)
if some other set of true invariants implies it.  For example, ``a[]
contains no duplicates'' implies ``a[i..j] contains no duplicates''.

@emph{Non-printing} is a post-pass that throws out any invariants that
are implied by other true invariants.  It is similar to suppression,
but it differs in that it can implement checks that are not sound to
perform until all data samples have been seen.  Non-printing is implemented by
the isObviousDynamically method.  The isObviousStatically method is
also used by the non-printing checks; it can be called at the end
without reference to equality sets.

Non-printing can do anything that non-checking can, and more.
However, implication checks that do not require all data samples to be
seen should be implemented as suppressions, not as non-printing.
There are two cases in which non-printing must be used.  First,
invariants that must see every data sample, because they cache
information about all samples, cannot be suppressed, because
suppressed invariants do not see all samples.  Second, there are
invariants that are obvious by themselves, without relying on other
invariants.  Third (and this is a questionable usage, but does appear
in the code as of October 2003), non-printing can suppress
uninteresting invariants, whereas non-checking is only valid for
mathematically true implications.  For example, if ``a[] == b[]'' we
may choose not to print invariants such as ``a[i..] < b[j..]'' even
though ``a[] == b[]'' does not imply anything about the truth of
``a[i..] < b[j..]''.

More detail can be found in two theses.  See Chapter 7,
``Scalability'', of @cite{Automatic Generation and Checking of Program
Specifications} (Technical report MIT-LCS-TR-852, at
@uref{http://pag.csail.mit.edu/~mistere/pubs/thesis-abstract.html}),
Jeremy W. Nimmer's Master's thesis.  Also see Chapter 5, ``Enabling
Incremental Dynamic Invariant Detection'', of @cite{Theorem-proving
distributed algorithms with dynamic analysis}
(@uref{http://pag.csail.mit.edu/pubs/thmprove-newin-mengthesis-abstract.html}),
Toh Ne Win's Master's thesis.


@menu
* Suppression optimization::    
@end menu

@node    Suppression optimization,  , Avoiding work for redundant invariants, Avoiding work for redundant invariants
@subsection Suppression optimization

Suppression optimization allows for elimination of redundancy based on
how a set of invariants might imply an invariant.  For example, ``a ==
b'' and ``b >= c'' implies ``a = max (b, c)'' We say that a set of
@emph{suppressors} suppress a @emph{suppressee} invariant.  A
suppressed invariant is neither instantiated or checked.  It is
instantiated only when one of its suppressors becomes falsified, in
which case the implication for suppression no longer holds.

Thus when certain invariants are not found in Daikon, they may be
hidden due to suppression.  Suppression is enabled by default, but it can
be disabled by the @var{daikon.suppress.NIS.enabled} configuration option.

@node    Dataflow hierarchy, Equality optimization, Avoiding work for redundant invariants, Daikon internals
@section Dataflow hierarchy

Dataflow hierarchy is a means to relate variables in different program
points in a partial ordering.  Variables in program point X are
related to variables in another program point Y by a ``flow'' relation
if every sample seen of X's variables is also meant to be seen at Y.
Y is called a parent program point of X.  For example, all the field
variables in the ENTRY program point of a method in class C relate to
the field variables in the CLASS program point of C.  This is because
the state of C, when in context at the entry ENTRY program point, is
also in context at the CLASS program point.  Any invariant that holds
true on a parent program point must hold on the child program point.
The purpose of dataflow hierarchy is to reduce the presence of
redundant invariants by only keeping invariants at the highest parent
at which they apply.  This saves both time and space.

There are many ways that program points can be connected.  Daikon
provides for four ways.  First, CLASS program points are parents of
all their method program points.  Second, between two classes that are
related by inheritance, corresponding program points relate --- for
example, java.util.Vector:::CLASS is a child of
java.util.List:::Class.  Third, when a program point contains
variables of a type whose CLASS program point is also available to
Daikon, the former program point's variables relate to the latter
program point's CLASS method.  For example, if X:::y is of type Y, and
Y contains fields a and b, X:::y, X:::y.a and X:::y.b relate to
Y:::this, Y:::b and Y:::a.  Fourth, variables at ENTER program
points are related to the ``orig'' versions at EXIT program points.

When using Daikon, the above four ways of relations in the dataflow
hierarchy will result in some true invariants that are not reported at
some program points.  However, the invariant will be present in some
parent program point.  Dataflow hierarchy is enabled by default, but
can be disabled by the @option{--nohierarchy} flag.  When dataflow is enabled,
the only samples that are examined by Daikon are the EXIT program
points (plus ``orig'' variables) since these contain a complete view of
the data.

@node    Equality optimization,  , Dataflow hierarchy, Daikon internals
@section Equality optimization

When N variables are equal within a program point there will be
N(N-1)/2 pairwise invariants to represent the equality within the
equal variables, and N copies of every other invariant.  For example,
if a, b, and c are equal, then ``a == b'', ``a == c'', ``b == c'' will be
reported as pairwise invariants, and ``odd(a)'', ``odd(b)'' and ``odd(c)''
will be reported.  If the variables will always be equal, then
reporting N times the invariants is wasteful.  Daikon thus treats
equality specially.

Each group of variables that are equal from the start of inferencing
are placed in @emph{equality sets}.  An equality set can hold an
arbitrary number of variables, and replaces the O(N^2) pairwise
equality invariants.  Every equality set has a leader or
@emph{canonical} representation by a variable in the set.
Non-equality invariants are only instantiated and checked on the
leader.  When printing invariants, Daikon reports only invariants on
the leader.  The user can easily determine that ``odd(a)'' and ``a == b''
imply ``odd(b)''.  Equality can be turned off at the command line with
the @option{--noequality} flag.


@node    Testing, Historical, Daikon internals, Top
@chapter Testing

Daikon has two sets of tests: regression tests and unit tests. If there
are any differences between the expected results and the ones you get,
don't check in your changes until you understand which is the desired
behavior and possibly update the goals.

The unit tests are found in @file{invariants/java/daikon/test/}; they use
the JUnit unit testing framework.  They take a few seconds to run.  They
are automatically run each time you compile Daikon (by running
@samp{make} in
 @file{$inv/java} or any of its subdirectories).  You can
also run them explicitly via @samp{make unit}.  When you write new code
or modify old code, please try to add unit tests.

The regression tests run Daikon on many different inputs and compare
Daikon's output to expected output.  They take an hour or longer to run.
When you make a change, you should generally run the regression tests
before checking it in.  Always run the regression tests when checking in
any non-trivial change to the code.  If any has a non-zero size, then your
edits have changed Daikon's output and you should not check in without
carefully determining that the changes are intentional and desirable (and
you should update the goal output files, so that the diffs are again zero).
The regression tests appear in the @file{$inv/tests} directory.  Type
@samp{make} in that directory to see a list of options.  Generally you
will want to run @samp{make diffs} and ensure that the list of diff files
that is created all have zero size.  You do not generally need to do
@samp{make clean}, which forces re-instrumentation (a slow process) the
next time you run the tests.



@menu
* Unit Testing::                
@end menu

@node    Unit Testing,  , Testing, Testing
@section Unit Testing

@menu
* Invariant Format Testing::    
* Sample Testing::              
@end menu

@node    Invariant Format Testing, Sample Testing, Unit Testing, Unit Testing
@subsection Invariant Format Testing

This tests the formatting of invariants with specified input.  The
tests are configured in the file @file{InvariantFormatTest.commands} under
@file{daikon/test/}.  Make sure the @file{InvariantFormatTest.commands} file is
in the classpath when this tester is run or the tester will not work.
(It will just tell you that the file is not in the classpath)

The file is formatted as follows:
@example
<fully qualified class name> [<instantiate args>]
<type string>
<goal string>+ <- 1 or more goal strings
<sample>* <- 0 or more samples
@end example

The file format should be the same regardless of blank or commented
lines except in the samples area. No blank lines or comments should
appear after the goal string before the first sample or between parts
of samples (these lines are used currently to determine where samples
lists end). This will be remedied in a future version of the tester.

@table @samp
@item Instantiate args: 
these are optional additional arguments to the static
instantiate method of the class.  Each argument consists of the type (boolean
or int) followed by the value.  For example:
@example
    boolean true
    int 37 boolean false
@end example

@item Type string: 
A type string must consist of one or more of the following:
"int", "double", "string", "int_array", "double_array", "string_array",
separated by spaces (without the quotes) This string represents the
types that an invariant is supposed to compare For instance, a binary
integer comparison would have type string "int int".  A pairwise
sequence comparison would have type string "int_array int_array"

@item Goal string: 
The goal string must start with the prefix "Goal " (don't
actually type the quotes), and then continue with "(<format type>): ",
where format type is the format in which the invariant will
print. After this the representation of the invariant must occur. It
must represent the invariant result exactly as printed, even white
space is significant (as proper formatting should be correct down to
the whitespace). The first variable (the one corresponding to the
first type in the type string) corresponds with "a", the second with
"b" and so on. Format the type string accordingly. (In samples, the
value of "a" is read first, possibly followed by "b", and then
possibly "c", depending on the arity of the invariant.)

@example
Example:
Type string, Goals
 |             |
\|/            |
int           \|/
Goal (daikon): a >= -6
Goal (java): a >= -6
Goal (esc): a >= -6
Goal (ioa): a >= -6
Goal (jml): a >= -6
Goal (simplify): (>= |a| -6)
@end example

Note that the spacing on the goal lines is exact, that is, no extra
spaces are allowed and no spaces are allowed to be missing. So the
exact format is again:
@example
Goal<1 space>(<format name>):<1 space><goal text>
@end example

@item Samples: 
Values formatted according to the type string, one value per
line Make sure that the samples provided are actually instances of that
particular invariant (That is, if the desired invariant is "a < b", then
the first number of each sample better be less than the second) 

@c The below is not necessary since we don't check this before formatting
@c 
@c Also be
@c sure to have enough samples to ensure the invariant is apparent (and
@c probable) to Daikon (6-8 will do for most binary integer comparisons,
@c 1-3 for array-based comparisons) Example: Formatting for
@c samples of a binary integer comparison

Arrays and strings must be formatted according to the Daikon dtrace file
convention (see the Daikon user manual for full description). This
states that arrays must be surrounded in brackets (start with "[", end
with "]"), and entries must be separated by a space. String must be
enclosed in quotes ("). Quotes within a string can be represented by the
following sequence: \"

For examples
@example
[1 2 3 4 5] - an array with the elements 1, 2, 3, 4, 5
"aString" - a string
"a string" - also legal as a string
"\"" - the string with the value "
["a" "b" "c"] - an array of strings

int int        <- type string
Goal: a < b    <- goal string, no comment/blank lines after this
1              <- or before this
2
2              <-|__ Pair of values (a = 2 , b = 3)
3              <-|
@end example

Other examples are in the existing test file (InvariantFormatTest.commands).
@end table
The output of a test run can be converted into goals by using the
--generate_goals switch to the tester as follows:
@example
java daikon.test.InvariantFormatTester --generate_goals
@end example
Note that this test is included in the set of tests performed by the
master tester, and so it is not necessary to separately run this test
except to generate goal files.

Furthermore, this framework cannot parse complex types from files
unless they contain a "public (Object) valueOf(String s)"
function. Otherwise the program has no was of knowing how to create
such an object from a string. All primitives and the String type are
already recognized.

@node    Sample Testing,  , Invariant Format Testing, Unit Testing
@subsection Sample Testing

Sample testing tests various components of Daikon as samples are being
processed.  A file (normally @file{daikon/test/SampleTester.commands}) 
specifies a decls file to use, the samples for each ppt/var, and assertions
about Daikon's state (such as whether or not a particular invariant exists).

Each line of the file specifies exactly one command.  Blank lines and
leading blanks are ignored.  Comments begin with the number sign (#) and
extend to the end of the line.  The type of command is specified as the
first token on the line followed by a colon.  The supported commands
are:

@deffn {SampleTester Command} decl: decl-file
  This command specifies the declaration file to use.  This is a normal
  decls file that should follow the format defined in the user manual.
@end deffn

@deffn {SampleTester Command} ppt: ppt
  This command specifies the program point that will be used with following
  vars, data, and assert commands.  The program point should be specified 
  exactly as it appears in the decls file.
@end deffn

@deffn {SampleTester Command} vars: var1 var2...
  Specifies the variables that will be used on following data lines.
  Each variable must match exactly a variable in the ppt.  Other
  variables will be treated as missing.  
@end deffn

@deffn {SampleTester Command} data: val1 val2...
  Specifies the values for each of the previously specified variables.  The
  values must match the type of the variables.  A single dash (-) indicates
  that a variable is missing.
@end deffn

@deffn {SampleTester Command} assert: assertion
  Specifies an assertion that should be true at this point (@pxref{Assertions}).
  The negation of an assertion can be specified by adding an exclamation
  point before the assertion (for example: @code{!inv("x > y", x, y})).
@end deffn

@menu
* Assertions::                  
* Example File::                
@end menu

@node       Assertions, Example File, Sample Testing, Sample Testing
@subsubsection Assertions

Assertions are formatted like function calls: <name>(arg1, arg2, ...).
The valid assertions for the assert: command are:

@deffn Assertion inv format var1 ...

  The inv assertion asserts that the specified invariant exists in the
  current ppt.  The format argument is the result of calling format() on
  the invariant.  This is how the invariant is recognized.  The remaining
  arguments are the variables that make up the invariants slice.  These
  must match exactly variables in the ppt.  The inv assertion returns true
  iff the slice exists and an invariant is found within that slice that
  matches format.

  Optionally, format can be replaced by the fully qualified class name of
  the invariant.  In this case, it is only necessary for the class to match.
@end deffn

More assertions can easily be added to @file{SampleTester.java} as required.

@node       Example File,  , Assertions, Sample Testing
@subsubsection Example File

The following is an simple example of sample testing.
@example
decl: daikon/test/SampleTesters.decls

ppt: foo.f():::EXIT35
  vars: x y z
  data: 1 1 0
  data: 2 1 0
  assert: inv("x >= y", x, y)
  assert: inv(daikon.inv.binary.twoScalar.IntGreaterEqual,x,y)
  assert: !inv("x <= y", x, y)
@end example


@node    Historical, Index, Testing, Top
@chapter Analyzing historical versions of Daikon

@cindex CVS repository

@c Commands to run to distribute CVS:
@c   cd /afs/csail.mit.edu/group/pag/projects/invariants/.CVS/
@c   tar czf ~mernst/www/tmp/inv-cvs.tar.gz invariants
@c This took 40 minutes on 1/7/2005.
@c Tell those who receive the repository:
@c   You can find a copy of the Daikon CVS repository at
@c     http://pag.csail.mit.edu/~mernst/tmp/inv-cvs.tar.gz
@c   Please let me know when you have downloaded it, so I can remove the
@c   file.  Please carefully read the "Analyzing historical versions of
@c   Daikon" section of the Daikon Developer Manual.  Let us know if you
@c   have any problems, questions, or suggestions; we will do our best
@c   to help.  Please let us know anything interesting you learn, and we
@c   wish you the best of luck with your research!
@c Distributions in 2005:
@c   1/7/2005	Miryung Kim <miryung@cs.washington.edu>


This section is intended primarily for researchers who are analyzing
historical versions of Daikon.  A number of researchers (for example, in
the testing community) use Daikon because it contains both a CVS
repository and a set of tests.  (The CVS repository can also be useful
to those making non-trivial changes to the Daikon code base, because the
CVS repository includes regression tests that are more extensive than
the unit tests that are included in the Daikon distribution.)

If you wish access to the Daikon CVS repository, send mail to
@email{daikon-developers@@lists.csail.mit.edu}.  We appreciate it if you
let us know why you need it and what you want to use it for.  Also, we
request that you keep us appraised of any problems that you encounter or
discoveries that you make, and that you let us know of any publications
so that we can publicize them at
@uref{http://www.pag.csail.mit.edu/daikon/pubs/#daikon-testsubject}.
Also, please do not redistribute the repository without prior permission
from us.

We typically give you a copy of the CVS repository (a 700MB download, as
of November 2004) rather than remote access to the master CVS
repository.  This protects you from the possibility that our server is
down, or that we someday cut you off from access to the repository; you
are guaranteed to be able to reproduce your results.  It is also less
hassle for us (we don't have to create an account for you), and it is
less load on our servers (since researchers may wish to perform many CVS
operations).

This section points out some pitfalls for such researchers.  Although
these problems are easy to avoid, some previous published work has made
these mistakes; don't let that happen to you!

Recall that Daikon contains two sets of tests (@pxref{Testing}); you
should include both in any analysis of Daikon's tests.

Daikon intentionally does not contain tests for third-party libraries
that are included (sometimes in source form) in the Daikon distribution.
For example, the @file{java/ajax/} and @file{java/jtb/} directories
contain external libraries.  Therefore, any measurement of Daikon's code
coverage should not include those libraries (or other libraries, some of
which are distributed as @file{.jar} files).

Be sure to see file @file{doc/www/mit/index.html} in the repository for
information about how group members use Daikon.  (This file changes from
time to time --- for instance, when the CVS branch was created and later
when development on it ceased.


@menu
* Branches::                    
@end menu

@node    Branches,  , Historical, Historical
@section Branches

The Daikon CVS repository contains two branches:  a main trunk and a
branch (named ENGINE_V2_PATCHES) for version 2 of Daikon.

The CVS manual
@ifinfo
(@pxref{Branching and merging,,,cvs,CVS -- Concurrent Versions System})
@end ifinfo
@ifnotinfo
(see section @uref{https://www.cvshome.org/docs/manual/cvs-1.11.18/cvs_5.html,``Branching and merging''} of the manual @emph{CVS -- Concurrent Versions System})
@end ifnotinfo
describes CVS branches:

@quotation
  CVS allows you to isolate changes onto a separate line of development,
  known as a ``branch''.  When you change files on a branch, those changes
  do not appear on the main trunk or other branches.

  Later you can move changes from one branch to another branch (or the
  main trunk) by "merging".  Merging involves first running 
  @samp{cvs update -j}, to merge the changes into the working directory.
  You can then commit that revision, and thus effectively copy the
  changes onto another branch.
@end quotation

In early January 2002 (or perhaps in late 2001), we created the
ENGINE_V2_PATCHES branch at the @file{invariants/java/daikon level} of
the Daikon CVS repository.  Primary development continued along the CVS
branch ENGINE_V2_PATCHES, which we called ``Daikon version 2''.  We
called the CVS trunk ``Daikon version 3''; it was experimental, and very
few people ran its code or performed development on it.  Periodically,
all changes made to the branch would be merged into the trunk, as one
large checkin on the trunk.  Later, development on version 3 became more
common, some changes were merged from the trunk to the branch, and and
version 2 was finally retired (and no more changes were made to the
branch) in December 2003.

A regular "cvs checkout" gets the trunk.  The "-r" flag specifies a
branch.  For example, to get the branch as of June 9, 2002, one could do
@smallexample
cvs -d $pag/projects/invariants/.CVS co -r ENGINE_V2_PATCHES -D 2003/06/09 invariants/java/daikon
@end smallexample

Some warnings about analyzing historical versions of Daikon:
@enumerate
@item
When analyzing 2002 (and at least parts of 2003) you should be careful
to use the branch, not the trunk.  Or, you could analyze both (but as a
single development effort, not as separate efforts).
@item
When a programmer periodically merged changes from the branch to the
trunk (or vice versa), that operation resulted in very large checkins.
The times at which these merges occurred is indicated in file
@file{invariants/java/daikon/merging.txt} in the repository; for
example, this happened 34 times during calendar year 2002.  CVS checkins
for the branch properly attribute and time-stamp the work that appears
as a single large checkin on the trunk.
@item
There may be long periods of time in the branch (respectively, the
trunk) with no checkins, but that does not necessarily indicate a lacuna
in development, as checkins might have occurred in the meanwhile in the
trunk (respectively, the branch).
@end enumerate



@node     Index,  , Historical, Top
@unnumbered Index

@printindex cp


@bye


@c  LocalWords:  texinfo setfilename settitle daikonemail setchapternewpage sp
@c  LocalWords:  hboxes finalout titlepage titlefont daikon eps pdf txt png jpg
@c  LocalWords:  vskip pt filll html img src alt ifnothtml dir ifnottex ifinfo
@c  LocalWords:  ifhtml detailmenu uref cindex java jpp cpp javac jikes proto
@c  LocalWords:  invs samp SingleScalar TwoScalar abs ThreeScalar TwoSequence
@c  LocalWords:  SingleSequence SequenceScalar noindent Daikon's InvName ppt ok
@c  LocalWords:  PptSlice dyn dkconfig VarInfo computeConfidence num repr esc
@c  LocalWords:  DAIKONDIR IOA JML var newtype OutputFormat PrintInvariants int
@c  LocalWords:  decls dtrace squar emph NISuppressor NISuppression suppressee
@c  LocalWords:  NISuppressee NISuppressionSet ni IntGreaterEqual eq IntEqual
@c  LocalWords:  lt IntLessThan makeEmpty LessThan GreaterThan orig theArray TR
@c  LocalWords:  FloatLessThan DisjSets SequenceScalarSubscriptFactory pxref co
@c  LocalWords:  Javadoc Varinfo logOn getClass foo vars isLoggable logDetail
@c  LocalWords:  msg showTrackback args webserver addInvariant href emacsclient
@c  LocalWords:  inv PptTopLevel FileIO php isObviousStatically LCS Nimmer's cp
@c  LocalWords:  isObviousDynamically Toh Win's nohierarchy noequality diffs
@c  LocalWords:  diff InvariantFormatTest classpath ioa jml aString valueOf val
@c  LocalWords:  deffn SampleTester decl subsubsection arg iff testsubject ajax
@c  LocalWords:  jtb cvs checkin smallexample checkins printindex
