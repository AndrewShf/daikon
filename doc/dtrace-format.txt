This file contains information about the file format of Daikon's data trace
files.


File format for data trace files
================================

[
 Added to declaration file format:
  * record lackwit_type_format
  * add to each program point:
     * specify that a variable is a constant, either at compile time
       (static final) or at run time (blank final).  I have to be able to
       do this at run time, so maybe only do it at run time?
  * record a "function invocation id" per function.  It's a unique ID that
    lets us map from entries to exits, to permit handline of orig values.
    The downside is the addition of an additional int variable in every
    procedure.
 Add to trace file format:
  * never permit mixing declarations and traces
  * specify relevant decls files, with message digests for them.  Possibly
    omit comments from the message digests??
    I'll keep a list of the decls files read so far.
]

A data trace (.dtrace) file contains two types of record:
 * static lexical information about a program point
 * dynamic information about values at a program point
A declaration (.decls) file contains only program point records; when a
declaration file exists, typically the data trace file contains only value
records.

Blank lines separate records.
Lines beginning with the '#' character are ignored (except inside a record,
where comments are not permitted).
The program point information must precede the first appearance of values
at that point, but it is not required that all the program point
declarations appear before any values are written to the file.  (This is
intended to provide flexibility for instrumentation implementations.)

The format of the program point information is:
  DECLARE
  program-point-name
  varname1
  type1
  comparable1
  varname2
  type2
  comparable2
  ...

Program point information includes:
 * name ("tag") of this program point, an arbitrary string containing no
   tab or newline characters.  
   By convention, the entry and exit points for a function have names of
   a special form so that they can be associated with one another.
   (Currently, those names end with ":::BEGIN" and ":::END".)  This
   convention permits instrumenters not to remember the original values of
   variables and output them at the procedure exit point.
 * for each variable:
    * name: an arbitrary, uninterpreted string containing no tabs or newlines.
    * type, as a human-readable string
      This is currently uninterpreted (that is, the strings are compared
      for equality but not destructed into their constituent parts).
      For arrays, this looks like "int[]" or "char[][]"
    * comparable variables, also known as "Lackwit types".  These indicate
      which other variables are comparable to this one, which is typically
      obtained via type-inference based analysis.  There are two formats,
      "implicit" and "explicit", for this information.
       * An implicit lackwit type is an arbitrary string, and comparisons
	 succeed exactly if the two lackwit types are identical.
       * An explicit lackwit type is a list of other variables, and
	 comparisons succeed if each variable is in the list of the other.
	 It takes the form of
	  * for scalar types:  A space-separated list of all the other
	    variables mentioned in this record that are comparable to this
	    one.
	  * for array types:  The lists are surrounded by parentheses, and
	    variables are given in parentheses for indices, like so:
            "(a b c)[(d e)][(f g h)]".
            The elements and indices of an array are named according to 
            %s-element and %s-index%d, where the indices are numbered
	    starting with 1.
          * If no information is supplied (ie, this line is blank), then
	    the variable is compared to all other variables of the same type.
 * Future enhancements:
    * permit variables to be omitted if they haven't changed (but always
      outputting the bit permits us to write a sanity checker)
    * permit variables to appear in any order

The format of the value information is:
  program-point-name
  varname1
  var-value-1
  var-modified-1
  varname2
  var-value-2
  var-modified-2
  ...

Value information includes:
 * name of the program point
 * for each variable:
    * name
    * value
       * integer, or
       * array (describe the format for that)
    * modified? (0 or 1)
   The variables should appear in the same order as they did in the
   declaration of the program point, without omissions or additions.

The file format is fairly verbose, but should be reasonable for people to
read.  Eventually we may add a terser (binary?) format with converters to
and from the text format, if files get so large that storing or reading
them is a problem.  Because Python is slow at finding specific characters
(say, tabs) in strings, the primary separator is newline rather than tab or
'='.  This may change (for instance, we might put the variable name,
modification bit, and value on a single line, tab-delimited) if we find the
format takes up too many lines in the file.


Here is an example of the file format:

# Program: sub.c
# Instrumented by: EDG front end version 3.14, 2/22/99
# Input: test22.in
# Lacwit types (comparable values) are given in "implicit" form.

DECLARE
subtract:::BEGIN
minuend
int
7
subtrahend
int
7

DECLARE
subtract:::END
minuend
int
7
subtrahend
int
7
result
int
7

subtract:::BEGIN
minuend
7
1
subtrahend
3
1

subtract:::BEGIN
minuend
22
1
subtrahend
10
1

subtract:::END
minuend
22
0
subtrahend
10
0
result
12
1

subtract:::END
minuend
7
0
subtrahend
3
0
result
4
1
