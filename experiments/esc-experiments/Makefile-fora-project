# This is a -*- Makefile -*- which each subdirectory (project) will include

# ==================================================================
# Variables which project Makefiles should declare before including
# this Makefile:
#
# PROJECT           Name of the directory in which the project resides (e.g. StackAr)
# TRACE_NAME        Name of the trace file daikon will generate (e.g. StackAr.dtrace)
# SOURCE_UNCHANGED  List of .java files which the files under examination need (e.g. DataStructures/Hashable.java ...)
# SOURCE_TO_DFEJ    List of .java files which should be instrumented (e.g. DataStructures/StackAr.java)
# PACKAGE           Package where the instrumented files lie (e.g. DataStructures)
# MAIN_RUN          File name of main class to run for data collection (e.g. DataStructures.StackArTester)
#

# ==================================================================
# Basic facts about this Makefile
#
# Assumes that each project has its own subdirectory under esc-experiments/
# Assumes that uninstrumented code lives at esc-experiments/ (+ package structure)
# Creates /scratch/$USER/esc-experiments/PROJECT/ directory to hold
#   * instrumented source
#   * decls files
#   * compiled source
#   * dtrace files
# Creates PROJECT/PROJECT.txt-daikon with daikon-style invariants
# Creates PROJECT/PROJECT.txt-simplify with simplify-style invariants
# Creates PROJECT/PROJECT.txt-esc with esc-style invariants
# Creates PROJECT/(+ package) with esc-annotated versions of the source
# Creates PROJECT/PROJECT.esc with output from escjava verification
#


DAIKON_OPTS?=--suppress_cont --suppress_post

## Copied from another makefile; uncomment as needed
DAIKON ?= java -mx128m daikon.Daikon
# DFEJ = dfej +E
# JAVAC := jikes -g +E +F
INV ?= $(HOME)/research/invariants
# TESTS = $(INV)/tests
# SCRIPTS = $(INV)/scripts
# MODBIT_MUNGE = $(SCRIPTS)/modbit-munge.pl
# TRACE_UNTRUNCATE = $(SCRIPTS)/trace-untruncate
TRACE_PURGE_FNS = $(SCRIPTS)/trace-purge-fns.pl
# TRACE_PURGE_VARS = $(SCRIPTS)/trace-purge-vars.pl
DAIKON_CLASS = $(INV)/java/daikon/Daikon.class

default: help

help:
	@echo "make options...."
	@echo "  make reset-scratch  : removes the /scratch folder (clean slate)"
	@echo ""
	@echo "  make create-scratch : 1 sets up the /scratch folder"
	@echo "  make instrument     : 2 instruments the source under test"
	@echo "  make compile        : 3 compiles the source under test"
	@echo "  make data           : 4 runs the source under test"
	@echo "  make txt-esc        : 5 detects invariants, writes in esc style"
	@echo "  make merge          : merges the esc-style output into the original source"
	@echo "  make esc            : runs escjava on the merged files"
	@echo "  make stats          : reports invariant counts"
	@echo ""
	@echo "  make inv            : detects invariants, writes in serialized style"
	@echo "  make txt-daikon     : detects invariants, writes in daikon style"
	@echo "  make txt-simplify   : detects invariants, writes in daikon style"
	@echo ""
	@echo "  make clean          : "
	@echo "  make all            : does 1-5, merge, esc"
	@echo ""
	@echo "Note that 1->5 are a chain, and invoking any of them will invoke"
	@echo "  previous steps if there is a dirty dependency in the chain"

all: txt-esc merge esc

SCRATCH_FOR_DAIKON?=/scratch/${USER}/esc-experiments/${PROJECT}

reset-scratch: reset-scratch-impl
create-scratch: ${SCRATCH_FOR_DAIKON}/.exists
copy-uninst: ${SCRATCH_FOR_DAIKON}/.copy-timestamp ${PROJECT}/.copy-timestamp
instrument: ${SCRATCH_FOR_DAIKON}/.instrument-timestamp
compile: ${SCRATCH_FOR_DAIKON}/.compile-timestamp
data: ${SCRATCH_FOR_DAIKON}/.run-timestamp
inv: ${PROJECT}.inv
txt-daikon: ${PROJECT}.txt-daikon
txt-simplify: ${PROJECT}.txt-simplify
txt-esc: ${PROJECT}.txt-esc
esc: ${PROJECT}.esc
stats: stats-impl

clean: reset-scratch
	@echo
	@echo \#\#\# clean
	@echo
	rm -f ${PROJECT}.txt-daikon ${PROJECT}.txt-daikon-failed ${PROJECT}.txt-simplify ${PROJECT}.txt-simplify-failed ${PROJECT}.txt-esc ${PROJECT}.txt-esc-failed ${PROJECT}.esc *.bak
#	rm -rf ${PACKAGE}


###########################################################################

reset-scratch-impl:
	@echo
	@echo \#\#\# reset-scratch
	@echo
	rm -rf daikon-java
	rm -rf daikon-output
	rm -rf ${SCRATCH_FOR_DAIKON}

# setup the /scratch directory for this project

${SCRATCH_FOR_DAIKON}/.exists:
	@echo
	@echo \#\#\# create-scratch
	@echo
	mkdir -p ${SCRATCH_FOR_DAIKON}/daikon
	ln -s ${SCRATCH_FOR_DAIKON}/daikon daikon-java
	ln -s ${SCRATCH_FOR_DAIKON}/daikon daikon-output
	touch ${SCRATCH_FOR_DAIKON}/.exists

# copy files which are used but not instrumented to /scratch and .

DOT_DOT_SOURCE_UNCHANGED:=${patsubst %,../%,${SOURCE_UNCHANGED}}
${SCRATCH_FOR_DAIKON}/.copy-timestamp: ${SCRATCH_FOR_DAIKON}/.exists ${DOT_DOT_SOURCE_UNCHANGED}
	@echo
	@echo \#\#\# copy-uninstrumented to /scratch and [project]
	@echo
	cd .. && cp -pP --target-directory=${SCRATCH_FOR_DAIKON}/ ${SOURCE_UNCHANGED} 
	cd .. && cp -pP --target-directory=${PROJECT}/ ${SOURCE_UNCHANGED} 
	cd ${PACKAGE} && rm -f *.java-unannotated
	touch ${SCRATCH_FOR_DAIKON}/.copy-timestamp

# instrument files under detection, and copy the uninstrumented versions to . for later merging

DOT_DOT_SOURCE_TO_DFEJ:=$(patsubst %,../%,${SOURCE_TO_DFEJ})
${SCRATCH_FOR_DAIKON}/.instrument-timestamp: ${SCRATCH_FOR_DAIKON}/.copy-timestamp ${DOT_DOT_SOURCE_TO_DFEJ}
	@echo
	@echo \#\#\# instrument
	@echo
	dfej -classpath ../:${CLASSPATH} ${DFEJ_OPTIONS} ${DOT_DOT_SOURCE_TO_DFEJ}
	cd .. && cp -pP --target-directory=${PROJECT}/ ${SOURCE_TO_DFEJ}
	touch ${SCRATCH_FOR_DAIKON}/.instrument-timestamp

# compile the files in /scratch

${SCRATCH_FOR_DAIKON}/.compile-timestamp: ${SCRATCH_FOR_DAIKON}/.instrument-timestamp
	@echo
	@echo \#\#\# compile
	@echo
	cd ${SCRATCH_FOR_DAIKON} && jikes `find . -name '*.java'`
	touch ${SCRATCH_FOR_DAIKON}/.compile-timestamp

# run the program under inspection from /scratch

${SCRATCH_FOR_DAIKON}/.run-timestamp: ${SCRATCH_FOR_DAIKON}/.compile-timestamp
	@echo
	@echo \#\#\# data
	@echo
	java -classpath ${SCRATCH_FOR_DAIKON}:${CLASSPATH} ${MAIN_RUN}
	modbit-munge.pl `find ${SCRATCH_FOR_DAIKON} -name '*.dtrace'`
	touch ${SCRATCH_FOR_DAIKON}/.run-timestamp

${PROJECT}.inv: ${SCRATCH_FOR_DAIKON}/.run-timestamp $(DAIKON_CLASS)
	@echo
	@echo \#\#\# inv
	@echo
	${DAIKON} -o $@ ${DAIKON_OPTS} `find ${SCRATCH_FOR_DAIKON} -name '*.decls' -o -name '*.dtrace'`

${PROJECT}.txt-daikon: ${SCRATCH_FOR_DAIKON}/.run-timestamp $(DAIKON_CLASS)
	@echo
	@echo \#\#\# txt-daikon
	@echo
	-rm -f $@-failed
	${DAIKON} --output_num_samples ${DAIKON_OPTS} `find ${SCRATCH_FOR_DAIKON} -name '*.decls' -o -name '*.dtrace'` >& $@ || (mv $@ $@-failed && false)
#	../remove-conditional-ppts.pl $@

${PROJECT}.txt-simplify: ${SCRATCH_FOR_DAIKON}/.run-timestamp $(DAIKON_CLASS)
	@echo
	@echo \#\#\# txt-simplify
	@echo
	-rm -f $@-failed
	${DAIKON} --simplify_output ${DAIKON_OPTS} `find ${SCRATCH_FOR_DAIKON} -name '*.decls' -o -name '*.dtrace'` >& $@ || (mv $@ $@-failed && false)

${PROJECT}.txt-esc: ${SCRATCH_FOR_DAIKON}/.run-timestamp $(DAIKON_CLASS)
	@echo
	@echo \#\#\# txt-esc
	@echo
	-rm -f $@-failed
	${DAIKON} --esc_output ${DAIKON_OPTS} `find ${SCRATCH_FOR_DAIKON} -name '*.decls' -o -name '*.dtrace'` >& $@ || (mv $@ $@-failed && false)
#	../remove-conditional-ppts.pl $@

#../DataStructures/StackAr.java-escannotated: txt-esc
PWD:=$(shell pwd)
merge:
	@echo
	@echo \#\#\# merge
	@echo
	cd ${PACKAGE} && ls *.java-unannotated | perl -p -e 's/^(.*)-unannotated$$/mv \1-unannotated \1/' | sh
	cd ${PACKAGE} && merge-esc.pl ${PWD}/${PROJECT}.txt-esc${EXTRA_MERGE_SUFFIX}
	cd ${PACKAGE} && ls *.java | perl -p -e 's/^(.*)$$/mv \1 \1-unannotated/' | sh
	cd ${PACKAGE} && ls *.java-escannotated | perl -p -e 's/^(.*)-escannotated$$/mv \1-escannotated \1/' | sh

# run escjava on the annotated files

# Used to depend on ${PROJECT}.txt-esc, but that's not quite right.
${PROJECT}.esc: ${SOURCE_TO_DFEJ}
	@echo
	@echo \#\#\# esc
	@echo
	escjava -suggest ${SOURCE_TO_DFEJ} > ${PROJECT}.esc

esc-clean:
	-rm -f ${PROJECT}.esc

esc-force: esc-clean ${PROJECT}.esc

stats-impl:
	@echo Stats for ${SOURCE_TO_DFEJ}:
	@echo '  invariant ' `egrep '^/\*@ inv' ${SOURCE_TO_DFEJ} | wc -l` ' (+' `egrep '^/\*! inv' ${SOURCE_TO_DFEJ} | wc -l` 'unexpressable)'
	@echo '  set       ' `egrep '^/\*@ set' ${SOURCE_TO_DFEJ} | wc -l` ' (+' `egrep '^/\*! set' ${SOURCE_TO_DFEJ} | wc -l` 'unexpressable)'
	@echo '  requires  ' `egrep '^/\*@ req' ${SOURCE_TO_DFEJ} | wc -l` ' (+' `egrep '^/\*! req' ${SOURCE_TO_DFEJ} | wc -l` 'unexpressable)'
	@echo '  modifies  ' `egrep '^/\*@ mod' ${SOURCE_TO_DFEJ} | wc -l` ' (+' `egrep '^/\*! mod' ${SOURCE_TO_DFEJ} | wc -l` 'unexpressable)'
	@echo '  ensures   ' `egrep '^/\*@ ens' ${SOURCE_TO_DFEJ} | wc -l` ' (+' `egrep '^/\*! ens' ${SOURCE_TO_DFEJ} | wc -l` 'unexpressable)'


# ###########################################################################

# ## Extras that should be patterned after the above at some point.

# daikon-output/StackAr-init.dtrace: daikon-output/StackAr.dtrace
# 	cp -pf $< $@
# 	trace-purge-fns.pl -v '<init>' $@

# daikon-init: daikon-output/StackAr-init.dtrace
# 	java daikon.Daikon ${DAIKON_OPTS} $< daikon-output/DataStructures/*.decls -o StackAr-init.inv > StackAr-init.txt

# daikon-output/StackAr-makeEmpty.dtrace: daikon-output/StackAr.dtrace
# 	cp -pf $< $@
# 	trace-purge-fns.pl -v 'makeEmpty' $@

# daikon-makeempty: daikon-output/StackAr-makeEmpty.dtrace
# 	java daikon.Daikon ${DAIKON_OPTS} $< daikon-output/DataStructures/*.decls -o StackAr-init.inv > StackAr-makeEmpty.txt

# daikon-output/StackAr-push.dtrace: daikon-output/StackAr.dtrace
# 	cp -pf $< $@
# 	trace-purge-fns.pl -v 'push' $@

# daikon-push: daikon-output/StackAr-push.dtrace
# 	java daikon.Daikon ${DAIKON_OPTS} $< daikon-output/DataStructures/*.decls -o StackAr-init.inv > StackAr-push.txt

# ###########################################################################
