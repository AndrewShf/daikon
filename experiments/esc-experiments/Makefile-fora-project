# This is a -*- Makefile -*- which each subdirectory (project) will include

# ==================================================================
# Variables which project Makefiles should declare before including
# this Makefile:
#
# PROJECT           Name of the directory in which the project resides (e.g. StackAr)
# TRACE_NAME        Name of the trace file daikon will generate (e.g. StackAr.dtrace)
# SOURCE_UNCHANGED  List of .java files which the files inder examination need (e.g. DataStructures/Hashable.java ...)
# SOURCE_TO_DFEJ    List of .java files which should be instrumented (e.g. DataStructures/StackAr.java)
# PACKAGE           Package where the instrumented files lice (e.g. DataStructures)
# MAIN_RUN          File name of main class to run for data collection (e.g. DataStructures.StackArTester)
#

# ==================================================================
# Basic facts about this Makefile
#
# Assumes that each project has it's own subdirectory under esc-experiments/
# Assumes that uninstumented code lives at esc-experiments/ (+ package structure)
# Creates /tmp/esc-experiments/PROJECT/ directory to hold
#   * instrumented source
#   * decls files
#   * compiled source
#   * dtrace files
# Creates PROJECT/PROJECT.txt-daikon with daikon-style invariants
# Creates PROJECT/PROJECT.txt-esc with esc-style invariants
# Creates PROJECT/(+ package) with esc-annotated versions of the source
# Creates PROJECT/PROJECT.esc with output from escjava verification
#


DAIKON_OPTS=--suppress_cont

## Copied from another makefile; uncomment as needed
# DAIKON = java -mx128m daikon.Daikon
# DFEJ = dfej +E
# JAVAC := jikes -g +E +F
INV = $(HOME)/research/invariants
# TESTS = $(INV)/tests
# SCRIPTS = $(INV)/scripts
# MODBIT_MUNGE = $(SCRIPTS)/modbit-munge.pl
# TRACE_UNTRUNCATE = $(SCRIPTS)/trace-untruncate
TRACE_PURGE_FNS = $(SCRIPTS)/trace-purge-fns.pl
# TRACE_PURGE_VARS = $(SCRIPTS)/trace-purge-vars.pl
DAIKON_CLASS = $(INV)/daikon/Daikon.class

default: help

help:
	@echo "make options...."
	@echo "  make reset-scratch  : removes the /tmp folder (clean slate)"
	@echo ""
	@echo "  make create-scratch : 1 sets up the /tmp folder"
	@echo "  make instrument     : 2 instuments the source under test"
	@echo "  make compile        : 3 compiles the source under test"
	@echo "  make data           : 4 runs the source under test"
	@echo "  make txt-daikon     : 5 detects invariants, writes in daikon style"
	@echo "  make txt-esc        : 6 detects invariants, writes in esc style"
	@echo "  make merge          : merges the esc-style output into the original source"
	@echo "  make esc            : runs escjava on the merged files"
	@echo ""
	@echo "  make clean          : "
	@echo "  make all            : does 1-6, merge, esc"
	@echo ""
	@echo "Note that 1->6 are a chain, and invoking any of them will invoke"
	@echo "  previous steps if there is a dirty dependency in the chain"

all: reset-scratch txt-esc merge esc

SCRATCH_FOR_DAIKON?=/tmp/esc-experiments/${PROJECT}

reset-scratch: reset-scratch-impl
create-scratch: ${SCRATCH_FOR_DAIKON}/.exists
copy-uninst: ${SCRATCH_FOR_DAIKON}/.copy-timestamp ${PROJECT}/.copy-timestamp
instrument: ${SCRATCH_FOR_DAIKON}/.instrument-timestamp
compile: ${SCRATCH_FOR_DAIKON}/.compile-timestamp
data: ${SCRATCH_FOR_DAIKON}/.run-timestamp
txt-daikon: ${PROJECT}.txt-daikon
txt-esc: ${PROJECT}.txt-esc
esc: ${PROJECT}.esc

clean: reset-scratch
	@echo
	@echo \#\#\# clean
	@echo
	rm -f ${PROJECT}.txt-daikon ${PROJECT}.txt-esc ${PROJECT}.esc

#esc: StackAr.esc

#daikon: StackAr.txt-esc

###########################################################################

reset-scratch-impl:
	@echo
	@echo \#\#\# reset-scratch
	@echo
	rm -rf daikon-java
	rm -rf daikon-output
	rm -rf ${SCRATCH_FOR_DAIKON}

# setup the /tmp directory for this project

${SCRATCH_FOR_DAIKON}/.exists:
	@echo
	@echo \#\#\# create-scratch
	@echo
	mkdir -p ${SCRATCH_FOR_DAIKON}/daikon
	ln -s ${SCRATCH_FOR_DAIKON}/daikon daikon-java
	ln -s ${SCRATCH_FOR_DAIKON}/daikon daikon-output
	touch ${SCRATCH_FOR_DAIKON}/.exists

# copy files which are used but not instrumented to /tmp and .

DOT_DOT_SOURCE_UNCHANGED:=${patsubst %,../%,${SOURCE_UNCHANGED}}
${SCRATCH_FOR_DAIKON}/.copy-timestamp: ${SCRATCH_FOR_DAIKON}/.exists ${DOT_DOT_SOURCE_UNCHANGED}
	@echo
	@echo \#\#\# copy-uninstrumented to /tmp and [project]
	@echo
	cd .. && cp -pP --target-directory=${SCRATCH_FOR_DAIKON}/ ${SOURCE_UNCHANGED} 
	cd .. && cp -pP --target-directory=${PROJECT}/ ${SOURCE_UNCHANGED} 
	touch ${SCRATCH_FOR_DAIKON}/.source-unchanged-timestamp

# instument files under detection, and copy the uninstrumented versions to . for later merging

DOT_DOT_SOURCE_TO_DFEJ:=$(patsubst %,../%,${SOURCE_TO_DFEJ})
${SCRATCH_FOR_DAIKON}/.instrument-timestamp: ${SCRATCH_FOR_DAIKON}/.copy-timestamp ${DOT_DOT_SOURCE_TO_DFEJ}
	@echo
	@echo \#\#\# instrument
	@echo
	dfej -classpath ../:${CLASSPATH} ${DOT_DOT_SOURCE_TO_DFEJ}
	cd .. && cp -pP --target-directory=${PROJECT}/ ${SOURCE_TO_DFEJ}
	touch ${SCRATCH_FOR_DAIKON}/.instrument-timestamp

# compile the files in /tmp

${SCRATCH_FOR_DAIKON}/.compile-timestamp: ${SCRATCH_FOR_DAIKON}/.instrument-timestamp
	@echo
	@echo \#\#\# compile
	@echo
	cd ${SCRATCH_FOR_DAIKON} && jikes `find . -name '*.java'`
	touch ${SCRATCH_FOR_DAIKON}/.compile-timestamp

# run the program under inspection from /tmp

${SCRATCH_FOR_DAIKON}/.run-timestamp: ${SCRATCH_FOR_DAIKON}/.compile-timestamp
	@echo
	@echo \#\#\# data
	@echo
	java -classpath ${SCRATCH_FOR_DAIKON}:${CLASSPATH} ${MAIN_RUN}

${PROJECT}.txt-daikon: ${SCRATCH_FOR_DAIKON}/.run-timestamp $(DAIKON_CLASS)
	@echo
	@echo \#\#\# txt-daikon
	@echo
	java daikon.Daikon ${DAIKON_OPTS} `find ${SCRATCH_FOR_DAIKON} -name '*.decls' -o -name '*.dtrace'` >& $@ || rm $@
	../remove-conditional-ppts.pl $@

${PROJECT}.txt-esc: ${SCRATCH_FOR_DAIKON}/.run-timestamp $(DAIKON_CLASS)
	@echo
	@echo \#\#\# txt-esc
	@echo
	java daikon.Daikon --esc_output ${DAIKON_OPTS} `find ${SCRATCH_FOR_DAIKON} -name '*.decls' -o -name '*.dtrace'` >& $@ || rm $@
	../remove-conditional-ppts.pl $@

#../DataStructures/StackAr.java-escannotated: txt-esc
PWD:=$(shell pwd)
merge:
	@echo
	@echo \#\#\# merge
	@echo
	cd ${PACKAGE} && merge-esc.pl ${PWD}/${PROJECT}.txt-esc
	cd ${PACKAGE} && ls *.java | perl -p -e 's/^(.*)$$/mv \1 \1-unannotated/' | sh
	cd ${PACKAGE} && ls *.java-escannotated | perl -p -e 's/^(.*)-escannotated$$/mv \1-escannotated \1/' | sh

# run escjava on the annontated files

${PROJECT}.esc:
	escjava ${SOURCE_TO_DFEJ} > ${PROJECT}.esc

# ###########################################################################

# ## Extras that should be patterned after the above at some point.

# daikon-output/StackAr-init.dtrace: daikon-output/StackAr.dtrace
# 	cp -pf $< $@
# 	trace-purge-fns.pl -v '<init>' $@

# daikon-init: daikon-output/StackAr-init.dtrace
# 	java daikon.Daikon ${DAIKON_OPTS} $< daikon-output/DataStructures/*.decls -o StackAr-init.inv > StackAr-init.txt

# daikon-output/StackAr-makeEmpty.dtrace: daikon-output/StackAr.dtrace
# 	cp -pf $< $@
# 	trace-purge-fns.pl -v 'makeEmpty' $@

# daikon-makeempty: daikon-output/StackAr-makeEmpty.dtrace
# 	java daikon.Daikon ${DAIKON_OPTS} $< daikon-output/DataStructures/*.decls -o StackAr-init.inv > StackAr-makeEmpty.txt

# daikon-output/StackAr-push.dtrace: daikon-output/StackAr.dtrace
# 	cp -pf $< $@
# 	trace-purge-fns.pl -v 'push' $@

# daikon-push: daikon-output/StackAr-push.dtrace
# 	java daikon.Daikon ${DAIKON_OPTS} $< daikon-output/DataStructures/*.decls -o StackAr-init.inv > StackAr-push.txt

# ###########################################################################
