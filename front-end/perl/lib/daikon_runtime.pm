package daikon_runtime;

# This is the package of routines that Daikon-annotated Perl code
# uses.

# Among the 5.6 features we use is three-argument open. Note that for
# backwards compatilibity it would be silly to say "use 5.6.0", since
# that version syntax wasn't introduced until 5.6.
use 5.006;

use Exporter;

use strict;
#use warnings;

use Carp qw(carp cluck croak confess);
use IO::File;

use vars '@EXPORT_OK';
use vars '@ISA';

@ISA = 'Exporter';
@EXPORT_OK = qw(trace trace_enter trace_return);

use Daikon::PerlType qw(LIST_LIMIT type_lub unparse_type
			guess_type_ref guess_type_list);

use Daikon::Output qw(declare_var output_var);

# indexed by {package name}
my %filehandles = ();

# indexed by {package_name}{program point name}
my %decls;

# indexed by {package_name}{program point name}{variable name}
my %types;

# Start tracing the subroutines in the given package. It's no longer
# necessary to call this explicitly, since the trace routines call it
# when they're first invoked in a given package.
sub begin_trace {
    my($package) = @_;
    if (exists $filehandles{$package}) {
	carp "Already tracing package $package\n";
	return;
    }
    my $fh = new IO::File;
    if (not -d "daikon-output") {
	mkdir "daikon-output" or carp "Can't create daikon-output/: $!";
    }
    my $fname = "daikon-output/$package.dtrace";
    my $op;
    if ($ENV{"DTRACEAPPEND"}) {
	$op = ">>"; # append to the .dtrace file
    } else {
	$op = ">";  # overwrite the .dtrace file
    }
    open($fh, $op, $fname) or carp "Can't create $fname: $!";
    $filehandles{$package} = $fh;
}

# Finish tracing the subroutines in the given package. This is called
# automatically from and END { } block. We wait until we're done to
# output the .decls file, and any type information we might have
# guessed. (For the type information, we have to wait because our
# guesses might need to be refined as we get more data. For the .decls
# file, this is just laziness)
sub end_trace {
    my($package) = @_;
#    warn "Finishing $package";
    close $filehandles{$package};
    delete $filehandles{$package};

    my $fname = "daikon-output/$package.decls";
    my $op;
    if ($ENV{"DTRACEAPPEND"}) {
	$op = ">>";
    } else {
	$op = ">";
    }
    open(DECLS, $op, $fname) or carp "Can't create $fname: $!";
    print DECLS "// Declarations for the Perl package $package\n";
    print DECLS "// Generated by daikon_runtime.pm\n\n";
    print DECLS "VarComparability\nnone\n\n";
    for my $lines_ref (values %{$decls{$package}}) {
	print DECLS join("", @$lines_ref), "\n";
    }
    close DECLS;

    $fname = "$package.types";
    # Note that at the moment we always append to the types file. I'm
    # not sure if this is the best behavior, but if we were given all
    # the type information we need, it's certainly silly to overwrite
    # the types with an empty file, which is what would happen if the
    # >> below were a >.
    open(TYPES, ">>", $fname) or carp "Can't create $fname: $!";
    for my $ppt (keys %{$types{$package}}) {
	for my $var (keys %{$types{$package}{$ppt}}) {
	    print TYPES "$ppt $var ";
	    print TYPES unparse_type($types{$package}{$ppt}{$var});
	    print TYPES "\n";
	}
    }
    close TYPES;
}

# Close out tracing and output .decls files for all the packages we
# started tracing.
sub end_trace_all {
    for my $p (keys %filehandles) {
	end_trace($p);
    }
}

# At the end of regular execution, finish any unfinished tracing.
END { end_trace_all(); }

# This is a little bit strange. We'd like to have a flag that is set
# to 1 inside the tracing routines, and tells re-entrant invocations
# of them not to do anything, to avoid confusing the
# output. (Reentrant calls to trace occur for instance if a value
# we're tracing is actually an overloaded object with a stringify or
# numify method that we're also tracing. They don't represent a real
# part of the execution we're trying to capture, so we'd like to
# ignore them).  I'd like to use Perl's local() operator to set a flag
# to 1 in such a way that it will always be reset to zero when I leave
# the tracing routine, even by some exception or other non-local exit.
# Unfortunately, for reasons of avoiding confusing beginning
# programmers and of implementation simplification, Perl doesn't let
# you use local() on a my() variable. It does, however, let you use
# local() an element of any array, my() or not. Therefore I use the
# 0th element of the @trace_mutex array as if it were a variable
# $trace_mutex for this purpose.
my @trace_mutex = (0);

# The main routine to handle the tracing at a single program
# point. The name argument is something like "ENTER" or "EXIT42", and
# @vars is a list of variable specifications like ['$x', \$x, 'int']
# (variable name, reference to value, type).
sub trace_name {
    my($name, @vars) = @_;
    if ($trace_mutex[0]) {
	if ($ENV{"DAIKON_PERL_DEBUG_REENTRANT"}) {
	    $trace_mutex[0] = 0; # Prevent looping during the backtrace
	    cluck "Whoa! Re-entering trace!\n";
	    $SIG{__DIE__} = 0;
	    use POSIX;
	    POSIX::_exit(0); # Really die, even in an eval
	} else {
	    return;
	}
    }
    local($trace_mutex[0]) = 1;
    # These calls to caller() are the way we extract information about
    # where the trace routine was called, to save the caller from
    # passing it explicitly. caller(i) gives you information about the
    # invocation i-levels up the call stack, but the return convention
    # is a bit tricky. For a given level, $package and $line (really
    # the 0th and 2th elements) are the package and line number of the
    # caller of that subroutine, while $subname and $wantlist (3th and
    # 5th) are the name and the scalar/list context of the subroutine
    # itself. Thus we need two calls. Also we have to be careful that
    # trace_name is always the same number of levels down the stack
    # from the code whenever it's called. For the values below, this
    # works if the routine being traced calls foo() and foo() calls
    # trace_name().
    my(undef,    undef, undef, $subname, undef, $wantlist) = caller(2);
    my($package, undef, $line, undef,    undef, undef)     = caller(1);
    $subname =~ s/.*:://; # Remove leading package qualifiers
    if ($wantlist) {
	$subname .= "_l";
    } else {
	$subname .= "_s";
    }
#    my $javaish_package = $package;
#    $javaish_package =~ s/::/./g;

    # The parens in the next line are import to get some tools
    # (e.g. the tree GUI) to work right. I guess otherwise they can't
    # tell that this is a subroutine.
    my $ppt_name = "${package}.${subname}():::$name";
    if (not exists $filehandles{$package}) {
	begin_trace($package);
    }
    if (not exists $decls{$package}{$ppt_name}) {
	# This is the first time seeing this program point, so make
	# the declaration.
	my @lines = ("DECLARE\n");
	push @lines, "$ppt_name\n";
	for my $v (@vars) {
	    confess "Bad variable format" unless ref($v) eq "ARRAY";
	    if ($v->[2] eq "unknown") {
		# Do type inference rather than data collection this pass
		$types{$package}{$ppt_name}{$v->[0]} = 'undef';
	    } else {
		push @lines, declare_var($v->[0], $v->[2]);
	    }
	}
	$decls{$package}{$ppt_name} = [@lines];
    }
    my $fh = $filehandles{$package};
    print $fh "$ppt_name\n";
    for my $v (@vars) {
	if ($v->[2] eq "unknown") {
	    # Type guessing
	    my $t = $types{$package}{$ppt_name}{$v->[0]};
 	    if ($v->[0] eq "return" and $ppt_name =~ /_l\(\):::EXIT/) {
		# List return types are the only place lists appear
 		$t = type_lub($t, guess_type_list($v->[1]));
 	    } else {
		# Other values are just single.
		my $this_type = guess_type_ref($v->[1])->[1];
		$t = type_lub($t, $this_type);
	    }
	    $types{$package}{$ppt_name}{$v->[0]} = $t;
	} else {
	    # Output a real value
	    output_var($fh, @$v);
	}
    }
    print $fh "\n";
}

# Trace the entrance to a subroutine. The arguments are a list of
# variable specs.
sub trace_enter { trace_name("ENTER", @_); }

# Trace the return from a subroutine. This is more complicated than
# entering because we need to distinguish scalar from list context,
# and different exit points from one another. We assume that
# "return(FOO)" will get rewritten into something like

# return trace_return((wantarray()?[FOO]:\scalar(FOO)),'int','(int),42,...)

# where FOO returns an int in scalar context and a list containing a
# single int in list ("array") context. Recall that there's no way to
# derive the list context return value from the scalar context value
# or vice versa, so we have to have code paths that capture both, but
# it the FOO expression might also have side effects, so we only want
# to capture one value for each call to the subroutine. The scalar and
# list types are in the usual unparsed format; they may not always be
# as similar as they are the example above. "42" is a sequence number
# chosen by the annotator to be differed from all other returns in the
# same subroutine; otherwise it's arbitrary. Any other arguments are
# additional variables to trace the value of, as with the other trace
# routines.

sub trace_return {
    my($ret_val_ref, $scalar_type, $list_type, $seq, @vars) = @_;
    if ((caller(1))[5]) {
	# list context
	trace_name("EXIT$seq", @vars, ['return', $ret_val_ref, $list_type]);
	return @$ret_val_ref;
    } else {
	# scalar (or void) context
	trace_name("EXIT$seq", @vars, ['return', $ret_val_ref, $scalar_type]);
	return $$ret_val_ref;
    }
}

# This would be the routine to trace at points other than entrance and
# exit, but that isn't supported at the moment.
# sub trace { trace_name("LINE", @_); }

1;
