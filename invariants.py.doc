This file contains implementation and design notes on the invariant
engine.  For user documentation, see the README file in the distribution.

Contents:
 * File format for data trace files
 * Data structures: mapping tuples of values to occurrence counts
 * Data strucures: creating maps from sub-tuples of values to occurrence counts


File format for data trace files
================================

A data trace (.dtrace) file contains two types of record:
 * static lexical information about a program point
 * dynamic information about values at a program point
A declaration (.decls) file contains only program point records.

Blank lines separate records.
Lines beginning with the '#' character are ignored (except inside a record,
where comments are not permitted).
The program point information must precede the first appearance of values
at that point, but it is not required that all the program point
declarations appear before any values are written to the file.  (This is
intended to provide flexibility for instrumentation implementations.)

The format of the program point information is:
  DECLARE
  program-point-name
  varname1
  type1
  comparable1
  varname2
  type2
  comparable2
  ...

Program point information includes:
 * name ("tag") of this program point, an arbitrary string containing no
   tab or newline characters.  
   By convention, the entry and exit points for a function have names of
   a special form so that they can be associated with one another.
   (Currently, those names end with ":::BEGIN" and ":::END".)  This
   convention permits instrumenters not to remember the original values of
   variables and output them at the procedure exit point.
 * for each variable:
    * name: an arbitrary, uninterpreted string containing no tabs or newlines.
    * type, as a human-readable string
      This is currently uninterpreted (that is, the strings are compared
      for equality but not destructed into their constituent parts).
    * comparable variables:  A list of all the other variables mentioned
      in this record that are comparable to this one.  If no information is
      supplied (ie, this line is blank), then the variable is compared to
      all other variables of the same type.  This information is typically
      obtained via a Lackwit-style analysis.
 * Future enhancements:
    * permit variables to be omitted if they haven't changed (but always
      outputting the bit permits us to write a sanity checker)
    * permit variables to appear in any order

The format of the value information is:
  program-point-name
  varname1
  var-value-1
  var-modified-1
  varname2
  var-value-2
  var-modified-2
  ...

Value information includes:
 * name of the program point
 * for each variable:
    * name
    * value
       * integer, or
       * array (describe the format for that)
    * modified? (0 or 1)
   The variables should appear in the same order as they did in the
   declaration of the program point, without omissions or additions.

The file format is fairly verbose, but should be reasonable for people to
read.  Eventually we may add a terser (binary?) format with converters to
and from the text format, if files get so large that storing or reading
them is a problem.  Because Python is slow at finding specific characters
(say, tabs) in strings, the primary separator is newline rather than tab or
'='.  This may change (for instance, we might put the variable name,
modification bit, and value on a single line, tab-delimited) if we find the
format takes up too many lines in the file.


Here is an example of the file format:

# Program: sub.c
# Instrumented by: EDG front end version 3.14, 2/22/99
# Input: test22.in

DECLARE
subtract:::BEGIN
minuend
int
subtrahend
int

DECLARE
subtract:::END
minuend					We could omit these variables if they
int					cannot be modified and we use the
subtrahend				current scheme of remembering the
int					original values in the engine.
result
int

subtract:::BEGIN
minuend
7
1
subtrahend
3
1

subtract:::BEGIN
minuend
22
1
subtrahend
10
1

subtract:::END
minuend
22
0
subtrahend
10
0
result
12
1

subtract:::END
minuend
7
0
subtrahend
3
0
result
4
1


Data structures: mapping tuples of values to occurrence counts
==============================================================

The primary datastructure used in invariants.py is a dictionary (a
hashtable; "dictionary" is the Python term) from tuples of values to the
number of occurrences of those tuples in the input.

For instance, suppose the input looks like

  foo	i 2	j 3
  foo	i 7	j 3
  bar	x 5	y 6	z 90210
  foo	i 7	j 3
  bar	x 3	y 6	z 9
  foo	i 2	j 3
  foo	i 7	j 3

Two dictionaries are created, one for the "foo" tag and one for the "bar"
tag.  The dictionary for foo looks like

  (2,3) -> 2
  (7,3) -> 3

(where "->" separates keys from values) because the tuple (2,3) occurs
twice in the input and the tuple (7,3) occurs thrice.  There are two tuples
for bar, each occurring once:

  (5, 6, 90210) -> 1
  (3, 6, 9) -> 1


Data strucures: creating maps from sub-tuples of values to occurrence counts
============================================================================

Invariant detection also works over dictionaries mapping tuples to
occurrence counts.  There are currently three types of invariants to
detect:  those involving one variable, those involving two variables, and
those involving three variables.  Their input dictionaries differ in the
arity of their keys.  For instance, the foo dictionary would be a
reasonable input to the binary invariant checker, and the bar dictionary
could be provided to the ternary invariant checker, but neither of these is
appropriate for the unary invariant checker as is.

In order to detect invariants over a subset of the available variables, we
produce a new dictionary with keys of smaller arity.  For instance, suppose
we start with a dictionary mapping pairs of elements to the number of their
occurrences.

  (1,1) -> 3
  (1,2) -> 4
  (1,7) -> 1
  (2,2) -> 5

We can convert this to a dictionary mapping single elements to the number
of their occurrences in two ways:  by examining the first element of the
pair, or by examining the second element of the pair.  The two resulting
dictionaries are, respectively:

  1 -> 8
  2 -> 5

and

  1 -> 3
  2 -> 9
  7 -> 1

Now these can be fed to the single-variable invariant discoverer.

Similarly, given dictionary

  (1,2,3) -> 4
  (1,2,7) -> 2
  (1,3,6) -> 5
  (7,2,3) -> 1

there are three different ways to associate pairs of variables with counts:

 columns 1 and 2:
  (1,2) -> 6
  (1,3) -> 5
  (7,2) -> 1

 columns 1 and 3:
  (1,3) -> 4
  (1,7) -> 2
  (1,6) -> 5
  (7,3) -> 1

 columns 2 and 3:
  (2,3) -> 5
  (2,7) -> 2
  (3,6) -> 5

This reduction of arity is performed by two different routines.  Function
dict_of_tuples_to_tuple_of_dicts converts a single dictionary from tuples
to counts into a collection of dictionaries, each from a single value to a
count; this is the first example given above.  Function
dict_of_tuples_slice takes a dictionary and a list of indices and returns a
dictionary whose keys contain only those elements (those columns, if you
will) of the original one's keys; this is the second example given above.
