#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(ARITY1) || defined(ARITY2) || defined(ARITY3))
  #error "One of ARITY1, ARITY2, or ARITY3 must be defined"
#endif

#if defined(ARITY1)
  #define PPTSLICE1 PptSlice1
  #define PPTSLICE1STRING "PptSlice1"
  #define NUM_TM 2
  #define ARITY 1
#elif defined(ARITY2)
  #define PPTSLICE1 PptSlice2
  #define PPTSLICE1STRING "PptSlice2"
  #define NUM_TM 4
  #define ARITY 2
#elif defined(ARITY3)
  #define PPTSLICE1 PptSlice3
  #define PPTSLICE1STRING "PptSlice3"
  #define NUM_TM 8
  #define ARITY 3
#else
  #error "One of ARITY1, ARITY2, or ARITY3 must be defined"
#endif

#if 0
Macro ORDER_VALUES forces values of interest to their original order.
This has a small execution cost -- see Vector values_order.
#endif
#define ORDER_VALUES

// ***** This file is automatically generated from PptSlice.java.jpp

package daikon;

import daikon.inv.*;
import daikon.suppress.*;
#ifdef ARITY1
import daikon.inv.unary.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.string.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.stringsequence.*;
#endif
#ifdef ARITY2
import daikon.inv.binary.*;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.inv.binary.twoString.*;
import daikon.inv.binary.sequenceScalar.*;
#endif
#ifdef ARITY3
import daikon.inv.ternary.*;
import daikon.inv.ternary.threeScalar.*;
#endif

import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;

import utilMDE.*;

// This file looks a *lot* like part of PptTopLevel.
// (That is fine; its purpose is similar and mostly subsumed by VarValues.)

public final class PPTSLICE1
  extends PptSlice
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  /**
   * Debug tracer
   **/
  public static final Logger debugSpecific = Logger.getLogger("daikon." + PPTSLICE1STRING);

  public static final Logger debugMerge = Logger.getLogger ("daikon.PptSlice.merge");

  // This is in PptSlice; do not repeat it here!
  // Invariants invs;


#if defined(ARITY1)
  public VarInfo var_info;
#endif

  // These are commented out (and all uses of them are commented out), but
  // they are retained in case someday we wish to reinstate them for some
  // debugging purpose.  Note, however, that they aren't accurate:  a slice
  // does not necessarily see all samples (because the slice might be
  // instantiated after some samples have already been processed).
  // /** Number of modified samples observed. **/
  // private int mod_samples = 0;
  // /** Number of unmodified samples observed. **/
  // private int unmod_samples = 0;

  /**
   * Create a new PPTSLICE1.  Warning: do not rearrange the contents
   * of var_infos once this has been created, as flow order is already
   * set up after construction.
   **/
  public PPTSLICE1(PptTopLevel parent, VarInfo[] var_infos) {
    super(parent, var_infos);
    Assert.assertTrue(var_infos.length == ARITY);
#if defined(ARITY1)
    var_info = var_infos[0];
#endif
    Dataflow.init_pptslice_po(this);

    if (debug.isLoggable(Level.FINE) || debugSpecific.isLoggable(Level.FINE))
      debug.info("Created " + PPTSLICE1STRING + " " + this.name());
    if (Debug.logOn())
      Debug.log (getClass(), this, "Created");

    // Make the caller do this, because
    //  1. there are few callers
    //  2. do not want to instantiate all invariants all at once
    // instantiate_invariants();
  }

#if defined(ARITY1)
  PptSlice1(PptTopLevel parent, VarInfo var_info) {
    this(parent, new VarInfo[] { var_info });
  }
#elif defined(ARITY2)
  PptSlice2(PptTopLevel parent, VarInfo var_info1, VarInfo var_info2) {
    this(parent, new VarInfo[] { var_info1, var_info2 });
  }
#elif defined(ARITY3)
  PptSlice3(PptTopLevel parent, VarInfo var_info1, VarInfo var_info2, VarInfo var_info3) {
    this(parent, new VarInfo[] { var_info1, var_info2, var_info3 });
  }
#endif

  public final int arity() {
    return ARITY;
  }

  void instantiate_invariants() {
    // Instantiate invariants
    if (debug.isLoggable(Level.FINE) || debugSpecific.isLoggable(Level.FINE))
      debug.info("instantiate_invariants for " + name() + ": originally " + invs.size() + " invariants in " + invs);
    if (Debug.logOn())
      log ("instantiate invariants");

    Vector new_invs = null;
#if defined(ARITY1)
    ProglangType rep_type = var_info.rep_type;
    boolean is_scalar = rep_type.isScalar();
    if (is_scalar) {
      new_invs = SingleScalarFactory.instantiate(this);
    } else if (rep_type == ProglangType.INT_ARRAY) {
      new_invs = SingleScalarSequenceFactory.instantiate(this);
    } else if (Daikon.dkconfig_enable_floats
               && rep_type == ProglangType.DOUBLE) {
      new_invs = SingleFloatFactory.instantiate(this);
    } else if (Daikon.dkconfig_enable_floats
               && rep_type == ProglangType.DOUBLE_ARRAY) {
      new_invs = SingleFloatSequenceFactory.instantiate(this);
    } else if (rep_type == ProglangType.STRING) {
      new_invs = SingleStringFactory.instantiate(this);
    } else if (rep_type == ProglangType.STRING_ARRAY) {
      new_invs = SingleStringSequenceFactory.instantiate(this);
    } else {
      // Do nothing; do not even complain
    }
#elif defined(ARITY2)
    ProglangType rep1 = var_infos[0].rep_type;
    ProglangType rep2 = var_infos[1].rep_type;
    boolean rep1_is_scalar = rep1.isScalar();
    boolean rep2_is_scalar = rep2.isScalar();
    boolean rep1_is_float  = rep1.isFloat();
    boolean rep2_is_float  = rep2.isFloat();
    if (rep1_is_scalar && rep2_is_scalar) {
      new_invs = TwoScalarFactory.instantiate(this);
    } else if ((rep1 == ProglangType.STRING)
        && (rep2 == ProglangType.STRING)) {
      new_invs = TwoStringFactory.instantiate(this);
    } else if ((rep1 == ProglangType.INT)
               && (rep2 == ProglangType.INT_ARRAY)) {
      new_invs = SequenceScalarFactory.instantiate(this);
    } else if ((rep1 == ProglangType.INT_ARRAY)
               && (rep2 == ProglangType.INT)) {
      new_invs = SequenceScalarFactory.instantiate(this);
    } else if ((rep1 == ProglangType.INT_ARRAY)
               && (rep2 == ProglangType.INT_ARRAY)) {
      new_invs = TwoSequenceFactory.instantiate(this);
    } else if (rep1_is_float && rep2_is_float) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = TwoFloatFactory.instantiate(this);
      }
    } else if ((rep1 == ProglangType.DOUBLE)
               && (rep2 == ProglangType.DOUBLE_ARRAY)) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = SequenceFloatFactory.instantiate(this);
      }
    } else if ((rep1 == ProglangType.DOUBLE_ARRAY)
               && (rep2 == ProglangType.DOUBLE)) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = SequenceFloatFactory.instantiate(this);
      }
    } else if ((rep1 == ProglangType.DOUBLE_ARRAY)
               && (rep2 == ProglangType.DOUBLE_ARRAY)) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = TwoSequenceFactoryFloat.instantiate(this);
      }
    } else {
      // Do nothing; do not even complain
    }
#elif defined(ARITY3)
    ProglangType rep1 = var_infos[0].file_rep_type;
    ProglangType rep2 = var_infos[1].file_rep_type;
    ProglangType rep3 = var_infos[2].file_rep_type;
    if ((rep1 == ProglangType.INT)
        && (rep2 == ProglangType.INT)
        && (rep3 == ProglangType.INT)) {
      new_invs = ThreeScalarFactory.instantiate(this);
    } else if ((rep1 == ProglangType.DOUBLE)
               && (rep2 == ProglangType.DOUBLE)
               && (rep3 == ProglangType.DOUBLE)) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = ThreeFloatFactory.instantiate(this);
      }
    } else {
      // Do nothing; do not even complain
    }
#endif

    if (new_invs != null) {
      for (int i=0; i<new_invs.size(); i++) {
        Invariant inv = (Invariant) new_invs.get(i);
        if (inv == null)
          continue;
        addInvariant(inv);
      }
    }

    if (debug.isLoggable(Level.FINE) || debugSpecific.isLoggable(Level.FINE)) {
      debug.info("after instantiate_invariants " + PPTSLICE1STRING + " " + name() + " = " + this + " has " + invs.size() + " invariants in " + invs);
    }
    if ((debugSpecific.isLoggable(Level.FINE)) && (invs.size() > 0)) {
      debug.info("the invariants are:");
      for (int i=0; i<invs.size(); i++) {
        Invariant inv = (Invariant) invs.get(i);
        debug.info("  " + inv.format());
        debug.info("    " + inv.repr());
      }
    }

  }

  // /**
  //  * Set the number of samples for this slice to be at least count.
  //  **/
  // public void set_samples (int count) {
  //   // Don't call num_samples(), because slices_see_all_samples is false.
  //   int old_num_samples = mod_samples + unmod_samples;
  //   if (old_num_samples >= count) return;
  //   // Distribute the new samples equally among the buckets.
  //   double ratio = ((double)count)/old_num_samples;
  //   mod_samples *= ratio;
  //   unmod_samples = count - mod_samples;
  // }

  // I could introduce another accessor that uses
  // UtilMDE.intersectionCardinalityAtLeast(), which might be more
  // efficient.

  // These accessors are for abstract methods declared in Ppt
  /** Returns the number of (non-missing) samples observed at this slice. **/
  public int num_samples() {
    // return an approximation
#if defined(ARITY1)
    int num_slice_samples = parent.num_samples(var_info);
#elif defined(ARITY2)
    int num_slice_samples = parent.num_samples(var_infos[0], var_infos[1]);
#elif defined(ARITY3)
    int num_slice_samples = parent.num_samples(var_infos[0], var_infos[1],
                                               var_infos[2]);
#endif
//       if (mod_samples + unmod_samples != num_slice_samples) {
//         System.out.println("num_samples(" + name() + "): "
//           + (mod_samples + unmod_samples) + " vs. " + num_slice_samples);
// #if defined(ARITY1)
//         System.out.println ("mbtracker.num_samples() = "
//                             + parent.mbtracker.num_samples());
// #endif
//       }
    return num_slice_samples;
  }

  /**
   * Returns (an approximation to) the number of distinct values observed
   * at this slice.  This is not the number of samples observed.
   **/
  public int num_values() {
    // return an approximation
#if defined(ARITY1)
    int num_values = parent.num_values(var_info);
#elif defined(ARITY2)
    int num_values = parent.num_values(var_infos[0], var_infos[1]);
#elif defined(ARITY3)
    int num_values = parent.num_values(var_infos[0], var_infos[1], var_infos[2]);
#endif
    return num_values;
  }

#if 0
  This method is only used by some twoSequence Invariants, like PairwiseIntComparison
#endif
#if defined(ARITY2)
  // Returns the number of distinct array element values stored in
  // this value tracker (only if the arrays are of equal length)
  public int num_elt_values() {
    throw new Error("to be implemented");
  }
#endif

#if 0
  num_no_dup_values() is only used by NoDuplicates
  num_seq_index_values() is only used by SeqIndexComparison
#endif
#if defined(ARITY1)
  // Returns the number of arrays seen whose length was > 1
  public int num_no_dup_values() {
    throw new Error("to be implemented");
  }

  // Returns the number of values seen as defined by
  // SeqIndexComparison.  That is, each distinct pair
  // (a[i], i) is considered a distinct value
  public int num_seq_index_values() {
    throw new Error("to be implemented");
  }
#endif

  // Accessing data
  int num_vars() {
    return var_infos.length;
  }
  Iterator var_info_iterator() {
    return Arrays.asList(var_infos).iterator();
  }


  boolean compatible(Ppt other) {
    // This insists that the var_infos lists are identical.  The Ppt
    // copy constructor does reuse the var_infos field.
    return (var_infos == other.var_infos);
  }

  ///////////////////////////////////////////////////////////////////////////
  /// Manipulating values
  ///


  /**
   * This procedure accepts a sample (a ValueTuple), extracts the values
   * from it, casts them to the proper types, and passes them along to the
   * invariants proper.  (The invariants accept typed values rather than a
   * ValueTuple that encapsulates objects of any type whatever.)
   **/
  public List add(ValueTuple full_vt, int count) {
    //     if (debugFlow.isLoggable(Level.FINE)) {
    //       debugFlow.fine ("<< Doing add for " + this.toString());
    //       StringBuffer sb = new StringBuffer();
    //       for (int i = 0; i < var_infos.length; i++) {
    //         VarInfo vi = var_infos[i];
    //         Object val = vi.getValue(full_vt);
    //         sb.append (" ");
    //         sb.append (ValueTuple.valToString (val));
    //       }
    //       debugFlow.fine ("    with values:" + sb);
    //     }

    Assert.assertTrue(invs.size() > 0);
    // Assert.assertTrue(! already_seen_all); // [INCR]
    for (int i=0; i<invs.size(); i++) {
      Assert.assertTrue(invs.get(i) != null);
    }

    // if (Global.debugInfer.isLoggable(Level.FINE)) {
    //   Global.debugInfer.fine (PPTSLICE1STRING + ".add(" + full_vt + ", " + count + ")" + " for " + name());
    // }

    // Do not bother putting values into a slice if missing.

#if defined(ARITY1)
    VarInfo vi1 = var_info;
#elif defined(ARITY2)
    VarInfo vi1 = var_infos[0];
    VarInfo vi2 = var_infos[1];
#elif defined(ARITY3)
    VarInfo vi1 = var_infos[0];
    VarInfo vi2 = var_infos[1];
    VarInfo vi3 = var_infos[2];
#endif

    // If any var has encountered out of array bounds values,
    // stop all invariants in this slice.  The presumption here is that
    // an index out of bounds implies that the derived variable (eg a[i])
    // doesn't really make any sense (essentially that i is not a valid
    // index for a).  Invariants on the derived variable are thus not
    // relevant
    for (int i = 0; i < var_infos.length; i++) {
      if (var_infos[i].missingOutOfBounds()) {
        List result = new ArrayList();
        for (int j = 0; j < invs.size(); j++) {
          Invariant inv = (Invariant) invs.get(j);
          if (PrintInvariants.print_discarded_invariants)
            DiscReasonMap.put(inv, DiscardCode.bad_sample,
                  var_infos[i].name.name() + " array index was out of bounds");
          if (Daikon.dkconfig_df_bottom_up) {
            inv.falsify();
            result.add (inv);
          } else
            destroyAndFlowInv(inv);
          if (inv.logOn())
            inv.log ("destroyed because " + var_infos[i].name.name()
                     + " array index out of bounds");
        }
        if (VarInfo.debugMissing.isLoggable (Level.FINE))
          VarInfo.debugMissing.fine ("Removing slice " + this +
                          " because var " + var_infos[i].name.name() +
                          " array index out of bounds");
        if (Daikon.dkconfig_df_bottom_up) {
          remove_falsified();
          return (result);
        } else
          return flow_and_remove_falsified();
      }
    }

    int mod1 = full_vt.getModified(vi1);
    if (mod1 == ValueTuple.MISSING_FLOW || mod1 == ValueTuple.MISSING_NONSENSICAL) {
      // System.out.println("Bailing out of add(" + full_vt + ") for " + name());
      return emptyList;
    }
    if (mod1 == ValueTuple.STATIC_CONSTANT) {
      Assert.assertTrue(vi1.is_static_constant);
      mod1 = ((num_samples() == 0)
              ? ValueTuple.MODIFIED : ValueTuple.UNMODIFIED);
    }
#if defined(ARITY2) || defined(ARITY3)
    int mod2 = full_vt.getModified(vi2);
    if (mod2 == ValueTuple.MISSING_FLOW || mod2 == ValueTuple.MISSING_NONSENSICAL) {
      // System.out.println("Bailing out of add(" + full_vt + ") for " + name());
      return emptyList;
    }
    if (mod2 == ValueTuple.STATIC_CONSTANT) {
      Assert.assertTrue(vi2.is_static_constant);
      mod2 = ((num_samples() == 0)
              ? ValueTuple.MODIFIED : ValueTuple.UNMODIFIED);
    }
#endif
#if defined(ARITY3)
    int mod3 = full_vt.getModified(vi3);
    if (mod3 == ValueTuple.MISSING_FLOW || mod3 == ValueTuple.MISSING_NONSENSICAL) {
      // System.out.println("Bailing out of add(" + full_vt + ") for " + name());
      return emptyList;
    }
    if (mod3 == ValueTuple.STATIC_CONSTANT) {
      Assert.assertTrue(vi3.is_static_constant);
      mod3 = ((num_samples() == 0)
              ? ValueTuple.MODIFIED : ValueTuple.UNMODIFIED);
    }
#endif
    Object val1 = full_vt.getValue(vi1);
    Assert.assertTrue (Intern.isInterned (val1));
#if defined(ARITY2) || defined(ARITY3)
    Object val2 = full_vt.getValue(vi2);
    Assert.assertTrue (Intern.isInterned (val2));
#endif
#if defined(ARITY3)
    Object val3 = full_vt.getValue(vi3);
    Assert.assertTrue (Intern.isInterned (val3));
#endif

    // if (! already_seen_all) // [INCR]
    {
      /* [INCR] ...
#if defined(ARITY1)
      Object vals = val1;
#elif defined(ARITY2)
      Object[] vals = Intern.intern(new Object[] { val1, val2 });
#elif defined(ARITY3)
      Object[] vals = Intern.intern(new Object[] { val1, val2, val3 });
#endif
      int[] tm_arr = (int[]) values_cache.get(vals);
      if (tm_arr == null) {
        tm_arr = new int[NUM_TM];
        values_cache.put(vals, tm_arr);
        values_order.add (vals);
      }
      */ // ... [INCR]
    }
    // System.out.println(PPTSLICE1STRING + " " + name() + ": add " + full_vt + " = " + vt);
    // System.out.println(PPTSLICE1STRING + " " + name() + " has " + invs.size() + " invariants.");
    // defer_invariant_removal(); [INCR]
    // Supply the new values to all the invariant objects.
    int num_invs = invs.size();
    Assert.assertTrue((mod1 == vi1.getModified(full_vt))
                  || ((vi1.getModified(full_vt) == ValueTuple.STATIC_CONSTANT)
                      && ((mod1 == ValueTuple.UNMODIFIED)
                          || (mod1 == ValueTuple.MODIFIED))));

    if (Daikon.dkconfig_df_bottom_up) {

      #if defined(ARITY1)
        List weakened_invs = add_val_bu (val1, mod1, count);
      #elif defined(ARITY2)
        List weakened_invs = add_val_bu (val1, val2, mod1, mod2, count);
      #elif defined(ARITY3)
        List weakened_invs = add_val_bu (val1, val2, val3, mod1, mod2,
                                         mod3, count);
      #endif
      remove_falsified();
      return (weakened_invs);
    } else {
      #if defined(ARITY1)
        add_val (val1, mod1, count);
      #elif defined(ARITY2)
        add_val (val1, val2, mod1, mod2, count);
      #elif defined(ARITY3)
        add_val (val1, val2, val3, mod1, mod2, mod3, count);
      #endif
    }
    // undefer_invariant_removal(); [INCR]
    return flow_and_remove_falsified();
  }

  // Top down versions of

#if defined (ARITY1)
  public void add_val (Object val1, int mod1, int count) {

    // if (mod1 == ValueTuple.MODIFIED)
    //   mod_samples += count;
    // else
    //   unmod_samples += count;

    Assert.assertTrue(mod1 != ValueTuple.MISSING_FLOW
                      && mod1 != ValueTuple.MISSING_NONSENSICAL);
    for (int i=0; i < invs.size(); i++) {
      UnaryInvariant inv = (UnaryInvariant) invs.get(i);
      if (inv.is_false()) continue;
      if (inv.getSuppressor() != null) continue;
      Invariant clone = (Invariant) inv.clone();
      InvariantStatus status = inv.add(val1, mod1, count);
      if (status == InvariantStatus.FALSIFIED) {
        destroyAndFlowInv(inv);
      } else if (status == InvariantStatus.WEAKENED) {
        flowClone(inv, clone);
      }
      if (PrintInvariants.print_discarded_invariants && inv.is_false()) {
        DiscReasonMap.put(inv, DiscardCode.bad_sample,
          "Falsified from sample: " + var_infos[0].name.name() + " = "
          + (var_infos[0].rep_type.isArray() ? ArraysMDE.toString(val1) : val1));
      }
    }
  }
#elif defined (ARITY2)

  public void add_val (Object val1, Object val2, int mod1, int mod2, int count) {

    Assert.assertTrue ((mod1 != ValueTuple.MISSING_FLOW
                       && mod1 != ValueTuple.MISSING_NONSENSICAL)
                       && (mod2 != ValueTuple.MISSING_FLOW
                       && mod2 != ValueTuple.MISSING_NONSENSICAL));

    // if (mod1 == ValueTuple.MODIFIED || mod2 == ValueTuple.MODIFIED)
    //   mod_samples += count;
    // else
    //   unmod_samples += count;
    if (Debug.logDetail())
      Debug.log (getClass(), this, "mod1 = " + mod1 + " mod2 = " + mod2
                 + " count = " + count);

    boolean array1 = var_infos[0].rep_type.isArray();
    boolean array2 = var_infos[1].rep_type.isArray();
    if (array2 && ! array1) {
      for (int i=0; i < invs.size(); i++) {
        BinaryInvariant inv = (BinaryInvariant) invs.get(i);
        if (inv.is_false()) continue;
        if (inv.getSuppressor() != null) continue;
        Invariant clone = (Invariant) inv.clone();
        InvariantStatus status = inv.add(val2, val1, mod1, count);
        if (status == InvariantStatus.FALSIFIED) {
          destroyAndFlowInv(inv);
        } else if (status == InvariantStatus.WEAKENED) {
          flowClone(inv, clone);
        }
        if (PrintInvariants.print_discarded_invariants && inv.is_false()) {
          DiscReasonMap.put(inv, DiscardCode.bad_sample,
                            "Falsified from sample: " +
                            var_infos[0].name.name() +
                            " = " + val1 + "," + var_infos[1].name.name() +
                            " = " + ArraysMDE.toString(val2));
        }
      }
    } else {
      for (int i=0; i < invs.size(); i++) {
        BinaryInvariant inv = (BinaryInvariant) invs.get(i);
        if (inv.is_false()) continue;
        if (inv.getSuppressor() != null) continue;
        Invariant clone = (Invariant) inv.clone();
        InvariantStatus status = inv.add(val1, val2, mod1, count);
        if (status == InvariantStatus.FALSIFIED) {
          destroyAndFlowInv(inv);
        } else if (status == InvariantStatus.WEAKENED) {
          flowClone(inv, clone);
        }
        if (PrintInvariants.print_discarded_invariants && inv.is_false()) {
          if (array1 && array2 && (!( (inv instanceof SeqSeqIntEqual)
              || (inv instanceof SeqSeqFloatEqual)
              || (inv instanceof SeqSeqStringEqual) ))
              && ArraysMDE.length(val1) != ArraysMDE.length(val2)) {
            // No need to print out two potentially huge arrays if the
            // reason for discard was because of different array lengths
            DiscReasonMap.put(inv, DiscardCode.bad_sample,
                                "Samples seen with different array lengths");
          } else {
            DiscReasonMap.put(inv, DiscardCode.bad_sample,
                    "Falsified from sample: " + var_infos[0].name.name()
                    + " = " + (array1 ? ArraysMDE.toString(val1) : val1)
                    + "," + var_infos[1].name.name()
                    + " = " + (array2 ? ArraysMDE.toString(val2) : val2));
          }
        }
      }
    }
  }
#elif defined (ARITY3)
  public void add_val (Object val1, Object val2, Object val3,
                       int mod1, int mod2, int mod3, int count) {

    Assert.assertTrue ((mod1 != ValueTuple.MISSING_FLOW
                        && mod1 != ValueTuple.MISSING_NONSENSICAL)
                        && (mod2 != ValueTuple.MISSING_FLOW
                        && mod2 != ValueTuple.MISSING_NONSENSICAL)
                        && (mod3 != ValueTuple.MISSING_FLOW
                        && mod3 != ValueTuple.MISSING_NONSENSICAL));

    // if (mod1 == ValueTuple.MODIFIED || mod2 == ValueTuple.MODIFIED || mod3 == ValueTuple.MODIFIED)
    //   mod_samples += count;
    // else
    //   unmod_samples += count;;

    // Debug print add info
    if (Debug.logDetail())
      Debug.log (getClass(), this, "Adding values: " + val1 + ", " + val2
                 + ", " + val3);

    for (int i=0; i < invs.size(); i++) {
      TernaryInvariant inv = (TernaryInvariant) invs.get(i);
      if (inv.is_false()) continue;
      if (inv.getSuppressor() != null) continue;
      Invariant clone = (Invariant) inv.clone();
      InvariantStatus status = inv.add(val1, val2, val3, mod1, count);
      if (status == InvariantStatus.FALSIFIED) {
        destroyAndFlowInv(inv);
      } else if (status == InvariantStatus.WEAKENED) {
        flowClone(inv, clone);
      }
      if (PrintInvariants.print_discarded_invariants && inv.is_false()) {
        // Currently there are no ternary invariants with arrays, but if
        // there are in the future, I don't want this to break.
        DiscReasonMap.put(inv, DiscardCode.bad_sample,
          "Falsified from sample: " + var_infos[0].name.name() + " = "
          + (var_infos[0].rep_type.isArray() ? ArraysMDE.toString(val1) : val1)
          + "," + var_infos[1].name.name() + " = "
          + (var_infos[1].rep_type.isArray() ? ArraysMDE.toString(val2) : val2)
          + "," + var_infos[2].name.name() + " = "
          + (var_infos[2].rep_type.isArray() ? ArraysMDE.toString(val3) : val3));
      }
    }
  }
#endif

  // Bottom up versions of the add routines.  These do not use any
  // of the invariant flow/destroy routines

#if defined (ARITY1)
  public List /*Invariant*/ add_val_bu (Object val1, int mod1, int count) {

    Assert.assertTrue(mod1 != ValueTuple.MISSING_FLOW
                      && mod1 != ValueTuple.MISSING_NONSENSICAL);
    List result = new ArrayList();
    for (int i=0; i < invs.size(); i++) {
      UnaryInvariant inv = (UnaryInvariant) invs.get(i);
      if (inv.is_false()) continue;
      if (inv.getSuppressor() != null) continue;
      InvariantStatus status = inv.add(val1, mod1, count);
      if (status == InvariantStatus.FALSIFIED) {
        inv.falsify();
        result.add (inv);
      } else if (status == InvariantStatus.WEAKENED) {
        result.add (inv);
      }
      if (PrintInvariants.print_discarded_invariants && inv.is_false()) {
        DiscReasonMap.put(inv, DiscardCode.bad_sample,
          "Falsified from sample: " + var_infos[0].name.name() + " = "
          + (var_infos[0].rep_type.isArray() ? ArraysMDE.toString(val1) : val1));
      }
    }
    return (result);
  }
#elif defined (ARITY2)

  public List /*Invariant*/ add_val_bu (Object val1, Object val2,
                                        int mod1, int mod2, int count) {

    Assert.assertTrue ((mod1 != ValueTuple.MISSING_FLOW
                       && mod1 != ValueTuple.MISSING_NONSENSICAL)
                       && (mod2 != ValueTuple.MISSING_FLOW
                       && mod2 != ValueTuple.MISSING_NONSENSICAL));

    List result = new ArrayList();
    boolean array1 = var_infos[0].rep_type.isArray();
    boolean array2 = var_infos[1].rep_type.isArray();
    if (array2 && ! array1) {
      for (int i=0; i < invs.size(); i++) {
        BinaryInvariant inv = (BinaryInvariant) invs.get(i);
        if (inv.is_false()) continue;
        if (inv.getSuppressor() != null) continue;
        InvariantStatus status = inv.add(val2, val1, mod1, count);
        if (status == InvariantStatus.FALSIFIED) {
          inv.falsify();
          result.add (inv);
        } else if (status == InvariantStatus.WEAKENED) {
          result.add (inv);
        }
        if (PrintInvariants.print_discarded_invariants && inv.is_false()) {
          DiscReasonMap.put(inv, DiscardCode.bad_sample,
                            "Falsified from sample: " +
                            var_infos[0].name.name() +
                            " = " + val1 + "," + var_infos[1].name.name() +
                            " = " + ArraysMDE.toString(val2));
        }
      }
    } else {
      for (int i=0; i < invs.size(); i++) {
        BinaryInvariant inv = (BinaryInvariant) invs.get(i);
        if (inv.is_false()) continue;
        if (inv.getSuppressor() != null) continue;
        Invariant clone = (Invariant) inv.clone();
        InvariantStatus status = inv.add(val1, val2, mod1, count);
        if (status == InvariantStatus.FALSIFIED) {
          inv.falsify();
          result.add (inv);
        } else if (status == InvariantStatus.WEAKENED) {
          result.add (inv);
        }
        if (PrintInvariants.print_discarded_invariants && inv.is_false()) {
          if (array1 && array2 && (!( (inv instanceof SeqSeqIntEqual)
              || (inv instanceof SeqSeqFloatEqual)
              || (inv instanceof SeqSeqStringEqual) ))
              && ArraysMDE.length(val1) != ArraysMDE.length(val2)) {
            // No need to print out two potentially huge arrays if the
            // reason for discard was because of different array lengths
            DiscReasonMap.put(inv, DiscardCode.bad_sample,
                                "Samples seen with different array lengths");
          } else {
            DiscReasonMap.put(inv, DiscardCode.bad_sample,
                    "Falsified from sample: " + var_infos[0].name.name()
                    + " = " + (array1 ? ArraysMDE.toString(val1) : val1)
                    + "," + var_infos[1].name.name()
                    + " = " + (array2 ? ArraysMDE.toString(val2) : val2));
          }
        }
      }
    }
    return (result);
  }
#elif defined (ARITY3)
  public List /*Invariant*/ add_val_bu (Object val1, Object val2, Object val3,
                                     int mod1, int mod2, int mod3, int count) {

    Assert.assertTrue ((mod1 != ValueTuple.MISSING_FLOW
                        && mod1 != ValueTuple.MISSING_NONSENSICAL)
                        && (mod2 != ValueTuple.MISSING_FLOW
                        && mod2 != ValueTuple.MISSING_NONSENSICAL)
                        && (mod3 != ValueTuple.MISSING_FLOW
                        && mod3 != ValueTuple.MISSING_NONSENSICAL));

    List result = new ArrayList();
    for (int i=0; i < invs.size(); i++) {
      TernaryInvariant inv = (TernaryInvariant) invs.get(i);
      if (inv.is_false()) continue;
      if (inv.getSuppressor() != null) continue;
      Invariant clone = (Invariant) inv.clone();
      InvariantStatus status = inv.add(val1, val2, val3, mod1, count);
      if (status == InvariantStatus.FALSIFIED) {
        inv.falsify();
        result.add (inv);
      } else if (status == InvariantStatus.WEAKENED) {
        result.add (inv);
      }
      if (PrintInvariants.print_discarded_invariants && inv.is_false()) {
        // Currently there are no ternary invariants with arrays, but if
        // there are in the future, I don't want this to break.
        DiscReasonMap.put(inv, DiscardCode.bad_sample,
          "Falsified from sample: " + var_infos[0].name.name() + " = "
          + (var_infos[0].rep_type.isArray() ? ArraysMDE.toString(val1) : val1)
          + "," + var_infos[1].name.name() + " = "
          + (var_infos[1].rep_type.isArray() ? ArraysMDE.toString(val2) : val2)
          + "," + var_infos[2].name.name() + " = "
          + (var_infos[2].rep_type.isArray() ? ArraysMDE.toString(val3) : val3));
      }
    }
    return (result);
  }
#endif


//   private void destroyInv(Invariant inv) {
//     inv.falsified = true;
//     if (PrintInvariants.print_discarded_invariants)
//       parent.falsified_invars.add(this);
//     removeInvariant(inv);
//   }

  public void addInvariant(Invariant invariant) {
    Assert.assertTrue(invariant != null);
    // Assert.assertTrue(invariant.ppt == this);

    invs.add(invariant);
    Global.instantiated_invariants++;
    if (Global.debugStatistics.isLoggable(Level.FINE) || debugSpecific.isLoggable(Level.FINE))
      debug.info("instantiated_invariant: " + invariant.format()
                 // [INCR] + "; " + "already_seen_all=" + already_seen_all
                 );
    if (invariant.logOn())
      invariant.log ("Instantiated " + invariant.format());

    /* [INCR] ... I think this is now unnecessary; not sure. XXX
    if (already_seen_all) {
      // Make this invariant up to date by supplying it with all the values
      // which have already been seen.
      // (Do not do
      //   Assert.assertTrue(values_cache.entrySet().size() > 0);
      // because all the values might have been missing.  We used to ignore
      // variables that could have some missing values, but no longer.)
#if defined(ARITY1)
      UnaryInvariant inv = (UnaryInvariant) invariant;
      for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
        Map.Entry entry = (Map.Entry) itor.next();
        Object val = entry.getKey();
        int[] tm_array = (int[]) entry.getValue();
        InvariantStatus status1 = inv.add(val, 0, tm_array[0]);
        InvariantStatus status2 = inv.add(val, 1, tm_array[1]);
        if (status1 == InvariantStatus.FALSIFIED ||
            status2 == InvariantStatus.FALSIFIED) {
          destroyInv(inv);
          break;
        }
      }
#elif defined(ARITY2)
      VarInfo vi1 = var_infos[0];
      VarInfo vi2 = var_infos[1];
      boolean array1 = vi1.rep_type.isArray();
      boolean array2 = vi2.rep_type.isArray();
      boolean doublearray1 = vi1.rep_type == ProglangType.DOUBLE_ARRAY;
      boolean doublearray2 = vi2.rep_type == ProglangType.DOUBLE_ARRAY;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          int[] tm_array = (int[]) entry.getValue();
          InvariantStatus status = InvariantStatus.NO_CHANGE;
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              InvariantStatus tempStatus =
                inv.add(seqval, sclval, mi, tm_array[mi]);
              if (tempStatus == InvariantStatus.FALSIFIED) {
                status = InvariantStatus.FALSIFIED;
                break;
              }
            }
          }
          if (status == InvariantStatus.FALSIFIED) {
            destroyInv(inv);
            break;
          }
        }
#if defined (ORDER_VALUES)
        // Make this invariant up to date by supplying it with all the values.
        Assert.assertTrue (values_order.size() == values_cache.size());
        for (Iterator itor = values_order.iterator() ; itor.hasNext() ; ) {
          Object[] vals = (Object[]) itor.next();
          int[] tm_array = (int[]) values_cache.get (vals);
          InvariantStatus status = InvariantStatus.NO_CHANGE;
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              InvariantStatus tempStatus =
                inv.add(val1, val2, mi, tm_array[mi]);
              if (tempStatus == InvariantStatus.FALSIFIED) {
                status = InvariantStatus.FALSIFIED;
                break;
              }
            }
          }
          if (status == InvariantStatus.FALSIFIED) {
            destroyInv(inv);
            break;
          }
        }
#endif
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          int[] tm_array = (int[]) entry.getValue();
          InvariantStatus status = InvariantStatus.NO_CHANGE;
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              InvariantStatus tempStatus =
                inv.add(val1, val2, mi, tm_array[mi]);
              if (tempStatus == InvariantStatus.FALSIFIED) {
                status = InvariantStatus.FALSIFIED;
                break;
              }
            }
          }
          if (status == InvariantStatus.FALSIFIED) {
            destroyInv(inv);
            break;
          }
        }
      }
#elif defined(ARITY3)
      VarInfo vi1 = var_infos[0];
      VarInfo vi2 = var_infos[1];
      VarInfo vi3 = var_infos[2];
      ProglangType rep1 = vi1.rep_type;
      ProglangType rep2 = vi2.rep_type;
      ProglangType rep3 = vi3.rep_type;
#if defined (ORDER_VALUES)
        for (Iterator itor = values_order.iterator(); itor.hasNext(); ) {
          Object[] vals = (Object[]) itor.next();
          int[] tm_array = (int[]) values_cache.get (vals);
          InvariantStatus status = InvariantStatus.NO_CHANGE;
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              InvariantStatus tempStatus =
                inv.add(val1, val2, val3, mi, tm_array[mi]);
              if (tempStatus == InvariantStatus.FALSIFIED) {
                status = InvariantStatus.FALSIFIED;
                break;
              }
            }
          }
          if (status == InvariantStatus.FALSIFIED) {
            destroyInv(inv);
            break;
          }
        }
#endif
        for (Iterator itor = values_cache.entrySet().iterator(); itor.hasNext(); ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          int[] tm_array = (int[]) entry.getValue();
          InvariantStatus status = InvariantStatus.NO_CHANGE;
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              InvariantStatus tempStatus =
                inv.add(val1, val2, val3, mi, tm_array[mi]);
              if (tempStatus == InvariantStatus.FALSIFIED) {
                status = InvariantStatus.FALSIFIED;
                break;
              }
            }
          }
          if (status == InvariantStatus.FALSIFIED) {
            destroyInv(inv);
            break;
          }
        }
      }
#endif
    }
    */ // ... [INCR]
  }

  /**
   * Copy invariants from this slice to a new slice over the variables
   * argNewVarInfos.  The new slice should not already exist.  Only
   * invariants that do not exist at the corresponding global ppt slice
   * are copied.
   **/
  protected PptSlice cloneAndPivot (VarInfo[] argNewVarInfos) {

    // Sort the VarInfos by var_index and build a matching permutation
    // from the current order to the new order
    VarInfo[] vis_sorted = (VarInfo[]) argNewVarInfos.clone();
    Arrays.sort (vis_sorted, VarInfo.IndexComparator.getInstance());
    int[] permutation = PptTopLevel.build_permute (argNewVarInfos, vis_sorted);

    // Assert sorted
    for (int i = 0; i < ARITY - 1; i++) {
      Assert.assertTrue (vis_sorted[i].varinfo_index
                         <= vis_sorted[i+1].varinfo_index);
    }

    Assert.assertTrue(ArraysMDE.fn_is_permutation(permutation));
    // Assert that the permutation represents the rearrangement
    for (int i=0; i < ARITY; i++) {
      // the variable that used to be at position "i" is now found at
      // position permutation[i].
      VarInfo oldvi = argNewVarInfos[i];
      VarInfo newvi = vis_sorted[permutation[i]];
      Assert.assertTrue(oldvi == newvi);
    }

    // Find the matching global slice.  To match each variable must
    // have the same transformation (orig/post) from here to the
    // global ppt.
    PptSlice gslice = find_global_slice (vis_sorted);

    // The new slice should not already exist.
    Assert.assertTrue(parent.findSlice(vis_sorted) == null);

    // Why not just clone?  Because then index order wouldn't be
    // preserved
    PPTSLICE1 result = new PPTSLICE1 (this.parent, vis_sorted);

    // // Set sample counts
    // result.mod_samples = this.mod_samples;
    // result.unmod_samples = this.unmod_samples;

    // re-parent the invariants and copy them out.  Don't copy any that
    // are duplicated (exactly) at the global slice.
    List newInvs = new LinkedList();
    for (Iterator i = invs.iterator(); i.hasNext(); ) {
      Invariant inv = (Invariant) i.next();
      Assert.assertTrue (inv.ppt == this);
      Invariant newInv = inv.transfer (result, permutation);
      if ((gslice == null) || !gslice.contains_inv_exact (newInv)) {
        newInvs.add (newInv);
        parent.attemptSuppression (newInv, true);
        Assert.assertTrue (newInv != inv);
        Assert.assertTrue (newInv.ppt == result);
        Assert.assertTrue (inv.ppt == this);
      }
    }

    if (Debug.logOn())
      result.log ("Copied " + newInvs.size() + " invariants from "
                  + this.name() + " with " + invs.size() + " invariants");
    result.invs.addAll (newInvs);
    if (PptSliceEquality.debug.isLoggable(Level.FINE)) {
      PptSliceEquality.debug.fine ("cloneAndPivot: newInvs " + invs);
    }
    return result;
  }

  /**
   * Copies new invariants (those that don't already exist) to the
   * slice defined by vis in ppt.  Vis should initially match the
   * order of variables in this slice (ie, it shouldn't be sorted)
   * Creates and adds the new slice if it doesn't already exist
   */
  public PptSlice copy_new_invs (PptTopLevel ppt, VarInfo[] vis) {

    // This should only be called on global slices
    Assert.assertTrue (parent == PptTopLevel.global);

    // Sort the varinfos and find the corresponding slice
    VarInfo[] vis_sorted = (VarInfo[]) vis.clone();
    Arrays.sort (vis_sorted, VarInfo.IndexComparator.getInstance());
    PPTSLICE1 slice = (PPTSLICE1) ppt.findSlice (vis_sorted);

    // Build the permutation from the here to the new slice
    int[] permute = PptTopLevel.build_permute (vis, vis_sorted);

    // Find the matching global slice.  Note that this may not match
    // this slice because of equality set differences
    PptSlice parent_gslice = find_global_slice (vis_sorted);

    // If the parent global slice, does match this one, there is nothing
    // to copy (since everything is already at the global ppt)
    if (parent_gslice == this)
      return (null);

    // If the slice doesn't already exist, create it.  Note that the
    // values filled in for sample counts and valueTracker won't be
    // correct.  This is just a short-term hack to get something there.
    if (slice == null) {

      // if no samples have arrived yet, don't flow anything.  The correct
      // invariants are created when the firs instantiations occur
      if (ppt.num_samples() == 0)
        return (null);

      // Don't create unnecessary slices
      if (!ppt.is_slice_ok (vis_sorted, vis_sorted.length))
        return (null);

      slice = new PPTSLICE1 (ppt, vis_sorted);

      // // Set sample counts
      // slice.mod_samples = mod_samples;
      // slice.unmod_samples = unmod_samples;

      ppt.addSlice (slice);
    }

    // Copy each invariant from here to slice.  Don't copy any invariants
    // that already exist at slice or at slice's global parent slice.
    List new_invs = new ArrayList (invs.size());
    for (Iterator i = invs.iterator(); i.hasNext(); ) {
      Invariant inv = (Invariant) i.next();
      Invariant new_inv = inv.transfer (slice, permute);
      if (slice.contains_inv (new_inv)) {
        new_inv.log ("slice already contains inv, not copied");
        continue;
      }
      if ((parent_gslice != null) &&parent_gslice.contains_inv_exact(new_inv)){
        new_inv.log ("global slice already contains inv, not copied");
        continue;
      }
      new_invs.add (new_inv);
    }
    slice.invs.addAll (new_invs);

    return (slice);
  }

  /**
   * Removes any invariants in this slice that are flowable and are
   * already present at the matching global slice.  These are
   * duplicates since any invariant at the global ppt is known to be
   * true here as well.
   *
   * Note that some invariants are not flowable since the contain
   * sample dependent state that is not normally true at the lower
   * ppt.
   */

  public void remove_global_invs() {

    // Find the matching global slice.  To match each variable
    // must have the same transformation (orig/post) from here
    // to the global ppt
    PptSlice gslice = find_global_slice (var_infos);
    log ("Found global slice " + gslice);

    // If there is not a matching global slice, there is nothing to do
    if (gslice == null)
      return;

    for (Iterator i = invs.iterator(); i.hasNext(); ) {
      Invariant inv = (Invariant) i.next();
      if (gslice.contains_inv_exact (inv) && inv.isFlowable()) {
        inv.log ("Removing because of match in global slice");
        i.remove();
      }
    }

  }

  /**
   * Creates invariants at this ppt by merging invariants from each of its
   * children.  An invariant must exist at each of the children in order
   * for it to be created here (at the parent).  Additionally, some invariants
   * have state information that must be merged.  This is done by the invariant
   * itself.
   *
   * The basic steps are:
   *
   *    1)  Find all of the child invariants.  These are the invariants in
   *        the matching slice of each child.
   *
   *    2)  For each invariant class, build a list of all of the invariants
   *        of that class.  Note that some invariant classes
   *        (eg, functionBinary) contain distinct invariants, each of which
   *        must be merged separately.  See Invariant.Match for more
   *        information concerning what makes an invariant the 'same'
   *
   *    3)  Each invariant that is found at each of the children is then
   *        merged to possibly create a parent invariant.
   */

  public void merge_invariants() {

    if (debugMerge.isLoggable (Level.FINE)) {
      debugMerge.fine ("merging invs for " + name());
    }

    // List of all invariants found over all of the children
    List all_invs = new ArrayList();

    // Keep count of the number of valid children processed.  An invariant
    // must be found at each valid child in order to exist at the parent.
    // A valid child is one that has received samples and has a corresponding
    // variable for each parent variable
    int valid_child_count = 0;

    // List of value caches from each child slice.
    List vtlist = new ArrayList();

    // Loop through all of the children of our top level parent
    child_loop:
    for (int i = 0; i < parent.children.size(); i++) {
      PptRelation rel = (PptRelation) parent.children.get(i);
      PptTopLevel ppt = rel.child;

      // Skip any children that have not seen any samples
      if (ppt.num_samples() == 0) {
        if (debugMerge.isLoggable (Level.FINE))
          debugMerge.fine ("-- slice ignored (no samples) " + ppt.name());
        continue;
      }

      // Child variable info
      VarInfo cvis[] = new VarInfo[var_infos.length];
      VarInfo cvis_sorted[] = new VarInfo[var_infos.length];

      // Build the corresponding array of VarInfos for the child.  If any
      // of the vars don't exist in this child, skip the child (since we
      // won't have data for each variable).
      for (int j = 0; j < var_infos.length; j++) {
        VarInfo pv = var_infos[j];
        VarInfo cv = rel.childVar (pv);
        if (cv == null)
          continue child_loop;
        cvis[j] = cv.canonicalRep();
        cvis_sorted[j] = cv.canonicalRep();
      }

      // If any of the child variables have always been missing, this
      // particular slice in the child received no samples.  If dynamic
      // constants are enabled, the slice will have never been created.
      // These slices can be skipped unless they contain a missing out of
      // bound var.  Out of bounds variables destroy all invariants in
      // the slice (since the variable is deemed to be nonsensical)
      if (slice_missing (ppt, cvis)) {
        if (debugMerge.isLoggable (Level.FINE))
          debugMerge.fine ("-- slice ignored (missing) " + ppt.name()
                           + " vars " + Debug.toString (cvis_sorted));
        continue;
      }

      // The child variables must be sorted by their index (in the child)
      Arrays.sort (cvis_sorted, VarInfo.IndexComparator.getInstance());

      // Keep track of the number of valid children
      valid_child_count++;

      // Find the corresponding slice.  If the slice does not exist or
      // has no invariants, there can be no invariants to merge (since
      // invariants must exist at each child to exist at the parent)
      PPTSLICE1 cslice = (PPTSLICE1) ppt.findSlice (cvis_sorted);
      if ((cslice == null) || (cslice.invs.size() == 0)) {
        if (Debug.logOn())
          this.log ("slice not found " + ppt.name() + " "
                   + VarInfo.toString (cvis_sorted)
                   + " num_samples= " + ppt.num_samples()
                   + " ppt.constants = " + ppt.constants);
        if (debugMerge.isLoggable (Level.FINE))
          debugMerge.fine ("-- slice not found " + ppt.name()
                           + " vars " + Debug.toString (cvis_sorted));
        return;
      }

      // // Update sample count info
      // mod_samples += cslice.mod_samples;
      // unmod_samples += cslice.unmod_samples;

      // Build the permutation array from child to parent slice
      int[] permute = PptTopLevel.build_permute (cvis_sorted, cvis);

      // Debug print child vars and permute to parent
      if (debugMerge.isLoggable (Level.FINE)) {
        debugMerge.fine ("-- Processing child " + ppt.name() + " ("
                         + rel.getRelationType() + ")");
        debugMerge.fine ("-- -- child vars = "
                         + VarInfo.toString (cvis_sorted));
        debugMerge.fine ("-- -- parent vars = "
                         + VarInfo.toString (var_infos));
        debugMerge.fine ("-- -- permute = " + ArraysMDE.toString (permute));
      }

      // Add each invariant (permuted to match the parent varinfos)
      // to our list of invariants.  Skip any invariants with ni-suppressions
      // Invariants with ni-suppressions are handled in ni_merge_invs()
      for (int j = 0; j < cslice.invs.size(); j++) {
        Invariant orig_inv = (Invariant) cslice.invs.get (j);
        if (orig_inv.get_ni_suppressions() != null)
          continue;
        Invariant inv = orig_inv.clone_and_permute (permute);
        all_invs.add (inv);
        if (inv.logOn()) {
          VarInfo[] child_vars = new VarInfo[var_infos.length];
          for (int k = 0; k < var_infos.length; k++) {
            VarInfo pv = var_infos[k];
            VarInfo cv = rel.childVar (pv);
            child_vars[k] = cv.canonicalRep();
          }
          orig_inv.log ("org inv");
          inv.log ("Created " + inv + " from " + orig_inv + " using permute "
                   + ArraysMDE.toString(permute) + " cvis_sorted = "
                   + VarInfo.toString (cvis_sorted) + " cvis = "
                   + VarInfo.toString (child_vars)
                   + " for ppt " + parent.name());
        }
      }
    }

    log ("Found " + all_invs.size() + " invariants to merge");
    if (debugMerge.isLoggable (Level.FINE) && (valid_child_count == 0))
      debugMerge.fine ("-- No valid children found");

    // For each invariant found, find the list of invariants of the
    // same type (type corresponds basically but not exactly to the
    // invariants class) and add the invariant to that list.
    // Invariant.Match.equals() defines if two invariants are of the
    // same 'type' for the purpose of merging invariants.
    Map inv_map = new LinkedHashMap();
    for (int i = 0; i < all_invs.size(); i++) {
      Invariant inv = (Invariant) all_invs.get (i);
      Invariant.Match imatch = new Invariant.Match (inv);
      ArrayList invs = (ArrayList) inv_map.get (imatch);
      if (inv.logOn()) {
        inv.log ("Adding " + inv.format() + " to " + name()
                 + " invs list " + invs);
      }
      if (invs == null) {
        invs = new ArrayList();
        inv_map.put (imatch, invs);
      }
      invs.add (inv);
    }

    Assert.assertTrue(vtlist.size() == 0);

    // Attempt to create a parent invariant for each invariant that
    // appeared at each valid child.  Note that some invariants will
    // not exist at the parent even if they exist at each child (eg,
    // LinearBinary)
    for (Iterator j = inv_map.values().iterator(); j.hasNext(); ) {
      ArrayList child_invs = (ArrayList) j.next();
      if (child_invs.size() > valid_child_count) {
        // this shouldn't happen
        System.out.println ("Found " + child_invs.size() + " invariants at "
                         + name() + " (" + valid_child_count + " children)");
        for (int k = 0; k < child_invs.size(); k++ )
          System.out.println ("-- Invariant = "
                            + ((Invariant) child_invs.get(k)).format()
                            + " @" + ((Invariant) child_invs.get(k)).ppt);
        Assert.assertTrue (child_invs.size() <= valid_child_count);
      }
      if (child_invs.size() == valid_child_count) {
        Invariant first = (Invariant) child_invs.get(0);
        if (Debug.logOn())
          first.log ("Attempting merge of " + child_invs.size()
                     + " invariants into ppt " + name());
        Invariant parent_inv = first.merge (child_invs, this);
        if (parent_inv != null) {
          invs.add (parent_inv);
          if (Debug.logOn())
            parent_inv.log ("Merge successful");
        }
      } else {
        if (Debug.logOn()) {
          Invariant inv = (Invariant) child_invs.get(0);
          inv.log ("Not merging invariant up, Found " + child_invs.size()
                    + "child invariants in " + valid_child_count + " children");
        }
      }
    }
  }

  /**
   * Creates invariants at this ppt by merging invariants from each of
   * its children.  This version handles only those invariant with
   * ni-suppressions.  An invariant must be valid at each of the
   * children in order for it to be created here (at the parent).  An
   * invariant is valid if it exists at the child or if it is
   * ni-suppressed at the child.
   *
   * This is accomplished by first creating all of possible invariants
   * for this slice with ni-suppressions.  Each possible invariant is then
   * examined in each child.  If the invariant is valid in the child, it
   * remains, otherwise it is removed.
   *
   * At the end only the valid invariants at the parent remain.
   *
   * Its possible that this could be extended to handle all invariants
   * and not just those with ni-suppressions.  The problem with this is
   * invariants with state that have to be merged.  The current approach
   * creates a list of these invariants.  A possible different approach
   * would be to apply the state from each child invariant to the possible
   * parent invariant in turn.  This would remove the need to create the
   * list
   */

  public void ni_merge_invariants() {

    if (debugMerge.isLoggable (Level.FINE)) {
      debugMerge.fine ("merging invs for " + name());
    }

    // Create all of the possible invariants that can be NIS suppressed
    instantiate_invariants();
    for (Iterator i = invs.iterator(); i.hasNext(); ) {
      Invariant inv = (Invariant) i.next();
      if (inv.get_ni_suppressions() == null)
        i.remove();
    }

    // Loop through all of the children of our top level parent
    child_loop:
    for (int i = 0; i < parent.children.size(); i++) {
      PptRelation rel = (PptRelation) parent.children.get(i);
      PptTopLevel ppt = rel.child;

      // Skip any children that have not seen any samples
      if (ppt.num_samples() == 0) {
        if (debugMerge.isLoggable (Level.FINE))
          debugMerge.fine ("-- slice ignored (no samples) " + ppt.name());
        continue;
      }

      // Child variable info
      VarInfo cvis[] = new VarInfo[var_infos.length];
      VarInfo cvis_sorted[] = new VarInfo[var_infos.length];

      // Build the corresponding array of VarInfos for the child.  If any
      // of the vars don't exist in this child, skip the child (since we
      // won't have data for each variable).
      for (int j = 0; j < var_infos.length; j++) {
        VarInfo pv = var_infos[j];
        VarInfo cv = rel.childVar (pv);
        if (cv == null)
          continue child_loop;
        cvis[j] = cv.canonicalRep();
        cvis_sorted[j] = cv.canonicalRep();
      }

      // If any of the child variables have always been missing, this
      // particular slice in the child received no samples.  If dynamic
      // constants are enabled, the slice will have never been created.
      // These slices can be skipped unless they contain a missing out of
      // bound var.  Out of bounds variables destroy all invariants in
      // the slice (since the variable is deemed to be nonsensical)
      if (slice_missing (ppt, cvis)) {
        if (debugMerge.isLoggable (Level.FINE))
          debugMerge.fine ("-- slice ignored (missing) " + ppt.name()
                           + " vars " + Debug.toString (cvis_sorted));
        continue;
      }

      // The child variables must be sorted by their index (in the child)
      Arrays.sort (cvis_sorted, VarInfo.IndexComparator.getInstance());

      // Find the corresponding slice.
      PPTSLICE1 cslice = (PPTSLICE1) ppt.findSlice (cvis_sorted);
      if ((cslice == null) || (cslice.invs.size() == 0)) {
        if (Debug.logOn())
          this.log ("slice not found " + ppt.name() + " "
                   + VarInfo.toString (cvis_sorted)
                   + " num_samples= " + ppt.num_samples()
                   + " ppt.constants = " + ppt.constants);
        if (debugMerge.isLoggable (Level.FINE))
          debugMerge.fine ("-- slice not found " + ppt.name()
                           + " vars " + Debug.toString (cvis_sorted));
      }

      // Build the permutation array from parent to child slice
      int[] permute = PptTopLevel.build_permute (cvis, cvis_sorted);

      // Debug print child vars and permute to parent
      if (debugMerge.isLoggable (Level.FINE)) {
        debugMerge.fine ("-- Processing child " + ppt.name() + " ("
                         + rel.getRelationType() + ")");
        debugMerge.fine ("-- -- child vars = "
                         + VarInfo.toString (cvis_sorted));
        debugMerge.fine ("-- -- parent vars = "
                         + VarInfo.toString (var_infos));
        debugMerge.fine ("-- -- permute = " + ArraysMDE.toString (permute));
      }

      // Process each parent invariant and remove it if it isn't valid in
      // the child.  To be valid, an invariant must either exist in the
      // child slice or be ni-suppressed in the child
      for (Iterator j = invs.iterator(); j.hasNext(); ) {
        Invariant parent_inv = (Invariant) j.next();
        Invariant child_inv = parent_inv.clone_and_permute (permute);
        if ((cslice != null) && (cslice.find_inv_exact (child_inv) != null))
          continue;
        NISuppressionSet ss = child_inv.get_ni_suppressions();
        if (!ss.suppressed (ppt, cvis_sorted))
          j.remove();
      }

      // Stop processing if there aren't any invariants left
      if (invs.size() == 0)
        return;
    }
  }


  /**
   * Returns whether or not the slice is missing due to having one or more
   * of its variables always missing.  This returns true only for missing
   * flow and/or missing nonsensical.  Out of Bounds is treated differently
   * since it destroys all of its invariants
   */
  private boolean slice_missing (PptTopLevel ppt, VarInfo[] vis) {

    if (ppt.constants != null) {
      #if defined(ARITY1)
        if (ppt.constants.is_missing(vis[0])
            && !vis[0].missingOutOfBounds())
          return(true);
      #elif defined(ARITY2)
        if ((ppt.constants.is_missing(vis[0])
             || ppt.constants.is_missing(vis[1]))
            && !vis[0].missingOutOfBounds()
            && !vis[1].missingOutOfBounds())
          return(true);
      #elif defined(ARITY3)
        if ((ppt.constants.is_missing(vis[0])
             || ppt.constants.is_missing(vis[1])
             || ppt.constants.is_missing(vis[2]))
            && !vis[0].missingOutOfBounds()
            && !vis[1].missingOutOfBounds()
            && !vis[2].missingOutOfBounds())
          return(true);
      #endif
    }
    return (false);
  }


}
