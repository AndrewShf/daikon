#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(ARITY1) || defined(ARITY2) || defined(ARITY3))
  #error "One of ARITY1, ARITY2, or ARITY3 must be defined"
#endif

#if defined(ARITY1)
  #define PPTSLICE1 PptSlice1
  #define PPTSLICE1STRING "PptSlice1"
  #define NUM_TM 2
  #define ARITY 1
#elif defined(ARITY2)
  #define PPTSLICE1 PptSlice2
  #define PPTSLICE1STRING "PptSlice2"
  #define NUM_TM 4
  #define ARITY 2
#elif defined(ARITY3)
  #define PPTSLICE1 PptSlice3
  #define PPTSLICE1STRING "PptSlice3"
  #define NUM_TM 8
  #define ARITY 3
#else
  #error "One of ARITY1, ARITY2, or ARITY3 must be defined"
#endif

#if 0
  // Macro ORDER_VALUES forces values of interest to their original order.
  // This has a small execution cost -- see Vector values_order.
#endif
#define ORDER_VALUES

// ***** This file is automatically generated from PptSlice.java.jpp

package daikon;

import daikon.inv.*;

#if defined(ARITY1)
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.string.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.stringsequence.*;
#elif defined(ARITY2)
import daikon.inv.binary.twoScalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.inv.binary.twoString.*;
import daikon.inv.binary.sequenceScalar.*;
#elif defined(ARITY3)
import daikon.inv.ternary.threeScalar.*;
#endif

import java.util.logging.Logger;
import java.util.logging.Level;

import java.util.*;

import utilMDE.*;

// This file looks a *lot* like part of PptTopLevel.
// (That is fine; its purpose is similar and mostly subsumed by VarValues.)

public final class PPTSLICE1
  extends PptSlice
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  /**
   * Debug tracer
   **/
  public static final Logger debugSpecific = Logger.getLogger("daikon." + PPTSLICE1STRING);

  // This is in PptSlice; do not repeat it here!
  // Invariants invs;

#if defined(ARITY1)
  public VarInfo var_info;

  // values_cache maps (interned) values to 2-element arrays of
  // [num_unmodified, num_modified].
#elif defined(ARITY2)
  // values_cache maps (interned) values to 4-element arrays of
  // [num_unmod_unmod, num_unmod_mod, num_mod_unmod, num_mod_mod].
#elif defined(ARITY3)
  // values_cache maps (interned) values to 8-element arrays of
  // [uuu, uum, umu, umm, muu, mum, mmu, mmm].
  // That is, the first element is (unmod,unmod,unmod);
  // the second element is (unmod,unmod,mod); etc.
#endif
  int[] tm_total = new int[NUM_TM];  // "tm" stands for "tuplemod"


  /**
   * Create a new PPTSLICE1.  Warning: do not rearrange the contents
   * of var_infos once this has been created, as flow order is already
   * set up after construction.
   **/
  public PPTSLICE1(PptTopLevel parent, VarInfo[] var_infos) {
    super(parent, var_infos);
    Assert.assertTrue(var_infos.length == ARITY);
#if defined(ARITY1)
    var_info = var_infos[0];
#endif
    Dataflow.init_pptslice_po(this);

    /* [INCR]
    // values_cache = new HashMap();
    // values_order  = new Vector();
    */ // [INCR]
    if (this.debugged || debug.isLoggable(Level.FINE) || debugSpecific.isLoggable(Level.FINE))
      debug.info("Created " + PPTSLICE1STRING + " " + this.name);

    // Make the caller do this, because
    //  1. there are few callers
    //  2. do not want to instantiate all invariants all at once
    // instantiate_invariants();
  }

#if defined(ARITY1)
  PptSlice1(PptTopLevel parent, VarInfo var_info) {
    this(parent, new VarInfo[] { var_info });
  }
#elif defined(ARITY2)
  PptSlice2(PptTopLevel parent, VarInfo var_info1, VarInfo var_info2) {
    this(parent, new VarInfo[] { var_info1, var_info2 });
  }
#elif defined(ARITY3)
  PptSlice3(PptTopLevel parent, VarInfo var_info1, VarInfo var_info2, VarInfo var_info3) {
    this(parent, new VarInfo[] { var_info1, var_info2, var_info3 });
  }
#endif

  void instantiate_invariants() {
    Assert.assertTrue(!no_invariants);

    // This test should be done by caller (PptTopLevel):
    // if (isControlled()) return;

    // Instantiate invariants
    if (this.debugged || debug.isLoggable(Level.FINE) || debugSpecific.isLoggable(Level.FINE))
      debug.info("instantiate_invariants for " + name + ": originally " + invs.size() + " invariants in " + invs);

    Vector new_invs = null;
#if defined(ARITY1)
    ProglangType rep_type = var_info.rep_type;
    boolean is_scalar = rep_type.isScalar();
    if (is_scalar) {
      new_invs = SingleScalarFactory.instantiate(this);
    } else if (rep_type == ProglangType.INT_ARRAY) {
      new_invs = SingleScalarSequenceFactory.instantiate(this);
    } else if (Daikon.dkconfig_enable_floats
               && rep_type == ProglangType.DOUBLE) {
      new_invs = SingleFloatFactory.instantiate(this);
    } else if (Daikon.dkconfig_enable_floats
               && rep_type == ProglangType.DOUBLE_ARRAY) {
      new_invs = SingleFloatSequenceFactory.instantiate(this);
    } else if (rep_type == ProglangType.STRING) {
      new_invs = SingleStringFactory.instantiate(this);
    } else if (rep_type == ProglangType.STRING_ARRAY) {
      new_invs = SingleStringSequenceFactory.instantiate(this);
    } else {
      // Do nothing; do not even complain
    }
#elif defined(ARITY2)
    ProglangType rep1 = var_infos[0].rep_type;
    ProglangType rep2 = var_infos[1].rep_type;
    boolean rep1_is_scalar = rep1.isScalar();
    boolean rep2_is_scalar = rep2.isScalar();
    boolean rep1_is_float  = rep1.isFloat();
    boolean rep2_is_float  = rep2.isFloat();
    if (rep1_is_scalar && rep2_is_scalar) {
      new_invs = TwoScalarFactory.instantiate(this);
    } else if ((rep1 == ProglangType.STRING)
        && (rep2 == ProglangType.STRING)) {
      new_invs = TwoStringFactory.instantiate(this);
    } else if ((rep1 == ProglangType.INT)
               && (rep2 == ProglangType.INT_ARRAY)) {
      new_invs = SequenceScalarFactory.instantiate(this);
    } else if ((rep1 == ProglangType.INT_ARRAY)
               && (rep2 == ProglangType.INT)) {
      new_invs = SequenceScalarFactory.instantiate(this);
    } else if ((rep1 == ProglangType.INT_ARRAY)
               && (rep2 == ProglangType.INT_ARRAY)) {
      new_invs = TwoSequenceFactory.instantiate(this);
    } else if (rep1_is_float && rep2_is_float) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = TwoFloatFactory.instantiate(this);
      }
    } else if ((rep1 == ProglangType.DOUBLE)
               && (rep2 == ProglangType.DOUBLE_ARRAY)) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = SequenceFloatFactory.instantiate(this);
      }
    } else if ((rep1 == ProglangType.DOUBLE_ARRAY)
               && (rep2 == ProglangType.DOUBLE)) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = SequenceFloatFactory.instantiate(this);
      }
    } else if ((rep1 == ProglangType.DOUBLE_ARRAY)
               && (rep2 == ProglangType.DOUBLE_ARRAY)) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = TwoSequenceFactoryFloat.instantiate(this);
      }
    } else {
      // Do nothing; do not even complain
    }
#elif defined(ARITY3)
    ProglangType rep1 = var_infos[0].file_rep_type;
    ProglangType rep2 = var_infos[1].file_rep_type;
    ProglangType rep3 = var_infos[2].file_rep_type;
    if ((rep1 == ProglangType.INT)
        && (rep2 == ProglangType.INT)
        && (rep3 == ProglangType.INT)) {
      new_invs = ThreeScalarFactory.instantiate(this);
    } else if ((rep1 == ProglangType.DOUBLE)
               && (rep2 == ProglangType.DOUBLE)
               && (rep3 == ProglangType.DOUBLE)) {
      if (Daikon.dkconfig_enable_floats) {
        new_invs = ThreeFloatFactory.instantiate(this);
      }
    } else {
      // Do nothing; do not even complain
    }
#endif

    if (new_invs != null) {
      for (int i=0; i<new_invs.size(); i++) {
        Invariant inv = (Invariant) new_invs.get(i);
        if (inv == null)
          continue;
        addInvariant(inv);
      }
    }

    if (this.debugged || debug.isLoggable(Level.FINE) || debugSpecific.isLoggable(Level.FINE)) {
      debug.info("after instantiate_invariants " + PPTSLICE1STRING + " " + name + " = " + this + " has " + invs.size() + " invariants in " + invs);
    }
    if ((this.debugged  || debugSpecific.isLoggable(Level.FINE)) && (invs.size() > 0)) {
      debug.info("the invariants are:");
      for (int i=0; i<invs.size(); i++) {
        Invariant inv = (Invariant) invs.get(i);
        debug.info("  " + inv.format());
        debug.info("    " + inv.repr());
      }
    }

  }

  /**
   * Set the number of samples for this slice to be at least count.
   **/
  public void set_samples (int count) {
    if (tm_total[0] < count) tm_total[0] = count;
  }

  // These accessors are for abstract methods declared in Ppt
  public int num_samples() {
#if defined(ARITY1)
    int result = tm_total[0] + tm_total[1];
#elif defined(ARITY2)
    int result = tm_total[0] + tm_total[1] + tm_total[2] + tm_total[3];
#elif defined(ARITY3)
    int result = tm_total[0] + tm_total[1] + tm_total[2] + tm_total[3]
      + tm_total[4] + tm_total[5] + tm_total[6] + tm_total[7];
#endif
    Assert.assertTrue(result >= 0);
    return result;
  }

  public int num_mod_non_missing_samples() {
#if defined(ARITY1)
    int result = tm_total[1];
#elif defined(ARITY2)
    int result = tm_total[1] + tm_total[2] + tm_total[3];
#elif defined(ARITY3)
    int result = tm_total[1] + tm_total[2] + tm_total[3]
       + tm_total[4] + tm_total[5] + tm_total[6] + tm_total[7];
#endif
    Assert.assertTrue(result >= 0);
    return result;
  }

#if defined(ARITY1)
  public String tuplemod_samples_summary() {
    Assert.assertTrue(! no_invariants);
    return "U=" + tm_total[0]
      + ", M=" + tm_total[1];
  }
#elif defined(ARITY2)
  public String tuplemod_samples_summary() {
    Assert.assertTrue(! no_invariants);
    return "UU=" + tm_total[0]
      + ", UM=" + tm_total[1]
      + ", MU=" + tm_total[2]
      + ", MM=" + tm_total[3];
  }
#elif defined(ARITY3)
  public String tuplemod_samples_summary() {
    Assert.assertTrue(! no_invariants);
    return "UUU=" + tm_total[0]
      + ", UUM=" + tm_total[1]
      + ", UMU=" + tm_total[2]
      + ", UMM=" + tm_total[3]
      + ", MUU=" + tm_total[4]
      + ", MUM=" + tm_total[5]
      + ", MMU=" + tm_total[6]
      + ", MMM=" + tm_total[7];
  }
#endif

  // public int num_missing() { return values_cache.num_missing; }

  // Accessing data
  int num_vars() {
    return var_infos.length;
  }
  Iterator var_info_iterator() {
    return Arrays.asList(var_infos).iterator();
  }


  boolean compatible(Ppt other) {
    // This insists that the var_infos lists are identical.  The Ppt
    // copy constructor does reuse the var_infos field.
    return (var_infos == other.var_infos);
  }

  ///////////////////////////////////////////////////////////////////////////
  /// Manipulating values
  ///

  /**
   * This procedure accepts a sample (a ValueTuple), extracts the values
   * from it, casts them to the proper types, and passes them along to the
   * invariants proper.  (The invariants accept typed values rather than a
   * ValueTuple that encapsulates objects of any type whatever.)
   * @param invsFlowed after this method, holds the Invariants that
   * flowed.
   **/
  public List add(ValueTuple full_vt, int count) {
    //     if (debugFlow.isLoggable(Level.FINE)) {
    //       debugFlow.fine ("<< Doing add for " + this.toString());
    //       StringBuffer sb = new StringBuffer();
    //       for (int i = 0; i < var_infos.length; i++) {
    //         VarInfo vi = var_infos[i];
    //         Object val = vi.getValue(full_vt);
    //         sb.append (" ");
    //         sb.append (ValueTuple.valToString (val));
    //       }
    //       debugFlow.fine ("    with values:" + sb);
    //     }

    Assert.assertTrue(! no_invariants);
    Assert.assertTrue(invs.size() > 0);
    // Assert.assertTrue(! already_seen_all); // [INCR]
    for (int i=0; i<invs.size(); i++) {
      Assert.assertTrue(invs.get(i) != null);
    }

    // if (Global.debugInfer.isLoggable(Level.FINE)) {
    //   Global.debugInfer.fine (PPTSLICE1STRING + ".add(" + full_vt + ", " + count + ")" + " for " + name);
    // }

    // Do not bother putting values into a slice if missing.

#if defined(ARITY1)
    VarInfo vi1 = var_info;
#elif defined(ARITY2)
    VarInfo vi1 = var_infos[0];
    VarInfo vi2 = var_infos[1];
#elif defined(ARITY3)
    VarInfo vi1 = var_infos[0];
    VarInfo vi2 = var_infos[1];
    VarInfo vi3 = var_infos[2];
#endif

    // If any var has encountered out of array bounds values,
    // stop all invariants in this slice.  The presumption here is that
    // an index out of bounds implies that the derived variable (eg a[i])
    // doesn't really make any sense (essentially that i is not a valid
    // index for a).  Invariants on the derived variable are thus not
    // relevant
    for (int i = 0; i < var_infos.length; i++) {
      if (var_infos[i].missingOutOfBounds()) {
        for (int j = 0; j < invs.size(); j++) {
          Invariant inv = (Invariant) invs.get(j);
          inv.destroyAndFlow();
          if (inv.logOn())
            inv.log ("destroyed because " + var_infos[i].name.name()
                     + "array index out of bounds");
        }
        return flow_and_remove_falsified();
      }
    }

    int mod1 = full_vt.getModified(vi1);
    if (mod1 == ValueTuple.MISSING_FLOW || mod1 == ValueTuple.MISSING_NONSENSICAL) {
      // System.out.println("Bailing out of add(" + full_vt + ") for " + name);
      return emptyList;
    }
    if (mod1 == ValueTuple.STATIC_CONSTANT) {
      Assert.assertTrue(vi1.is_static_constant);
      mod1 = ((num_mod_non_missing_samples() == 0)
              ? ValueTuple.MODIFIED : ValueTuple.UNMODIFIED);
    }
#if defined(ARITY2) || defined(ARITY3)
    int mod2 = full_vt.getModified(vi2);
    if (mod2 == ValueTuple.MISSING_FLOW || mod2 == ValueTuple.MISSING_NONSENSICAL) {
      // System.out.println("Bailing out of add(" + full_vt + ") for " + name);
      return emptyList;
    }
    if (mod2 == ValueTuple.STATIC_CONSTANT) {
      Assert.assertTrue(vi2.is_static_constant);
      mod2 = ((num_mod_non_missing_samples() == 0)
              ? ValueTuple.MODIFIED : ValueTuple.UNMODIFIED);
    }
#endif
#if defined(ARITY3)
    int mod3 = full_vt.getModified(vi3);
    if (mod3 == ValueTuple.MISSING_FLOW || mod3 == ValueTuple.MISSING_NONSENSICAL) {
      // System.out.println("Bailing out of add(" + full_vt + ") for " + name);
      return emptyList;
    }
    if (mod3 == ValueTuple.STATIC_CONSTANT) {
      Assert.assertTrue(vi3.is_static_constant);
      mod3 = ((num_mod_non_missing_samples() == 0)
              ? ValueTuple.MODIFIED : ValueTuple.UNMODIFIED);
    }
#endif
    Object val1 = full_vt.getValue(vi1);
    Assert.assertTrue (Intern.isInterned (val1));
#if defined(ARITY2) || defined(ARITY3)
    Object val2 = full_vt.getValue(vi2);
    Assert.assertTrue (Intern.isInterned (val2));
#endif
#if defined(ARITY3)
    Object val3 = full_vt.getValue(vi3);
    Assert.assertTrue (Intern.isInterned (val3));
#endif

    // if (! already_seen_all) // [INCR]
    {
      /* [INCR] ...
#if defined(ARITY1)
      Object vals = val1;
#elif defined(ARITY2)
      Object[] vals = Intern.intern(new Object[] { val1, val2 });
#elif defined(ARITY3)
      Object[] vals = Intern.intern(new Object[] { val1, val2, val3 });
#endif
      int[] tm_arr = (int[]) values_cache.get(vals);
      if (tm_arr == null) {
        tm_arr = new int[NUM_TM];
        values_cache.put(vals, tm_arr);
        values_order.add (vals);
      }
      */ // ... [INCR]
#if defined(ARITY1)
      int mod_index = mod1;
#elif defined(ARITY2)
      int mod_index = mod1 * 2 + mod2;
#elif defined(ARITY3)
      int mod_index = mod1 * 4 + mod2 * 2 + mod3;
#endif
      // tm_arr[mod_index] += count; // [INCR]
      tm_total[mod_index] += count;
    }

    // System.out.println(PPTSLICE1STRING + " " + name + ": add " + full_vt + " = " + vt);
    // System.out.println(PPTSLICE1STRING + " " + name + " has " + invs.size() + " invariants.");

    // defer_invariant_removal(); [INCR]

    // Supply the new values to all the invariant objects.
    int num_invs = invs.size();

    Assert.assertTrue((mod1 == vi1.getModified(full_vt))
                  || ((vi1.getModified(full_vt) == ValueTuple.STATIC_CONSTANT)
                      && ((mod1 == ValueTuple.UNMODIFIED)
                          || (mod1 == ValueTuple.MODIFIED))));

#if defined(ARITY1)
    Assert.assertTrue(mod1 != ValueTuple.MISSING_FLOW && mod1 != ValueTuple.MISSING_NONSENSICAL);
    ProglangType rep = vi1.rep_type;
    boolean rep_is_scalar = rep.isScalar();
    if (rep_is_scalar) {
      // long value = vi1.getIntValue(full_vt);
      long value = ((Long) val1).longValue();
      for (int i=0; i<num_invs; i++) {
        SingleScalar inv = (SingleScalar)invs.get(i);
        if (inv.falsified) continue;
        // Should the suppressed invariants be put in their own list?
        if (inv.getSuppressor() != null) continue;
        inv.add(value, mod1, count);
      }
    } else if (rep == ProglangType.DOUBLE) {
      // double value = vi1.getDoubleValue(full_vt);
      double value = ((Double) val1).doubleValue();
      for (int i=0; i<num_invs; i++) {
        SingleFloat inv = (SingleFloat)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value, mod1, count);
      }
    } else if (rep == ProglangType.STRING) {
      // String value = vi1.getStringValue(full_vt);
      String value = (String) val1;
      for (int i=0; i<num_invs; i++) {
        // System.out.println("Trying " + invs.get(i));
        SingleString inv = (SingleString) invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value, mod1, count);
      }
    } else if (rep == ProglangType.DOUBLE_ARRAY) {
      // double[] value = vi1.getDoubleArrayValue(full_vt);
      double[] value = (double[]) val1;
      for (int i=0; i<num_invs; i++) {
        SingleFloatSequence inv = (SingleFloatSequence)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value, mod1, count);
      }
    } else if (rep == ProglangType.INT_ARRAY) {
      // long[] value = vi1.getIntArrayValue(full_vt);
      long[] value = (long[]) val1;
      for (int i=0; i<num_invs; i++) {
        SingleScalarSequence inv = (SingleScalarSequence)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value, mod1, count);
      }
    } else if (rep == ProglangType.STRING_ARRAY) {
      String[] value = (String[]) val1;
      for (int i=0; i<num_invs; i++) {
        SingleStringSequence inv = (SingleStringSequence)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value, mod1, count);
      }
    } else {
      throw new Error("unrecognized representation " + rep.format());
    }
#elif defined(ARITY2)
    Assert.assertTrue((mod1 != ValueTuple.MISSING_FLOW && mod1 != ValueTuple.MISSING_NONSENSICAL)
                  && (mod2 != ValueTuple.MISSING_FLOW && mod2 != ValueTuple.MISSING_NONSENSICAL));
    int mod_index = mod1 * 2 + mod2;
    boolean string1 = vi1.rep_type == ProglangType.STRING;
    boolean string2 = vi2.rep_type == ProglangType.STRING;
    boolean array1 = vi1.rep_type.isArray();
    boolean array2 = vi2.rep_type.isArray();
    boolean stringArray1 = vi1.rep_type == ProglangType.STRING_ARRAY;
    boolean stringArray2 = vi2.rep_type == ProglangType.STRING_ARRAY;
    if (string1 && string2) {
      String value1 = (String) val1;
      String value2 = (String) val2;
      for (int i=0; i<num_invs; i++) {
        TwoString inv = (TwoString)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value1, value2, mod_index, count);
      }
    } else if (string1 || string2) {
      throw new Error("impossible");
    } else if (vi1.rep_type==ProglangType.INT && vi2.rep_type==ProglangType.INT) {
      // long value1 = vi1.getIntValue(full_vt);
      // long value2 = vi2.getIntValue(full_vt);
      long value1 = ((Long) val1).longValue();
      long value2 = ((Long) val2).longValue();
      for (int i=0; i<num_invs; i++) {
        TwoScalar inv = (TwoScalar)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value1, value2, mod_index, count);
      }
    } else if (vi1.rep_type==ProglangType.DOUBLE && vi2.rep_type==ProglangType.DOUBLE) {
      double value1 = ((Double) val1).doubleValue();
      double value2 = ((Double) val2).doubleValue();
      for (int i=0; i<num_invs; i++) {
        TwoFloat inv = (TwoFloat)invs.get(i);
        inv.add(value1, value2, mod_index, count);
      }
    } else if (vi1.rep_type==ProglangType.DOUBLE_ARRAY && vi2.rep_type==ProglangType.DOUBLE_ARRAY) {
      double[] value1 = (double[]) val1;
      double[] value2 = (double[]) val2;
      for (int i=0; i<num_invs; i++) {
        TwoSequenceFloat inv = (TwoSequenceFloat)invs.get(i);
        inv.add(value1, value2, mod_index, count);
      }
    } else if (vi1.rep_type==ProglangType.DOUBLE && vi2.rep_type==ProglangType.DOUBLE_ARRAY) {
      double value1 = ((Double) val1).doubleValue();
      double[] value2 = (double[]) val2;
      for (int i=0; i<num_invs; i++) {
        SequenceFloat inv = (SequenceFloat)invs.get(i);
        inv.add(value2, value1, mod_index, count);
      }
   }   else if (vi1.rep_type==ProglangType.DOUBLE_ARRAY && vi2.rep_type==ProglangType.DOUBLE) {
        double[] value1 = (double[]) val1;
        double value2 = ((Double) val2).doubleValue();
      for (int i=0; i<num_invs; i++) {
        SequenceFloat inv = (SequenceFloat)invs.get(i);
        inv.add(value1, value2, mod_index, count);
      }

    } else if (array1 && (!array2)) {
      long[] seqval = (long[]) val1;
      long sclval = ((Long) val2).longValue();
      for (int i=0; i<num_invs; i++) {
        SequenceScalar inv = (SequenceScalar)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(seqval, sclval, mod_index, count);
      }
    } else if ((!array1) && (array2)) {
      long[] seqval = (long[]) val2;
      long sclval = ((Long) val1).longValue();
      for (int i=0; i<num_invs; i++) {
        SequenceScalar inv = (SequenceScalar)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(seqval, sclval, mod_index, count);
      }
    } else if (array1 && array2 && !stringArray1 && !stringArray2) {
      long[] value1 = (long[]) val1;
      long[] value2 = (long[]) val2;
      for (int i=0; i<num_invs; i++) {
        TwoSequence inv = (TwoSequence)invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value1, value2, mod_index, count);
      }
    } else {
      throw new Error("impossible");
    }
#elif defined(ARITY3)
    Assert.assertTrue((mod1 != ValueTuple.MISSING_FLOW && mod1 != ValueTuple.MISSING_NONSENSICAL)
                  && (mod2 != ValueTuple.MISSING_FLOW && mod2 != ValueTuple.MISSING_NONSENSICAL)
                  && (mod3 != ValueTuple.MISSING_FLOW && mod3 != ValueTuple.MISSING_NONSENSICAL));
    int mod_index = mod1 * 4 + mod2 * 2 + mod3;
    ProglangType rep1 = vi1.file_rep_type;
    ProglangType rep2 = vi2.file_rep_type;
    ProglangType rep3 = vi3.file_rep_type;
    if ((rep1 == ProglangType.INT)
        && (rep2 == ProglangType.INT)
        && (rep3 == ProglangType.INT)) {
      long value1 = ((Long) val1).longValue();
      long value2 = ((Long) val2).longValue();
      long value3 = ((Long) val3).longValue();
      for (int i=0; i<invs.size(); i++) {
        ThreeScalar inv = (ThreeScalar) invs.get(i);
        if (inv.falsified) continue;
        if (inv.getSuppressor() != null) continue;
        inv.add(value1, value2, value3, mod_index, count);
      }
    } else if ((rep1 == ProglangType.DOUBLE)
               && (rep2 == ProglangType.DOUBLE)
               && (rep3 == ProglangType.DOUBLE)) {
      double value1 = ((Double) val1).doubleValue();
      double value2 = ((Double) val2).doubleValue();
      double value3 = ((Double) val3).doubleValue();
      for (int i = 0; i < invs.size(); i++) {
        ThreeFloat inv = (ThreeFloat) invs.get(i);
        inv.add(value1, value2, value3, mod_index, count);
      }
    } else {
      // temporarily do nothing:  efficiency hack, as there are currently
      // no ternary invariants over non-scalars
    }
#endif

    // undefer_invariant_removal(); [INCR]
    return flow_and_remove_falsified();
  }

  public void addInvariant(Invariant invariant) {
    Assert.assertTrue(invariant != null);

    invs.add(invariant);
    Global.instantiated_invariants++;
    if (Global.debugStatistics.isLoggable(Level.FINE) || this.debugged || debugSpecific.isLoggable(Level.FINE))
      debug.info("instantiated_invariant: " + invariant.format()
                 // [INCR] + "; " + "already_seen_all=" + already_seen_all
                 );
    if (invariant.logOn())
      invariant.log ("Instantiated " + invariant.format());

    /* [INCR] ... I think this is now unnecessary; not sure. XXX
    if (already_seen_all) {
      // Make this invariant up to date by supplying it with all the values
      // which have already been seen.
      // (Do not do
      //   Assert.assertTrue(values_cache.entrySet().size() > 0);
      // because all the values might have been missing.  We used to ignore
      // variables that could have some missing values, but no longer.)
#if defined(ARITY1)
      ProglangType rep = var_info.rep_type;

      if (rep == ProglangType.INT) {
        SingleScalar inv = (SingleScalar) invariant;
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          long val = ((Long) entry.getKey()).longValue();
          int[] tm_array = (int[]) entry.getValue();
          inv.add(val, 0, tm_array[0]);
          inv.add(val, 1, tm_array[1]);
          if (inv.falsified)
            break;
        }
      } else if (rep == ProglangType.DOUBLE) {
        SingleFloat inv = (SingleFloat) invariant;
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          double val = ((Double) entry.getKey()).doubleValue();
          int[] tm_array = (int[]) entry.getValue();
          inv.add(val, 0, tm_array[0]);
          inv.add(val, 1, tm_array[1]);
          if (inv.falsified)
            break;
        }
      } else if (rep == ProglangType.STRING) {
        SingleString inv = (SingleString) invariant;
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          String val = (String) entry.getKey();
          int[] tm_array = (int[]) entry.getValue();
          inv.add(val, 0, tm_array[0]);
          inv.add(val, 1, tm_array[1]);
          if (inv.falsified)
            break;
        }
      } else if (rep == ProglangType.INT_ARRAY) {
        SingleScalarSequence inv = (SingleScalarSequence) invariant;
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          long[] val = (long[]) entry.getKey();
          int[] tm_array = (int[]) entry.getValue();
          inv.add(val, 0, tm_array[0]);
          inv.add(val, 1, tm_array[1]);
          if (inv.falsified)
            break;
        }
      } else if (rep == ProglangType.DOUBLE_ARRAY) {
        SingleFloatSequence inv = (SingleFloatSequence) invariant;
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          double[] val = (double[]) entry.getKey();
          int[] tm_array = (int[]) entry.getValue();
          inv.add(val, 0, tm_array[0]);
          inv.add(val, 1, tm_array[1]);
          if (inv.falsified)
            break;
        }
      } else if (rep == ProglangType.STRING_ARRAY) {
        SingleStringSequence inv = (SingleStringSequence) invariant;
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          String[] val = (String[]) entry.getKey();
          int[] tm_array = (int[]) entry.getValue();
          inv.add(val, 0, tm_array[0]);
          inv.add(val, 1, tm_array[1]);
          if (inv.falsified)
            break;
        }
      } else {
        throw new Error("unrecognized representation " + rep.format());
      }
#elif defined(ARITY2)
      VarInfo vi1 = var_infos[0];
      VarInfo vi2 = var_infos[1];
      boolean string1 = vi1.rep_type == ProglangType.STRING;
      boolean string2 = vi2.rep_type == ProglangType.STRING;
      boolean array1 = vi1.rep_type.isArray();
      boolean array2 = vi2.rep_type.isArray();
      boolean doublearray1 = vi1.rep_type == ProglangType.DOUBLE_ARRAY;
      boolean doublearray2 = vi2.rep_type == ProglangType.DOUBLE_ARRAY;

      if (string1 && string2) {
        TwoString inv = (TwoString) invariant;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          String value1 = (String) vals[0];
          String value2 = (String) vals[1];
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(value1, value2, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }
      } else if (string1 || string2) {
        throw new Error("impossible");
      } else if ((!array1) && (!array2)) {
        TwoScalar inv = (TwoScalar) invariant;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          long value1 = ((Long) vals[0]).longValue();
          long value2 = ((Long) vals[1]).longValue();
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(value1, value2, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }
      } else if (doublearray1 && (!array2)) {
        SequenceFloat inv = (SequenceFloat) invariant;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          double[] seqval = (double[]) vals[0];
          double sclval = ((Double) vals[1]).doubleValue();
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(seqval, sclval, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }
      } else if (array1 && (!array2)) {
        SequenceScalar inv = (SequenceScalar) invariant;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          long[] seqval = (long[]) vals[0];
          long sclval = ((Long) vals[1]).longValue();
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(seqval, sclval, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }
       } else if ((!array1) && doublearray2) {
        SequenceFloat inv = (SequenceFloat) invariant;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          double[] seqval = (double[]) vals[1];
          double sclval = ((Double) vals[0]).doubleValue();
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(seqval, sclval, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }

       } else if ((!array1) && array2) {
        SequenceScalar inv = (SequenceScalar) invariant;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          long[] seqval = (long[]) vals[1];
          long sclval = ((Long) vals[0]).longValue();
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(seqval, sclval, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }
      } else if (doublearray1 && doublearray2) {
        TwoSequenceFloat inv = (TwoSequenceFloat) invariant;
#if defined (ORDER_VALUES)
        // Make this invariant up to date by supplying it with all the values.
        Assert.assertTrue (values_order.size() == values_cache.size());
        for (Iterator itor = values_order.iterator() ; itor.hasNext() ; ) {
          Object[] vals = (Object[]) itor.next();
          double[] val1 = (double[]) vals[0];
          double[] val2 = (double[]) vals[1];
          int[] tm_array = (int[]) values_cache.get (vals);
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(val1, val2, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }
#else
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          double[] val1 = (double[]) vals[0];
          double[] val2 = (double[]) vals[1];
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(val1, val2, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }
#endif

      } else if (array1 && array2) {
        TwoSequence inv = (TwoSequence) invariant;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          long[] val1 = (long[]) vals[0];
          long[] val2 = (long[]) vals[1];
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(val1, val2, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
          if (inv.falsified)
            break;
        }
      } else {
        System.out.println ("Skipped invariant " + invariant.name());
      }
#elif defined(ARITY3)
      VarInfo vi1 = var_infos[0];
      VarInfo vi2 = var_infos[1];
      VarInfo vi3 = var_infos[2];
      ProglangType rep1 = vi1.rep_type;
      ProglangType rep2 = vi2.rep_type;
      ProglangType rep3 = vi3.rep_type;
      if ((rep1 == ProglangType.INT)
          && (rep2 == ProglangType.INT)
          && (rep3 == ProglangType.INT)) {
        ThreeScalar inv = (ThreeScalar) invariant;
        // Make this invariant up to date by supplying it with all the values.
        for (Iterator itor = values_cache.entrySet().iterator() ; itor.hasNext() ; ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          long val1 = ((Long) vals[0]).longValue();
          long val2 = ((Long) vals[1]).longValue();
          long val3 = ((Long) vals[2]).longValue();
          int[] tm_array = (int[]) entry.getValue();
          for (int mi=0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(val1, val2, val3, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }
        }
      } else if (rep1 == ProglangType.DOUBLE
                 && rep2 == ProglangType.DOUBLE
                 && rep3 == ProglangType.DOUBLE) {
#if defined (ORDER_VALUES)
        ThreeFloat inv = (ThreeFloat) invariant;
        for (Iterator itor = values_order.iterator(); itor.hasNext(); ) {
          Object[] vals = (Object[]) itor.next();
          double val1 = ((Double) vals[0]).doubleValue();
          double val2 = ((Double) vals[1]).doubleValue();
          double val3 = ((Double) vals[2]).doubleValue();
          int[] tm_array = (int[]) values_cache.get (vals);
          for (int mi = 0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(val1, val2, val3, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }

          if (inv.falsified)
            break;
        }
#else
        ThreeFloat inv = (ThreeFloat) invariant;
        for (Iterator itor = values_cache.entrySet().iterator(); itor.hasNext(); ) {
          Map.Entry entry = (Map.Entry) itor.next();
          Object[] vals = (Object[]) entry.getKey();
          double val1 = ((Double) vals[0]).doubleValue();
          double val2 = ((Double) vals[1]).doubleValue();
          double val3 = ((Double) vals[2]).doubleValue();
          int[] tm_array = (int[]) entry.getValue();
          for (int mi = 0; mi<tm_array.length; mi++) {
            if (tm_array[mi] > 0) {
              inv.add(val1, val2, val3, mi, tm_array[mi]);
              if (inv.falsified)
                break;
            }
          }

          if (inv.falsified)
            break;
        }
#endif
      }
#endif
    }
    */ // ... [INCR]
  }

  /**
   * @see daikon.PptSlice#cloneOnePivot(VarInfo leader, VarInfo newLeader)
   **/
  protected PptSlice cloneAndPivot (VarInfo[] argNewVarInfos) {
    VarInfo[] newVarInfos = new VarInfo[arity];
    // rename the VarInfo references to subsitute newLeader for leader
    int [] permutation = new int[arity];
    for (int i = 0; i < arity; i++) {
      newVarInfos[i] = argNewVarInfos[i];
      permutation[i] = i;
    }

    // Now sort both of the above arrays, by using index comparisons
    // on the former.  Why am I hard-wiring?  Because Java doesn't
    // have a double-array sort routine, and slice sizes won't exceed
    // 3.
    for (int i = 0; i < arity - 1; i++) {
      for (int j = arity - 2; j >= i; j--) {
        VarInfo tempVi;
        int temp;
        if (newVarInfos[j].varinfo_index > newVarInfos[j+1].varinfo_index) {
          tempVi = newVarInfos[j];
          newVarInfos[j] = newVarInfos[j+1];
          newVarInfos[j+1] = tempVi;

          temp = permutation[j];
          permutation[j] = permutation[j+1];
          permutation[j+1] = temp;
        }
      }
    }
    // Assert sorted
    for (int i = 0; i < arity - 1; i++) {
      Assert.assertTrue (newVarInfos[i].varinfo_index <= newVarInfos[i+1].varinfo_index);
    }
    Assert.assertTrue(ArraysMDE.fn_is_permutation(permutation));

    // Why not just clone?  Because then index order wouldn't be
    // preserved
    PPTSLICE1 result = new PPTSLICE1 (this.parent, newVarInfos);


    // Set sample counts
    for (int i = 0; i < tm_total.length; i++) {
      result.tm_total[i] = this.tm_total[i];
    }

    // re-parent the invariants and copy them out
    List newInvs = new LinkedList();
    for (Iterator i = invs.iterator(); i.hasNext(); ) {
      Invariant inv = (Invariant) i.next();
      Assert.assertTrue (inv.ppt == this);
      Invariant newInv = inv.transfer (result, permutation);
      // if (!newInv.isObvious()) {
      newInvs.add (newInv);
      parent.attemptSuppression (newInv, true);
      Assert.assertTrue (newInv != inv);
      Assert.assertTrue (newInv.ppt == result);
      Assert.assertTrue (inv.ppt == this);
      // }
    }

    result.invs.addAll (newInvs);
    if (PptSliceEquality.debug.isLoggable(Level.FINE)) {
      PptSliceEquality.debug.fine ("cloneAndPivot: newInvs " + invs);
    }
    result.repCheck();
    return result;
  }

}
