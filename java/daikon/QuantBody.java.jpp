#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(BOOLEAN) \
      || defined(BYTE) \
      || defined(CHAR) \
      || defined(DOUBLE) \
      || defined(FLOAT) \
      || defined(INT) \
      || defined(LONG) \
      || defined(SHORT) \
      || defined(OBJECT) \
      || defined(STRING))
  #error "One of BOOLEAN, BYTE, CHAR, DOUBLE, FLOAT, INT, INTEGER, LONG, SHORT, OBJECT, STRING  must be defined"
#endif

#if defined(BOOLEAN)
  #define _TYPE boolean
  #define _TYPE_WRAPPER_NAME Boolean
  #define ARRAY_GET_NAME java.lang.reflect.Array.getBoolean
  #define BAD_VALUE false
#elif defined(BYTE)
  #define _TYPE byte
  #define _TYPE_WRAPPER_NAME Byte
  #define ARRAY_GET_NAME java.lang.reflect.Array.getByte
  #define BAD_VALUE Byte.MAX_VALUE
#elif defined(CHAR)
  #define _TYPE char
  #define _TYPE_WRAPPER_NAME Character
  #define ARRAY_GET_NAME java.lang.reflect.Array.getChar
  #define BAD_VALUE Character.MAX_VALUE
#elif defined(DOUBLE)
  #define _TYPE double
  #define _TYPE_WRAPPER_NAME Double
  #define ARRAY_GET_NAME java.lang.reflect.Array.getDouble
  #define BAD_VALUE Double.NaN
#elif defined(FLOAT)
  #define _TYPE float
  #define _TYPE_WRAPPER_NAME Float
  #define ARRAY_GET_NAME java.lang.reflect.Array.getFloat
  #define BAD_VALUE Float.NaN
#elif defined(INT)
  #define _TYPE int
  #define _TYPE_WRAPPER_NAME Integer
  #define ARRAY_GET_NAME java.lang.reflect.Array.getInt
  #define BAD_VALUE Integer.MAX_VALUE
#elif defined(LONG)
  #define _TYPE long
  #define _TYPE_WRAPPER_NAME Long
  #define ARRAY_GET_NAME java.lang.reflect.Array.getLong
  #define BAD_VALUE Long.MAX_VALUE
#elif defined(SHORT)
  #define _TYPE short
  #define _TYPE_WRAPPER_NAME Short
  #define ARRAY_GET_NAME java.lang.reflect.Array.getShort
  #define BAD_VALUE Short.MAX_VALUE
#elif defined(OBJECT)
  #define _TYPE Object
  #define ARRAY_GET_NAME java.lang.reflect.Array.get
  #define BAD_VALUE null
#elif defined(STRING)
  #define _TYPE String
  #define ARRAY_GET_NAME (String)java.lang.reflect.Array.get
  #define BAD_VALUE null
#endif

#define _TYPE_WRAPPER_GETVAL_METHOD _TYPE ## Value
#define COLLECT_TYPE collect ## _TYPE
#define COLLECT_TYPE_FIELD collect ## _TYPE ## _field
#define GET_ELEMENT getElement_ ## _TYPE

#if defined(BYTE)
  #define COMPATIBLE int
  #define CAST_TYPE int
#endif
#if defined(INT)
  #define COMPATIBLE long
  #define CAST_TYPE long
#endif
#if defined(LONG)
  #define COMPATIBLE int
  #define CAST_TYPE long
#endif
#if defined(DOUBLE)
  #define COMPATIBLE float
  #define CAST_TYPE double
#endif
#if defined(FLOAT)
  #define COMPATIBLE double
  #define CAST_TYPE double
#endif

public static _TYPE GET_ELEMENT (Object o, long i) {
  if (o == null) { return BAD_VALUE; }
  java.lang.Class c = o.getClass();
  if (c.isArray()) {
    return ARRAY_GET_NAME (o, (int)i);
  } else if (o instanceof java.util.AbstractCollection) {
    return ARRAY_GET_NAME (((java.util.AbstractCollection)o).toArray(), (int)i);
  } else {
    return BAD_VALUE;
  }
}

public static _TYPE GET_ELEMENT (_TYPE[] arr, long i) {
  if (arr == null) { return BAD_VALUE; }
  return arr[(int)i];
}

#if defined(INT)
   public static utilMDE.FuzzyFloat fuzzy = new utilMDE.FuzzyFloat();

public static int size(Object o) {
  if (o == null) { return BAD_VALUE; }
  java.lang.Class c = o.getClass();
  if (c.isArray()) {
    return java.lang.reflect.Array.getLength(o);
  } else if (java.util.AbstractCollection.class.isInstance(o)) {
    return ((java.util.AbstractCollection)o).size();
  } else {
    return BAD_VALUE;
  }
}
#endif

#if (defined(FLOAT) || defined(DOUBLE))

  private static boolean eq(_TYPE x, _TYPE y) {
    return fuzzy.eq(x,y);
  }

  private static boolean ne(_TYPE x, _TYPE y) {
    return fuzzy.ne(x,y);
  }

  #if !(defined(BOOLEAN) || defined(OBJECT) || defined(STRING))
  private static boolean lt(_TYPE x, _TYPE y) {
    return fuzzy.lt(x,y);
  }

  private static boolean lte(_TYPE x, _TYPE y) {
    return fuzzy.lte(x,y);
  }

  private static boolean gt(_TYPE x, _TYPE y) {
    return fuzzy.gt(x,y);
  }

  private static boolean gte(_TYPE x, _TYPE y) {
    return fuzzy.gte(x,y);
  }
  #endif

#else

  private static boolean eq(_TYPE x, _TYPE y) {
    return (x == y);
  }

  private static boolean ne(_TYPE x, _TYPE y) {
    return x != y;
  }

  #if !(defined(BOOLEAN) || defined(OBJECT) || defined(STRING))
  private static boolean lt(_TYPE x, _TYPE y) {
    return x < y;
  }

  private static boolean lte(_TYPE x, _TYPE y) {
    return x <= y;
  }

  private static boolean gt(_TYPE x, _TYPE y) {
    return x > y;
  }

  private static boolean gte(_TYPE x, _TYPE y) {
    return x >= y;
  }
  #endif

#endif

#if (defined(OBJECT))

  /** Returns an array of Strings, where the strings are the result of
   * invoking x.getClass().toString() for each element x in the
   * array. If an element of the array is null, its slot in the returned
   * array is null.
   */
  /*@ pure */ public static String[] typeArray(_TYPE[] seq) {
    if (seq == null) { return null; }
    String[] retval = new String[seq.length];
    for (int i = 0 ; i < seq.length ; i++) {
      if (seq[i] == null) {
        retval[i] = null;
      } else {
        retval[i] = seq[i].getClass().toString();
      }
    }
    return retval;
  }

#endif

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))

  /** True iff both sequences have the same length, and all seq2[i] divide seq1[i].
   *
   * Meaning (in pseudo-FOL):
   *
   * <pre>
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq2.length-1 } : seq2[i] divides seq1[i]
   * </pre>
   *
   */
  /*@ pure */ public static boolean pairwiseDivides(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (! (eq(seq1[i] % seq2[i], 0))) {
        return false;
      }
    }
    return true;
  }
  /*@ pure */ public static boolean pairwiseDivides(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (! (eq(seq1[i] % seq2[i], 0))) {
        return false;
      }
    }
    return true;
  }

  /** True iff both sequences have the same length, and all seq1[i] ==  seq2[i] * seq2[i].
   *
   * Meaning (in pseudo-FOL):
   *
   * <pre>
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq2.length-1 } : seq1[i] ==  seq2[i] * seq2[i]
   * </pre>
   *
   */
  /*@ pure */ public static boolean pairwiseSquare(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (eq(seq1[i], seq2[i] * seq2[i]))) {
      return false;
    }
  }
  return true;
}
  /*@ pure */ public static boolean pairwiseSquare(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (! (eq(seq1[i], seq2[i] * seq2[i]))) {
        return false;
      }
    }
    return true;
  }

#endif

#if (defined(INT) || defined(LONG))

  /** True iff both sequences have the same length, and all seq1[i] == ~ seq2[i].
   *
   * Meaning (in pseudo-FOL):
   *
   * <pre>
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq2.length-1 } : seq1[i] == ~ seq2[i]
   * </pre>
   *
   */
  /*@ pure */ public static boolean pairwiseBitwiseComplement(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (! (seq1[i] == ~seq2[i])) {
        return false;
      }
    }
    return true;
  }
  /*@ pure */ public static boolean pairwiseBitwiseComplement(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (! (seq1[i] == ~seq2[i])) {
        return false;
      }
    }
    return true;
  }

#if (defined(INT))
  /*@ pure */ public static boolean pairwiseBitwiseComplement(Object[] seq1, Object[] seq2) {
    if (seq1 == null) { return false; }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (seq1[i] == null) {
        return false;
      }
    }
    if (seq2 == null) { return false; }
    for (int i = 0 ; i < seq2.length ; i++) {
      if (seq2[i] == null) {
        return false;
      }
    }
    int[] hashArr1 = new int[seq1.length];
    for (int i = 0 ; i < seq1.length ; i++) {
      hashArr1[i] = seq1[i].hashCode();
    }
    int[] hashArr2 = new int[seq2.length];
    for (int i = 0 ; i < seq2.length ; i++) {
      hashArr2[i] = seq2[i].hashCode();
    }
    return pairwiseBitwiseComplement(hashArr1, hashArr2);
  }
#endif

  /** True iff both sequences have the same length, and all seq1[i] == (seq2[i] | seq1[i]).
   *
   * Meaning (in pseudo-FOL):
   *
   * <pre>
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq2.length-1 } : seq1[i] == (seq2[i] | seq1[i])
   * </pre>
   *
   */
  /*@ pure */ public static boolean pairwiseBitwiseSubset(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (eq(seq1[i], (seq2[i] | seq1[i])))) {
      return false;
    }
  }
  return true;
}
  /*@ pure */ public static boolean pairwiseBitwiseSubset(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (! (eq(seq1[i], (seq2[i] | seq1[i])))) {
        return false;
      }
    }
    return true;
  }

#if (defined(INT))
  /*@ pure */ public static boolean pairwiseBitwiseSubset(Object[] seq1, Object[] seq2) {
    if (seq1 == null) { return false; }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (seq1[i] == null) {
        return false;
      }
    }
    if (seq2 == null) { return false; }
    for (int i = 0 ; i < seq2.length ; i++) {
      if (seq2[i] == null) {
        return false;
      }
    }
    int[] hashArr1 = new int[seq1.length];
    for (int i = 0 ; i < seq1.length ; i++) {
      hashArr1[i] = seq1[i].hashCode();
    }
    int[] hashArr2 = new int[seq2.length];
    for (int i = 0 ; i < seq2.length ; i++) {
      hashArr2[i] = seq2[i].hashCode();
    }
    return pairwiseBitwiseSubset(hashArr1, hashArr2);
  }
#endif

#endif

#if (defined(BYTE) || defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

// These methods aren't used to express any invariants; no need for them.
//   /**
//    * Requires: seq.length > 0
//    * Returns the minimum element in the array.
//    */
//   /*@ pure */ public static _TYPE min(_TYPE[] seq) {
//      //Assert.assertTrue(seq.length > 0);
//     _TYPE retval = seq[0];
//     for (int i = 1 ; i < seq.length ; i++) {
//       if (lt(seq[i], retval)) {
//         retval = seq[i];
//       }
//     }
//     return retval;
//   }

//   /**
//    * Requires: seq.length > 0
//    * Returns the minimum element in the array.
//    */
//   /*@ pure */ public static _TYPE max(_TYPE[] seq) {
//      //Assert.assertTrue(seq.length > 0);
//     _TYPE retval = seq[0];
//     for (int i = 1 ; i < seq.length ; i++) {
//       if (gt(seq[i], retval)) {
//         retval = seq[i];
//       }
//     }
//     return retval;
//   }

#endif

  /**
   * Returns the array { seq1[0], ..., seq1[seq1.length-1], seq2[0], ... , seq2[seq2.length-1] }
   * If either (or both) array is (are) empty, returns only those elements
   * in the other array (or none at all).
   */
  /*@ pure */ public static _TYPE[] concat(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    return utilMDE.ArraysMDE.concat(seq1, seq2);
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static CAST_TYPE[] concat(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    int newLength = seq1.length + seq2.length;
    CAST_TYPE[] retval = new CAST_TYPE[newLength];
    int i = 0;
    for ( ; i < seq1.length ; i++) {
      retval[i] = seq1[i];
    }
    for (int j = 0 ; j < seq2.length ; j++) {
      retval[i+j] = seq2[j];
    }
    return retval;
  }
#endif

/**
 * Returns an array that is equivalent to the set union of seq1 and seq2.
 * This method gives no assurances about the order or repetition of elements:
 * elements may be repeated, and their order may be different from the
 * order of elements in seq1 and seq2.
 */
  /*@ pure */ public static _TYPE[] union(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    return concat(seq1, seq2);
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static CAST_TYPE[] union(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    return concat(seq1, seq2);
  }
#endif

/**
 * Returns an array that is equivalent to the set intersection of seq1 and seq2.
 * This method gives no assurances about the order or repetition of elements:
 * elements may be repeated, and their order may be different from the
 * order of elements in seq1 and seq2.
 */
  /*@ pure */ public static _TYPE[] intersection(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    _TYPE[] intermediate = new _TYPE[seq1.length + seq2.length];
    int length = 0;
    for (int i = 0 ; i < seq1.length ; i++) {
      if ( memberOf(seq1[i], seq2) ) {
        intermediate[length++] = seq1[i];
      }
    }
    for (int i = 0 ; i < seq2.length ; i++) {
      if ( memberOf(seq2[i], seq1) ) {
        intermediate[length++] = seq2[i];
      }
    }
    _TYPE[] retval = new _TYPE[length];
    for (int i = 0 ; i < length; i++) {
      retval[i] = intermediate[i];
    }
    return retval;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static CAST_TYPE[] intersection(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    CAST_TYPE[] intermediate = new CAST_TYPE[seq1.length + seq2.length];
    int length = 0;
    for (int i = 0 ; i < seq1.length ; i++) {
      if ( memberOf(seq1[i], seq2) ) {
        intermediate[length++] = seq1[i];
      }
    }
    for (int i = 0 ; i < seq2.length ; i++) {
      if ( memberOf(seq2[i], seq1) ) {
        intermediate[length++] = seq2[i];
      }
    }
    CAST_TYPE[] retval = new CAST_TYPE[length];
    for (int i = 0 ; i < length; i++) {
      retval[i] = intermediate[i];
    }
    return retval;
  }
#endif

  /**
   * Returns an array that is equivalent to the set difference of seq1 and seq2.
   * This method gives no assurances about the order or repetition of elements:
   * elements may be repeated, and their order may be different from the
   * order of elements in seq1 and seq2.
   */
  /*@ pure */ public static _TYPE[] setDiff(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    _TYPE[] intermediate = new _TYPE[seq1.length];
    int length = 0;
    for (int i = 0 ; i < seq1.length ; i++) {
      if (!memberOf(seq1[i], seq2)) {
        intermediate[length++] = seq1[i];
      }
    }
    _TYPE[] retval = new _TYPE[length];
    for (int i = 0 ; i < length ; i++ ) {
      retval[i] = intermediate[i];
    }
    return retval;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static CAST_TYPE[] setDiff(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    CAST_TYPE[] intermediate = new CAST_TYPE[seq1.length];
    int length = 0;
    for (int i = 0 ; i < seq1.length ; i++) {
      if (!memberOf(seq1[i], seq2)) {
        intermediate[length++] = seq1[i];
      }
    }
    CAST_TYPE[] retval = new CAST_TYPE[length];
    for (int i = 0 ; i < length ; i++ ) {
      retval[i] = intermediate[i];
    }
    return retval;
  }
#endif

  /**
   * Retuns true iff seq1 and seq2 are equal when considered as sets.
   */
  /*@ pure */ public static boolean setEqual(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    for (int i = 0; i < seq1.length ; i++) {
      if ( !memberOf(seq1[i], seq2) ) {
        return false;
      }
    }
    for (int i = 0; i < seq2.length ; i++) {
      if ( !memberOf(seq2[i], seq1) ) {
        return false;
      }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean setEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    for (int i = 0; i < seq1.length ; i++) {
      if ( !memberOf(seq1[i], seq2) ) {
        return false;
      }
    }
    for (int i = 0; i < seq2.length ; i++) {
      if ( !memberOf(seq2[i], seq1) ) {
        return false;
      }
    }
    return true;
  }
#endif


  /** True iff seq1 is the reverse of seq2.
   *
   * Meaning (in pseudo-FOL):
   *
   * <pre>
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq1.length-1 } : seq1[i] == seq2[seq2.length-1-i]
   * </pre>
   *
   */
  /*@ pure */ public static boolean isReverse(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    int length = seq1.length;
    for (int i = 0 ; i < length ; i++) {
      if (ne(seq1[i], seq2[length - i - 1])) {
        return false;
      }
    }
    return true;
  }

#if (defined(OBJECT))
  /*@ pure */ public static boolean isReverse(Collection seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return isReverse(seq1.toArray(new _TYPE[]{}), seq2);
  }
#endif

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean isReverse(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    int length = seq1.length;
    for (int i = 0 ; i < length ; i++) {
      if (ne(seq1[i], seq2[length - i - 1])) {
        return false;
      }
    }
    return true;
  }
#endif


  /**
   * True iff seq1 is a subset of seq2, when the sequences are
   * considered as sets.
   */
  /*@ pure */ public static boolean subsetOf(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (!memberOf(seq1[i], seq2)) {
        return false;
      }
    }
    return true;
  }

#if (defined(OBJECT))
  /*@ pure */ public static boolean subsetOf(Collection seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return subsetOf(seq1.toArray(new _TYPE[]{}), seq2);
  }
#endif

#if (defined(OBJECT))
  /*@ pure */ public static boolean subsetOf(_TYPE[] seq1, Collection seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return subsetOf(seq1, seq2.toArray(new _TYPE[]{}));
  }
#endif

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean subsetOf(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (!memberOf(seq1[i], seq2)) {
        return false;
      }
    }
    return true;
  }
#endif


  /**
   * Returns true iff seq contains no duplicate elements.
   */
  /*@ pure */ public static boolean noDups(_TYPE[] seq) {
    if (seq == null) { return false; }
    return utilMDE.ArraysMDE.noDuplicates(seq);
  }

/**
 * Returns true iff elt is in array arr.
 */

#if (defined(BYTE) || defined(SHORT) || defined(INT) || defined(LONG))
/*@ pure */ public static boolean memberOf(long elt, _TYPE[] arr) {
  if (arr == null) { return false; }
  for (int i = 0 ; i < arr.length ; i++) {
    if (eq(arr[i], elt)) { return true; }
  }
  return false;
}
#endif

#if (defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean memberOf(double elt, _TYPE[] arr) {
  if (arr == null) { return false; }
  for (int i = 0 ; i < arr.length ; i++) {
    if (eq(arr[i], elt)) { return true; }
  }
  return false;
}
#endif


#if (defined(BOOLEAN) || defined(CHAR) || defined(OBJECT) || defined(STRING))
/*@ pure */ public static boolean memberOf(_TYPE elt, _TYPE[] arr) {
  if (arr == null) { return false; }
  for (int i = 0 ; i < arr.length ; i++) {
    if (eq(arr[i], elt)) { return true; }
  }
  return false;
}
#endif

#if (defined(INT))
  /** True iff all elements in elt occur once or more in arr.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..elt.length-1 } : elt[i] element_of arr
   *
   */
  /*@ pure */ public static boolean eltsOneOf(Object elts, Object arr) {
    if (arr == null) { return false; }
    if (elts == null) { return false; }
    if (!(elts.getClass().isArray() && arr.getClass().isArray())) {
      //throw new IllegalArgumentException("both arguments must be arrays.");
      return false;
    }
    Class eltsType = elts.getClass().getComponentType();
    Class arrType = arr.getClass().getComponentType();
    if (isIntegralType(eltsType) && isIntegralType(arrType)) {
      // Cast both arrays to long and call eltsOneOf(long[],long[])
      long[] elts_long = new long[Array.getLength(elts)];
      for (int i = 0 ; i < elts_long.length ; i++) {
        elts_long[i] = Array.getLong(elts, i);
      }
      long[] arr_long = new long[Array.getLength(arr)];
      for (int i = 0 ; i < arr_long.length ; i++) {
        arr_long[i] = Array.getLong(arr, i);
      }
      return eltsOneOf(elts_long, arr_long);
    } else {
      if (!(isNumericType(eltsType) && isNumericType(arrType))) {
        //throw new IllegalArgumentException("both arguments must be arrays of numeric types.");
        return false;
      }
      // Cast both arrays to double and call eltsOneOf(double[],double[])
      double[] elts_double = new double[Array.getLength(elts)];
      for (int i = 0 ; i < elts_double.length ; i++) {
        elts_double[i] = Array.getDouble(elts, i);
      }
      double[] arr_double = new double[Array.getLength(arr)];
      for (int i = 0 ; i < arr_double.length ; i++) {
        arr_double[i] = Array.getDouble(arr, i);
      }
      return eltsOneOf(elts_double, arr_double);
    }
  }

  /*@ pure */ public static boolean eltsOneOf(long[] elt, long[] arr) {
    if (elt == null) { return false; }
    if (arr == null) { return false; }
    for (int c = 0 ; c < elt.length ; c++) {
      if (!memberOf(elt[c], arr)) {
        return false;
      }
    }
    return true;
  }
  /*@ pure */ public static boolean eltsOneOf(double[] elt, double[] arr) {
    if (elt == null) { return false; }
    if (arr == null) { return false; }
    for (int c = 0 ; c < elt.length ; c++) {
      if (!memberOf(elt[c], arr)) {
        return false;
      }
    }
    return true;
  }

#endif

#if (defined(BOOLEAN) || defined(CHAR) || defined(OBJECT) || defined(STRING))
  /*@ pure */ public static boolean eltsOneOf(_TYPE[] elt, _TYPE[] arr) {
    if (elt == null) { return false; }
    if (arr == null) { return false; }
    for (int c = 0 ; c < elt.length ; c++) {
      if (!memberOf(elt[c], arr)) {
        return false;
      }
    }
    return true;
  }
#endif

  /**
   * Returns a subsequence of seq with first elements seq[start] and
   * last element seq[end].
   */
  /*@ pure */ public static _TYPE[] slice(_TYPE[] seq, int start , int end) {
    if (seq == null) { return null; }
    int sliceStart = start;
    int sliceEnd = end;
    if (start < 0) { return new _TYPE[] { }; }
    if (end > seq.length-1) { return new _TYPE[] { }; }
    if (sliceStart > sliceEnd) { return new _TYPE[] { }; }
    int length = sliceEnd - sliceStart + 1;
    return utilMDE.ArraysMDE.subarray(seq, sliceStart, length);
  }

  /*@ pure */ public static _TYPE[] slice(_TYPE[] seq, long start , int end) {
    return slice(seq, (int)start, end);
  }
  /*@ pure */ public static _TYPE[] slice(_TYPE[] seq, int start , long end) {
    return slice(seq, start, (int)end);
  }
  /*@ pure */ public static _TYPE[] slice(_TYPE[] seq, long start , long end) {
    return slice(seq, (int)start, (int)end);
  }


  /** True iff all elements in arr equal elt.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..arr.length-1 } : arr[i] == elt
   *
   */
  /*@ pure */ public static boolean eltsEqual(_TYPE[] arr, _TYPE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (ne(arr[i], elt)) { return false; }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean eltsEqual(_TYPE[] arr, COMPATIBLE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (ne(arr[i], elt)) { return false; }
    }
    return true;
  }
#endif

  /** True iff every element in arr does not equal elt.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..arr.length-1 } : arr[i] != elt
   *
   */
  /*@ pure */ public static boolean eltsNotEqual(_TYPE[] arr, _TYPE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (eq(arr[i], elt)) { return false; }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean eltsNotEqual(_TYPE[] arr, COMPATIBLE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (eq(arr[i], elt)) { return false; }
    }
    return true;
  }
#endif

#if (defined(BYTE) || defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

  /** True iff every element in arr is greater than elt.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..arr.length-1 } : arr[i] > elt
   *
   */
  /*@ pure */ public static boolean eltsGT(_TYPE[] arr, _TYPE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (lte(arr[i], elt)) { return false; }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean eltsGT(_TYPE[] arr, COMPATIBLE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (lte(arr[i], elt)) { return false; }
    }
    return true;
  }
#endif

  /** True iff every element in arr is greater than or equal to elt.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..arr.length-1 } : arr[i] >= elt
   *
   */
  /*@ pure */ public static boolean eltsGTE(_TYPE[] arr, _TYPE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (lt(arr[i], elt)) { return false; }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean eltsGTE(_TYPE[] arr, COMPATIBLE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (lt(arr[i], elt)) { return false; }
    }
    return true;
  }

#endif

  /** True iff every element in arr is less than elt.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..arr.length-1 } : arr[i] < elt
   *
   */
  /*@ pure */ public static boolean eltsLT(_TYPE[] arr, _TYPE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (gte(arr[i], elt)) { return false; }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean eltsLT(_TYPE[] arr, COMPATIBLE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (gte(arr[i], elt)) { return false; }
    }
    return true;
  }
#endif

  /** True iff every element in arr is less than or equal to elt.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..arr.length-1 } : arr[i] <= elt
   *
   */
  /*@ pure */ public static boolean eltsLTE(_TYPE[] arr, _TYPE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (gt(arr[i], elt)) { return false; }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean eltsLTE(_TYPE[] arr, COMPATIBLE elt) {
    if (arr == null) { return false; }
    for (int i = 0 ; i < arr.length ; i++) {
      if (gt(arr[i], elt)) { return false; }
    }
    return true;
  }

#endif

#endif

  /** True iff seq1 and seq2 have the same length, and every seq1[i] == seq2[i].
   *
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == se2.length
   * /\ forall i in { 0..seq1.length-1 } : seq1[i] == seq2[i]
   *
   */
#if (defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean pairwiseEqual(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (_TYPE_WRAPPER_NAME.isNaN(seq1[i]) && _TYPE_WRAPPER_NAME.isNaN(seq2[i])) {
        continue;
      }
      if (ne(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }
#else
  /*@ pure */ public static boolean pairwiseEqual(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (ne(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }
#endif

#if (defined(OBJECT) || defined(STRING))
  /*@ pure */ public static boolean pairwiseEqual(java.util.AbstractCollection seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return pairwiseEqual((_TYPE[])seq1.toArray(), seq2);
  }

  /*@ pure */ public static boolean pairwiseEqual(_TYPE[] seq1, java.util.AbstractCollection seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return pairwiseEqual(seq1, (_TYPE[])seq2.toArray());
  }
#endif

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean pairwiseEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (ne(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }
#endif

  /** True iff seq1 and seq2 have the same length, and every seq1[i] != seq2[i].
   *
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == se2.length
   * /\ forall i in { 0..seq1.length-1 } : seq1[i] != seq2[i]
   *
   */
  /*@ pure */ public static boolean pairwiseNotEqual(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (eq(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean pairwiseNotEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (eq(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }
#endif

#if (defined(BYTE) || defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

  /** True iff seq1 and seq2 have the same length, and every seq1[i] < seq2[i].
   *
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == se2.length
   * /\ forall i in { 0..seq1.length-1 } : seq1[i] < seq2[i]
   *
   */
  /*@ pure */ public static boolean pairwiseLT(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (gte(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean pairwiseLT(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (gte(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }
#endif

  /** True iff seq1 and seq2 have the same length, and every seq1[i] <= seq2[i].
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == se2.length
   * /\ forall i in { 0..seq1.length-1 } : seq1[i] <= seq2[i]
   *
   */
  /*@ pure */ public static boolean pairwiseLTE(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (gt(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean pairwiseLTE(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (gt(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }

#endif

  /** True iff seq1 and seq2 have the same length, and every seq1[i] > seq2[i].
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == se2.length
   * /\ forall i in { 0..seq1.length-1 } : seq1[i] > seq2[i]
   *
   */
  /*@ pure */ public static boolean pairwiseGT(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (lte(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean pairwiseGT(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (lte(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }
#endif

  /** True iff seq1 and seq2 have the same length, and every seq1[i] >= seq2[i].
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == se2.length
   * /\ forall i in { 0..seq1.length-1 } : seq1[i] >= seq2[i]
   *
   */
  /*@ pure */ public static boolean pairwiseGTE(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (lt(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean pairwiseGTE(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    if (seq1.length != seq2.length) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (lt(seq1[i], seq2[i])) {
        return false;
      }
    }
    return true;
  }

#endif

#endif

  /**
   * Returns true iff seq1 is lexically equal to seq2.
   */
  /*@ pure */ public static boolean lexEqual(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return pairwiseEqual(seq1, seq2);
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean lexEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return pairwiseEqual(seq1, seq2);
  }

#endif

  /**
   * Returns true iff seq1 is lexically not equal to seq2.
   */
  /*@ pure */ public static boolean lexNotEqual(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return !lexEqual(seq1, seq2);
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean lexNotEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return !lexEqual(seq1, seq2);
  }
#endif

#if (defined(BYTE) || defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

  /**
   * Returns true iff seq1 is lexically <  seq2.
   */
  /*@ pure */ public static boolean lexLT(_TYPE[] seq1, _TYPE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    int minlength = (seq1.length < seq2.length) ? seq1.length : seq2.length;
    for (int i = 0 ; i < minlength ; i++) {
      if (gt(seq1[i], seq2[i])) {
        return false;
      } else if (lt(seq1[i], seq2[i])) {
        return true;
      }
    }
    if (seq1.length >= seq2.length) {
      return false;
    }
    return true;
  }


#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean lexLT(_TYPE[] seq1, COMPATIBLE[] seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    int minlength = (seq1.length < seq2.length) ? seq1.length : seq2.length;
    for (int i = 0 ; i < minlength ; i++) {
      if (gt(seq1[i], seq2[i])) {
        return false;
        } else if (lt(seq1[i], seq2[i])) {
          return true;
        }
      }
      if (seq1.length >= seq2.length) {
        return false;
      }
      return true;
    }
#endif

  /**
   * Returns true iff seq1 is lexically <= to seq2.
   */
  /*@ pure */ public static boolean lexLTE(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1 == null) { return false; }
  if (seq2 == null) { return false; }
    int minlength = (seq1.length < seq2.length) ? seq1.length : seq2.length;
    for (int i = 0 ; i < minlength ; i++) {
      if (gt(seq1[i], seq2[i])) {
        return false;
      } else if (lt(seq1[i], seq2[i])) {
        return true;
      }
    }
    if (seq1.length > seq2.length) {
      return false;
    }
    return true;
  }


#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean lexLTE(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1 == null) { return false; }
  if (seq2 == null) { return false; }
    int minlength = (seq1.length < seq2.length) ? seq1.length : seq2.length;
    for (int i = 0 ; i < minlength ; i++) {
      if (gt(seq1[i], seq2[i])) {
        return false;
      } else if (lt(seq1[i], seq2[i])) {
        return true;
      }
    }
    if (seq1.length > seq2.length) {
      return false;
    }
    return true;
  }
#endif

  /**
   * Returns true iff seq1 is lexically > to seq2.
   */
  /*@ pure */ public static boolean lexGT(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1 == null) { return false; }
  if (seq2 == null) { return false; }
    int minlength = (seq1.length < seq2.length) ? seq1.length : seq2.length;
    for (int i = 0 ; i < minlength ; i++) {
      if (lt(seq1[i], seq2[i])) {
        return false;
      } else if (gt(seq1[i], seq2[i])) {
        return true;
      }
    }
    if (seq1.length <= seq2.length) {
      return false;
    }
    return true;
  }


#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean lexGT(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1 == null) { return false; }
  if (seq2 == null) { return false; }
    int minlength = (seq1.length < seq2.length) ? seq1.length : seq2.length;
    for (int i = 0 ; i < minlength ; i++) {
      if (lt(seq1[i], seq2[i])) {
        return false;
      } else if (gt(seq1[i], seq2[i])) {
        return true;
      }
    }
    if (seq1.length <= seq2.length) {
      return false;
    }
    return true;
  }
#endif

  /**
   * Returns true iff seq1 is lexically >= to seq2.
   */
  /*@ pure */ public static boolean lexGTE(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1 == null) { return false; }
  if (seq2 == null) { return false; }
    int minlength = (seq1.length < seq2.length) ? seq1.length : seq2.length;
    for (int i = 0 ; i < minlength ; i++) {
      if (lt(seq1[i], seq2[i])) {
        return false;
      } else if (gt(seq1[i], seq2[i])) {
        return true;
      }
    }
    if (seq1.length < seq2.length) {
      return false;
    }
    return true;
  }

#if (defined(BYTE) || defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
  /*@ pure */ public static boolean lexGTE(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1 == null) { return false; }
  if (seq2 == null) { return false; }
    int minlength = (seq1.length < seq2.length) ? seq1.length : seq2.length;
    for (int i = 0 ; i < minlength ; i++) {
      if (lt(seq1[i], seq2[i])) {
        return false;
      } else if (gt(seq1[i], seq2[i])) {
        return true;
      }
    }
    if (seq1.length < seq2.length) {
      return false;
    }
    return true;
  }

#endif

#endif

  /** True iff for all applicable i, every seq[i] == seq[i+1].
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-2 } : seq[i] == seq[i+1]
   *
   */
  /*@ pure */ public static boolean eltwiseEqual(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (i < seq.length-1) {
        if (ne(seq[i], seq[i+1])) {
          return false;
        }
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] != seq[i+1].
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-2 } : seq[i] != seq[i+1]
   *
   */
  /*@ pure */ public static boolean eltwiseNotEqual(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (i < seq.length-1) {
        if (eq(seq[i], seq[i+1])) {
          return false;
        }
      }
    }
    return true;
  }

#if (defined(BYTE) || defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

  /** True iff for all applicable i, every seq[i] < seq[i+1].
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-2 } : seq[i] < seq[i+1]
   *
   */
  /*@ pure */ public static boolean eltwiseLT(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (i < seq.length-1) {
        if (gte(seq[i], seq[i+1])) {
          return false;
        }
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] <= seq[i+1].
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-2 } : seq[i] <= seq[i+1]
   *
   */
  /*@ pure */ public static boolean eltwiseLTE(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (i < seq.length-1) {
        if (gt(seq[i], seq[i+1])) {
          return false;
        }
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] > seq[i+1].
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-2 } : seq[i] > seq[i+1]
   *
   */
  /*@ pure */ public static boolean eltwiseGT(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (i < seq.length-1) {
        if (lte(seq[i], seq[i+1])) {
          return false;
        }
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] >= seq[i+1].
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-2 } : seq[i] >= seq[i+1]
   *
   */
  /*@ pure */ public static boolean eltwiseGTE(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (i < seq.length-1) {
        if (lt(seq[i], seq[i+1])) {
          return false;
        }
      }
    }
    return true;
  }

#endif

#if (defined(BYTE) || defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

  /** True iff for all applicable i, every seq[i] == i.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-1 } : seq[i] == i
   *
   */
  /*@ pure */ public static boolean equalIndex(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (ne(seq[i], i)) {
        return false;
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] != i.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-1 } : seq[i] != i
   *
   */
  /*@ pure */ public static boolean notEqualIndex(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (eq(seq[i], i)) {
        return false;
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] < i.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-1 } : seq[i] < i
   *
   */
  /*@ pure */ public static boolean ltIndex(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (gte(seq[i], i)) {
        return false;
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] <= i.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-1 } : seq[i] <= i
   *
   */
  /*@ pure */ public static boolean lteIndex(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (gt(seq[i], i)) {
        return false;
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] > i.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-1 } : seq[i] > i
   *
   */
  /*@ pure */ public static boolean  gtIndex(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (lte(seq[i], i)) {
        return false;
      }
    }
    return true;
  }

  /** True iff for all applicable i, every seq[i] >= i.
   *
   * Meaning (in pseudo-FOL):
   *
   * forall i in { 0..seq.length-1 } : seq[i] >= i
   *
   */
  /*@ pure */ public static boolean gteIndex(_TYPE[] seq) {
  if (seq == null) { return false; }
    for (int i = 0 ; i < seq.length ; i++) {
      if (lt(seq[i], i)) {
        return false;
      }
    }
    return true;
  }
#endif

  // Returns the results of following the fields specified in
  // fields[fieldsStartIdx..] for 'object'.
  // If 'object' is an array, returns an array where each element consists of
  // following the fields specified in fields[fieldsStartIdx..].
  // Returns null if any element access causes an exception.
  /*@ pure */ private static _TYPE[] COLLECT_TYPE (Object object,
                                                  String[] fields, int fieldsStartIdx) {

    if (object == null) { return null; }
    if (fields == null) { return null; }
    if (!(fieldsStartIdx >= 0 && fieldsStartIdx < fields.length)) { return null; }

    Object fieldObj = null;
    try {
      Field field = (object instanceof java.lang.Class)
        ? ((Class)object).getDeclaredField(fields[fieldsStartIdx])
        : object.getClass().getDeclaredField(fields[fieldsStartIdx]);
      field.setAccessible(true);
      // Class cls = field.getType();
      fieldObj = field.get(object);
      //System.out.println("***fieldObj="+fieldObj);

    } catch (Exception e) {
      return null;
#if 0
//        String exceptionMessage = null;
//        if (e instanceof NoSuchFieldException) {
//           exceptionMessage = "daikon.Quant.fieldArray: NoSuchFieldException: ";
//        } else if (e instanceof NullPointerException) {
//           exceptionMessage = "daikon.Quant.fieldArray: NoSuchFieldException: ";
//        } else if (e instanceof SecurityException) {
//           exceptionMessage = "daikon.Quant.fieldArray: SecurityException: ";
//        } else {
//           exceptionMessage = "daikon.Quant.fieldArray: Exception: ";
//        }
//        throw new RuntimeException(exceptionMessage);
#endif
    }

    if (fieldObj == null) {
      return null;
    }

    // base case: one field
    if (fields.length - 1 == fieldsStartIdx) {

#if (defined(OBJECT) || defined(STRING))

      if (daikon.ProglangType.list_implementors.contains(fieldObj.getClass().getName())) {
        // last field is the collection
        return (_TYPE[])((java.util.AbstractCollection)fieldObj).toArray();
      } else if (fieldObj.getClass().isArray()) {
        // last field is an array
        return (_TYPE[])fieldObj;
      } else {
        return new _TYPE[] { (_TYPE)fieldObj };
      }
#else

      // This can't happen, because an AbstractCollection cannot hold primitive values.
      //if (daikon.ProglangType.list_implementors.contains(fieldObj.getClass().getName())) {
      //return (_TYPE[])((java.util.AbstractCollection)fieldObj).toArray(new _TYPE[]{});

      if (fieldObj.getClass().isArray()) {
        return (_TYPE[])fieldObj;
      } else {
        //Assert.assertTrue(cls.equals(_TYPE_WRAPPER_NAME.TYPE));
        return
          new _TYPE[] { ((_TYPE_WRAPPER_NAME)fieldObj)._TYPE_WRAPPER_GETVAL_METHOD() };
      }

#endif

    // recursive case: more than one field
    } else {

      if (daikon.ProglangType.list_implementors.contains(fieldObj.getClass().getName())) {

        java.util.AbstractCollection collection = (java.util.AbstractCollection)fieldObj;
        _TYPE[] intermediate = new _TYPE[collection.size()];
        int index = 0;
        for (Iterator i = collection.iterator() ; i.hasNext() ; ) {
          _TYPE[] oneEltArray = COLLECT_TYPE (i.next(), fields, fieldsStartIdx + 1);
          //Assert.assertTrue(oneEltArray.length == 1);
          intermediate[index++] = oneEltArray[0];
        }
        return intermediate;

      } else if (fieldObj.getClass().isArray()) {

        // collect elements across array
        _TYPE[] intermediate = new _TYPE[Array.getLength(fieldObj)];
        for (int i = 0 ; i < intermediate.length ; i++) {
          _TYPE[] oneEltArray = COLLECT_TYPE (Array.get(fieldObj, i),
                                             fields, fieldsStartIdx + 1);
          //Assert.assertTrue(oneEltArray.length == 1);
          intermediate[i] = oneEltArray[0];
        }
        return intermediate;

      } else {

        return COLLECT_TYPE (fieldObj, fields, fieldsStartIdx + 1);
      }
    }
  }

  /**
   * Daikon creates invariants over "variables" such as the following.
   *
   * x.arr[].z   The result of collecting all elements y.z for all y's
   *             in array x.arr.
   * arr[].y.z   The result of collecting all elements x.y.z for all x's
   *             in array arr.
   * x.y.z[]     The result of collecting all elements in array x.y.z[]
   *
   * The collect() method does this collecting work.
   *
   * Given an object (x, arr, or x, correspondingly, in the above examples)
   * and a "field string" (arr.z, y.z, or y.z, correspondingly, in the
   * above example), the collect method collects the elements the result
   * from following the fields, one of which is assumed to be an array.
   *
   * requires: fieldStr.length() > 0 and object != null
   * requires: fieldStr contains only field names, no "[]" strings.
   *
   * requires: the method only works for field sequences with exactly
   * one field representing an array. For example, the collection
   * a[].b[].c will fail.
   *
   * If the resulting collection is of non-primitive type, then collect
   * returns an array of type Object[].
   */
  /*@ pure */ public static _TYPE[] COLLECT_TYPE (Object object, String fieldStr) {

    if (object == null) { return null; }
    if (fieldStr == null) { return null; }

    //Assert.assertTrue(fieldStr != null && !"".equals(fieldStr));
    String[] splits = fieldStr.split("\\.");
    _TYPE[] retval = COLLECT_TYPE (object, splits, 0);
    //System.err.println("%%% fieldArray returned: " + utilMDE.ArraysMDE.toString(retval));
    return retval;
  }

  // If 'object' is an array, returns an array where each element is consists of
  // following the fields specified in fields[fieldsStartIdx..].
  // if 'object' is not an array, returns the results of
  // following the fields specified in fields[fieldsStartIdx..] for 'object'.
  /*@ pure */  public static _TYPE COLLECT_TYPE_FIELD (Object object, String fieldStr) {

    if (object == null) { return BAD_VALUE; }
    if (fieldStr == null) { return BAD_VALUE; }

    String[] splits = fieldStr.split("\\.");

    Object fieldObj = object;

    for (int i = 0 ; i < splits.length ; i++) {

      String fieldName = splits[i];

      try {
        Field field =
          (fieldObj instanceof java.lang.Class)
          ? ((Class)fieldObj).getDeclaredField(fieldName)
          : fieldObj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        fieldObj = field.get(fieldObj);

      } catch (Exception e) {
        return BAD_VALUE;
#if 0
        //             String exceptionMessage = null;
        //             if (e instanceof NoSuchFieldException) {
        //                 exceptionMessage = "daikon.Quant: NoSuchFieldException: ";
        //             } else if (e instanceof NullPointerException) {
        //                 exceptionMessage = "daikon.Quant: NoSuchFieldException: ";
        //             } else if (e instanceof SecurityException) {
        //                 exceptionMessage = "daikon.Quant: SecurityException: ";
        //             } else {
        //                 exceptionMessage = "daikon.Quant: Exception: ";
        //             }
        //             throw new RuntimeException(exceptionMessage);
#endif
      }

    }

#if (defined(OBJECT))
    return fieldObj;
#elif (defined(STRING))
    return (String)fieldObj;
#else
    return ((_TYPE_WRAPPER_NAME)fieldObj)._TYPE_WRAPPER_GETVAL_METHOD();
#endif

  }
