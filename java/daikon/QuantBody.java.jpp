#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(BOOLEAN) \
      || defined(BYTE) \
      || defined(CHAR) \
      || defined(DOUBLE) \
      || defined(FLOAT) \
      || defined(INT) \
      || defined(LONG) \
      || defined(SHORT) \
      || defined(OBJECT) \
      || defined(STRING))
  #error "One of BOOLEAN, BYTE, CHAR, DOUBLE, FLOAT, INT, INTEGER, LONG, SHORT, OBJECT, STRING  must be defined"
#endif

#if defined(BOOLEAN)
  #define _TYPE boolean
  #define _TYPE_WRAPPER_NAME Boolean
  #define _TYPE_WRAPPER_GETVAL_METHOD booleanValue
  #define COLLECT_TYPE collectboolean
#elif defined(BYTE)
  #define _TYPE byte
  #define _TYPE_WRAPPER_NAME Byte
  #define _TYPE_WRAPPER_GETVAL_METHOD byteValue
  #define COLLECT_TYPE collectbyte
#elif defined(CHAR)
  #define _TYPE char
  #define _TYPE_WRAPPER_NAME Character
  #define _TYPE_WRAPPER_GETVAL_METHOD charValue
  #define COLLECT_TYPE collectchar
#elif defined(DOUBLE)
  #define _TYPE double
  #define _TYPE_WRAPPER_NAME Double
  #define _TYPE_WRAPPER_GETVAL_METHOD doubleValue
  #define COLLECT_TYPE collectdouble
#elif defined(FLOAT)
  #define _TYPE float
  #define _TYPE_WRAPPER_NAME Float
  #define _TYPE_WRAPPER_GETVAL_METHOD floatValue
  #define COLLECT_TYPE collectfloat
#elif defined(INT)
  #define _TYPE int
  #define _TYPE_WRAPPER_NAME Integer
  #define _TYPE_WRAPPER_GETVAL_METHOD intValue
  #define COLLECT_TYPE collectint
#elif defined(LONG)
  #define _TYPE long
  #define _TYPE_WRAPPER_NAME Long
  #define _TYPE_WRAPPER_GETVAL_METHOD longValue
  #define COLLECT_TYPE collectlong
#elif defined(SHORT)
  #define _TYPE short
  #define _TYPE_WRAPPER_NAME Short
  #define _TYPE_WRAPPER_GETVAL_METHOD shortValue
  #define COLLECT_TYPE collectshort
#elif defined(OBJECT)
  #define _TYPE Object
  #define COLLECT_TYPE collectObject
#elif defined(STRING)
  #define _TYPE String
  #define COLLECT_TYPE collectString
#endif

#if defined(INT)
  #define COMPATIBLE long
  #define CAST_TYPE long
#endif
#if defined(LONG)
  #define COMPATIBLE int
  #define CAST_TYPE long
#endif
#if defined(DOUBLE)
  #define COMPATIBLE float
  #define CAST_TYPE double
#endif
#if defined(FLOAT)
  #define COMPATIBLE double
  #define CAST_TYPE double
#endif

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))

  /**
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq2.length-1) : seq2[i] divides seq1[i]
   *
   */
  /*@ pure */ public static boolean pairwiseDivides(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (seq1[i] % seq2[i] == 0)) {
      return false;
    }
  }
  return true;
}
/*@ pure */ public static boolean pairwiseDivides(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (seq1[i] % seq2[i] == 0)) {
      return false;
    }
  }
  return true;
}

  /**
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq2.length-1) : seq1[i] ==  seq2[i] * seq2[i]
   *
   */
  /*@ pure */ public static boolean pairwiseSquare(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (seq1[i] == seq2[i] * seq2[i])) {
      return false;
    }
  }
  return true;
}
/*@ pure */ public static boolean pairwiseSquare(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (seq1[i] == seq2[i] * seq2[i])) {
      return false;
    }
  }
  return true;
}

#endif

#if (defined(INT) || defined(LONG))

  /**
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq2.length-1) : seq1[i] == ~ seq2[i]
   *
   */
  /*@ pure */ public static boolean pairwiseBitwiseComplement(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (seq1[i] == ~seq2[i])) {
      return false;
    }
  }
  return true;
}
/*@ pure */ public static boolean pairwiseBitwiseComplement(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (seq1[i] == ~seq2[i])) {
      return false;
    }
  }
  return true;
}

  /**
   * Meaning (in pseudo-FOL):
   *
   * /\ seq1.length == seq2.length
   * /\ forall i in { 0..seq2.length-1) : seq1[i] == (seq2[i] | seq1[i])
   *
   */
  /*@ pure */ public static boolean pairwiseBitwiseSubset(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (seq1[i] == (seq2[i] | seq1[i]))) {
      return false;
    }
  }
  return true;
}
/*@ pure */ public static boolean pairwiseBitwiseSubset(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (! (seq1[i] == (seq2[i] | seq1[i]))) {
      return false;
    }
  }
  return true;
}

#endif

#if (defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))


/**
 * Requires: seq.length > 0
 * Returns the minimum element in the array.
 */
/*@ pure */ public static _TYPE min(_TYPE[] seq) {
  Assert.assertTrue(seq.length > 0);
  _TYPE retval = seq[0];
  for (int i = 1 ; i < seq.length ; i++) {
    if (seq[i] < retval) {
      retval = seq[i];
    }
  }
  return retval;
}

/**
 * Requires: seq.length > 0
 * Returns the minimum element in the array.
 */
/*@ pure */ public static _TYPE max(_TYPE[] seq) {
  Assert.assertTrue(seq.length > 0);
  _TYPE retval = seq[0];
  for (int i = 1 ; i < seq.length ; i++) {
    if (seq[i] > retval) {
      retval = seq[i];
    }
  }
  return retval;
}

#endif

/**
 * Returns the array { seq1[0], ..., seq1[seq1.length-1], seq2[0], ... , seq2[seq2.length-1] }
 * If either (or both) array is (are) empty, returns only those elements
 * in the other array (or none at all).
 */
/*@ pure */ public static _TYPE[] concat(_TYPE[] seq1, _TYPE[] seq2) {
  return utilMDE.ArraysMDE.concat(seq1, seq2);
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static CAST_TYPE[] concat(_TYPE[] seq1, COMPATIBLE[] seq2) {
  int newLength = seq1.length + seq2.length;
  CAST_TYPE[] retval = new CAST_TYPE[newLength];
  int i = 0;
  for ( ; i < seq1.length ; i++) {
    retval[i] = seq1[i];
  }
  for (int j = 0 ; j < seq2.length ; j++) {
    retval[i+j] = seq2[j];
  }
  return retval;
}
#endif

/**
 * Returns an array that is equivalent to the set union of seq1 and seq2.
 * This method gives no assurances about the order or repetition of elements:
 * elements may be repeated, and their order may be different from the
 * order of elements in seq1 and seq2.
 */
/*@ pure */ public static _TYPE[] union(_TYPE[] seq1, _TYPE[] seq2) {
  return concat(seq1, seq2);
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static CAST_TYPE[] union(_TYPE[] seq1, COMPATIBLE[] seq2) {
  return concat(seq1, seq2);
}
#endif

/**
 * Returns an array that is equivalent to the set intersection of seq1 and seq2.
 * This method gives no assurances about the order or repetition of elements:
 * elements may be repeated, and their order may be different from the
 * order of elements in seq1 and seq2.
 */
/*@ pure */ public static _TYPE[] intersection(_TYPE[] seq1, _TYPE[] seq2) {
  _TYPE[] intermediate = new _TYPE[seq1.length + seq2.length];
  int length = 0;
  for (int i = 0 ; i < seq1.length ; i++) {
    if ( memberOf(seq1[i], seq2) ) {
      intermediate[length++] = seq1[i];
    }
  }
  for (int i = 0 ; i < seq2.length ; i++) {
    if ( memberOf(seq2[i], seq1) ) {
      intermediate[length++] = seq2[i];
    }
  }
  _TYPE[] retval = new _TYPE[length];
  for (int i = 0 ; i < length; i++) {
    retval[i] = intermediate[i];
  }
  return retval;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static CAST_TYPE[] intersection(_TYPE[] seq1, COMPATIBLE[] seq2) {
  CAST_TYPE[] intermediate = new CAST_TYPE[seq1.length + seq2.length];
  int length = 0;
  for (int i = 0 ; i < seq1.length ; i++) {
    if ( memberOf(seq1[i], seq2) ) {
      intermediate[length++] = seq1[i];
    }
  }
  for (int i = 0 ; i < seq2.length ; i++) {
    if ( memberOf(seq2[i], seq1) ) {
      intermediate[length++] = seq2[i];
    }
  }
  CAST_TYPE[] retval = new CAST_TYPE[length];
  for (int i = 0 ; i < length; i++) {
    retval[i] = intermediate[i];
  }
  return retval;
}
#endif

/**
 * Returns an array that is equivalent to the set difference of seq1 and seq2.
 * This method gives no assurances about the order or repetition of elements:
 * elements may be repeated, and their order may be different from the
 * order of elements in seq1 and seq2.
 */
/*@ pure */ public static _TYPE[] setDiff(_TYPE[] seq1, _TYPE[] seq2) {
  _TYPE[] intermediate = new _TYPE[seq1.length];
  int length = 0;
  for (int i = 0 ; i < seq1.length ; i++) {
    if (!memberOf(seq1[i], seq2)) {
      intermediate[length++] = seq1[i];
    }
  }
  _TYPE[] retval = new _TYPE[length];
  for (int i = 0 ; i < length ; i++ ) {
    retval[i] = intermediate[i];
  }
  return retval;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static CAST_TYPE[] setDiff(_TYPE[] seq1, COMPATIBLE[] seq2) {
  CAST_TYPE[] intermediate = new CAST_TYPE[seq1.length];
  int length = 0;
  for (int i = 0 ; i < seq1.length ; i++) {
    if (!memberOf(seq1[i], seq2)) {
      intermediate[length++] = seq1[i];
    }
  }
  CAST_TYPE[] retval = new CAST_TYPE[length];
  for (int i = 0 ; i < length ; i++ ) {
    retval[i] = intermediate[i];
  }
  return retval;
}
#endif

/**
 * Retuns true iff seq1 and seq2 are equal when considered as sets.
 */
/*@ pure */ public static boolean setEqual(_TYPE[] seq1, _TYPE[] seq2) {
  for (int i = 0; i < seq1.length ; i++) {
    if ( !memberOf(seq1[i], seq2) ) {
      return false;
    }
  }
  for (int i = 0; i < seq2.length ; i++) {
    if ( !memberOf(seq2[i], seq1) ) {
      return false;
    }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean setEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
  for (int i = 0; i < seq1.length ; i++) {
    if ( !memberOf(seq1[i], seq2) ) {
      return false;
    }
  }
  for (int i = 0; i < seq2.length ; i++) {
    if ( !memberOf(seq2[i], seq1) ) {
      return false;
    }
  }
  return true;
}

#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * /\ seq1.length == seq2.length
 * /\ forall i in { 0..seq1.length-1) : seq1[i] == seq2[seq2.length-1-i]
 *
 */
/*@ pure */ public static boolean isReverse(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  int length = seq1.length;
  for (int i = 0 ; i < length ; i++) {
    if (seq1[i] != seq2[length - i - 1]) {
      return false;
    }
  }
  return true;
}

#if (defined(OBJECT))
/*@ pure */ public static boolean isReverse(Collection seq1, _TYPE[] seq2) {
  return isReverse(seq1.toArray(new _TYPE[]{}), seq2);
}
#endif

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean isReverse(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  int length = seq1.length;
  for (int i = 0 ; i < length ; i++) {
    if (seq1[i] != seq2[length - i - 1]) {
      return false;
    }
  }
  return true;
}
#endif

/**
 * Returns true iff seq contains no duplicate elements.
 */
/*@ pure */ public static boolean noDups(_TYPE[] seq) {
  return utilMDE.ArraysMDE.noDuplicates(seq);
}

/**
 * Returns true iff elt is in array arr.
 */

/*@ pure */ public static boolean memberOf(_TYPE elt, _TYPE[] arr) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] == elt) { return true; }
  }
  return false;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean memberOf(_TYPE elt, COMPATIBLE[] arr) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] == elt) { return true; }
  }
  return false;
}
#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..elt.length-1) : elt[i] element_of arr
 *
 */
/*@ pure */ public static boolean eltsOneOf(_TYPE[] elt, _TYPE[] arr) {
  for (int c = 0 ; c < elt.length ; c++) {
    if (!memberOf(elt[c], arr)) {
      return false;
    }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean eltsOneOf(_TYPE[] elt, COMPATIBLE[] arr) {
  for (int c = 0 ; c < elt.length ; c++) {
    if (!memberOf(elt[c], arr)) {
      return false;
    }
  }
  return true;
}
#endif

/**
 * Return
 */
/*@ pure */ public static _TYPE[] slice(_TYPE[] seq, int start , int end) {
  int sliceStart = start;
  int sliceEnd = end;
  if (start < 0) { sliceStart = 0; }
  if (end > seq.length-1) { sliceEnd = seq.length-1; }
  if (sliceStart > sliceEnd) { return new _TYPE[] { }; }
  int length = sliceEnd - sliceStart + 1;
  return utilMDE.ArraysMDE.subarray(seq, sliceStart, length);
}

/*@ pure */ public static _TYPE[] slice(_TYPE[] seq, long start , int end) {
  return slice(seq, (int)start, end);
}
/*@ pure */ public static _TYPE[] slice(_TYPE[] seq, int start , long end) {
  return slice(seq, start, (int)end);
}
/*@ pure */ public static _TYPE[] slice(_TYPE[] seq, long start , long end) {
  return slice(seq, (int)start, (int)end);
}


/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..arr.length-1) : arr[i] == elt
 *
 */
/*@ pure */ public static boolean eltsEqual(_TYPE[] arr, _TYPE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] != elt) { return false; }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean eltsEqual(_TYPE[] arr, COMPATIBLE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] != elt) { return false; }
  }
  return true;
}
#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..arr.length-1) : arr[i] != elt
 *
 */
/*@ pure */ public static boolean eltsNotEqual(_TYPE[] arr, _TYPE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] == elt) { return false; }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean eltsNotEqual(_TYPE[] arr, COMPATIBLE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] == elt) { return false; }
  }
  return true;
}
#endif

#if (defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..arr.length-1) : arr[i] > elt
 *
 */
/*@ pure */ public static boolean eltsGT(_TYPE[] arr, _TYPE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] <= elt) { return false; }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean eltsGT(_TYPE[] arr, COMPATIBLE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] <= elt) { return false; }
  }
  return true;
}
#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..arr.length-1) : arr[i] >= elt
 *
 */
/*@ pure */ public static boolean eltsGTE(_TYPE[] arr, _TYPE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] < elt) { return false; }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean eltsGTE(_TYPE[] arr, COMPATIBLE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] < elt) { return false; }
  }
  return true;
}

#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..arr.length-1) : arr[i] < elt
 *
 */
/*@ pure */ public static boolean eltsLT(_TYPE[] arr, _TYPE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] >= elt) { return false; }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean eltsLT(_TYPE[] arr, COMPATIBLE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] >= elt) { return false; }
  }
  return true;
}
#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..arr.length-1) : arr[i] <= elt
 *
 */
/*@ pure */ public static boolean eltsLTE(_TYPE[] arr, _TYPE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] > elt) { return false; }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean eltsLTE(_TYPE[] arr, COMPATIBLE elt) {
  for (int i = 0 ; i < arr.length ; i++) {
    if (arr[i] > elt) { return false; }
  }
  return true;
}

#endif

#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * /\ seq1.length == se2.length
 * /\ forall i in { 0..seq1.length-1) : seq1[i] == seq2[i]
 *
 */
/*@ pure */ public static boolean pairwiseEqual(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] != seq2[i]) {
      return false;
    }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean pairwiseEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] != seq2[i]) {
      return false;
    }
  }
  return true;
}
#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * /\ seq1.length == se2.length
 * /\ forall i in { 0..seq1.length-1) : seq1[i] != seq2[i]
 *
 */
/*@ pure */ public static boolean pairwiseNotEqual(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] == seq2[i]) {
      return false;
    }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean pairwiseNotEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] == seq2[i]) {
      return false;
    }
  }
  return true;
}
#endif

#if (defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

/**
 * Meaning (in pseudo-FOL):
 *
 * /\ seq1.length == se2.length
 * /\ forall i in { 0..seq1.length-1) : seq1[i] < seq2[i]
 *
 */
/*@ pure */ public static boolean pairwiseLT(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] >= seq2[i]) {
      return false;
    }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean pairwiseLT(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] >= seq2[i]) {
      return false;
    }
  }
  return true;
}
#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * /\ seq1.length == se2.length
 * /\ forall i in { 0..seq1.length-1) : seq1[i] <= seq2[i]
 *
 */
/*@ pure */ public static boolean pairwiseLTE(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] > seq2[i]) {
      return false;
    }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean pairwiseLTE(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] > seq2[i]) {
      return false;
    }
  }
  return true;
}

#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * /\ seq1.length == se2.length
 * /\ forall i in { 0..seq1.length-1) : seq1[i] > seq2[i]
 *
 */
/*@ pure */ public static boolean pairwiseGT(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] <= seq2[i]) {
      return false;
    }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean pairwiseGT(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] <= seq2[i]) {
      return false;
    }
  }
  return true;
}
#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * /\ seq1.length == se2.length
 * /\ forall i in { 0..seq1.length-1) : seq1[i] >= seq2[i]
 *
 */
/*@ pure */ public static boolean pairwiseGTE(_TYPE[] seq1, _TYPE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] < seq2[i]) {
      return false;
    }
  }
  return true;
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean pairwiseGTE(_TYPE[] seq1, COMPATIBLE[] seq2) {
  if (seq1.length != seq2.length) {
    return false;
  }
  for (int i = 0 ; i < seq1.length ; i++) {
    if (seq1[i] < seq2[i]) {
      return false;
    }
  }
  return true;
}

#endif

#endif

/**
 * Returns true iff seq1 is lexically equal to seq2
 */
/*@ pure */ public static boolean lexEqual(_TYPE[] seq1, _TYPE[] seq2) {
  return pairwiseEqual(seq1, seq2);
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean lexEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
  return pairwiseEqual(seq1, seq2);
}

#endif

/**
 * Returns true iff seq1 is lexically not equal to seq2
 */
/*@ pure */ public static boolean lexNotEqual(_TYPE[] seq1, _TYPE[] seq2) {
  return !lexEqual(seq1, seq2);
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean lexNotEqual(_TYPE[] seq1, COMPATIBLE[] seq2) {
  return !lexEqual(seq1, seq2);
}
#endif

#if (defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

/**
 * Returns true iff seq1 is lexically < to seq2
 */
/*@ pure */ public static boolean lexLT(_TYPE[] seq1, _TYPE[] seq2) {
  int maxlength = (seq1.length < seq2.length) ? seq2.length : seq1.length;
  // we maintain the invariant that for j < i, seq1 and seq2 are
  // pairwise equal up to j.
  for (int i = 0 ; i <= maxlength ; i++) {
    // case 1 : we've reached the end of at least one of the sequences
    if (seq1.length == i && seq2.length == i) {
      return false; // they're both equal
    }
    if (seq1.length == i && seq2.length > i) {
      return true; // both equal up to i-1 and seq2 longer than seq1
    }
    if (seq1.length > i && seq2.length == i) {
      return false; // both equal up to i-1 and seq1 longer than seq2
    }
    // case 2 : we haven't reached the end of either sequence
    Assert.assertTrue(seq1.length > i && seq2.length > i);
    if (seq1[i] < seq2[i]) {
      return true;
    }
    if (seq1[i] > seq2[i]) {
      return false;
    }
  }
  throw new RuntimeException("Quant.java.jpp: lex method shouldn't have reached this point! (bad impl?)");
}


#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean lexLT(_TYPE[] seq1, COMPATIBLE[] seq2) {
  int maxlength = (seq1.length < seq2.length) ? seq2.length : seq1.length;
  // we maintain the invariant that for j < i, seq1 and seq2 are
  // pairwise equal up to j.
  for (int i = 0 ; i <= maxlength ; i++) {
    // case 1 : we've reached the end of at least one of the sequences
    if (seq1.length == i && seq2.length == i) {
      return false; // they're both equal
    }
    if (seq1.length == i && seq2.length > i) {
      return true; // both equal up to i-1 and seq2 longer than seq1
    }
    if (seq1.length > i && seq2.length == i) {
      return false; // both equal up to i-1 and seq1 longer than seq2
    }
    // case 2 : we haven't reached the end of either sequence
    Assert.assertTrue(seq1.length > i && seq2.length > i);
    if (seq1[i] < seq2[i]) {
      return true;
    }
    if (seq1[i] > seq2[i]) {
      return false;
    }
  }
  throw new RuntimeException("Quant.java.jpp: lex method shouldn't have reached this point! (bad impl?)");
}
#endif

/**
 * Returns true iff seq1 is lexically <= to seq2
 */
/*@ pure */ public static boolean lexLTE(_TYPE[] seq1, _TYPE[] seq2) {
  int maxlength = (seq1.length < seq2.length) ? seq2.length : seq1.length;
  // we maintain the invariant that for j < i, seq1 and seq2 are
  // pairwise equal up to j.
  for (int i = 0 ; i <= maxlength ; i++) {
    // case 1 : we've reached the end of at least one of the sequences
    if (seq1.length == i && seq2.length == i) {
      return true; // they're both equal
    }
    if (seq1.length == i && seq2.length > i) {
      return true; // both equal up to i-1 and seq2 longer than seq1
    }
    if (seq1.length > i && seq2.length == i) {
      return false; // both equal up to i-1 and seq1 longer than seq2
    }
    // case 2 : we haven't reached the end of either sequence
    Assert.assertTrue(seq1.length > i && seq2.length > i);
    if (seq1[i] < seq2[i]) {
      return true;
    }
    if (seq1[i] > seq2[i]) {
      return false;
    }
  }
  throw new RuntimeException("Quant.java.jpp: lex method shouldn't have reached this point! (bad impl?)");
}


#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean lexLTE(_TYPE[] seq1, COMPATIBLE[] seq2) {
  int maxlength = (seq1.length < seq2.length) ? seq2.length : seq1.length;
  // we maintain the invariant that for j < i, seq1 and seq2 are
  // pairwise equal up to j.
  for (int i = 0 ; i <= maxlength ; i++) {
    // case 1 : we've reached the end of at least one of the sequences
    if (seq1.length == i && seq2.length == i) {
      return true; // they're both equal
    }
    if (seq1.length == i && seq2.length > i) {
      return true; // both equal up to i-1 and seq2 longer than seq1
    }
    if (seq1.length > i && seq2.length == i) {
      return false; // both equal up to i-1 and seq1 longer than seq2
    }
    // case 2 : we haven't reached the end of either sequence
    Assert.assertTrue(seq1.length > i && seq2.length > i);
    if (seq1[i] < seq2[i]) {
      return true;
    }
    if (seq1[i] > seq2[i]) {
      return false;
    }
  }
  throw new RuntimeException("Quant.java.jpp: lex method shouldn't have reached this point! (bad impl?)");
}
#endif

/**
 * Returns true iff seq1 is lexically > to seq2
 */
/*@ pure */ public static boolean lexGT(_TYPE[] seq1, _TYPE[] seq2) {
  int maxlength = (seq1.length < seq2.length) ? seq2.length : seq1.length;
  // we maintain the invariant that for j < i, seq1 and seq2 are
  // pairwise equal up to j.
  for (int i = 0 ; i <= maxlength ; i++) {
    // case 1 : we've reached the end of at least one of the sequences
    if (seq1.length == i && seq2.length == i) {
      return false; // they're both equal
    }
    if (seq1.length == i && seq2.length > i) {
      return false; // both equal up to i-1 and seq2 longer than seq1
    }
    if (seq1.length > i && seq2.length == i) {
      return true; // both equal up to i-1 and seq1 longer than seq2
    }
    // case 2 : we haven't reached the end of either sequence
    Assert.assertTrue(seq1.length > i && seq2.length > i);
    if (seq1[i] > seq2[i]) {
      return true;
    }
    if (seq1[i] < seq2[i]) {
      return false;
    }
  }
  throw new RuntimeException("Quant.java.jpp: lex method shouldn't have reached this point! (bad impl?)");
}


#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean lexGT(_TYPE[] seq1, COMPATIBLE[] seq2) {
  int maxlength = (seq1.length < seq2.length) ? seq2.length : seq1.length;
  // we maintain the invariant that for j < i, seq1 and seq2 are
  // pairwise equal up to j.
  for (int i = 0 ; i <= maxlength ; i++) {
    // case 1 : we've reached the end of at least one of the sequences
    if (seq1.length == i && seq2.length == i) {
      return false; // they're both equal
    }
    if (seq1.length == i && seq2.length > i) {
      return false; // both equal up to i-1 and seq2 longer than seq1
    }
    if (seq1.length > i && seq2.length == i) {
      return true; // both equal up to i-1 and seq1 longer than seq2
    }
    // case 2 : we haven't reached the end of either sequence
    Assert.assertTrue(seq1.length > i && seq2.length > i);
    if (seq1[i] > seq2[i]) {
      return true;
    }
    if (seq1[i] < seq2[i]) {
      return false;
    }
  }
  throw new RuntimeException("Quant.java.jpp: lex method shouldn't have reached this point! (bad impl?)");
}
#endif

/**
 * Returns true iff seq1 is lexically >= to seq2
 */
/*@ pure */ public static boolean lexGTE(_TYPE[] seq1, _TYPE[] seq2) {
  int maxlength = (seq1.length < seq2.length) ? seq2.length : seq1.length;
  // we maintain the invariant that for j < i, seq1 and seq2 are
  // pairwise equal up to j.
  for (int i = 0 ; i <= maxlength ; i++) {
    // case 1 : we've reached the end of at least one of the sequences
    if (seq1.length == i && seq2.length == i) {
      return true; // they're both equal
    }
    if (seq1.length == i && seq2.length > i) {
      return false; // both equal up to i-1 and seq2 longer than seq1
    }
    if (seq1.length > i && seq2.length == i) {
      return true; // both equal up to i-1 and seq1 longer than seq2
    }
    // case 2 : we haven't reached the end of either sequence
    Assert.assertTrue(seq1.length > i && seq2.length > i);
    if (seq1[i] > seq2[i]) {
      return true;
    }
    if (seq1[i] < seq2[i]) {
      return false;
    }
  }
  throw new RuntimeException("Quant.java.jpp: lex method shouldn't have reached this point! (bad impl?)");
}

#if (defined(INT) || defined(LONG) || defined(FLOAT) || defined(DOUBLE))
/*@ pure */ public static boolean lexGTE(_TYPE[] seq1, COMPATIBLE[] seq2) {
  int maxlength = (seq1.length < seq2.length) ? seq2.length : seq1.length;
  // we maintain the invariant that for j < i, seq1 and seq2 are
  // pairwise equal up to j.
  for (int i = 0 ; i <= maxlength ; i++) {
    // case 1 : we've reached the end of at least one of the sequences
    if (seq1.length == i && seq2.length == i) {
      return true; // they're both equal
    }
    if (seq1.length == i && seq2.length > i) {
      return false; // both equal up to i-1 and seq2 longer than seq1
    }
    if (seq1.length > i && seq2.length == i) {
      return true; // both equal up to i-1 and seq1 longer than seq2
    }
    // case 2 : we haven't reached the end of either sequence
    Assert.assertTrue(seq1.length > i && seq2.length > i);
    if (seq1[i] > seq2[i]) {
      return true;
    }
    if (seq1[i] < seq2[i]) {
      return false;
    }
  }
  throw new RuntimeException("Quant.java.jpp: lex method shouldn't have reached this point! (bad impl?)");
}

#endif

#endif

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-2) : seq[i] == seq[i+1]
 *
 */
/*@ pure */ public static boolean eltwiseEqual(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (i < seq.length-1) {
      if (seq[i] != seq[i+1]) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-2) : seq[i] != seq[i+1]
 *
 */
/*@ pure */ public static boolean eltwiseNotEqual(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (i < seq.length-1) {
      if (seq[i] == seq[i+1]) {
        return false;
      }
    }
  }
  return true;
}

#if (defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-2) : seq[i] < seq[i+1]
 *
 */
/*@ pure */ public static boolean eltwiseLT(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (i < seq.length-1) {
      if (seq[i] >= seq[i+1]) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-2) : seq[i] <= seq[i+1]
 *
 */
/*@ pure */ public static boolean eltwiseLTE(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (i < seq.length-1) {
      if (seq[i] > seq[i+1]) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-2) : seq[i] > seq[i+1]
 *
 */
/*@ pure */ public static boolean eltwiseGT(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (i < seq.length-1) {
      if (seq[i] <= seq[i+1]) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-2) : seq[i] >= seq[i+1]
 *
 */
/*@ pure */ public static boolean eltwiseGTE(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (i < seq.length-1) {
      if (seq[i] < seq[i+1]) {
        return false;
      }
    }
  }
  return true;
}

#endif

#if (defined(DOUBLE) || defined(FLOAT) || defined(INT) || defined(LONG) || defined(SHORT))

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-1) : seq[i] == i
 *
 */
/*@ pure */ public static boolean equalIndex(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (seq[i] != i) {
      return false;
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-1) : seq[i] != i
 *
 */
/*@ pure */ public static boolean notEqualIndex(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (seq[i] == i) {
      return false;
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-1) : seq[i] < i
 *
 */
/*@ pure */ public static boolean ltIndex(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (seq[i] >= i) {
      return false;
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-1) : seq[i] <= i
 *
 */
/*@ pure */ public static boolean lteIndex(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (seq[i] > i) {
      return false;
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-1) : seq[i] > i
 *
 */
/*@ pure */ public static boolean  gtIndex(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (seq[i] <= i) {
      return false;
    }
  }
  return true;
}

/**
 * Meaning (in pseudo-FOL):
 *
 * forall i in { 0..seq.length-1) : seq[i] >= i
 *
 */
/*@ pure */ public static boolean gteIndex(_TYPE[] seq) {
  for (int i = 0 ; i < seq.length ; i++) {
    if (seq[i] < i) {
      return false;
    }
  }
  return true;
}
#endif

/*@ pure */  public static _TYPE[] COLLECT_TYPE (Object object,
                                                String[] fields, int fieldsStartIdx) {

  Field field = null;
  Class cls = null;
  Object fieldObj = null;
  try {
    field = object.getClass().getField(fields[fieldsStartIdx]);
    cls = field.getType();
    fieldObj = field.get(object);
    //System.out.println("***fieldObj="+fieldObj);
  } catch (NoSuchFieldException e) {
    throw new RuntimeException("daikon.Quant.fieldArray: NoSuchFieldException: "
                               + ", object=" + object
                               + "fields=" + utilMDE.ArraysMDE.toString(fields)
                               + "fieldsStartIdx=" + fieldsStartIdx);
  } catch (NullPointerException e) {
    throw new RuntimeException("daikon.Quant.fieldArray: NullPointerException: "
                               + ", object=" + object
                               + "fields=" + utilMDE.ArraysMDE.toString(fields)
                               + "fieldsStartIdx=" + fieldsStartIdx);
  } catch (SecurityException e) {
    throw new RuntimeException("daikon.Quant.fieldArray: SecurityException: "
                               + ", object=" + object
                               + "fields=" + utilMDE.ArraysMDE.toString(fields)
                               + "fieldsStartIdx=" + fieldsStartIdx);
  } catch (Exception e) {
    throw new RuntimeException("daikon.Quant.fieldArray: Exception: "
                               + ", object=" + object
                               + "fields=" + utilMDE.ArraysMDE.toString(fields)
                               + "fieldsStartIdx=" + fieldsStartIdx);
  }

  // base case: one field
  if (fields.length - 1 == fieldsStartIdx) {

#if (defined(OBJECT) || defined(STRING))

    if (fieldObj.getClass().isArray()) {
      // last field is the array
      return (_TYPE[])fieldObj;
    } else {
      return new _TYPE[] { (_TYPE)fieldObj };
    }
#else
    if (fieldObj.getClass().isArray()) {
      return (_TYPE[])fieldObj;
    } else {
      Assert.assertTrue(cls.equals(_TYPE_WRAPPER_NAME.TYPE));
      return
        new _TYPE[] { ((_TYPE_WRAPPER_NAME)fieldObj)._TYPE_WRAPPER_GETVAL_METHOD() };
    }

#endif

  // recursive case: more than one field
  } else {

    if (fieldObj.getClass().isArray()) {

      // collect elements across array
      _TYPE[] intermediate = new _TYPE[Array.getLength(fieldObj)];
      for (int i = 0 ; i < intermediate.length ; i++) {
        _TYPE[] oneEltArray = COLLECT_TYPE (Array.get(fieldObj, i),
                                           fields, fieldsStartIdx + 1);
        Assert.assertTrue(oneEltArray.length == 1);
        intermediate[i] = oneEltArray[0];
      }
      return intermediate;

    } else {

      return COLLECT_TYPE (fieldObj, fields, fieldsStartIdx + 1);
    }
  }
}

/**
 * Daikon creates invariants over "variables" such as
 *
 * x.arr[].z   The result of collecting all elements y.z for all y's
 *             in array x.arr.
 * arr[].y.z   The result of collecting all elements x.y.z for all x's
 *             in array arr.
 * x.y.z[]     The result of collecting all elements in array x.y.z[]
 *
 * The collect() method does this collecting work.
 *
 * Given an object (x, arr, or x, correspondingly, in the above examples)
 * and a "field string" (arr.z, y.z, or y.z, correspondingly, in the
 * above example), the collect method collects the elements the result
 * from following the fields, one of which is assumed to be an array.
 *
 * requires: fieldStr.length() > 0 and object != null
 * requires: fieldStr contains only field names, no "[]" strings.
 *
 * requires: the method only works for field sequences with exactly
 * one field representing an array. For example, the collection
 * a[].b[].c will fail.
 *
 * If the resulting collection is of non-primitive type, then collect
 * returns an array of type Object[].
 */
/*@ pure */ public static _TYPE[] COLLECT_TYPE (Object object, String fieldStr) {

  Assert.assertTrue(fieldStr != null && !"".equals(fieldStr));
  String[] splits = fieldStr.split("\\.");
  _TYPE[] retval = COLLECT_TYPE (object, splits, 0);
  //System.err.println("%%% fieldArray returned: " + utilMDE.ArraysMDE.toString(retval));
  return retval;
}
