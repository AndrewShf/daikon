#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(FLOAT) || defined(LONG))
  #error "One of Float or Long must be defined"
#endif

#if defined(LONG)
  #define CLASSNAME Functions
  #define PRIMITIVE "int"
  #define PRIM long
#elif defined(FLOAT)
  #define CLASSNAME FunctionsFloat
  #define PRIMITIVE "double"
  #define PRIM double
#endif

// ***** This file is automatically generated from Functions.java.jpp

package daikon.inv;

import utilMDE.*;

public final class CLASSNAME {

  public final static String[][] unaryFunctionNames;
//  public final static Method[] unaryFunctions;

  public final static String[][] binarySymmetricFunctionNames;
//  public final static Method[] binarySymmetricFunctions;

  public final static String[][] binaryNonSymmetricFunctionNames;
//  public final static Method[] binaryNonSymmetricFunctions;

  public final static boolean bounds_check = true;

//  private static Method[] methodNamesToMethods(String[] names) {
//    try {
//      Method[] result = new Method[names.length];
//      for (int i=0; i<unaryFunctionNames.length; i++)
//        result[i] = UtilMDE.methodForName(names[i]);
//      return result;
//    } catch (Exception e) {
//      e.printStackTrace();
//      throw new Error(e.toString());
//    }
//  }

  static {

    // I need to have the names available so the methods can be serialized.

    unaryFunctionNames = new String[][] {
      /// Java language operators (in precedence order)
      // increment: subsumed by LinearBinary
      // decrement: subsumed by LinearBinary
#if defined(LONG)
      {"~", ""},
#endif
      // logicalComplement: subsumed by LinearBinary
      // "utilMDE.MathMDE.negate(" + PRIMITIVE + ")",
      /// Non-operators
    };
  //  unaryFunctions = methodNamesToMethods(unaryFunctionNames);

    binarySymmetricFunctionNames = new String[][] {
      /// Java language operators (in precedence order, omitting boolean operators)
      // Maybe instead of mul I should have a specific invariant that also
      // looks for a leading constant.
      {"", " * ", ""},
      // plus: subsumed by LinearTernary.
#if defined(LONG)
      {"(", " & ", ")"},          // bitwise and
      {"(", " && ", ")"},         // logical and
      {"(", " ^ ", ")"},          // bitwise xor
      {"utilMDE.MathMDE.logicalXor(", ", ", ")"}, // there is no ^^, alas
      {"(", " | ", ")"},          // bitwise or
      {"(", " || ", ")"},         // logical or
#endif
      /// Non-operators.
      {"java.lang.Math.min(", ", ", ")"},
      {"java.lang.Math.max(", ", ", ")"},
#if defined(LONG)
      {"utilMDE.MathMDE.gcd(", ", ", ")"},
#endif
    };
    // binarySymmetricFunctions = methodNamesToMethods(binarySymmetricFunctionNames);

    binaryNonSymmetricFunctionNames = new String[][] {
      /// Java language operators (in precedence order, omitting boolean operators)
      {"", " / ", ""},          // divide
#if defined(LONG)
      {"", " % ", ""},          // mod
      // minus: subsumed by LinearTernary
      // (Are the shifts also subsumed by LinearTernary?)
      {"", " << ", ""},         // left shift
      {"", " >> ", ""},         // signed right shift
      {"", " >>> ", ""},        // unsigned right shift
      /// Non-operators.
#endif
      {"java.lang.Math.pow(", ", ", ")"},       // exponentiation
      // MathMDE_cmp = "utilMDE.MathMDE.cmp(int,int)"
      // MathMDE_cmp = "utilMDE.MathMDE.round(int,int)"
    };
//    binaryNonSymmetricFunctions = methodNamesToMethods(binaryNonSymmetricFunctionNames);

  }

  public static PRIM invokeUnary(int methodnumber, PRIM arg) {
#if defined(LONG)
    switch (methodnumber) {
    case 0: return MathMDE.bitwiseComplement(arg);
    case 1: return MathMDE.negate(arg);
    case 2: return Math.abs(arg);
    }
#else
    switch (methodnumber) {
    case 0: return MathMDE.negate(arg);
    // case 1: return Math.abs(arg);
    }
#endif
    System.out.println("returning 0, unary");
    return 0;
  }

  public static PRIM invokeBinary(int methodnumber, PRIM arg, PRIM arg2) {

#if defined(FLOAT)
    switch (methodnumber) {
    case 0: return MathMDE.mul(arg, arg2);
    case 1: return Math.min(arg, arg2);
    case 2: return Math.max(arg, arg2);
    case 3: return MathMDE.div(arg, arg2);
    case 4: return Math.pow(arg, arg2);
    }
#elif defined(LONG)
    switch (methodnumber) {
    case 0:  return MathMDE.mul(arg, arg2);
    case 1:  return MathMDE.bitwiseAnd(arg, arg2);
    case 2:  return MathMDE.logicalAnd(arg, arg2);
    case 3:  return MathMDE.bitwiseXor(arg, arg2);
    case 4:  return MathMDE.logicalXor(arg, arg2);
    case 5:  return MathMDE.bitwiseOr(arg, arg2);
    case 6:  return MathMDE.logicalOr(arg, arg2);
    case 7:  return Math.min(arg, arg2);
    case 8:  return Math.max(arg, arg2);
    case 9:  return MathMDE.gcd(arg, arg2);
    case 10: return MathMDE.div(arg, arg2);
    case 11: return MathMDE.mod(arg, arg2);
    case 12: if (bounds_check && ((arg2 > 63) || (arg2 < 0)))
               throw new ArithmeticException ("arg2 (" + arg2 + ") out of range 0..63");
             return MathMDE.lshift(arg, arg2);
    case 13: if (bounds_check && ((arg2 > 63) || (arg2 < 0)))
               throw new ArithmeticException ("arg2 (" + arg2 + ") out of range 0..63");
             return MathMDE.rshiftSigned(arg, arg2);
    case 14: if (bounds_check && ((arg2 > 63) || (arg2 < 0)))
               throw new ArithmeticException ("arg2 (" + arg2 + ") out of range 0..63");
             return MathMDE.rshiftUnsigned(arg, arg2);
    case 15: return MathMDE.pow(arg, arg2);
    }
#endif
    System.out.println("returning 0 binary");
    return 0;
  }

  public static boolean is_symmetric (int methodnumber) {
    if (methodnumber < binarySymmetricFunctionNames.length)
      return (true);
    else
      return (false);
  }

  // don't permit instantiation
  private CLASSNAME() { }

}
