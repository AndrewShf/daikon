// ***** This file is automatically generated from Functions.java.jpp

package daikon.inv;

import utilMDE.*;

public final class FunctionsFloat {

  public final static String[][] unaryFunctionNames;
//  public final static Method[] unaryFunctions;

  public final static String[][] binarySymmetricFunctionNames;
//  public final static Method[] binarySymmetricFunctions;

  public final static String[][] binaryNonSymmetricFunctionNames;
//  public final static Method[] binaryNonSymmetricFunctions;

//  private static Method[] methodNamesToMethods(String[] names) {
//    try {
//      Method[] result = new Method[names.length];
//      for (int i=0; i<unaryFunctionNames.length; i++)
//        result[i] = UtilMDE.methodForName(names[i]);
//      return result;
//    } catch (Exception e) {
//      e.printStackTrace();
//      throw new Error(e.toString());
//    }
//  }

  static {

    // I need to have the names available so the methods can be serialized.

    unaryFunctionNames = new String[][] {
      /// Java language operators (in precedence order)
      // increment: subsumed by LinearBinary
      // decrement: subsumed by LinearBinary

      // logicalComplement: subsumed by LinearBinary
      //"utilMDE.MathMDE.negate(double)",
      /// Non-operators
    };
  //  unaryFunctions = methodNamesToMethods(unaryFunctionNames);

    binarySymmetricFunctionNames = new String[][] {
      /// Java language operators (in precedence order, omitting boolean operators)
      // Maybe instead of mul I should have a specific invariant that also
      // looks for a leading constant.
      {"", " * ", ""},
      // plus: subsumed by LinearTernary.

      /// Non-operators.
      {"java.lang.Math.min(", ", ", ")"},
      {"java.lang.Math.max(", ", ", ")"},

    };
    //binarySymmetricFunctions = methodNamesToMethods(binarySymmetricFunctionNames);

    binaryNonSymmetricFunctionNames = new String[][] {
      /// Java language operators (in precedence order, omitting boolean operators)
      {"", " / ", ""},          // divide

      {"java.lang.Math.pow(", ", ", ")"},       // exponentiation
      // MathMDE_cmp = "utilMDE.MathMDE.cmp(int,int)"
      // MathMDE_cmp = "utilMDE.MathMDE.round(int,int)"
    };
//    binaryNonSymmetricFunctions = methodNamesToMethods(binaryNonSymmetricFunctionNames);

  }

  public static double invokeUnary(int methodnumber, double arg) {

    switch(methodnumber) {
    case 0: return MathMDE.negate(arg);
    //case 1: return Math.abs(arg);
    }

    System.out.println("returning 0, unary");
    return 0;
  }

  public static double invokeBinary(int methodnumber, double arg, double arg2) {

    switch(methodnumber) {
    case 0: return MathMDE.mul(arg, arg2);
    case 1: return Math.min(arg, arg2);
    case 2: return Math.max(arg, arg2);
    case 3: return MathMDE.div(arg, arg2);
    case 4: return Math.pow(arg, arg2);
    }

    System.out.println("returning 0 binary");
    return 0;
  }

  // don't permit instantiation
  private FunctionsFloat () { }

}
