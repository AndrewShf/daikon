#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif


#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME SequenceScalarFactory
  #define PROGLANGTYPESCALAR INT
  #define PROGLANGTYPEARRAY INT_ARRAY
  #define MEMBER Member
  #define CLASSSTRING "SequenceScalarFactory"
#elif defined(TYPEDOUBLE)
  #define CLASSNAME SequenceFloatFactory
  #define PROGLANGTYPESCALAR DOUBLE
  #define PROGLANGTYPEARRAY DOUBLE_ARRAY
  #define MEMBER MemberFloat
  #define CLASSSTRING "SequenceFloatFactory"
#endif

// ***** This file is automatically generated from SequenceScalarFactory.java.jpp

package daikon.inv.binary.sequenceScalar;

import daikon.*;

import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;

public final class CLASSNAME {

  /** Main debug tracer **/
  public static final Logger debug =
   Logger.getLogger("daikon.inv.binary.sequenceScalar." + CLASSSTRING);

  // public final static boolean debugSequenceScalarFactory = false;
  // public final static boolean debugSequenceScalarFactory = true;

  // Adds the appropriate new Invariant objects to the specified Invariants
  // collection.
  public static Vector instantiate(PptSlice ppt) {
    if (debug.isLoggable(Level.FINE)) {
      debug.fine (CLASSSTRING + " instantiate " + ppt.name);
    }

    boolean seq_first;

    VarInfo seqvar;
    VarInfo sclvar;
    {
      VarInfo vi0 = ppt.var_infos[0];
      VarInfo vi1 = ppt.var_infos[1];
      if ((vi0.rep_type == ProglangType.PROGLANGTYPEARRAY)
          && (vi1.rep_type == ProglangType.PROGLANGTYPESCALAR)) {
        seq_first = true;
        seqvar = ppt.var_infos[0];
        sclvar = ppt.var_infos[1];
      } else if ((vi0.rep_type == ProglangType.PROGLANGTYPESCALAR)
                 && (vi1.rep_type == ProglangType.PROGLANGTYPEARRAY)) {
        seq_first = false;
        seqvar = ppt.var_infos[1];
        sclvar = ppt.var_infos[0];
      } else {
        throw new Error("Bad types");
      }
    }

    if (! seqvar.eltsCompatible(sclvar)) {
      debug.fine ("Elements not compatible, returning");
      return null;
    }

    Vector result = new Vector();
    // I could check that the length of the sequence isn't always 0.
    result.add(MEMBER.instantiate(ppt, seq_first));
    #if (defined TYPELONG)
      result.add(SeqIntLessThan.instantiate(ppt, seq_first));
      result.add(SeqIntGreaterThan.instantiate(ppt, seq_first));
      result.add(SeqIntLessEqual.instantiate(ppt, seq_first));
      result.add(SeqIntGreaterEqual.instantiate(ppt, seq_first));
      result.add(SeqIntEqual.instantiate(ppt, seq_first));
    #else
      result.add(SeqFloatLessThan.instantiate(ppt, seq_first));
      result.add(SeqFloatGreaterThan.instantiate(ppt, seq_first));
      result.add(SeqFloatLessEqual.instantiate(ppt, seq_first));
      result.add(SeqFloatGreaterEqual.instantiate(ppt, seq_first));
      result.add(SeqFloatEqual.instantiate(ppt, seq_first));
    #endif
    return result;
  }

  private CLASSNAME() {
  }

}
