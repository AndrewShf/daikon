package daikon.inv.binary.sequenceString;

import daikon.*;
import daikon.inv.*;
import daikon.inv.binary.twoScalar.*;
import daikon.derive.*;
import daikon.derive.unary.*;
import daikon.derive.binary.*;
import java.util.*;
import utilMDE.*;

// *****
// Do not edit this file directly:
// it is automatically generated from Member.java.jpp
// *****

public final class Member extends SequenceString  {

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  public static boolean dkconfig_enabled = true;

  public final static boolean debugMember = false;
  // public final static boolean debugMember = true;

  protected Member(PptSlice ppt, boolean seq_first) {
    super(ppt, seq_first);
    Assert.assert(sclvar().rep_type == ProglangType.STRING );
    Assert.assert(seqvar().rep_type == ProglangType.STRING_ARRAY );
  }

  public static Member instantiate(PptSlice ppt, boolean seq_first) {
    if (!dkconfig_enabled) return null;

    VarInfo seqvar = ppt.var_infos[seq_first ? 0 : 1];
    VarInfo sclvar = ppt.var_infos[seq_first ? 1 : 0];

    // SUPPRESSED INVARIANT: Member, if isEqualToObviousMember (complicated)
    if (isEqualToObviousMember(sclvar, seqvar)) {
      Global.implied_noninstantiated_invariants += 1;
      if (debugMember) {
        System.out.println("Member not instantiated (obvious): "
                           + sclvar.name + " in " + seqvar.name);
      }
      return null;
    }

    if (debugMember) {
      System.out.println("Member instantiated: "
                         + sclvar.name + " in " + seqvar.name);
    }
    return new Member(ppt, seq_first);
  }

  public boolean isObviousImplied() {
    return isEqualToObviousMember(sclvar(), seqvar());
  }

  // Like isObviousMember, but also checks everything equal to the given
  // variables.
  public static boolean isEqualToObviousMember(VarInfo sclvar, VarInfo seqvar) {
    /* [INCR]
    Assert.assert(sclvar.isCanonical());
    Assert.assert(seqvar.isCanonical());
    Vector scl_equalto = sclvar.equalTo();
    scl_equalto.add(0, sclvar);
    Vector seq_equalto = seqvar.equalTo();
    seq_equalto.add(0, seqvar);

    for (int sclidx=0; sclidx<scl_equalto.size(); sclidx++) {
      for (int seqidx=0; seqidx<seq_equalto.size(); seqidx++) {
        VarInfo this_sclvar = (VarInfo) scl_equalto.elementAt(sclidx);
        VarInfo this_seqvar = (VarInfo) seq_equalto.elementAt(seqidx);
        if (isObviousMember(this_sclvar, this_seqvar))
          return true;
      }
    }
    */
    return false;
  }

  public static boolean isObviousMember(VarInfo sclvar, VarInfo seqvar) {

    VarInfo sclvar_seq = sclvar.isDerivedSequenceMember();
    // System.out.println("Member.isObviousMember(" + sclvar.name + ", " + seqvar.name + "):");
    // System.out.println("  sclvar.derived=" + sclvar.derived
    //                    + ", sclvar_seq=" + ((sclvar_seq == null) ? "null" : sclvar_seq.name));

    if (sclvar_seq == null) {
      // The scalar is not obviously (lexically) a member of any array.
      return false;
    }
    if (sclvar_seq == seqvar) {
      // The scalar is a member of the same array.
      return true;
    }
    // The scalar is a member of a different array than the sequence.
    // But maybe the relationship is still obvious, so keep checking.

    // If the scalar is a member of a subsequence of the sequence, then
    // the scalar is a member of the full sequence.
    // This is satisfied, for instance, when determining that
    // max(B[0..I]) is an obvious member of B.
    VarInfo sclseqsuper = sclvar_seq.isDerivedSubSequenceOf();
    if (sclseqsuper == seqvar)
      return true;

    // We know the scalar was derived from some array, but not from the
    // sequence variable.  If also not from what the sequence variable was
    // derived from, we don't know anything about membership.
    // Check:
    //  * whether comparing B[I] to B[0..J]
    //  * whether comparing min(B[0..I]) to B[0..J]
    VarInfo seqvar_super = seqvar.isDerivedSubSequenceOf();
    if ((seqvar_super != sclvar_seq)
        && (seqvar_super != sclseqsuper)) {
      // System.out.println("Member.isObviousMember(" + sclvar.name + ", " + seqvar.name + "):"
      //                    + " isDerivedSubSequenceOf() != " + sclvar_seq.name);
      return false;
    }

    // If the scalar is a positional element of the sequence from which
    // the sequence at hand was derived, then any relationship will be
    // (mostly) obvious by comparing the length of the sequence to the
    // index.  By contrast, if the scalar is max(...) or min(...), all bets
    // are off.

    if (seqvar.derived instanceof SequenceStringSubsequence ) {
      // the sequence is B[0..J-1] or similar.  Get information about it.
      SequenceStringSubsequence  seqsss = (SequenceStringSubsequence ) seqvar.derived;
      // System.out.println("seqvar: " + seqvar.name);
      VarInfo seq_index = seqsss.sclvar();
      int seq_shift = seqsss.index_shift;
      boolean seq_from_start = seqsss.from_start;

      if (sclvar.derived instanceof SequenceStringSubscript ) {
        // B[I] in B[0..J]

        SequenceStringSubscript  sclsss = (SequenceStringSubscript ) sclvar.derived;
        VarInfo scl_index = sclsss.sclvar(); // "I" in "B[I]"
        int scl_shift = sclsss.index_shift;
        // System.out.println("scl_shift = " + scl_shift + ", seq_shift = " + seq_shift);
        if (VarInfo.compare_vars(scl_index, scl_shift, seq_index, seq_shift,
                                 seq_from_start)) {
          return true;
        }
      } else if (sclvar.derived instanceof SequenceInitial) {
        // System.out.println("sclvar derived from SequenceInitial: " + sclvar.name);

        // B[0] in B[0..J]; also B[-1] in B[J..]
        SequenceInitial sclse = (SequenceInitial) sclvar.derived;
        int scl_index = sclse.index;
        if (((scl_index == 0) && seq_from_start)
            || ((scl_index == -1) && !seq_from_start))
          // It might not be true, because the array could be empty;
          // but if the array isn't empty, then it's obvious.
          return true;
      } else if ((sclvar.derived instanceof SequenceMin)
                 || (sclvar.derived instanceof SequenceMax)) {
        if (sclvar_seq.derived instanceof SequenceScalarSubsequence) {
          // min(B[0..I]) in B[0..J]
          // System.out.println("seqvar_super = " + seqvar_super + ", sclseqsuper = " + sclseqsuper);
          // System.out.println("seqvar_super = " + seqvar_super.name + ", sclseqsuper = " + sclseqsuper.name);
          Assert.assert(seqvar_super == sclseqsuper);
          SequenceScalarSubsequence sclsss = (SequenceScalarSubsequence) sclvar_seq.derived;
          boolean scl_from_start = sclsss.from_start;
          if (scl_from_start == seq_from_start) {
            VarInfo scl_index = sclsss.sclvar();
            int scl_shift = sclsss.index_shift;
            boolean comparison = VarInfo.compare_vars(scl_index, scl_shift, seq_index, seq_shift,
                                                      seq_from_start);
            // System.out.println("comparison="+comparison+" for obvious membership: " + sclvar.name + " " + seqvar.name);
            if (comparison) {
              return true;
            }
          }
        }
      }
    }

    /// I need to test this code!
    // Now do tests over variable name, to avoid invariants like:
    //   header.next in header.~ll~next~
    //   header.next.element in header.~ll~next~.element
    //   header.next in header.next.~ll~next~
    //   return.current in return.current.~ll~next~
    String sclname = sclvar.name.name(); // mistere adds: this code
    String seqname = seqvar.name.name(); // looks pretty sketchy (XXX)
    int llpos = seqname.indexOf("~ll~");
    if (llpos != -1) {
      int tildepos = seqname.indexOf("~", llpos+5);
      if (tildepos != -1) {
        int midsize = tildepos-llpos-4;
        int lastsize = seqname.length()-tildepos-1;
        if (seqname.regionMatches(0, sclname, 0, llpos)
            && (((tildepos == seqname.length() - 1)
                 && (llpos == sclname.length()))
                || (seqname.regionMatches(llpos+4, sclname, llpos, midsize)
                    && seqname.regionMatches(tildepos+1, sclname, tildepos-4, lastsize))))
          return true;
      }
    }

    // int lastdot = sclvar.lastIndexOf(".");
    // if (lastdot != -1) {
    //   if (sclname.substring(0, lastdot).equals(seqname.substring(0, lastdot))
    //       && seqname.substring(lastdot).equals("~ll~" + sclname.substring(lastdot) + "~")) {
    //     return true;
    //   }
    // }

    return false;
  }

  public String repr() {
    return "Member" + varNames() + ": "
      + "no_invariant=" + no_invariant;
  }

  public String format() {
    return sclvar().name.name() + " in " + seqvar().name.name();
  }

  public String format_ioa(String classname) {
    String scl = sclvar().name.ioa_name(classname);
    String[] form =
      VarInfoName.QuantHelper.format_ioa(new VarInfo[] { seqvar()}, classname);
    return "~(" + form[0] + form[1] + " ~= " + scl + form[2] + ")";
  }

  public String format_esc() {
    // "exists x in a..b : P(x)" gets written as "!(forall x in a..b : !P(x))"
    String[] form =
      VarInfoName.QuantHelper.format_esc(new VarInfoName[]
	{ seqvar().name, sclvar().name });
    return "!" + form[0] + "(" + form[1] + " != " + form[2] + ")" + form[3];
  }

  public String format_simplify() {
    // "exists x in a..b : P(x)" gets written as "!(forall x in a..b : !P(x))"
    String[] form =
      VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
	{ seqvar().name, sclvar().name });
    return "(NOT " + form[0] + "(NEQ " + form[1] + " " + form[2] + ")" + form[3] + ")";
  }

  public void add_modified(String [] a, String  i, int count) {
    if (ArraysMDE.indexOf(a, i) == -1) {
      if (debugMember) {
        System.out.println("Member destroyed:  " + format() + " because " + i + " not in " + ArraysMDE.toString(a));
      }
      flowThis();
      destroy();
      return;
    }
  }

  protected double computeProbability() {
    if (no_invariant)
      return Invariant.PROBABILITY_NEVER;
    else
      return Invariant.PROBABILITY_JUSTIFIED;
  }

  public boolean isSameFormula(Invariant other)
  {
    Assert.assert(other instanceof Member);
    return true;
  }
}

