#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
#error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if (defined(TYPELONG))
  #define CLASSNAME FunctionUnary
  #define SUPERCLASS TwoScalar
  #define CORECLASS FunctionUnaryCore
  #define PRIMITIVE long
  #define CLASSSTRING "FunctionUnary"
  #define FUNCTION_LIST ~
#elif defined(TYPEDOUBLE)
  #define CLASSNAME FunctionUnaryFloat
  #define SUPERCLASS TwoFloat
  #define CORECLASS FunctionUnaryCoreFloat
  #define PRIMITIVE double
  #define CLASSSTRING "FunctionUnaryFloat"
  #define FUNCTION_LIST none
#endif

// ***** This file is automatically generated from FunctionUnary.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.Invariant;
import java.lang.reflect.*;



/**
 * Represents an invariant between two PRIMITIVE scalars by applying a
 * function to one of the scalars.  Prints as either "x == function(y)"
 * or "x = [op] y" depending upon whether it is an actual function call
 * or a unary operator.
 *
 * Current PRIMITIVE functions are: FUNCTION_LIST
 **/
public class CLASSNAME
  extends SUPERCLASS
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff FunctionUnary invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  public CORECLASS core;

  protected CLASSNAME(PptSlice ppt, String[] methodname, int methodNumber, boolean inverse) {
    super(ppt);
    core = new CORECLASS(this, methodname, methodNumber, inverse);
  }

  public static CLASSNAME instantiate(PptSlice ppt, String[] methodname, int methodNumber, boolean inverse) {
    if (!dkconfig_enabled) return null;
    return new CLASSNAME(ppt, methodname, methodNumber, inverse);
  }

  protected Object clone() {
    CLASSNAME result = (CLASSNAME) super.clone();
    result.core = (CORECLASS) core.clone();
    result.core.wrapper = result;
    return result;
  }

  protected Invariant resurrect_done_swapped() {
    core.swap();
    return this;
  }

  public String repr() {
    return CLASSSTRING + varNames() + ": " + core.repr();
  }

  public String format_using(OutputFormat format) {
    return core.format_using(format, var1().name, var2().name);
  }

  public void add_modified(PRIMITIVE x, PRIMITIVE y, int count) {
    core.add_modified(x, y, count);
  }


  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isExact() {
    return true;
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((CLASSNAME) other).core);
  }
}
