#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if (defined(TYPELONG))
  #define CLASSNAME FunctionUnaryCore
  #define PRIMITIVE long
  #define NUMWRAPPER Long
  #define FUNCTIONS Functions
  #define CLASSSTRING "FunctionUnaryCore"
  #define VALUETRACKER ValueTracker
#elif defined(TYPEDOUBLE)
  #define CLASSNAME FunctionUnaryCoreFloat
  #define PRIMITIVE double
  #define NUMWRAPPER Double
  #define FUNCTIONS FunctionsFloat
  #define CLASSSTRING "FunctionUnaryCoreFloat"
  #define VALUETRACKER FloatValueTracker
#endif

// ***** This file is automatically generated from FunctionUnaryCore.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import java.io.*;
import java.lang.reflect.*;
import utilMDE.*;

// Two basic options here:
//     * take java.lang.reflect.Method objects
//        + that fits in well with pre-existing methods.  It also does wrapping
//          and unwrapping as appropriate
//        - I must provide an object or arrange that the methods are all static,
//          so I might end up with a new object of my own type after all.
//     * take Invokable objects, where I define a new interface with invoke() method
//        + I might not want wrapping, unwrapping, and args wrapped in Object[]:
//          more efficient not to do so
//        + might be more efficient to define my own interface with specialized
//          types, not Object
//        - must convert existing functions to this format.

public final class CLASSNAME
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  // transient public Method function;  // transient:  Method not serializable
  public final String[] methodname;   // provided to permit serialization

  private int methodNumber;
  // false if we're looking for y=fn(x), true if we're looking for x=fn(y)
  public boolean inverse;

  private VALUETRACKER values_cache = new VALUETRACKER(8);

  public Invariant wrapper;

  public CLASSNAME(Invariant wrapper, String[] methodname, int methodNumber, boolean inverse) {
    this.wrapper = wrapper;
    this.methodname = methodname;
    this.inverse = inverse;
    this.methodNumber = methodNumber;
  }

  public Object clone() {
    try {
      CLASSNAME result = (CLASSNAME) super.clone();
      result.values_cache = (VALUETRACKER) values_cache.clone();
      return result;
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  // swapping during resurrection
  public void swap() {
    inverse = !inverse;
  }

  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException, NoSuchMethodException {
    in.defaultReadObject();
    this.set_function();
  }

  private void set_function() throws ClassNotFoundException, NoSuchMethodException {
  }

  public void add_modified(PRIMITIVE x, PRIMITIVE y, long count) {
    boolean ok = false;
    ok = (inverse
          ? (x == (FUNCTIONS.invokeUnary(methodNumber, y)))
          : (y == (FUNCTIONS.invokeUnary(methodNumber, x))));

    if (! ok) {
      wrapper.destroyAndFlow();
    }

    values_cache.add(x, y);
  }

  public double computeProbability() {
    if (wrapper.falsified)
      return Invariant.PROBABILITY_NEVER;
    // For now, only depend on number of samples.
    // But if this prob = 0, should depend on the function as well.
    return Invariant.prob_is_ge(values_cache.num_values(), 5);
  }


  public String format_using(OutputFormat format,
                             VarInfoName vname1,
                             VarInfoName vname2)
  {
    String argname = (inverse ? vname2 : vname1).name_using(format);
    String resultname = (inverse ? vname1 : vname2).name_using(format);
    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.IOA)
        || (format == OutputFormat.JML))
    {
      String eq = " == ";
      if (format == OutputFormat.IOA) eq = " = ";
      String result = resultname + eq + methodname[0] + argname + methodname[1];
      if (format == OutputFormat.IOA) result += " ***";
      return result;
    }

    return wrapper.format_unimplemented(format);
  }

  public String format_simplify(String vname1, String vname2) {
    String argname = inverse ? vname2 : vname1;
    String resultname = inverse ? vname1 : vname2;
    if (methodname[1].equals("")) {
      return "(EQ " + resultname + " (" + methodname[0] + " " + argname + "))";
    } else {
      return "format_simplify() doesn't know function " + methodname[0] + "-" +
        methodname[1];
    }
  }

  public String repr() {
    return CLASSSTRING + wrapper.varNames() + ": "
      + "function=" + methodname[0] + "." + methodname[1]
      + ",inverse=" + inverse;
  }

  public boolean isSameFormula(CLASSNAME other)
  {
    return methodname[0].equals(other.methodname[0]) &&
      methodname[1].equals(other.methodname[1]);
  }
}
