#if 0
// Do not attempt to compile this file with a Java compiler such as javac.
// You first need to preprocess it with cpp, the C preprocessor.
// The correct way to build the system is to run 'make'.
#endif

#if 0
// This file is the source for all scalar (integer), float, and string
// simple two variable comparisons.  One of the defines immediately
// below must be defined in the Makefile to specify which version
// should be built.  For example: scalar equals, float equals, scalar
// less than, etc.
#endif

#if !(defined(EQUAL) || defined(NONEQUAL) || defined(LESSTHAN) || defined(LESSEQUAL) || defined(GREATERTHAN) || defined(GREATEREQUAL) || defined(EQUALFLOAT) || defined(NONEQUALFLOAT) || defined(LESSTHANFLOAT) || defined(LESSEQUALFLOAT) || defined(GREATERTHANFLOAT) || defined(GREATEREQUALFLOAT) || defined(EQUALSTRING) || defined(NONEQUALSTRING) || defined(LESSTHANSTRING) || defined(LESSEQUALSTRING) || defined(GREATERTHANSTRING) || defined(GREATEREQUALSTRING))
  #error "EQUAL, NONEQUAL, LESSTHAN, LESSEQUAL, GREATERTHAN, GREATEREQUAL, EQUALFLOAT, NONEQUALFLOAT, LESSTHANFLOAT, LESSEQUALFLOAT, GREATERTHANFLOAT, or GREATEREQUALFLOAT must be defined"
#endif

#if (defined(EQUAL) || defined(NONEQUAL) || defined(LESSTHAN) \
    || defined(LESSEQUAL) || defined(GREATERTHAN) || defined(GREATEREQUAL))
  #define PRIMITIVE long
  #define IS_NUMERIC 1
  #define ISTYPE isIntegral()
  #define SUPERCLASS TwoScalar
  #define MEMBER Member
  #define INT(x) Int ## x
  #define LINEARBINARY LinearBinary
  #define SEQSEQINTEQUAL SeqSeqIntEqual
  #define SEQ_SUBSCRIPT SequenceScalarSubscript
  #define NO_DUPS NoDuplicates
  #define INT_TYPE long
  #define ONEOF OneOfScalar
  #define LOWERBOUND LowerBound
  #define UPPERBOUND UpperBound
  #define LESS_THAN_CLASS IntLessThan
  #define GREATER_THAN_CLASS IntGreaterThan
  #define EQUAL_CLASS IntEqual
#elif (defined (EQUALFLOAT) || defined(NONEQUALFLOAT) \
    || defined(LESSTHANFLOAT) || defined(LESSEQUALFLOAT) \
    || defined(GREATERTHANFLOAT) || defined(GREATEREQUALFLOAT))
  #define IS_NUMERIC 1
  #define PRIMITIVE double
  #define ISTYPE isFloat()
  #define SUPERCLASS TwoFloat
  #define MEMBER Member
  #define INT(x) Float ## x
  #define LINEARBINARY LinearBinaryFloat
  #define SEQSEQINTEQUAL SeqSeqFloatEqual
  #define SEQ_SUBSCRIPT SequenceFloatSubscript
  #define NO_DUPS NoDuplicatesFloat
  #define INT_TYPE double
  #define ONEOF OneOfFloat
  #define LOWERBOUND LowerBoundFloat
  #define UPPERBOUND UpperBoundFloat
  #define LESS_THAN_CLASS FloatLessThan
  #define GREATER_THAN_CLASS FloatGreaterThan
  #define EQUAL_CLASS FloatEqual
#else
  #define IS_STRING 1
  #define PRIMITIVE String
  #define ISTYPE isString()
  #define SUPERCLASS TwoString
  #define MEMBER MemberString
  #define INT(x) String ## x
  #define SEQSEQINTEQUAL SeqSeqStringEqual
  #define SEQ_SUBSCRIPT SequenceStringSubscript
  #define NO_DUPS NoDuplicatesString
  #define INT_TYPE String
  #define ONEOF OneOfString
  #define LESS_THAN_CLASS StringLessThan
  #define GREATER_THAN_CLASS StringGreaterThan
  #define EQUAL_CLASS StringEqual
#endif

#if defined(EQUAL)
  #define INTEQUAL IntEqual
  #define INTEQUALstring "IntEqual"
  #define EQUALS(a,b) (a == b)
  #define EQUALSstring "=="
  #define PAIRWISE_COMPARE PairwiseIntEqual
  #define DEBUGINTEQUAL debugIntEqual
  #define SEQINTEQUAL seqIntEqual
#elif defined(EQUALFLOAT)
  #define INTEQUAL FloatEqual
  #define INTEQUALstring "FloatEqual"
  #define EQUALS(a,b) (Global.fuzzy.eq (a, b))
  #define EQUALSstring "=="
  #define PAIRWISE_COMPARE PairwiseFloatEqual
  #define DEBUGINTEQUAL debugIntEqual
  #define SEQINTEQUAL seqIntEqual
#elif defined (EQUALSTRING)
  #define INTEQUAL StringEqual
  #define INTEQUALstring "StringEqual"
  #define EQUALS(a,b) ((a != null) && (b != null) && (a == b))
  #define EQUALSstring "=="
  #define PAIRWISE_COMPARE PairwiseStringEqual
  #define DEBUGINTEQUAL debugStringEqual
  #define SEQINTEQUAL seqStringEqual

#elif defined(NONEQUAL)
  #define INTEQUAL IntNonEqual
  #define INTEQUALstring "IntNonEqual"
  #define EQUALS(a,b) (a != b)
  #define EQUALSstring "!="
  #define DEBUGINTEQUAL debugIntNonEqual
  #define SEQINTEQUAL seqIntNonEqual
#elif defined(NONEQUALFLOAT)
  #define INTEQUAL FloatNonEqual
  #define INTEQUALstring "FloatNonEqual"
  #define EQUALS(a,b) (Global.fuzzy.ne (a, b))
  #define EQUALSstring "!="
  #define DEBUGINTEQUAL debugIntNonEqual
  #define SEQINTEQUAL seqIntNonEqual
#elif defined (NONEQUALSTRING)
  #define INTEQUAL StringNonEqual
  #define INTEQUALstring "StringNonEqual"
  #define EQUALS(a,b) (a != b)
  #define EQUALSstring "!="
  #define DEBUGINTEQUAL debugStringNonEqual
  #define SEQINTEQUAL seqIntStringEqual

#elif defined(LESSTHAN)
  #define INTEQUAL IntLessThan
  #define INTEQUAL_SWAP IntGreaterThan
  #define INTEQUALstring "IntLessThan"
  #define EQUALS(a,b) (a < b)
  #define EQUALSstring "<"
  #define PAIRWISE_COMPARE PairwiseIntLessThan
  #define DEBUGINTEQUAL debugIntLessThan
  #define SEQINTEQUAL seqIntLessThan
#elif defined(LESSTHANFLOAT)
  #define INTEQUAL FloatLessThan
  #define INTEQUAL_SWAP FloatGreaterThan
  #define INTEQUALstring "FloatLessThan"
  #define EQUALS(a,b) (Global.fuzzy.lt (a, b))
  #define EQUALSstring "<"
  #define PAIRWISE_COMPARE PairwiseFloatLessThan
  #define DEBUGINTEQUAL debugIntLessThan
  #define SEQINTEQUAL seqIntLessThan
#elif defined(LESSTHANSTRING)
  #define INTEQUAL StringLessThan
  #define INTEQUAL_SWAP StringGreaterThan
  #define INTEQUALstring "StringLessThan"
  #define EQUALS(a,b) ((a != null) && (b != null) && (a.compareTo (b) < 0))
  #define EQUALSstring "<"
  #define PAIRWISE_COMPARE PairwiseStringLessThan
  #define DEBUGINTEQUAL debugStringLessThan
  #define SEQINTEQUAL seqStringLessThan

#elif defined(LESSEQUAL)
  #define INTEQUAL IntLessEqual
  #define INTEQUAL_SWAP IntGreaterEqual
  #define INTEQUALstring "IntLessEqual"
  #define EQUALS(a,b) (a <= b)
  #define EQUALSstring "<="
  #define PAIRWISE_COMPARE PairwiseIntLessEqual
  #define DEBUGINTEQUAL debugIntLessEqual
  #define SEQINTEQUAL seqIntLessEqual
#elif defined(LESSEQUALFLOAT)
  #define INTEQUAL FloatLessEqual
  #define INTEQUAL_SWAP FloatGreaterEqual
  #define INTEQUALstring "FloatLessEqual"
  #define EQUALS(a,b) (Global.fuzzy.lte (a, b))
  #define EQUALSstring "<="
  #define PAIRWISE_COMPARE PairwiseFloatLessEqual
  #define DEBUGINTEQUAL debugIntLessEqual
  #define SEQINTEQUAL seqIntLessEqual
#elif defined(LESSEQUALSTRING)
  #define INTEQUAL StringLessEqual
  #define INTEQUAL_SWAP StringGreaterEqual
  #define INTEQUALstring "StringLessEqual"
  #define EQUALS(a,b) ((a != null) && (b != null) && (a.compareTo (b) <= 0))
  #define EQUALSstring "<="
  #define PAIRWISE_COMPARE PairwiseStringLessEqual
  #define DEBUGINTEQUAL debugStringLessEqual
  #define SEQINTEQUAL seqStringLessEqual

#elif defined(GREATERTHAN)
  #define INTEQUAL IntGreaterThan
  #define INTEQUAL_SWAP IntLessThan
  #define INTEQUALstring "IntGreaterThan"
  #define EQUALS(a,b) (a > b)
  #define EQUALSstring ">"
  #define PAIRWISE_COMPARE PairwiseIntGreaterThan
  #define DEBUGINTEQUAL debugIntGreaterThan
  #define SEQINTEQUAL seqIntGreaterThan
#elif defined(GREATERTHANFLOAT)
  #define INTEQUAL FloatGreaterThan
  #define INTEQUAL_SWAP FloatLessThan
  #define INTEQUALstring "FloatGreaterThan"
  #define EQUALS(a,b) (Global.fuzzy.gt (a, b))
  #define EQUALSstring ">"
  #define PAIRWISE_COMPARE PairwiseFloatGreaterThan
  #define DEBUGINTEQUAL debugIntGreaterThan
  #define SEQINTEQUAL seqIntGreaterThan
#elif defined(GREATERTHANSTRING)
  #define INTEQUAL StringGreaterThan
  #define INTEQUAL_SWAP StringLessThan
  #define INTEQUALstring "StringGreaterThan"
  #define EQUALS(a,b) ((a != null) && (b != null) && (a.compareTo(b) > 0))
  #define EQUALSstring ">"
  #define PAIRWISE_COMPARE PairwiseStringGreaterThan
  #define DEBUGINTEQUAL debugStringGreaterThan
  #define SEQINTEQUAL seqStringGreaterThan

#elif defined(GREATEREQUAL)
  #define INTEQUAL IntGreaterEqual
  #define INTEQUAL_SWAP IntLessEqual
  #define INTEQUALstring "IntGreaterEqual"
  #define EQUALS(a,b) (a >= b)
  #define EQUALSstring ">="
  #define PAIRWISE_COMPARE PairwiseIntGreaterEqual
  #define DEBUGINTEQUAL debugIntGreaterEqual
  #define SEQINTEQUAL seqIntGreaterEqual
#elif defined(GREATEREQUALFLOAT)
  #define INTEQUAL FloatGreaterEqual
  #define INTEQUAL_SWAP FloatLessEqual
  #define INTEQUALstring "FloatGreaterEqual"
  #define EQUALS(a,b) (Global.fuzzy.gte (a, b))
  #define EQUALSstring ">="
  #define NONEQUALSstring "<="
  #define PAIRWISE_COMPARE PairwiseFloatGreaterEqual
  #define DEBUGINTEQUAL debugIntGreaterEqual
  #define SEQINTEQUAL seqIntGreaterEqual
#elif defined(GREATEREQUALSTRING)
  #define INTEQUAL StringGreaterEqual
  #define INTEQUAL_SWAP StringLessEqual
  #define INTEQUALstring "StringGreaterEqual"
  #define EQUALS(a,b) ((a != null) && (b != null) && (a.compareTo (b) >= 0))
  #define EQUALSstring ">="
  #define NONEQUALSstring "<="
  #define PAIRWISE_COMPARE PairwiseStringGreaterEqual
  #define DEBUGINTEQUAL debugStringGreaterEqual
  #define SEQINTEQUAL seqStringGreaterEqual
#else
  #error "EQUAL, NONEQUAL, LESSTHAN, LESSEQUAL, GREATERTHAN, or GREATEREQUAL must be defined"
#endif

#if defined (EQUAL) || defined (EQUALFLOAT) || defined (EQUALSTRING)
  #define EQUAL_OP 1
#elif defined (NONEQUAL) || defined (NONEQUALFLOAT) || defined (NONEQUALSTRING)
  #define NONEQUAL_OP 1
#elif defined(LESSTHAN) || defined(LESSTHANFLOAT) || defined(LESSTHANSTRING)
  #define LESSTHAN_OP 1
#elif defined(LESSEQUAL) || defined(LESSEQUALFLOAT) || defined(LESSEQUALSTRING)
  #define LESSEQUAL_OP 1
#elif defined(GREATERTHAN) || defined(GREATERTHANFLOAT) \
    || defined(GREATERTHANSTRING)
  #define GREATERTHAN_OP 1
#elif defined(GREATEREQUAL) || defined (GREATEREQUALFLOAT) \
    || defined(GREATEREQUALSTRING)
  #define GREATEREQUAL_OP 1
#else
  #error "Unexpected op"
#endif

#if (defined(LESSTHAN) || defined(LESSEQUAL))
  #define LOWER_BD LowerBound
  #define UPPER_BD UpperBound
  #define LB_MIN min()
  #define UB_MAX max()
#elif (defined(LESSTHANFLOAT) || defined(LESSEQUALFLOAT))
  #define LOWER_BD LowerBoundFloat
  #define UPPER_BD UpperBoundFloat
  #define LB_MIN min()
  #define UB_MAX max()
#elif (defined(GREATERTHAN) || defined(GREATEREQUAL))
  #define LOWER_BD UpperBound
  #define UPPER_BD LowerBound
  #define LB_MIN max()
  #define UB_MAX min()
#elif (defined(GREATERTHANFLOAT) || defined(GREATEREQUALFLOAT))
  #define LOWER_BD UpperBoundFloat
  #define UPPER_BD LowerBoundFloat
  #define LB_MIN max()
  #define UB_MAX min()
#endif

#if (defined(EQUAL) || defined(EQUALFLOAT))
  #define IMPLEMENTSCOMPARISON implements Comparison
#else
  #define IMPLEMENTSCOMPARISON
#endif

// ***** This file is automatically generated from IntComparisons.java.jpp

#if defined (IS_STRING)
package daikon.inv.binary.twoString;
#else
package daikon.inv.binary.twoScalar;
#endif

import daikon.*;
import daikon.inv.*;
#ifdef IS_STRING
  import daikon.inv.unary.string.*;
#else
  import daikon.inv.unary.scalar.*;
  #ifdef NONEQUAL_OP
    import daikon.inv.unary.sequence.*;
  #else
    import daikon.inv.binary.twoSequence.*;
  #endif
  import daikon.derive.unary.*;
  import daikon.derive.binary.*;
#endif
import daikon.suppress.*;

import utilMDE.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.*;

/**
 * Represents an invariant of EQUALSstring between two
 * PRIMITIVE scalars.
 **/
public final class INTEQUAL
  extends SUPERCLASS IMPLEMENTSCOMPARISON {

  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff INTEQUAL invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  public static final Logger debug
    = Logger.getLogger("daikon.inv.binary.twoScalar." + INTEQUALstring);

#if (defined(NONEQUAL))
  /**
   * Boolean.  True iff INTEQUAL invariants should be considered.
   **/
  public static boolean dkconfig_integral_only = true;
#endif

  protected INTEQUAL(PptSlice ppt) {
   super(ppt);
  }

  public static INTEQUAL instantiate(PptSlice ppt) {

    if (logOn() || debug.isLoggable(Level.FINE)) {
      Debug.log (debug, INTEQUAL.class, ppt, "Attempt Instantiate");
    }

    if (!dkconfig_enabled) return null;

    // Make sure the null case doesn't crash.  Null is passed when the
    // invariant is used for non-standard purposes.
    if (ppt == null)
      return new INTEQUAL(ppt);

    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];
    VarInfo seqvar1 = var1.isDerivedSequenceMember();
    VarInfo seqvar2 = var2.isDerivedSequenceMember();

    // for strings, only check equality unless both vars are integral
    #if defined (IS_STRING) && !defined (EQUALSTRING)
      if (!(var1.type.isIntegral() && var2.type.isIntegral()))
        return null;
     #endif

    #if !defined (IS_STRING)


  #if !(defined(EQUAL) || defined(EQUALFLOAT))
    #if (defined(NONEQUAL))
      if (dkconfig_integral_only == true) {
        if (! (var1.file_rep_type.ISTYPE && var2.file_rep_type.ISTYPE)) {
          return null;
        }
      }
    #else
      if (! (var1.file_rep_type.ISTYPE && var2.file_rep_type.ISTYPE)) {
        return null;
      }
    #endif
  #endif

      if (logOn() || debug.isLoggable(Level.FINE)) {
        Debug.log (debug, INTEQUAL.class, ppt,
               "seqvar1=" + ((seqvar1 == null) ? "null" : seqvar1.name.name())
           + ", seqvar2=" + ((seqvar2 == null) ? "null" : seqvar2.name.name()));
      }
  #endif // not string


#if !(defined(EQUAL) || defined(EQUALFLOAT))
  #if 0
    // [This comment describes the absence of certain code, so it
    // doesn't really belong in any of the generated files]

    // It messes things up to avoid instantiating a comparison between
    // "a" and "b" here, if they're going to turn out to be equal,
    // because we get lots of duplicate invariants that differ only in
    // containing a or b. Plus, to boot, you also get a LinearBinary
    // invariant with a=1 and b=0 that prints as "a == b", defeating
    // the original purpose of suppressing a stupid-looking invariant.
  #endif

  #if 0
    // This code is also removed because these sorts of static checks
    // can't be reliability performed with equality sets (just because
    // the leader is size-1 doesn't imply that each member is size-1

    { // Tests involving sequence lengths.
      SequenceLength sl1 = null;
      if (var1.isDerived() && (var1.derived instanceof SequenceLength))
        sl1 = (SequenceLength) var1.derived;
      SequenceLength sl2 = null;
      if (var2.isDerived() && (var2.derived instanceof SequenceLength))
        sl2 = (SequenceLength) var2.derived;

      // Avoid "size(a)-1 cmp size(b)-1"; use "size(a) cmp size(b)" instead.
      if ((sl1 != null) && (sl2 != null) &&
          ((sl1.shift == sl2.shift) && (sl1.shift != 0) || (sl2.shift != 0))) {
        // "size(a)-1 cmp size(b)-1"; should just use "size(a) cmp size(b)"
        Debug.log (debug, INTEQUAL.class, ppt,
               "Not instantiating, compare of form size(a)-1 op size(b)-1"
               + " var1= " + var1.name.name() + " var2= " + var2.name.name());
        return null;
      }
    }
  #endif
#endif

#if 0
This code needs to be re-inserted later, to avoid instantiation of certain
invariants.

    boolean only_eq = false;
    boolean obvious_lt = false;
    boolean obvious_gt = false;
    boolean obvious_le = false;
    boolean obvious_ge = false;

    // Commented out temporarily (October 24, 2001).
    if (false && (seqvar1 != null) && (seqvar2 != null)) {
      Derivation deriv1 = var1.derived;
      Derivation deriv2 = var2.derived;
      boolean min1 = (deriv1 instanceof SequenceMin);
      boolean max1 = (deriv1 instanceof SequenceMax);
      boolean min2 = (deriv2 instanceof SequenceMin);
      boolean max2 = (deriv2 instanceof SequenceMax);
      VarInfo super1 = seqvar1.isDerivedSubSequenceOf();
      VarInfo super2 = seqvar2.isDerivedSubSequenceOf();

      if (debug.isLoggable(Level.FINE)) {
        debug.fine (INTEQUALstring + ".instantiate: "
                            + "min1=" + min1
                            + ", max1=" + max1
                            + ", min2=" + min2
                            + ", max2=" + max2
                            + ", super1=" + super1
                            + ", super2=" + super2
                            + ", iom(var2, seqvar1)=" + MEMBER.isObviousMember(var2, seqvar1)
                            + ", iom(var1, seqvar2)=" + MEMBER.isObviousMember(var1, seqvar2));
      }
      if (seqvar1 == seqvar2) {
        // Both variables are derived from the same sequence.  The
        // invariant is obvious as soon as it's nonequal, because "all
        // elements equal" will be reported elsewhere.
        if (min1 || max2)
          obvious_lt = true;
        else if (max1 || min2)
          obvious_gt = true;
      } else if ((min1 || max1) && MEMBER.isObviousMember(var2, seqvar1)) {
        if (min1) {
          obvious_le = true;
        } else if (max1) {
          obvious_ge = true;
        }
      } else if ((min2 || max2) && MEMBER.isObviousMember(var1, seqvar2)) {
        if (min2) {
          obvious_ge = true;
        } else if (max2) {
          obvious_le = true;
        }
      } else if (((min1 && max2) || (max1 && min2))
                 && (super1 != null) && (super2 != null) && (super1 == super2)
                 && VarInfo.seqs_overlap(seqvar1, seqvar2)) {
        // If the sequences overlap, then clearly the min of either is no
        // greater than the max of the other.
        if (min1 && max2) {
          obvious_le = true;
          // System.out.println("obvious_le: " + var1.name + " " + var2.name);
        } else if (max1 && min2) {
          obvious_ge = true;
          // System.out.println("obvious_ge: " + var1.name + " " + var2.name);
        }
      }
    }
#endif

    return new INTEQUAL(ppt);
  }

#ifdef (EQUAL_OP)
  public boolean is_equality_inv() {
    return (true);
  }
#endif

  protected Invariant resurrect_done_swapped() {
    #if defined (EQUAL_OP) || defined (NONEQUAL_OP)
      // we don't care if things swap; we have symmetry
      return this;
    #else
      // we have no non-static member data, so we only need care about our type
      // As of now, the constructor chain is side-effect free;
      // let's hope it stays that way.
      INTEQUAL_SWAP result = new INTEQUAL_SWAP(ppt);
      return result;
    #endif
  }

#if (defined(EQUAL_OP) || defined(NONEQUAL_OP))
  public boolean is_symmetric() {
    return (true);
  }

#else

  /**
   * Returns the class that corresponds to this class with its variable
   * order swapped
   */
  public static Class swap_class () {
    return INTEQUAL_SWAP.class;
  }
#endif


  // Look up a previously instantiated INTEQUAL relationship.
  // Should this implementation be made more efficient?
  public static INTEQUAL find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity() == 2);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof INTEQUAL)
        return (INTEQUAL) inv;
    }
    return null;
  }


  public String repr() {
    return INTEQUALstring + varNames();
  }

  public String format_using(OutputFormat format) {
    String var1name = var1().name.name_using(format, var1());
    String var2name = var2().name.name_using(format, var2());


    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.ESCJAVA)
        || (format == OutputFormat.IOA))

    {
      String comparator = EQUALSstring;
      #if defined(EQUAL_OP)
        if (format == OutputFormat.IOA) comparator = "=";
      #elif defined(NONEQUAL_OP)
        if (format == OutputFormat.IOA) comparator = "~=";
      #endif
      return var1name + " " + comparator + " " + var2name;
    }


    if (format.isJavaFamily()) {
      #if defined(EQUALFLOAT)
        return Invariant.formatFuzzy("eq", var1(), var2(), format);
      #elif defined(NONEQUALFLOAT)
        return Invariant.formatFuzzy("ne", var1(), var2(), format);
      #elif defined(LESSTHANFLOAT)
        return Invariant.formatFuzzy("lt", var1(), var2(), format);
      #elif defined(LESSEQUALFLOAT)
        return Invariant.formatFuzzy("lte", var1(), var2(), format);
      #elif defined(GREATERTHANFLOAT)
        return Invariant.formatFuzzy("gt", var1(), var2(), format);
      #elif defined(GREATEREQUALFLOAT)
        return Invariant.formatFuzzy("gte", var1(), var2(), format);
      #else
        return var1name + " " + EQUALSstring + " " + var2name;
      #endif

    }

    if (format == OutputFormat.SIMPLIFY) {
      #if defined(EQUAL_OP)
        String comparator = "EQ";
      #elif defined(NONEQUAL_OP)
        String comparator = "NEQ";
      #else
        String comparator = EQUALSstring;
      #endif
      return "(" + comparator
        + " " + var1().simplifyFixup(var1name)
        + " " + var2().simplifyFixup(var2name) + ")";
    }

    return format_unimplemented(format);
  }

  public InvariantStatus check_modified(PRIMITIVE v1, PRIMITIVE v2, int count) {
    if (!(EQUALS(v1, v2))) {
      return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  public InvariantStatus add_modified(PRIMITIVE v1, PRIMITIVE v2, int count) {
    if (logDetail() || debug.isLoggable(Level.FINE))
      log (debug, "add_modified (" + v1 + ", " + v2 + ",  "
           + "ppt.num_values = " + ppt.num_values() + ")");
    if ((logOn() || debug.isLoggable(Level.FINE)) &&
        check_modified(v1, v2, count) == InvariantStatus.FALSIFIED)
      log (debug, "destroy in add_modified (" + v1 + ", " + v2 + ",  "
           + count + ")");

    return check_modified(v1, v2, count);
  }

  // This is very tricky, because whether two variables are equal should
  // presumably be transitive, but it's not guaranteed to be so when using
  // this method and not dropping out all variables whose values are ever
  // missing.
  protected double computeConfidence() {
    // Should perhaps check number of samples and be unjustified if too few
    // samples.

    #if defined(EQUAL_OP)
      // We MUST check if we have seen samples; otherwise we get
      // undesired transitivity with missing values.
      if (ppt.num_samples() == 0) {
        return Invariant.CONFIDENCE_UNJUSTIFIED;
      }

      // It's an equality invariant.  I ought to use the actual ranges somehow.
      // Actually, I can't even use this .5 test because it can make
      // equality non-transitive.
      // return Math.pow(.5, num_values());
      return Invariant.CONFIDENCE_JUSTIFIED;
    #else
      // // The reason for this multiplication is that there might be only a
      // // very few possible values.  Example:  towers of hanoi has only 6
      // // possible (pegA, pegB) pairs.
      // return 1 - (Math.pow(.5, ppt.num_values())
      //             * Math.pow(.99, ppt.num_mod_samples()));
      return 1 - Math.pow(.5, ppt.num_samples());
    #endif
  }

#if defined(EQUAL_OP)
  public boolean enoughSamples() {
    return (ppt.num_samples() > 0);
  }
#endif

  // For Comparison interface
  public double eq_confidence() {
    if (isExact())
      return getConfidence();
    else
      return Invariant.CONFIDENCE_NEVER;
  }

  public boolean isExact() {
    #if defined(EQUAL_OP)
      return true;
    #else
      return false;
    #endif
  }

  // // Temporary, for debugging
  // public void destroy() {
  //   if (debug.isLoggable(Level.FINE)) {
  //     System.out.println(INTEQUALstring + ".destroy(" + ppt.name() + ")");
  //     System.out.println(repr());
  //     (new Error()).printStackTrace();
  //   }
  //   super.destroy();
  // }

  public InvariantStatus add(Object v1, Object v2, int mod_index, int count) {
    if (debug.isLoggable(Level.FINE)) {
      debug.fine(INTEQUALstring + ppt.varNames() + ".add("
                 + v1 + "," + v2
                 + ", mod_index=" + mod_index + ")"
                 + ", count=" + count + ")");
    }
    return super.add(v1, v2, mod_index, count);
  }

  public boolean isSameFormula(Invariant other) {
    return true;
  }

  public boolean isExclusiveFormula(Invariant other) {

    // Also ought to check against LinearBinary, etc.
    #if defined(EQUAL_OP)
      if ((other instanceof INT(LessThan))
        || (other instanceof INT(GreaterThan))
        || (other instanceof INT(NonEqual)))
      return true;
    #endif

    #if defined(NONEQUAL_OP)
      if (other instanceof INT(Equal))
        return true;
    #endif

    #if defined(LESSTHAN_OP)
        if ((other instanceof INT(Equal))
            || (other instanceof INT(GreaterEqual))
            || (other instanceof INT(GreaterThan)))
          return true;
    #endif

    #if defined(GREATERTHAN_OP)
      if ((other instanceof INT(LessThan))
          || (other instanceof INT(LessEqual))
          || (other instanceof INT(Equal)))
        return true;
    #endif

    #if defined(LESSEQUAL_OP)
      if (other instanceof INT(GreaterThan))
        return true;
    #endif

    #if defined(GREATEREQUAL_OP)
      if (other instanceof INT(LessThan))
        return true;
    #endif

    return false;
  }

#if (defined(EQUAL_OP))
  /**
   *  Since this invariant can be a postProcessed equality, we have to
   *  handle isObvious especially to avoid circular isObvious
   *  relations.  We only check if this.ppt.var_infos imply
   *  obviousness rather than the cartesian product on the equality
   *  set.
   **/
  public DiscardInfo isObviousStatically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      return isObviousStatically(this.ppt.var_infos);
    } else {
      return super.isObviousStatically_SomeInEquality();
    }
  }

  /**
   *  Since this invariant can be a postProcessed equality, we have to
   *  handle isObvious especially to avoid circular isObvious
   *  relations.  We only check if this.ppt.var_infos imply
   *  obviousness rather than the cartesian product on the equality
   *  set.
   **/
  public DiscardInfo isObviousDynamically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      return isObviousDynamically(this.ppt.var_infos);
    } else {
      return super.isObviousDynamically_SomeInEquality();
    }
  }
#endif

  public DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    VarInfo var1 = vis[0];
    VarInfo var2 = vis[1];

    // If arithmetic equal
    #if (defined(EQUAL) || defined(EQUALFLOAT))
      // a+c=b+c is implied, because a=b must have also been reported.
      if ((var1.name instanceof VarInfoName.Add)
          && (var2.name instanceof VarInfoName.Add) &&
          ((((VarInfoName.Add) var1.name).amount)
          == (((VarInfoName.Add) var2.name).amount))) {
        return new DiscardInfo(this, DiscardCode.obvious,
          "Invariants of the form a+c==b+c are implied " +
          "since a==b is reported.");
        }
    #endif

    // Find the slice that corresponds to vis
    PptSlice ppt = this.ppt.parent.findSlice_unordered (vis);

    // If there is a matching slice
    if (ppt != null) {

      #if (defined (NONEQUAL_OP))
        // If we know x<y or x>y, then x!=y is uninteresting
        LESS_THAN_CLASS ilt = LESS_THAN_CLASS.find(ppt);
        if ((ilt != null) /* && ilt.enoughSamples() */ ) {
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          return new DiscardInfo(this, DiscardCode.obvious,
                        n1+"<"+n2+" or "+n1+">"+n2+" --> "+n1+"!="+n2);
        }
        GREATER_THAN_CLASS igt = GREATER_THAN_CLASS.find(ppt);
        if ((igt != null) /* && igt.enoughSamples() */ ) {
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          return new DiscardInfo(this, DiscardCode.obvious,
                        n1+"<"+n2+" or "+n1+">"+n2+" --> "+n1+"!="+n2);
        }
      #endif

      #if defined(LESSEQUAL_OP) || defined (GREATEREQUAL_OP)
        // If we know x=y, then any x<=y or x>=y comparison is uninteresting
        EQUAL_CLASS ie = EQUAL_CLASS.find(ppt);
        if ((ie != null) /* && ie.enoughSamples() */ ) {
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          return new DiscardInfo(this, DiscardCode.obvious, n1 + "==" + n2
                        + " --> " + n1 + ">=" + n2 + " and " + n1 + "<=" + n2);
        }
      #endif

      #if defined(LESSEQUAL_OP)
        // If we know x<y, then x<=y is uninteresting
        LESS_THAN_CLASS ilt = LESS_THAN_CLASS.find(ppt);
        if ((ilt != null) /* && ilt.enoughSamples() */ ) {
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          return new DiscardInfo(this, DiscardCode.obvious, n1 + "<" + n2
                      + " --> " + n1 + "<=" + n2);
        }
      #endif

      #if defined(GREATEREQUAL_OP)
        // If we know x>y, then x>=y is uninteresting
        GREATER_THAN_CLASS igt = GREATER_THAN_CLASS.find(ppt);
        if ((igt != null) /* && igt.enoughSamples() */ ) {
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          return new DiscardInfo(this, DiscardCode.obvious, n1 + ">" + n2
                                   + " --> " + n1 + ">=" + n2);
        }
      #endif


      #if defined(LESS) || defined(GREATER)
        // If we know y=x+c, then any x<y or x>y comparison is uninteresting
        LinearBinary lb = LinearBinary.find(ppt);
        if ((lb != null) && (lb.core.a == 1) && lb.enoughSamples()) {
          Assert.assertTrue(lb.core.b != 0);
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          return new DiscardInfo(this, DiscardCode.obvious, n1 + " and " + n2
                                  + " already satisfy " + lb.format());
        }
      #endif

      #if defined(LESSFLOAT) || defined(GREATERFLOAT)
        // If we know y=x+c, then any x<y or x>y comparison is uninteresting
        LinearBinaryFloat lb = LinearBinaryFloat.find(ppt);
        if ((lb != null) && (lb.core.a == 1) && lb.enoughSamples()) {
          Assert.assertTrue(lb.core.b != 0);
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          return new DiscardInfo(this, DiscardCode.obvious, n1 + " and " + n2
                                 + " already satisfy " + lb.format());
        }
      #endif
    }

// #ifndef EQUAL
//     { // Check for comparisons against constants
//       if (var1.isConstant() || (var2.isConstant())) {
//         // One of the two variables is constant.  Figure out which one.
//         VarInfo varconst;
//         VarInfo varnonconst;
//         boolean var1const = var1.isConstant();
//         boolean can_be_lt;
//         boolean can_be_gt;
//         if (var1const) {
//           varconst = var1;
//           varnonconst = var2;
//           can_be_lt = core.can_be_gt;
//           can_be_gt = core.can_be_lt;
//         } else {
//           varconst = var2;
//           varnonconst = var1;
//           can_be_lt = core.can_be_lt;
//           can_be_gt = core.can_be_gt;
//         }
//         // Now "varconst" and "varnonconst" are set.
//         long valconst = ((Long) varconst.constantValue()).longValue();
//         PptSlice1 nonconstslice = ppt.parent.findSlice(varnonconst);
//         if (nonconstslice != null) {
//           if (can_be_lt) {
//             UpperBound ub = UpperBound.find(nonconstslice);
//             if ((ub != null) && ub.enoughSamples() && ub.max() < valconst) {
//               return true;
//             }
//           } else {
//             LowerBound lb = LowerBound.find(nonconstslice);
//             if ((lb != null) && lb.enoughSamples() && lb.min() > valconst) {
//               return true;
//             }
//           }
//         }
//       }
//     }
// #endif

    #if defined (IS_NUMERIC)
    { // Sequence length tests
      SequenceLength sl1 = null;
      if (var1.isDerived() && (var1.derived instanceof SequenceLength))
        sl1 = (SequenceLength) var1.derived;
      SequenceLength sl2 = null;
      if (var2.isDerived() && (var2.derived instanceof SequenceLength))
        sl2 = (SequenceLength) var2.derived;

      // "size(a)-1 cmp size(b)-1" is never even instantiated;
      // use "size(a) cmp size(b)" instead.

      // This might never get invoked, as equality is printed out specially.
      VarInfo s1 = (sl1 == null) ? null : sl1.base;
      VarInfo s2 = (sl2 == null) ? null : sl2.base;
      if ((s1 != null) && (s2 != null)
          && (s1.equalitySet == s2.equalitySet)) {
        // lengths of equal arrays being compared
        String n1 = var1.name.name();
        String n2 = var2.name.name();
        return new DiscardInfo(this, DiscardCode.obvious, n1 + " and  " + n2
                            + " are equal arrays, so equal size is implied");
      }

      #if defined(LESSTHAN_OP)
        if ((sl2 != null) && (sl2.shift == 0)) {
          // "x < size(a)"
          // ("x <= size(a)-1" or "x < size(a)-1" would be more informative)
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          String discardString = "Invariants of the form x < size(a) "
                               + "suppressed since x <= size(a)-1 or "
                               + "x < size(a)-1 is preferred";
          return new DiscardInfo(this, DiscardCode.obvious, discardString);
        } else if ((sl1 != null) && (sl1.shift == -1)) {
          // "size(a)-1 < x"  ("size(a) <= x" would be more informative)
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          String discardString = "Invariants of the form size(a)-1 < x are "
                               + "suppressed since size(a) <= x is preferred";
          return new DiscardInfo(this, DiscardCode.obvious, discardString);
        }
      #elif defined(GREATERTHAN_OP)
        if ((sl1 != null) && (sl1.shift == 0)) {
          // "size(a) > x"  ("size(a) >= x" would be more informative)
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          String discardString = "Invariants of the form size(a)-1 > x are "
                               + "suppressed since size(a) >= x is preferred";
          return new DiscardInfo(this, DiscardCode.obvious, discardString);
        } else if ((sl2 != null) && (sl2.shift == -1)) {
          // "x > size(a)-1"  ("x >= size(a)" would be more informative)
          String n1 = var1.name.name();
          String n2 = var2.name.name();
          String discardString = "Invariants of the form x > size(a)-1 are "
                               + "suppressed sinec x >= size(a) is preferred";
          return new DiscardInfo(this, DiscardCode.obvious, discardString);
        }
      #endif
    }

    // If any of the vars are both constants, or if one is
    // a constant and the other has a bound,we are not
    // interested in any IntComparisons

    /* PptSlice1 slice1 = this.ppt.parent.findSlice(var1());
    if (slice1 != null) {
      PptSlice1 slice2 = this.ppt.parent.findSlice(var2());
      if (slice2 != null) {
        ONEOF oo1 = ONEOF.find(slice1);
        // Check if var1 is constant
        if ((oo1 != null) && (oo1.num_elts() == 1)) {
          LOWERBOUND lb = LOWERBOUND.find(slice2);
          if ((lb != null)  && lb.justified() && lb.enoughSamples() && !lb.hasUninterestingConstant()) {
            if (logOn())
              log ("Discarded because constant var and LOWERBOUND found. Bound is " + lb.min());
            return true;
          }
          UPPERBOUND ub = UPPERBOUND.find(slice2);
          if ((ub != null) && ub.justified() && ub.enoughSamples() && !ub.hasUninterestingConstant()) {
            if (logOn())
              log ("Discarded because constant var and UPPERBOUND found. Bound is " + ub.max());
            return true;
          }
        }
        ONEOF oo2 = ONEOF.find(slice2);
        // Check if var2 is constant
        if ((oo2 != null) && (oo2.num_elts() == 1)) {
          // Case where both var1 and var2 are constants
          if ((oo1 != null) && (oo1.num_elts() == 1)) {
            if (logOn())
              log ("Discarded because both variables are constants.");
            return true;
          }
          LOWERBOUND lb2 = LOWERBOUND.find(slice1);
          if ((lb2 != null) && lb2.justified() && lb2.enoughSamples() && !lb2.hasUninterestingConstant()) {
            if (logOn())
              log ("Discarded because LOWERBOUND and constant var found. Bound is " + lb2.min());
            return true;
          }
          UPPERBOUND ub2 = UPPERBOUND.find(slice1);
          if ((ub2 != null) && ub2.justified() && ub2.enoughSamples() && !ub2.hasUninterestingConstant()) {
            log ("Discarded because UPPERBOUND and constant var found. Bound is " + ub2.max());
            return true;
          }
        }
      }
      }*/

//     { // Sequence sum tests
//       SequenceSum ss1 = null;
//       if (var1.isDerived() && (var1.derived instanceof SequenceSum))
//         ss1 = (SequenceSum) var1.derived;
//       SequenceSum ss2 = null;
//       if (var2.isDerived() && (var2.derived instanceof SequenceSum))
//         ss2 = (SequenceSum) var2.derived;
//       if ((ss1 != null) && (ss2 != null)) {
//         EltLowerBound lb = null;
//         EltUpperBound ub = null;
//         boolean shorter1 = false;
//         boolean shorter2 = false;
//         PptTopLevel parent = ppt.parent;
//         if (SubSequence.isObviousDerived(ss1.base, ss2.base)) {
//           lb = EltLowerBound.find(parent.findSlice(ss2.base));
//           ub = EltUpperBound.find(parent.findSlice(ss2.base));
//           shorter1 = true;
//         } else if (SubSequence.isObviousDerived(ss2.base, ss1.base)) {
//           lb = EltLowerBound.find(parent.findSlice(ss1.base));
//           ub = EltUpperBound.find(parent.findSlice(ss1.base));
//           shorter2 = true;
//         }
//         if ((lb != null) && (!lb.enoughSamples()))
//           lb = null;
//         if ((ub != null) && (!ub.enoughSamples()))
//           ub = null;
//         // We are comparing sum(a) to sum(b).
//         boolean shorter_can_be_lt;
//         boolean shorter_can_be_gt;
//         if (shorter1) {
//           shorter_can_be_lt = core.can_be_lt;
//           shorter_can_be_gt = core.can_be_gt;
//         } else {
//           shorter_can_be_lt = core.can_be_gt;
//           shorter_can_be_gt = core.can_be_lt;
//         }
//         if (shorter_can_be_lt
//             && (lb != null) && ((lb.min() > 0)
//                                 || (core.can_be_eq && lb.min() == 0))) {
//           return true;
//         }
//         if (shorter_can_be_gt
//             && (ub != null) && ((ub.max() < 0)
//                                 || (core.can_be_eq && ub.max() == 0))) {
//           return true;
//         }
//       }
//     }

//     {
//       // (Is this test ever true?  Aren't SeqINTEQUAL and
//       // INTEQUAL instantiated at the same time?  Apparently not:  see
//       // the printStackTrace below.
//
//       // For each sequence variable, if this is an obvious member, and
//       // it has the same invariant, then this one is obvious.
//       PptTopLevel pptt = ppt.parent;
//       for (int i=0; i<pptt.var_infos.length; i++) {
//         VarInfo vi = pptt.var_infos[i];
//         if (Member.isObviousMember(var1, vi)) {
//           PptSlice2 other_slice = pptt.findSlice_unordered(vi, var2);
//           if (other_slice != null) {
//             SeqINTEQUAL sic = SeqINTEQUAL.find(other_slice);
//             if ((sic != null)
//                 && sic.enoughSamples()) {
//               // This DOES happen; verify by running on replace.c
//               // System.out.println("Surprise:  this can happen (var1 in INTEQUAL).");
//               // new Error().printStackTrace();
//               return true;
//             }
//           }
//         }
//         if (Member.isObviousMember(var2, vi)) {
//           PptSlice2 other_slice = pptt.findSlice_unordered(vi, var1);
//           if (other_slice != null) {
//             SeqINTEQUAL sic = SeqINTEQUAL.find(other_slice);
//             if ((sic != null)
//                 && sic.enoughSamples()) {
//               // This DOES happen
//               // System.out.println("Surprise:  this can happen (var2 in " + INTEQUALstring + ").");
//               // new Error().printStackTrace();
//               return true;
//             }
//           }
//         }
//       }
//     }
    #endif

    return null;
  } // isObviousDynamically

#if defined(EQUAL) || defined(EQUALFLOAT)
#endif

#if defined (LESSTHAN) || defined (GREATERTHAN) || defined (LESSTHANFLOAT) || defined (GREATERTHANFLOAT)

  /**
   * Suppression in the form y = x + b ==> y EQUALSstring x (where b EQUALSstring 0).
   */
  public static SuppressionLink lb_suppress (INTEQUAL inv,
                 SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression by LinearBinary (x = y + c)");

    // Setup to look for LinearBinary over our variables
    supTemplate.resetResults();
    supTemplate.set(0, LINEARBINARY.class, inv.var1(), inv.var2());

    // look for invariants that match our template
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (sl != null) {

      LINEARBINARY lb = (LINEARBINARY) supTemplate.results[0];

      // If the invariant isn't active, we can't use it
      if (!lb.isActive())
        return (null);

      // Only 'a == 1' implies a less than or greater than relationship
      if (lb.core.a != 1.0)
        return (null);

      // b determines whether we are greater than or less than
      if (EQUALS (lb.core.b, 0))
        return (null);

      if (logOn() || debug.isLoggable(Level.FINE)) {
        inv.log (debug, " Suppressed by " + lb.format());
      }
    }
    return (sl);
  }
  /**
   * Suppression in the form y = x-1 + b ==> y EQUALSstring x
   * (where b EQUALSstring 1).
   */
  public static SuppressionLink lb_offset_suppress (INTEQUAL inv,
                 SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression by LinearBinary (x = size(y)-1 + c)");

    boolean v1_shift = false;
    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();
    SequenceLength v1_size = null;
    if (v1.isDerived() && (v1.derived instanceof SequenceLength))
      v1_size = (SequenceLength) v1.derived;
    SequenceLength v2_size = null;
    if (v2.isDerived() && (v2.derived instanceof SequenceLength))
      v2_size = (SequenceLength) v2.derived;

    // If neither is a size(array[]) this doesn't apply
    if ((v1_size == null) && (v2_size == null))
      return (null);

    // Determine which var (if any) is shifted (shift == -1).  We are
    // only interested in cases where only one of the arguments is
    // shifted.  If both are shifted, then there should be a
    // suppression directly from the same comparison on the unshifted
    // versions.
    if ((v1_size != null) && (v2_size != null)) {
      if (v1_size.isSameFormula (v2_size))
        return (null);
      v1_shift = v1_size.shift == -1;
    } else if ((v1_size != null) && (v1_size.shift == -1)) {
      v1_shift = true;
    } else if ((v2_size != null) && (v2_size.shift == -1)) {
      v1_shift = false;
    } else {
      return (null);
    }

    // Setup to look for LinearBinary on the unshifted variable
    supTemplate.resetResults();
    if (v1_shift) {
      SequenceLength sl = new SequenceLength (v1_size.base, 0);
      VarInfo v = sl.getVarInfo();
      v = inv.ppt.parent.findVar (v.name);
      supTemplate.set(0, LINEARBINARY.class, v, v2);
    } else {
      SequenceLength sl = new SequenceLength (v2_size.base, 0);
      VarInfo v = sl.getVarInfo();
      v = inv.ppt.parent.findVar (v.name);
      supTemplate.set(0, LINEARBINARY.class, v1, v);
    }

    // look for invariants that match our template
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (sl != null) {

      LINEARBINARY lb = (LINEARBINARY) supTemplate.results[0];

      // If the invariant isn't active, we can't use it
      if (!lb.isActive())
        return (null);

      // Only 'a == 1' implies a less than or greater than relationship
      if (lb.core.a != 1.0)
        return (null);

      // b determines whether we are greater than or less than
      if (v1_shift) {
        if (EQUALS (lb.core.b, -1))
          return (null);
      } else {
        if (EQUALS (lb.core.b, 1))
          return (null);
      }

      if (logOn() || debug.isLoggable(Level.FINE)) {
        inv.log (debug, " Suppressed by " + lb.format() + " v1_shift = "
                + v1_shift + " equals = " + EQUALSstring);
      }
    }
    return (sl);
  }

#endif

  // It appears as though some special stuff happens with Bounds and
  // OneOf's, so I'll leave the next 3 suppressions out for now and
  // come back to it later. -Jelani 7/30/2003
#if !(defined(EQUAL) || defined(EQUALFLOAT) || defined(NONEQUAL) || defined(NONEQUALFLOAT) || defined(IS_STRING))
  /**
   * Suppression in the form x LESSTHAN a and y GREATERTHAN b and a LESSTHAN b ==> x LESSTHAN y
   */
  public static SuppressionLink bound_suppress (INTEQUAL inv,
                 SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression of the form ((x cmp a) ^ (y inverse_cmp b) ^ (a cmp b) ==> x cmp y)");

    // Setup to look for Bound's
    supTemplate.resetResults();
    supTemplate.set(0, UPPER_BD.class, inv.var1());
    supTemplate.set(1, LOWER_BD.class, inv.var2());

    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (sl != null) {
      UPPER_BD ub = (UPPER_BD) supTemplate.results[0];
      LOWER_BD lb = (LOWER_BD) supTemplate.results[1];

      // Check to make sure the Bounds have actually been set
      if ((lb.ppt.num_samples() == 0) || (ub.ppt.num_samples() == 0))
        return null;

      INT_TYPE max = ub.UB_MAX;
      INT_TYPE min = lb.LB_MIN;

      if (! EQUALS(max, min) )
        return null;

    }
    return sl;
  }
#endif

  #if !(defined(EQUAL) || defined(EQUALFLOAT) || defined(NONEQUAL) || defined(NONEQUALFLOAT) || defined (IS_STRING))
  /**
   * Suppression in the form x one of A={a,b,c} and y GREATERTHAN d and maxA LESSTHAN d ==> x LESSTHAN y
   */
  public static SuppressionLink bound_one_of_suppress (INTEQUAL inv,
                 SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression of the form ((x cmp a) ^ (y inverse_cmp b) ^ (a cmp b) ==> x cmp y)");

    // Setup to look for Bound's
    supTemplate.resetResults();
    supTemplate.set(0, ONEOF.class, inv.var1());
    supTemplate.set(1, LOWER_BD.class, inv.var2());

    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (sl != null) {
      ONEOF oo = (ONEOF) supTemplate.results[0];
      LOWER_BD lb = (LOWER_BD) supTemplate.results[1];

      // Check to make sure the Bound has actually been set
      if ((lb.ppt.num_samples() == 0) || (oo.num_elts() == 0))
        return null;

      INT_TYPE[] elts = oo.getElts();

      // Find the max (or min for GreaterThan-type invariants) of
      // the OneOf set
      INT_TYPE max = elts[0];
      if (oo.num_elts() > 1) {
        for (int i=1; i<elts.length; i++) {
          if (EQUALS(max, elts[i]))
            max = elts[i];
        }
      }

      INT_TYPE min = lb.LB_MIN;

      if (! EQUALS(max, min) )
        return null;

    }
    return sl;
  }
#endif

  /**
   * Suppression in the form x one of A={a, b, c} and y one of B={d,
   * e, f} and m EQUALSstring n for all m in A,<br> n in B ==> x
   * EQUALSstring y
   */
  public static SuppressionLink one_of_suppress (INTEQUAL inv,
                 SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression of the form ((x one of A={a,b,c}) ^ (y one of B={d,e,f}) ^ (m cmp n for all" +
                "m in A, n in B)) ==> x cmp y");

    // Setup to look for OneOf's over our variables
    supTemplate.resetResults();
    supTemplate.set(0, ONEOF.class, inv.var1());
    supTemplate.set(1, ONEOF.class, inv.var2());

    // look for invariants that match our template
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (sl != null) {

      ONEOF oo1 = (ONEOF) supTemplate.results[0];
      ONEOF oo2 = (ONEOF) supTemplate.results[1];

      #if (defined(EQUAL) || defined(EQUALFLOAT))
      // Not interested if both variables are not constants
      if ((oo1.num_elts() != 1) || (oo2.num_elts() != 1))
        return (null);
      #endif

      INT_TYPE[] elts1 = oo1.getElts();
      INT_TYPE[] elts2 = oo2.getElts();

      #if !(defined(EQUAL) || defined(EQUALFLOAT))
      // The EQUALSstring relationship must hold on all combinations
      // of constants that the vars are equal to.  This could be made
      // asymptotically faster by first sorting both arrays, but since
      // OneOf arrays are never bigger than length 3, it's not worth
      // it
      for (int i=0; i < elts1.length; i++) {
        for (int j=0; j < elts2.length; j++) {
          if (! EQUALS(elts1[i], elts2[j]) )
            return (null);
        }
      }
      #else
      if (! EQUALS(elts1[0], elts2[0]) )
        return (null);
      #endif

      if (logOn() || debug.isLoggable(Level.FINE)) {
        inv.log (debug, " Suppressed by " + oo1.format() + " and " + oo2.format());
      }
    }
    return (sl);
    }

#if !defined (NOTEQUAL) && !defined (NOTEQUALFLOAT) && !defined(IS_STRING)
  /**
   * Suppress 'x[n] cmp y[n]' by 'x[] cmp y[]'.
   */
  public static SuppressionLink pairwise_suppress(INTEQUAL inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression by 'x[] cmp y[] (elementwise)'");

    // Make sure v1 and v2 are SEQ_SUBSCRIPT with the same subscript
    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();
    if (!v1.isDerived() || !(v1.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    if (!v2.isDerived() || !(v2.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    SEQ_SUBSCRIPT der1 = (SEQ_SUBSCRIPT) v1.derived;
    SEQ_SUBSCRIPT der2 = (SEQ_SUBSCRIPT) v2.derived;
    if ((der1.sclvar() != der2.sclvar())
        || (der1.index_shift != der2.index_shift))
      return (null);

    #if (defined(NONEQUAL) || defined(NONEQUALFLOAT))
    return null;
    #else
    // Build a template for PAIRWISE_COMPARE
    supTemplate.set(0, PAIRWISE_COMPARE.class, der1.seqvar(), der2.seqvar());

    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (logOn() && (sl!=null)) {
      PAIRWISE_COMPARE pw = (PAIRWISE_COMPARE) supTemplate.results[0];
      inv.log ("Suppressed by '" + pw.format() +"'");
    }
    return (sl);
    #endif
  }
#endif

#if defined(EQUAL)

  /**
   * Suppress 'size(x[]) == size(y[])' by 'x[] == y[]'.
   */

  public static SuppressionLink seqlen_suppress (INTEQUAL inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression of 'size(x[]) == size(y[])' "
                + "by 'x[] == y[]'");

    // Make sure v1 and v2 are size(array) with the same shift
    VarInfo v1 = inv.var1();
    if (!v1.isDerived() || !(v1.derived instanceof SequenceLength))
      return (null);
    VarInfo v2 = inv.var2();
    if (!v2.isDerived() || !(v2.derived instanceof SequenceLength))
      return (null);
    if (!v1.derived.isSameFormula (v2.derived))
      return (null);

    // Build a template for arr1 == arr2 of the correct type
    supTemplate.resetResults();
    VarInfo bv1 = v1.derived.getBases()[0];
    VarInfo bv2 = v2.derived.getBases()[0];
    if (bv1.rep_type.baseIsString())
      supTemplate.set(0, SeqSeqStringEqual.class, bv1, bv2);
    else if (bv1.rep_type.baseIsFloat())
      supTemplate.set(0, SeqSeqFloatEqual.class, bv1, bv2);
    else
      supTemplate.set(0, SeqSeqIntEqual.class, bv1, bv2);
    if (logOn())
      inv.log ("Suppression Template - " + supTemplate.searchString());

    // Invariants must match and represent equality
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (sl == null)
      inv.log ("invariant not suppressed (SeqComparison not found)");
    return (sl);
  }

  /**
   * Suppress 'x[a] == y[a]' by 'x[] == y[]' when a is the same variable.
   */

  public static SuppressionLink seq_equal_suppress (INTEQUAL inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression of 'x[a] == y[a])' "
                + "by 'x[] == y[]'");

    // Make sure v1 and v2 are SEQ_SUBSCRIPT with the same subscript
    VarInfo v1 = inv.var1();
    if (!v1.isDerived() || !(v1.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    VarInfo v2 = inv.var2();
    if (!v2.isDerived() || !(v2.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    SEQ_SUBSCRIPT der1 = (SEQ_SUBSCRIPT) v1.derived;
    SEQ_SUBSCRIPT der2 = (SEQ_SUBSCRIPT) v2.derived;
    if ((der1.sclvar() != der2.sclvar())
        || (der1.index_shift != der2.index_shift))
      return (null);

    // Build a template for lexical comparison
    supTemplate.set(0, SEQSEQINTEQUAL.class, der1.seqvar(), der2.seqvar());

    // Matching invariants must represent equality
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (sl != null) {
      SEQSEQINTEQUAL seq = (SEQSEQINTEQUAL) supTemplate.results[0];
      if (logOn())
        inv.log ((seq.isEqual() ? "" : "Not ") + "suppressed by '"
                + seq.format() +"'");
      if (!seq.isEqual())
        sl = null;
    }
    return (sl);
  }
  /**
   * Suppress 'x[a] == y[b]' by 'x[] == y[]' and 'a == b'.
   */

  public static SuppressionLink seq_sub_equal_suppress (INTEQUAL inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression of 'x[a] == y[b])' "
                + "by 'x[] == y[]' and 'a == b'");

    // Make sure v1 and v2 are SEQ_SUBSCRIPT with the same shift
    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();
    if (!v1.isDerived() || !(v1.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    if (!v2.isDerived() || !(v2.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    SEQ_SUBSCRIPT der1 = (SEQ_SUBSCRIPT) v1.derived;
    SEQ_SUBSCRIPT der2 = (SEQ_SUBSCRIPT) v2.derived;
    if (der1.index_shift != der2.index_shift)
      return (null);

    // Build a template for sequences being equal
    supTemplate.set(0, SEQSEQINTEQUAL.class, der1.seqvar(), der2.seqvar());

    // Build a template for the subscripts being equal
    supTemplate.set(1, INTEQUAL.class, der1.sclvar(), der2.sclvar());

    // Matching sequence invariants must represent equality.  The INTEQUAL
    // invariant for the subscripts only exists if they are equal.
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    if (sl != null) {
      SEQSEQINTEQUAL seq = (SEQSEQINTEQUAL) supTemplate.results[0];
      if (logOn()) {
        Invariant eq = supTemplate.results[1];
        inv.log ((seq.isEqual() ? "" : "Not ") + "suppressed by '"
                + seq.format() +"'" + " and '" + eq.format() + "'");
      }
      if (!seq.isEqual())
        sl = null;
    }
    return (sl);
  }

#endif

#if defined(NONEQUAL) || defined(NONEQUALFLOAT)

  /**
   * Suppress invariants of the form 'x[n] != x[p]' by the
   * 'x[] contains no duplicates' invariant, along with 'n != p'
   */

  public static SuppressionLink nodups_suppress (INTEQUAL inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    if (logOn())
      inv.log ("Considering suppression by NoDuplicates");

    // Make sure v1 and v2 are SEQ_SUBSCRIPT from the same array
    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();
    if (!v1.isDerived() || !(v1.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    if (!v2.isDerived() || !(v2.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    SEQ_SUBSCRIPT der1 = (SEQ_SUBSCRIPT) v1.derived;
    SEQ_SUBSCRIPT der2 = (SEQ_SUBSCRIPT) v2.derived;
    if (der1.seqvar() != der2.seqvar())
      return (null);

    // Build a template for NO_DUPS
    supTemplate.set(0, NO_DUPS.class, der1.seqvar());

    // Build a template for the subscripts being different
    // Note that INTEQUAL is defined as IntNonEqual (or float) here
    supTemplate.set(1, INTEQUAL.class, der1.sclvar(), der2.sclvar());

    // Any match suppresses
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    return (sl);
  }
#endif

#ifdef 0
  // The following creates the correct factories based on the comparison
  // type.  This is the only place where it is necessary to know all of the
  // suppressions that can be used on a particular type.  The code above can
  // safely define suppressions independent of one another
#endif

#define FACTORY_INVCLASS INTEQUAL

#if defined(NONEQUAL) || defined(NONEQUALFLOAT)

  // Create a suppression factory for nodups and constant
  #define FACTORY_CNT       1
  #define FACTORY1          nodups_suppress
  #define FACTORY1_INV_CNT  2
  #define FACTORY1_VAR_INFO {new VarInfo[1], new VarInfo[2]}
  #if 0
    // #define FACTORY2          one_of_suppress
    // #define FACTORY2_INV_CNT  2
    // #define FACTORY2_VAR_INFO {new VarInfo[1], new VarInfo[1]}
  #endif
  #include "daikon/inv/suppressionFactory.java.jpp"

#elif defined (LESSTHAN) || defined (LESSTHANFLOAT) || defined (GREATERTHAN) || defined (GREATERTHANFLOAT)

  // Create a suppression factory for linear binary, constant, and pairwise
  #define FACTORY_CNT       3
  #define FACTORY1          lb_suppress
  #define FACTORY1_INV_CNT  1
  #define FACTORY1_VAR_INFO {new VarInfo[2]}
  #define FACTORY2          pairwise_suppress
  #define FACTORY2_INV_CNT  1
  #define FACTORY2_VAR_INFO {new VarInfo[2]}
  #define FACTORY3          lb_offset_suppress
  #define FACTORY3_INV_CNT  1
  #define FACTORY3_VAR_INFO {new VarInfo[2]}
  #if 0
    // #define FACTORY3          bound_suppress
    // #define FACTORY3_INV_CNT  2
    // #define FACTORY3_VAR_INFO {new VarInfo[1], new VarInfo[1]}
    // #define FACTORY4          bound_one_of_suppress
    // #define FACTORY4_INV_CNT  2
    // #define FACTORY4_VAR_INFO {new VarInfo[1], new VarInfo[1]}
    // #define FACTORY3          one_of_suppress
    // #define FACTORY3_INV_CNT  2
    // #define FACTORY3_VAR_INFO {new VarInfo[1], new VarInfo[1]}
  #endif
  #include "daikon/inv/suppressionFactory.java.jpp"

#elif defined (LESSEQUAL) || defined (LESSEQUALFLOAT) || defined (GREATEREQUAL) || defined (GREATEREQUALFLOAT)

  // Create a suppression factory for pairwise and constant
  #define FACTORY_CNT       1
  #define FACTORY1          pairwise_suppress
  #define FACTORY1_INV_CNT  1
  #define FACTORY1_VAR_INFO {new VarInfo[2]}
  #if 0
    // #define FACTORY2          bound_suppress
    // #define FACTORY2_INV_CNT  2
    // #define FACTORY2_VAR_INFO {new VarInfo[1], new VarInfo[1]}
    // #define FACTORY3          bound_one_of_suppress
    // #define FACTORY3_INV_CNT  2
    // #define FACTORY3_VAR_INFO {new VarInfo[1], new VarInfo[1]}
    // #define FACTORY2          one_of_suppress
    // #define FACTORY2_INV_CNT  2
    // #define FACTORY2_VAR_INFO {new VarInfo[1], new VarInfo[1]}
  #endif
  #include "daikon/inv/suppressionFactory.java.jpp"

#elif defined (EQUAL)

  // Create suppression factory for pairwise, seqlen, seq_equal, seq_sub_equal, and constant
  #define FACTORY_CNT       4
  #define FACTORY1          pairwise_suppress
  #define FACTORY1_INV_CNT  1
  #define FACTORY1_VAR_INFO {new VarInfo[2]}
  #define FACTORY2          seqlen_suppress
  #define FACTORY2_INV_CNT  1
  #define FACTORY2_VAR_INFO {new VarInfo[2]}
  #define FACTORY3          seq_equal_suppress
  #define FACTORY3_INV_CNT  1
  #define FACTORY3_VAR_INFO {new VarInfo[2]}
  #define FACTORY4          seq_sub_equal_suppress
  #define FACTORY4_INV_CNT  2
  #define FACTORY4_VAR_INFO {new VarInfo[2], new VarInfo[2]}
  #if 0
    // #define FACTORY5          one_of_suppress
    // #define FACTORY5_INV_CNT  2
    // #define FACTORY5_VAR_INFO {new VarInfo[1], new VarInfo[1]}
  #endif
  #include "daikon/inv/suppressionFactory.java.jpp"

#endif



}
