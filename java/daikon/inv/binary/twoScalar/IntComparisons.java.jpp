#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(EQUAL) || defined(NONEQUAL) || defined(LESSTHAN) || defined(LESSEQUAL) || defined(GREATERTHAN) || defined(GREATEREQUAL) || defined(EQUALFLOAT) || defined(NONEQUALFLOAT) || defined(LESSTHANFLOAT) || defined(LESSEQUALFLOAT) || defined(GREATERTHANFLOAT) || defined(GREATEREQUALFLOAT))
#error "EQUAL, NONEQUAL, LESSTHAN, LESSEQUAL, GREATERTHAN, or GREATEREQUAL should be defined"
#endif

#if (defined(EQUAL) || defined(NONEQUAL) || defined(LESSTHAN) || defined(LESSEQUAL) || defined(GREATERTHAN) |\
| defined(GREATEREQUAL))
#  define PRIMITIVE long
#  define ISTYPE isIntegral()
#  define SUPERCLASS TwoScalar
#  define MEMBER Member
#  define VALUETRACKER ValueTracker
#  define INT(x) Int ## x
#else
#  define PRIMITIVE double
#  define ISTYPE isFloat()
#  define SUPERCLASS TwoFloat
#  define MEMBER Member
#  define VALUETRACKER FloatValueTracker
#  define INT(x) Float ## x
#endif

#if defined(EQUAL)
#  define INTEQUAL IntEqual
#  define INTEQUALstring "IntEqual"
#  define EQUALS ==
#  define EQUALSstring "=="
#  define SEQINTEQUAL seqIntEqual
#elif defined(EQUALFLOAT)
#  define INTEQUAL FloatEqual
#  define INTEQUALstring "FloatEqual"
#  define EQUALS ==
#  define EQUALSstring "=="
#  define SEQINTEQUAL seqIntEqual
#elif defined(NONEQUAL)
#  define INTEQUAL IntNonEqual
#  define INTEQUALstring "IntNonEqual"
#  define EQUALS !=
#  define EQUALSstring "!="
#  define SEQINTEQUAL seqIntNonEqual
#elif defined(NONEQUALFLOAT)
#  define INTEQUAL FloatNonEqual
#  define INTEQUALstring "FloatNonEqual"
#  define EQUALS !=
#  define EQUALSstring "!="
#  define SEQINTEQUAL seqIntNonEqual
#elif defined(LESSTHAN)
#  define INTEQUAL IntLessThan
#  define INTEQUAL_SWAP IntGreaterThan
#  define INTEQUALstring "IntLessThan"
#  define EQUALS <
#  define EQUALSstring "<"
#  define SEQINTEQUAL seqIntLessThan
#elif defined(LESSTHANFLOAT)
#  define INTEQUAL FloatLessThan
#  define INTEQUAL_SWAP FloatGreaterThan
#  define INTEQUALstring "FloatLessThan"
#  define EQUALS <
#  define EQUALSstring "<"
#  define SEQINTEQUAL seqIntLessThan
#elif defined(LESSEQUAL)
#  define INTEQUAL IntLessEqual
#  define INTEQUAL_SWAP IntGreaterEqual
#  define INTEQUALstring "IntLessEqual"
#  define EQUALS <=
#  define EQUALSstring "<="
#  define SEQINTEQUAL seqIntLessEqual
#elif defined(LESSEQUALFLOAT)
#  define INTEQUAL FloatLessEqual
#  define INTEQUAL_SWAP FloatGreaterEqual
#  define INTEQUALstring "FloatLessEqual"
#  define EQUALS <=
#  define EQUALSstring "<="
#  define SEQINTEQUAL seqIntLessEqual
#elif defined(GREATERTHAN)
#  define INTEQUAL IntGreaterThan
#  define INTEQUAL_SWAP IntLessThan
#  define INTEQUALstring "IntGreaterThan"
#  define EQUALS >
#  define EQUALSstring ">"
#  define SEQINTEQUAL seqIntGreaterThan
#elif defined(GREATERTHANFLOAT)
#  define INTEQUAL FloatGreaterThan
#  define INTEQUAL_SWAP FloatLessThan
#  define INTEQUALstring "FloatGreaterThan"
#  define EQUALS >
#  define EQUALSstring ">"
#  define SEQINTEQUAL seqIntGreaterThan
#elif defined(GREATEREQUAL)
#  define INTEQUAL IntGreaterEqual
#  define INTEQUAL_SWAP IntLessEqual
#  define INTEQUALstring "IntGreaterEqual"
#  define EQUALS >=
#  define EQUALSstring ">="
#  define SEQINTEQUAL seqIntGreaterEqual
#elif defined(GREATEREQUALFLOAT)
#  define INTEQUAL FloatGreaterEqual
#  define INTEQUAL_SWAP FloatLessEqual
#  define INTEQUALstring "FloatGreaterEqual"
#  define EQUALS >=
#  define EQUALSstring ">="
#  define SEQINTEQUAL seqIntGreaterEqual
#else
#  error "Impossible"
#endif
#if (defined(EQUAL) || defined(EQUALFLOAT))
#define IMPLEMENTSCOMPARISON implements Comparison
#else
#  define IMPLEMENTSCOMPARISON
#  define TRACK_NUM_VALUES
#endif

// ***** This file is automatically generated from IntComparisons.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.binary.sequenceScalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.derive.*;
import daikon.derive.unary.*;

import utilMDE.*;

import org.apache.log4j.Category;

import java.util.*;

public final class INTEQUAL
  extends SUPERCLASS IMPLEMENTSCOMPARISON
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff INTEQUAL invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  public static final Category debug
    = Category.getInstance("daikon.inv.binary.twoScalar." + INTEQUALstring);

#ifdef TRACK_NUM_VALUES
  private VALUETRACKER values_cache = new VALUETRACKER(8);

  protected Object clone() {
    INTEQUAL result = (INTEQUAL) super.clone();
    result.values_cache = (VALUETRACKER) values_cache.clone();
    return result;
  }
#endif

  protected INTEQUAL(PptSlice ppt) {
    super(ppt);
  }

  public static INTEQUAL instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;

    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];
    VarInfo seqvar1 = var1.isDerivedSequenceMember();
    VarInfo seqvar2 = var2.isDerivedSequenceMember();

#if !(defined(EQUAL) || defined(EQUALFLOAT))
    if (! (var1.file_rep_type.ISTYPE && var2.file_rep_type.ISTYPE)) {
      return null;
    }
#endif


    if (debug.isDebugEnabled() || ppt.debugged) {
      debug.debug(INTEQUALstring + ".instantiate(" + ppt.name + ")"
                          + ", seqvar1=" + seqvar1
                          + ", seqvar2=" + seqvar2);
    }

    { // Tests involving sequence lengths.

      SequenceLength sl1 = null;
      if (var1.isDerived() && (var1.derived instanceof SequenceLength))
        sl1 = (SequenceLength) var1.derived;
      SequenceLength sl2 = null;
      if (var2.isDerived() && (var2.derived instanceof SequenceLength))
        sl2 = (SequenceLength) var2.derived;

      // Avoid "size(a)-1 cmp size(b)-1"; use "size(a) cmp size(b)" instead.
      if ((sl1 != null) && (sl2 != null)
          && ((sl1.shift == sl2.shift) && (sl1.shift != 0) || (sl2.shift != 0))) {
        // "size(a)-1 cmp size(b)-1"; should just use "size(a) cmp size(b)"
        return null;
      }
    }

    boolean only_eq = false;
    boolean obvious_lt = false;
    boolean obvious_gt = false;
    boolean obvious_le = false;
    boolean obvious_ge = false;

    // Commented out temporarily (October 24, 2001)
    if (false && (seqvar1 != null) && (seqvar2 != null)) {
      Derivation deriv1 = var1.derived;
      Derivation deriv2 = var2.derived;
      boolean min1 = (deriv1 instanceof SequenceMin);
      boolean max1 = (deriv1 instanceof SequenceMax);
      boolean min2 = (deriv2 instanceof SequenceMin);
      boolean max2 = (deriv2 instanceof SequenceMax);
      VarInfo super1 = seqvar1.isDerivedSubSequenceOf();
      VarInfo super2 = seqvar2.isDerivedSubSequenceOf();

      if (debug.isDebugEnabled() || ppt.debugged) {
        debug.debug(INTEQUALstring + ".instantiate: "
                            + "min1=" + min1
                            + ", max1=" + max1
                            + ", min2=" + min2
                            + ", max2=" + max2
                            + ", super1=" + super1
                            + ", super2=" + super2
                            + ", iom(var2, seqvar1)=" + MEMBER.isObviousMember(var2, seqvar1)
                            + ", iom(var1, seqvar2)=" + MEMBER.isObviousMember(var1, seqvar2));
      }
      if (seqvar1 == seqvar2) {
        // Both variables are derived from the same sequence.  The
        // invariant is obvious as soon as it's nonequal, because "all
        // elements equal" will be reported elsewhere.
        if (min1 || max2)
          obvious_lt = true;
        else if (max1 || min2)
          obvious_gt = true;
      } else if ((min1 || max1) && MEMBER.isObviousMember(var2, seqvar1)) {
        if (min1) {
          obvious_le = true;
        } else if (max1) {
          obvious_ge = true;
        }
      } else if ((min2 || max2) && MEMBER.isObviousMember(var1, seqvar2)) {
        if (min2) {
          obvious_ge = true;
        } else if (max2) {
          obvious_le = true;
        }
      } else if (((min1 && max2) || (max1 && min2))
                 && (super1 != null) && (super2 != null) && (super1 == super2)
                 && VarInfo.seqs_overlap(seqvar1, seqvar2)) {
        // If the sequences overlap, then clearly the min of either is no
        // greater than the max of the other.
        if (min1 && max2) {
          obvious_le = true;
          // System.out.println("obvious_le: " + var1.name + " " + var2.name);
        } else if (max1 && min2) {
          obvious_ge = true;
          // System.out.println("obvious_ge: " + var1.name + " " + var2.name);
        }
      }
    }

    return new INTEQUAL(ppt);
  }

  protected Invariant resurrect_done_swapped() {
#if defined(EQUAL) || defined(EQUALFLOAT) || defined(NONEQUAL) || defined(NONEQUALFLOAT)
    // we don't care if things swap; we have symmetry
    return this;
#else
    // we have no non-static member data, so we only need care about our type
    // As of now, the constructor chain is side-effect free;
    // let's hope it stays that way.
    return new INTEQUAL_SWAP(ppt);
#endif
  }

  // Look up a previously instantiated INTEQUAL relationship.
  // Should this implementation be made more efficient?
  public static INTEQUAL find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 2);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof INTEQUAL)
        return (INTEQUAL) inv;
    }
    return null;
  }


  public String repr() {
    return INTEQUALstring + varNames();
  }

  public String format_using(OutputFormat format) {
    String var1name = var1().name.name_using(format);
    String var2name = var2().name.name_using(format);

    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.ESCJAVA)
        || (format == OutputFormat.JML)
        || (format == OutputFormat.JAVA)
        || (format == OutputFormat.IOA))
    {
      String comparator = EQUALSstring;
#if defined(EQUAL) || defined(EQUALFLOAT)
      if (format == OutputFormat.IOA) comparator = "=";
#elif defined(NONEQUAL) || defined (NONEQUALFLOAT)
      if (format == OutputFormat.IOA) comparator = "~=";
#endif
      return var1name + " " + comparator + " " + var2name;
    }

    if (format == OutputFormat.SIMPLIFY) {
#if defined(EQUAL) || defined(EQUALFLOAT)
    String comparator = "EQ";
#elif defined(NONEQUAL) || defined(NONEQUALFLOAT)
    String comparator = "NEQ";
#else
    String comparator = EQUALSstring;
#endif
      return "(" + comparator + " " + var1name + " " + var2name + ")";
    }

    return format_unimplemented(format);
  }

  public void add_modified(PRIMITIVE v1, PRIMITIVE v2, int count) {
    // if (ppt.debugged) {
    //   System.out.println(INTEQUALstring + ppt.varNames() + ".add_modified("
    //                      + v1 + "," + v2 + ", count=" + count + ")");
    // }
    if (!(v1 EQUALS v2)) {
      flowThis();
      destroy();
      return;
    }
#ifdef TRACK_NUM_VALUES
    values_cache.add(v1, v2);
#endif
  }

  // This is very tricky, because whether two variables are equal should
  // presumably be transitive, but it's not guaranteed to be so when using
  // this method and not dropping out all variables whose values are ever
  // missing.
  public double computeProbability() {
    if (falsified) {
      return Invariant.PROBABILITY_NEVER;
    }
    // Should perhaps check number of samples and be unjustified if too few
    // samples.

#if (defined(EQUAL) || defined(EQUALFLOAT))
    // We MUST check if we have seen samples; otherwise we get
    // undesired transitivity with missing values.
    if (ppt.num_samples() == 0) {
      return Invariant.PROBABILITY_UNJUSTIFIED;
    }

    // It's an equality invariant.  I ought to use the actual ranges somehow.
    // Actually, I can't even use this .5 test because it can make
    // equality non-transitive.
    // return Math.pow(.5, num_values());
    return Invariant.PROBABILITY_JUSTIFIED;
#else
    // The reason for this multiplication is that there might be only a
    // very few possible values.  Example:  towers of hanoi has only 6
    // possible (pegA, pegB) pairs.
    return (Math.pow(.5, values_cache.num_values())
            * Math.pow(.99, ppt.num_mod_non_missing_samples()));
#endif
  }

#if (defined(EQUAL) || defined(EQUALFLOAT))
  public boolean enoughSamples() {
    return (ppt.num_samples() > 0);
  }
#endif

  // For Comparison interface
  public double eq_probability() {
    if (isExact())
      return computeProbability();
    else
      return Invariant.PROBABILITY_NEVER;
  }

  public boolean isExact() {
#if (defined(EQUAL) || defined(EQUALFLOAT))
    return true;
#else
    return false;
#endif
  }

  // // Temporary, for debugging
  // public void destroy() {
  //   if (debug.isDebugEnabled() || ppt.debugged) {
  //     System.out.println(INTEQUALstring + ".destroy(" + ppt.name + ")");
  //     System.out.println(repr());
  //     (new Error()).printStackTrace();
  //   }
  //   super.destroy();
  // }

  public void add(PRIMITIVE v1, PRIMITIVE v2, int mod_index, int count) {
    if (ppt.debugged) {
      System.out.println(INTEQUALstring + ppt.varNames() + ".add("
                         + v1 + "," + v2
                         + ", mod_index=" + mod_index + ")"
                         + ", count=" + count + ")");
    }
    super.add(v1, v2, mod_index, count);
  }

  public boolean isSameFormula(Invariant other)
  {
    return true;
  }

  public boolean isExclusiveFormula(Invariant other)
  {
    // Also ought to check against LinearBinary, etc.
#if defined(EQUAL) || defined(EQUALFLOAT)
    if ((other instanceof INT(LessThan)) || (other instanceof INT(GreaterThan)))
      return true;
#endif

#if defined(LESSTHAN) || defined(LESSTHANFLOAT)
    if ((other instanceof INT(Equal)) || (other instanceof INT(GreaterEqual)) || (other instanceof INT(GreaterThan)))
      return true;
#endif

#if defined(GREATERTHAN) || defined(GREATERTHANFLOAT)
    if ((other instanceof INT(LessThan)) || (other instanceof INT(LessEqual)) || (other instanceof INT(Equal)))
      return true;
#endif

#if defined(LESSEQUAL) || defined(LESSEQUALFLOAT)
    if (other instanceof INT(GreaterThan))
      return true;
#endif

#if defined(GREATEREQUAL) || defined(GREATEREQUALFLOAT)
    if (other instanceof INT(LessThan))
      return true;
#endif

    return false;
  }

  public boolean isObviousImplied() {
    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];
#if (defined(EQUAL) || defined(EQUALFLOAT))
    // a+c=b+c is implied, because a=b must have also been reported.
    return ((var1.name instanceof VarInfoName.Add) && (var2.name instanceof VarInfoName.Add) &&
              ((((VarInfoName.Add) var1.name).amount) == (((VarInfoName.Add) var2.name).amount)));
#else
#ifdef NONEQUAL
    { // If we know x<y or x>y, then x!=y is uninteresting
      IntLessThan ilt = IntLessThan.find(ppt);
      if ((ilt != null) /* && ilt.enoughSamples() */ ) {
        return true;
      }
      IntGreaterThan igt = IntGreaterThan.find(ppt);
      if ((igt != null) /* && igt.enoughSamples() */ ) {
        return true;
      }
    }
#endif

#ifdef NONEQUALFLOAT
    { // If we know x<y or x>y, then x!=y is uninteresting
      FloatLessThan ilt = FloatLessThan.find(ppt);
      if ((ilt != null) /* && ilt.enoughSamples() */ ) {
        return true;
      }
      FloatGreaterThan igt = FloatGreaterThan.find(ppt);
      if ((igt != null) /* && igt.enoughSamples() */ ) {
        return true;
      }
    }
#endif

#if defined(LESSEQUAL) || defined(GREATEREQUAL)
    { // If we know x=y, then any x<=y or x>=y comparison is uninteresting
      IntEqual ie = IntEqual.find(ppt);
      if ((ie != null) /* && ie.enoughSamples() */ ) {
        return true;
      }
    }
#endif

#if defined(LESSEQUALFLOAT) || defined(GREATEREQUALFLOAT)
    { // If we know x=y, then any x<=y or x>=y comparison is uninteresting
      FloatEqual ie = FloatEqual.find(ppt);
      if ((ie != null) /* && ie.enoughSamples() */ ) {
        return true;
      }
    }
#endif

#if defined(LESSEQUAL)
    { // If we know x<y, then x<=y is uninteresting
      IntLessThan ilt = IntLessThan.find(ppt);
      if ((ilt != null) /* && ilt.enoughSamples() */ ) {
        return true;
      }
    }
#endif
#if defined(LESSEQUALFLOAT)
    { // If we know x<y, then x<=y is uninteresting
      FloatLessThan ilt = FloatLessThan.find(ppt);
      if ((ilt != null) /* && ilt.enoughSamples() */ ) {
        return true;
      }
    }
#endif

#if defined(GREATEREQUAL)
    { // If we know x>y, then x>=y is uninteresting
      IntGreaterThan igt = IntGreaterThan.find(ppt);
      if ((igt != null) /* && igt.enoughSamples() */ ) {
        return true;
      }
    }
#endif

#if defined(GREATEREQUALFLOAT)
    { // If we know x>y, then x>=y is uninteresting
      FloatGreaterThan igt = FloatGreaterThan.find(ppt);
      if ((igt != null) /* && igt.enoughSamples() */ ) {
        return true;
      }
    }
#endif


#if defined(LESS) || defined(GREATER)
    { // If we know y=x+c, then any x<y or x>y comparison is uninteresting
      LinearBinary lb = LinearBinary.find(ppt);
      if ((lb != null) && (lb.core.a == 1) && lb.enoughSamples()) {
        Assert.assertTrue(lb.core.b != 0);
        return true;
      }
    }
#endif

#if defined(LESSFLOAT) || defined(GREATERFLOAT)
    { // If we know y=x+c, then any x<y or x>y comparison is uninteresting
      LinearBinaryFloat lb = LinearBinaryFloat.find(ppt);
      if ((lb != null) && (lb.core.a == 1) && lb.enoughSamples()) {
        Assert.assertTrue(lb.core.b != 0);
        return true;
      }
    }
#endif


// #ifndef EQUAL
//     { // Check for comparisons against constants
//       if (var1.isConstant() || (var2.isConstant())) {
//         // One of the two variables is constant.  Figure out which one.
//         VarInfo varconst;
//         VarInfo varnonconst;
//         boolean var1const = var1.isConstant();
//         boolean can_be_lt;
//         boolean can_be_gt;
//         if (var1const) {
//           varconst = var1;
//           varnonconst = var2;
//           can_be_lt = core.can_be_gt;
//           can_be_gt = core.can_be_lt;
//         } else {
//           varconst = var2;
//           varnonconst = var1;
//           can_be_lt = core.can_be_lt;
//           can_be_gt = core.can_be_gt;
//         }
//         // Now "varconst" and "varnonconst" are set.
//         long valconst = ((Long) varconst.constantValue()).longValue();
//         PptSlice1 nonconstslice = ppt.parent.findSlice(varnonconst);
//         if (nonconstslice != null) {
//           if (can_be_lt) {
//             UpperBound ub = UpperBound.find(nonconstslice);
//             if ((ub != null) && ub.enoughSamples() && ub.core.max1 < valconst) {
//               return true;
//             }
//           } else {
//             LowerBound lb = LowerBound.find(nonconstslice);
//             if ((lb != null) && lb.enoughSamples() && lb.core.min1 > valconst) {
//               return true;
//             }
//           }
//         }
//       }
//     }
// #endif
    { // Sequence length tests

      SequenceLength sl1 = null;
      if (var1.isDerived() && (var1.derived instanceof SequenceLength))
        sl1 = (SequenceLength) var1.derived;
      SequenceLength sl2 = null;
      if (var2.isDerived() && (var2.derived instanceof SequenceLength))
        sl2 = (SequenceLength) var2.derived;

      // "size(a)-1 cmp size(b)-1" is never even instantiated;
      // use "size(a) cmp size(b)" instead.

      // This might never get invoked, as equality is printed out specially.
      VarInfo s1 = (sl1 == null) ? null : sl1.base;
      VarInfo s2 = (sl2 == null) ? null : sl2.base;
      /* [INCR]
      if ((s1 != null) && (s2 != null)
          && (s1.equal_to == s2.equal_to)) {
        // lengths of equal arrays being compared
        return true;
      }
      */

#if defined(LESSTHAN) || defined(LESSTHANFLOAT)
      if ((sl2 != null) && (sl2.shift == 0)) {
        // "x < size(a)"  ("x <= size(a)-1" or "x < size(a)-1" would be more informative)
        return true;
      } else if ((sl1 != null) && (sl1.shift == -1)) {
        // "size(a)-1 < x"  ("size(a) <= x" would be more informative)
        return true;
      }
#elif defined(GREATERTHAN) || defined(GREATERTHANFLOAT)
      if ((sl1 != null) && (sl1.shift == 0)) {
        // "size(a) > x"  ("size(a) >= x" would be more informative)
        return true;
      } else if ((sl2 != null) && (sl2.shift == -1)) {
        // "x > size(a)-1"  ("x >= size(a)" would be more informative)
        return true;
      }
#endif
    }

//     { // Sequence sum tests
//       SequenceSum ss1 = null;
//       if (var1.isDerived() && (var1.derived instanceof SequenceSum))
//         ss1 = (SequenceSum) var1.derived;
//       SequenceSum ss2 = null;
//       if (var2.isDerived() && (var2.derived instanceof SequenceSum))
//         ss2 = (SequenceSum) var2.derived;
//       if ((ss1 != null) && (ss2 != null)) {
//         EltLowerBound lb = null;
//         EltUpperBound ub = null;
//         boolean shorter1 = false;
//         boolean shorter2 = false;
//         PptTopLevel parent = ppt.parent;
//         if (SubSequence.isObviousDerived(ss1.base, ss2.base)) {
//           lb = EltLowerBound.find(parent.findSlice(ss2.base));
//           ub = EltUpperBound.find(parent.findSlice(ss2.base));
//           shorter1 = true;
//         } else if (SubSequence.isObviousDerived(ss2.base, ss1.base)) {
//           lb = EltLowerBound.find(parent.findSlice(ss1.base));
//           ub = EltUpperBound.find(parent.findSlice(ss1.base));
//           shorter2 = true;
//         }
//         if ((lb != null) && (!lb.enoughSamples()))
//           lb = null;
//         if ((ub != null) && (!ub.enoughSamples()))
//           ub = null;
//         // We are comparing sum(a) to sum(b).
//         boolean shorter_can_be_lt;
//         boolean shorter_can_be_gt;
//         if (shorter1) {
//           shorter_can_be_lt = core.can_be_lt;
//           shorter_can_be_gt = core.can_be_gt;
//         } else {
//           shorter_can_be_lt = core.can_be_gt;
//           shorter_can_be_gt = core.can_be_lt;
//         }
//         if (shorter_can_be_lt
//             && (lb != null) && ((lb.core.min1 > 0)
//                                 || (core.can_be_eq && lb.core.min1 == 0))) {
//           return true;
//         }
//         if (shorter_can_be_gt
//             && (ub != null) && ((ub.core.max1 < 0)
//                                 || (core.can_be_eq && ub.core.max1 == 0))) {
//           return true;
//         }
//       }
//     }

//     {
//       // (Is this test ever true?  Aren't SeqINTEQUAL and
//       // INTEQUAL instantiated at the same time?  Apparently not:  see
//       // the printStackTrace below.
//
//       // For each sequence variable, if this is an obvious member, and
//       // it has the same invariant, then this one is obvious.
//       PptTopLevel pptt = ppt.parent;
//       for (int i=0; i<pptt.var_infos.length; i++) {
//         VarInfo vi = pptt.var_infos[i];
//         if (Member.isObviousMember(var1, vi)) {
//           PptSlice2 other_slice = pptt.findSlice_unordered(vi, var2);
//           if (other_slice != null) {
//             SeqINTEQUAL sic = SeqINTEQUAL.find(other_slice);
//             if ((sic != null)
//                 && sic.enoughSamples()) {
//               // This DOES happen; verify by running on replace.c
//               // System.out.println("Surprise:  this can happen (var1 in INTEQUAL).");
//               // new Error().printStackTrace();
//               return true;
//             }
//           }
//         }
//         if (Member.isObviousMember(var2, vi)) {
//           PptSlice2 other_slice = pptt.findSlice_unordered(vi, var1);
//           if (other_slice != null) {
//             SeqINTEQUAL sic = SeqINTEQUAL.find(other_slice);
//             if ((sic != null)
//                 && sic.enoughSamples()) {
//               // This DOES happen
//               // System.out.println("Surprise:  this can happen (var2 in " + INTEQUALstring + ").");
//               // new Error().printStackTrace();
//               return true;
//             }
//           }
//         }
//       }
//     }

    return false;
#endif  // #if !defined(EQUAL)
  } // isObviousImplied

#if defined(EQUAL) || defined(EQUALFLOAT)
  /* [INCR]
  public boolean hasNonCanonicalVariable() {
    VarInfo[] vis = ppt.var_infos;
    return ! (vis[0].isCanonical() || vis[1].isCanonical());
  }
  */ // ... [INCR]
#endif

}
