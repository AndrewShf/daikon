#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPEDOUBLE) || defined(TYPELONG))
#error "ONE MUST BE DEFINED"
#endif

#if defined(TYPEDOUBLE)
#define CLASSNAME LinearBinaryFloat
#define SUPERCLASS TwoFloat
#define CORECLASS LinearBinaryCoreFloat
#define PRIMITIVE double
#define CLASSSTRING "LinearBinaryFloat"
#elif defined(TYPELONG)
#define CLASSNAME LinearBinary
#define SUPERCLASS TwoScalar
#define CORECLASS LinearBinaryCore
#define PRIMITIVE long
#define CLASSSTRING "LinearBinary"
#endif

// ***** This file is automatically generated from LinearBinary.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.Invariant;
import daikon.derive.unary.SequenceLength;
import java.util.*;
import utilMDE.*;


/**
 * Invariants of the form x = ay + b
 **/
public class CLASSNAME
  extends SUPERCLASS
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff LinearBinary invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  public CORECLASS core;

  protected CLASSNAME(PptSlice ppt) {
    super(ppt);
    core = new CORECLASS(this);
  }

  public static CLASSNAME instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    if (ppt.debugged) {
      ppt.debug.debug(CLASSSTRING + ".instantiate(" + ppt.name + ")");
    }
    return new CLASSNAME(ppt);
  }

  protected Object clone() {
    CLASSNAME result = (CLASSNAME) super.clone();
    result.core = (CORECLASS) core.clone();
    result.core.wrapper = result;
    return result;
  }

  protected Invariant resurrect_done_swapped() {
    core.swap();
    return this;
  }

  public String repr() {
    return CLASSSTRING + varNames() + ": "
      + "falsified=" + falsified
      + "; " + core.repr();
  }

  public String format_using(OutputFormat format) {
    return core.format_using(format, var1().name, var2().name);
  }

  // XXX core needs to change to do flow
  public void add_modified(PRIMITIVE x, PRIMITIVE y, int count) {
    core.add_modified(x, y, count);
  }

  public boolean enoughSamples() {
    return core.enoughSamples();
  }

  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isExact() {
    return true;
  }

  public boolean isObviousDerived() {
    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];
    // avoid comparing "size(a)" to "size(a)-1"; yields "size(a)-1 = size(a) - 1"
    if (var1.isDerived() && (var1.derived instanceof SequenceLength)
        && var2.isDerived() && (var2.derived instanceof SequenceLength)) {
      SequenceLength sl1 = (SequenceLength) var1.derived;
      SequenceLength sl2 = (SequenceLength) var2.derived;
      if (sl1.base == sl2.base) {
        return true;
      }
    }
    // avoid comparing "size(a)-1" to anything; should compare "size(a)" instead
    if (var1.isDerived() && (var1.derived instanceof SequenceLength)
        && ((SequenceLength) var1.derived).shift != 0) {
      return true;
    }
    if (var2.isDerived() && (var2.derived instanceof SequenceLength)
        && ((SequenceLength) var2.derived).shift != 0) {
      return true;
    }

    return false;
  }

  public boolean isObviousImplied() {
    if (core.a == 0) return true;                // Constant
    if (core.a == 1 && core.b == 0) return true; // Equality
    return false;
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((CLASSNAME) other).core);
  }

  public boolean isExclusiveFormula(Invariant other)
  {
    if (other instanceof CLASSNAME) {
      return core.isExclusiveFormula(((CLASSNAME) other).core);
    }
    return false;
  }


  // Look up a previously instantiated invariant.
  public static CLASSNAME find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 2);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof CLASSNAME)
        return (CLASSNAME) inv;
    }
    return null;
  }

  // Returns a vector of LinearBinary objects.
  // This ought to produce an iterator instead.
  public static Vector findAll(VarInfo vi) {
    Vector result = new Vector();
    for (Iterator itor = vi.ppt.views_iterator() ; itor.hasNext() ; ) {
      PptSlice view = (PptSlice) itor.next();
      if ((view.arity == 2) && view.usesVar(vi)) {
        CLASSNAME lb = CLASSNAME.find(view);
        if (lb != null) {
          result.add(lb);
        }
      }
    }
    return result;
  }


}
