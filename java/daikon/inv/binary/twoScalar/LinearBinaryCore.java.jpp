#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "One of TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME LinearBinaryCore
  #define PRIMITIVE long
  #define CLASSSTRING "LinearBinaryCore"
  #define EQUAL(a,b) ((a) == (b))
#elif defined(TYPEDOUBLE)
  #define CLASSNAME LinearBinaryCoreFloat
  #define PRIMITIVE double
  #define CLASSSTRING "LinearBinaryCoreFloat"
  #define EQUAL(a,b) (Global.fuzzy.eq ((a), (b)))
#else
  #error "One of TYPELONG or TYPEDOUBLE must be defined"
#endif

// ***** This file is automatically generated from LinearBinaryCore.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import utilMDE.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.io.Serializable;

public final class CLASSNAME
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  /** Debug tracer **/
  public static final Logger debug =
    Logger.getLogger("daikon.inv.binary.twoScalar." + CLASSSTRING);

  // This invariant represents y == ax + b; the first argument is x, second is y
  // (This form rules out vertical lines.  We should instead state
  // this invariant like "ax + by = 1".  This would make swapping
  // easier and allow for vertical lines.)
  public double a = 0, b = 0;

  public PRIMITIVE min_x, min_y, max_x, max_y;
  public double min_a, max_a, min_b, max_b;

  public Invariant wrapper;

  public int values_seen = 0;

  // We delay computation of a and b until we have seen several pairs so
  // that we can compute a and b based on a far-separated pair.  We reduce
  // the likelihood of roundoff error by getting 4 points, then choosing
  // the two that are furthest apart in order to compute a and b.
  final static int MINPAIRS = 4;

  PRIMITIVE[] x_cache = new PRIMITIVE[MINPAIRS];
  PRIMITIVE[] y_cache = new PRIMITIVE[MINPAIRS];

  public CLASSNAME(Invariant wrapper) {
    this.wrapper = wrapper;
  }

  public Object clone() {
    try {
      CLASSNAME result = (CLASSNAME) super.clone();
      if (x_cache != null)
        result.x_cache = (PRIMITIVE[]) x_cache.clone();
      if (y_cache != null)
        result.y_cache = (PRIMITIVE[]) y_cache.clone();
      return result;
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  public void swap() {
    // was a swap
    if (values_seen < MINPAIRS) {
    } else {
      if (a == 0) {
        // can't swap horizontal line into vertical, but if a was 0,
        // then we might as well falsify ourselves because this is just
        // a constant
        values_seen = Integer.MAX_VALUE;
        a = 0;
        b = 0;
      } else {
        a = 1 / a;   // a' =  1/a
        b = -b * a;  // b' = -b/a
      }
    }


    PRIMITIVE[] tmp = x_cache;
    x_cache = y_cache;
    y_cache = tmp;
  }

  /**
   * Returns whether or not the invariant is currently active.  We become
   * active after MINPAIRS values have been seen and a line calculated.
   * Before that, a and b are uninitialized
   */
  public boolean isActive() {
    return (values_seen >= MINPAIRS);
  }

  // Note that this method is relatively inconsistent with respect to
  // differing ordering of the points.  It will always give exactly the
  // same answer with points that are delivered in the same order, but
  // it can calculate different a/b and change whether or not it even
  // finds a line with a different order.  Current code always guarantees
  // that the points arrive in the same order (I think).
  public InvariantStatus add_modified(PRIMITIVE x, PRIMITIVE y, int count) {
    if (values_seen < MINPAIRS) {
      if (debug.isLoggable(Level.FINE)) {
        debug.fine ("min point: " + wrapper.ppt.name +": " + x + ", " + y);
      }
      // We delay computation of a and b until we have seen several pairs
      // so that we can compute a and b based on a far-separated pair.  If
      // the points in a pair are nearby, then roundoff errors in the
      // computation of the slope can be non-negligible.

      for (int i=0; i<values_seen; i++)
        if ((x_cache[i] == x) && (y_cache[i] == y))
          return InvariantStatus.NO_CHANGE;
      x_cache[values_seen] = x;
      y_cache[values_seen] = y;
      values_seen++;
      if (values_seen == MINPAIRS) {
        // Find the most separated pair.
        int[] sep_indices = maxsep_indices();
        int max_i = sep_indices[0];
        int max_j = sep_indices[1];

        // Set a and b based on that pair
        if (max_i == -1) {
          values_seen--;
          wrapper.destroyAndFlow();
          return InvariantStatus.FALSIFIED;
        }
        // remember the min and max pairs
        if (x_cache[max_i] < x_cache[max_j]) {
          // swap max_i and max_j
          int tmp = max_i;
          max_i = max_j;
          max_j = tmp;
        }
        min_x = x_cache[max_i];
        min_y = y_cache[max_i];
        max_x = x_cache[max_j];
        max_y = y_cache[max_j];

        // calculate a and b for this pair and remember them as min/max a,b
        if (set_bi_linear(min_x, max_x, min_y, max_y) == InvariantStatus.FALSIFIED) {
          return InvariantStatus.FALSIFIED;
        }
        min_a = a;
        max_a = a;
        min_b = b;
        max_b = b;
        if (debug.isLoggable(Level.FINE))
            debug.fine (wrapper.ppt.name + ": Initial a (" + a +
                         ") and b (" + b + ")");

        // Check all values against a and b.
        if (a == 0) {
          debug.fine ("Suppressing " + CLASSSTRING + " (" + wrapper.format() + ") because a == 0");
          values_seen--;
          wrapper.destroyAndFlow();
          return InvariantStatus.FALSIFIED;
        }
        for (int i=0; i<MINPAIRS; i++) {
          // if the point is close enough in either x or y it is close enough
          // The double check is used because lines with different slopes may
          // indicate an unreasonably high x or y diff when the actual point
          // is very close.  It would probably be better to calculate the
          // actual distance from the line, but it would be unclear what to
          // compare this to (average or X and Y?).  This seems like a
          // reasonable compromise
          if ((!EQUAL (y_cache[i],  a*x_cache[i]+b))
              && (!EQUAL (x_cache[i], ((y_cache[i] - b) / a)))) {
            if (debug.isLoggable(Level.FINE)) {
              debug.fine ("Suppressing " + CLASSSTRING + " (" + wrapper.format() + ") at index " + i + ": "
                          + y_cache[i] + " != " + a + "*" + x_cache[i] + "+" + b);
              debug.fine ("    ");
            }
            values_seen--;
            wrapper.destroyAndFlow();
            return InvariantStatus.FALSIFIED;
          }
        }
      }
    } else {
      // Check the new value against a and b. (see prev explanation for double
      // EQUAL check)
      if ((! EQUAL (y, a*x+b))  && (!EQUAL (x, (y - b)/ a))) {
        // see if this new point is off one end or the other
        if (x < min_x) {
          min_x = x;
          min_y = y;
        } else if (x > max_x) {
          max_x = x;
          max_y = y;
        }

        PRIMITIVE delta_x = max_x - min_x;
        // should be fixed in the future to permit vertical lines
        if (delta_x == 0) {
          wrapper.destroyAndFlow();
          return InvariantStatus.FALSIFIED;
        }

        // calculate a new a and b possibly using a new end point
        double new_a = (max_y - min_y) / (max_x - min_x);
        double new_b = (min_y*max_x - min_x*max_y) / (max_x-min_x);

        // if the a or b is a new min/max remember it.
        if (new_a < min_a) min_a = new_a;
        if (new_a > max_a) max_a = new_a;
        if (new_b < min_b) min_b = new_b;
        if (new_b > max_b) max_b = new_b;

        //pick a new a and b as the average of their endpoints
        new_a = (min_a + max_a) / 2;
        new_b = (min_b + max_b) / 2;
        if (debug.isLoggable(Level.FINE))
            debug.fine (wrapper.ppt.name + ": Trying new a (" + new_a +
                         ") and b (" + new_b + ")");

        // if the new a and b are 'equal' to min/max a and b and
        // this point fits, then this new equation is good enough both
        // for existing points and the new point.
        if (Global.fuzzy.eq(new_a, min_a) && Global.fuzzy.eq(new_a, max_a) &&
            Global.fuzzy.eq(new_b, min_b) && Global.fuzzy.eq(new_b, max_b) &&
            EQUAL (y, new_a*x + new_b)) {
          a = new_a;
          b = new_b;
          if (debug.isLoggable(Level.FINE))
            debug.fine (wrapper.ppt.name + ": New a (" + a + ") and b ("
                         + b + ")");
        } else {
          if (debug.isLoggable(Level.FINE)) {
            debug.fine ("Suppressing " + CLASSSTRING + " (" +
                        wrapper.format() + ") at new value: "
                        + y + " != " + a + "*" + x + "+" + b);
          }
          wrapper.destroyAndFlow();
          return InvariantStatus.FALSIFIED;
        }
        //??? wrapper.destroyAndFlow();
        //??? return;
      }
    }
    return InvariantStatus.NO_CHANGE;
  }

  /**
   * Returns a 2-element int array of the indices of the most separated
   * pair of points.
   **/
  int[] maxsep_indices() {
    // Find the most separated pair.
    // Do I really need to check in two dimensions, or would one be enough?

    // indices of the most-separated pair of points
    int max_i = -1;
    int max_j = -1;
    // (square of the) distance between the most separated pair
    double max_separation = 0;
    for (int i=0; i<MINPAIRS-1; i++) {
      for (int j=i+1; j<MINPAIRS; j++) {
        // not long, lest we get wraparound
        double xsep = ((double)x_cache[i] - x_cache[j]);
        double ysep = ((double)y_cache[i] - y_cache[j]);
        double separation = xsep*xsep + ysep*ysep;
#if defined(TYPEDOUBLE)
        // Roundoff error might result in 0.
        // Assert.assertTrue(separation > 0);
#endif
        if (separation > max_separation) {
          max_separation = separation;
          max_i = i;
          max_j = j;
        }
      }
    }
    return new int[] { max_i, max_j };
  }


  /**
   * Given ((x0,y0),(x1,y1)), set a and b such that y = ax + b.
   * @return true if such an (a,b) exists
   **/
  private InvariantStatus set_bi_linear(PRIMITIVE x0, PRIMITIVE x1, PRIMITIVE y0, PRIMITIVE y1) {
    if (x1 - x0 == 0) {         // not "x0 == x1", due to roundoff
      // x being constant would have been discovered elsewhere (and this
      // invariant would not have been instantiated).
      if (debug.isLoggable(Level.FINE)) {
        debug.fine ("Suppressing " + CLASSSTRING + " due to equal x values: (" + x0 + "," + y0 + "), (" + x1 + "," + y1 + ")");
      }
      return InvariantStatus.FALSIFIED;
    }
    a = (y1-y0)/(x1-x0);
    b = (y0*x1-x0*y1)/(x1-x0);
    return InvariantStatus.NO_CHANGE;
  }

  public boolean enoughSamples() {
    return (wrapper.ppt.num_values() >= MINPAIRS);
  }

  public double computeProbability() {
    if (wrapper.falsified)
      return Invariant.PROBABILITY_NEVER;
    else
      return Invariant.prob_is_ge(wrapper.ppt.num_values(), MINPAIRS);
  }

  public String repr() {
    return CLASSSTRING + wrapper.varNames() + ": "
      + "a=" + a
      + ",b=" + b
      + ",values_seen=" + values_seen;
  }

  // Format one term of an equation.
  // Variable "first" indicates whether this is the leading term
  // Variable "var" is the name of the variable; may be null for the constant term.
  public static String formatTerm(OutputFormat format,
                                  double coeff,
                                  VarInfoName var,
                                  boolean first)
  {
    if (coeff == 0)
      return "";
    String sign;
    if (coeff < 0) {
      if (first) {
        sign = "- ";
      } else {
        sign = " - ";
      }
      coeff = -coeff;
    } else if (first) {
      sign = "";
    } else {
      sign = " + ";
    }
    String coeff_string = (coeff == (int)coeff) ? "" + (int)coeff : "" + coeff;
    if (var == null)
      return sign + coeff_string;
    if (coeff == 1)
      return sign + var.name_using(format);
    else
      return sign + coeff_string + " * " + var.name_using(format);
  }

  public String format_using(OutputFormat format,
                             VarInfoName x, VarInfoName y,
                             double a, double b)
  {
    if (a == 0 && b == 0) {
      return wrapper.format_too_few_samples(format, "0 * " + y
                                            + " == 0 * " + x + " + 0");
    }

    String xname = x.name_using(format);
    String yname = y.name_using(format);

    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.JAVA)
        || (format == OutputFormat.ESCJAVA)
        || (format == OutputFormat.JML)
        || (format == OutputFormat.IOA)
        || (format == OutputFormat.DBCJAVA))
    {
      String eq = " == ";
      if (format == OutputFormat.IOA) eq = " = ";
      return yname + eq
        + formatTerm(format, a, x, true)
        + formatTerm(format, b, null, false);
    }

    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify(x.simplify_name(), y.simplify_name(), a, b);
    }
    throw new Error("Unknown OutputFormat: " + format);
  }

  public static String format_simplify(String str_x, String str_y,
                                       double a, double b)
  {
      int ia = (int) a;
      int ib = (int) b;

      String str_a, str_b;
      if (ia != a || ib != b) {
        // floating point
        str_a = Invariant.simplify_format_double(a);
        str_b = Invariant.simplify_format_double(b);
      } else {
        // integer
        str_a = ia + "";
        str_b = ib + "";
      }

      // y == a x + b
      String str_ax = (a == 1.0) ? str_x : "(* " + str_a + " " + str_x + ")";
      String str_axpb = (b == 0.0) ? str_ax :
        "(+ " + str_ax + " " + str_b + ")";
      return "(EQ " + str_y + " " + str_axpb + ")";
  }

  public String format_using(OutputFormat format,
                             VarInfoName x, VarInfoName y)
  {
    String result = format_using(format, x, y, a, b);
    if (result != null) {
      return result;
    } else {
      return wrapper.format_unimplemented(format);
    }
  }

  // Format as "x = cy+d" instead of as "y = ax+b".
  public String format_reversed_using(OutputFormat format,
                                      VarInfoName x, VarInfoName y)
  {
    Assert.assertTrue(a == 1 || a == -1);
    return format_using(format, y, x, a, -b/a);
  }

  /**
   * In general, we can't merge formulas, but we can merge invariants with
   * too few samples to have formed a line with invariants with enough
   * samples.  And those will appear to have different formulas.
   */

  public boolean mergeFormulasOk() {
    return (true);
  }

  /**
   * Merge the linear binary cores in cores to form a new core. Any
   * core in the list that has seen enough points to define a
   * line, must define the same line.  Any cores that have not
   * yet seen enough points, will have each of their points applied to
   * that invariant.  The merged core is returned.  Null is
   * returned if the cores don't describe the same line
   *
   * @param cores   List of LinearBinary cores to merge.  They should
   *                all be permuted to match the variable order in
   *                ppt.
   */
  public CLASSNAME merge (List cores, Invariant wrapper) {

    // Look for any active lines.  All must define the same line
    CLASSNAME result = null;
    for (int i = 0; i < cores.size(); i++) {
      CLASSNAME c = (CLASSNAME) cores.get (i);
      if (!c.isActive())
        continue;
      if (result == null)
        result = (CLASSNAME) c.clone();
      else {
        if (!Global.fuzzy.eq (result.a, c.a)
            || !Global.fuzzy.eq (result.b, c.b))
          return (null);
      }
    }

    // If no active lines were found, created an empty core
    if (result == null)
      result = new CLASSNAME (wrapper);
    else
      result.wrapper = wrapper;

    // Merge in any points from non-active cores
    for (int i = 0; i < cores.size(); i++) {
      CLASSNAME c = (CLASSNAME) cores.get (i);
      if (c.isActive())
        continue;
      for (int j = 0; j < c.values_seen; j++) {
        result.add_modified (c.x_cache[j], c.y_cache[j], 1);
        if (wrapper.falsified)
          return (null);
      }
    }

    return (result);
  }

  public boolean isSameFormula(CLASSNAME other)
  {
    boolean thisMeaningless = values_seen < MINPAIRS;
    boolean otherMeaningless = other.values_seen < MINPAIRS;

    if (thisMeaningless && otherMeaningless) {
      return true;
    } else {
      return
        (values_seen >= MINPAIRS) &&
        (other.values_seen >= MINPAIRS) &&
        (a == other.a) &&
        (b == other.b);
    }
  }

  public boolean isExclusiveFormula(CLASSNAME other)
  {
    if ((values_seen < MINPAIRS) ||
        (other.values_seen < MINPAIRS)) {
      return false;
    }

    return ((a == other.a)
            && (b != other.b));
  }

}
