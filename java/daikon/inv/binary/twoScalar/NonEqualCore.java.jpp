#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
#error "ONE MUST BE DEFINED"
#endif

#if (defined(TYPELONG))
#define CLASSNAME NonEqualCore
#define PRIMITIVE long
#define NUMWRAPPER Long
#define CLASSSTRING "NonEqualCore"
#define NONEQUALSTRING "NonEqual"

#elif (defined(TYPEDOUBLE))
#define CLASSNAME NonEqualCoreFloat
#define PRIMITIVE double
#define NUMWRAPPER Double
#define CLASSSTRING "NonEqualCoreFloat"
#define NONEQUALSTRING "NonEqualFloat"

#endif


// ***** This file is automatically generated from NonEqualCore.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.*;
import utilMDE.*;
import java.io.Serializable;


public final class CLASSNAME
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  PRIMITIVE min1 = NUMWRAPPER.MAX_VALUE;
  PRIMITIVE min2 = NUMWRAPPER.MAX_VALUE;
  PRIMITIVE max1 = NUMWRAPPER.MIN_VALUE;
  PRIMITIVE max2 = NUMWRAPPER.MIN_VALUE;

  // If nonzero, use this as the range instead of the actual range.
  // This lets one use a specified probability of nonzero (say, 1/10
  // for pointers).
  long override_range = 0;

  int samples = 0;

  public Invariant wrapper;

  // public NonEqualCore(Invariant wrapper) {
  //   this(wrapper, 0);
  // }

  public CLASSNAME(Invariant wrapper, long override_range) {
    this.wrapper = wrapper;
    this.override_range = override_range;
  }

  public Object clone() {
    try {
      return super.clone();
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  // for resurrection
  protected void swap() {
    // was a swap
    PRIMITIVE tmp;

    tmp = min1;
    min1 = min2;
    min2 = min1;

    tmp = max1;
    max1 = max2;
    max2 = tmp;
  }

  public void add_modified(PRIMITIVE v1, PRIMITIVE v2, int count) {
    if (wrapper.ppt.debugged) {
      System.out.println(CLASSSTRING + wrapper.ppt.varNames() + ".add_modified("
                         + v1 + "," + v2 + ", count=" + count + ")");
    }
    if (v1 == v2) {
      if (wrapper.ppt.debugged) {
        System.out.println(CLASSSTRING + ".destroy()");
      }
      wrapper.flowThis();
      wrapper.destroy();
      return;
    }
    if (v1 < min1) min1 = v1;
    if (v1 > max1) max1 = v1;
    if (v2 < min2) min2 = v2;
    if (v2 > max2) max2 = v2;
    samples += count;
  }

  public double computeProbability() {
    if (wrapper.falsified)
      return Invariant.PROBABILITY_NEVER;
    else if ((min1 > max2) || (max1 < min2))
      return Invariant.PROBABILITY_UNJUSTIFIED;
    else {
      double probability_one_nonequal;
      if (override_range != 0) {
        probability_one_nonequal = 1 - 1/(double)override_range;
      } else {
        PRIMITIVE overlap = Math.min(max1, max2) - Math.max(min1, min2);
        // Looks like we're comparing pointers.  Fix this later.
        if (overlap < 0)
          return Invariant.PROBABILITY_JUSTIFIED;

        Assert.assertTrue(overlap >= 0);
        overlap++;
        double range1 = (double)max1 - min1 + 1;
        double range2 = (double)max2 - min2 + 1;

        // probability of being equal by chance
        //  = (overlap/range1) * (overlap/range2) * (1/overlap)
        //  = overlap/(range1 * range2)

        // Hack; but this seems too stringent otherwise
        overlap *= 2;

        probability_one_nonequal = 1-((double)overlap)/(range1 * range2);
      }

      return Math.pow(probability_one_nonequal, samples);
    }
  }

  public String repr() {
    return CLASSSTRING + ": "
      + ",min1=" + min1
      + ",min2=" + min2
      + ",max1=" + max1
      + ",max2=" + max2;
  }


  public boolean isSameFormula(CLASSNAME other)
  {
    return true;
  }

  public boolean isExclusiveFormula(Invariant other)
  {
    return false;
  }

  public boolean isExact() {
    return false;
  }

}
