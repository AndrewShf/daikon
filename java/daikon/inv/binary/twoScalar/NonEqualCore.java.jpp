#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if (defined(TYPELONG))
  #define CLASSNAME NonEqualCore
  #define PRIMITIVE long
  #define NUMWRAPPER Long
  #define CLASSSTRING "NonEqualCore"
  #define NONEQUALSTRING "NonEqual"
  #define EQUAL(a,b) ((a) == (b))
#elif (defined(TYPEDOUBLE))
  #define CLASSNAME NonEqualCoreFloat
  #define PRIMITIVE double
  #define NUMWRAPPER Double
  #define CLASSSTRING "NonEqualCoreFloat"
  #define NONEQUALSTRING "NonEqualFloat"
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
#endif


// ***** This file is automatically generated from NonEqualCore.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.*;
import utilMDE.*;
import java.io.Serializable;
import java.util.*;
import java.lang.Math;

public final class CLASSNAME
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  PRIMITIVE min1 = NUMWRAPPER.MAX_VALUE;
  PRIMITIVE min2 = NUMWRAPPER.MAX_VALUE;
  PRIMITIVE max1 = NUMWRAPPER.MIN_VALUE;
  PRIMITIVE max2 = NUMWRAPPER.MIN_VALUE;

  // If nonzero, use this as the range instead of the actual range.
  // This lets one use a specified probability of nonzero (say, 1/10
  // for pointers).
  long override_range = 0;

  int samples = 0;

  public Invariant wrapper;

  // public NonEqualCore(Invariant wrapper) {
  //   this(wrapper, 0);
  // }

  public CLASSNAME(Invariant wrapper, long override_range) {
    this.wrapper = wrapper;
    this.override_range = override_range;
  }

  public Object clone() {
    try {
      return super.clone();
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  // for resurrection
  protected void swap() {
    // was a swap
    PRIMITIVE tmp;

    tmp = min1;
    min1 = min2;
    min2 = min1;

    tmp = max1;
    max1 = max2;
    max2 = tmp;
  }

  public InvariantStatus add_modified(PRIMITIVE v1, PRIMITIVE v2, int count) {
    if (wrapper.ppt.debugged) {
      System.out.println(CLASSSTRING + wrapper.ppt.varNames() + ".add_modified("
                         + v1 + "," + v2 + ", count=" + count + ")");
    }
    if (EQUAL (v1, v2)) {
      if (wrapper.ppt.debugged) {
        System.out.println(CLASSSTRING + ".destroy()");
      }
      return InvariantStatus.FALSIFIED;
    }
    if (v1 < min1) min1 = v1;
    if (v1 > max1) max1 = v1;
    if (v2 < min2) min2 = v2;
    if (v2 > max2) max2 = v2;
    samples += count;
    return InvariantStatus.NO_CHANGE;
  }

  public double computeConfidence() {
    if ((min1 > max2) || (max1 < min2)) {
      // The two ranges do not overlap.
      return Invariant.CONFIDENCE_UNJUSTIFIED;
    } else {
      // The two ranges do overlap.  Determine the extent of each range and
      // the extent of the overlap.  From this, compute the probability
      // that the values are different each time through.
      double probability_one_nonequal = 1 - confidence_one_nonequal();
      return 1 - Math.pow(probability_one_nonequal, samples);
    }
  }

  public double computeProbability() {
    if ((min1 > max2) || (max1 < min2)) {
      // The two ranges do not overlap.
      return Invariant.PROBABILITY_UNJUSTIFIED;
    } else {
      // The two ranges do overlap.  Determine the extent of each range and
      // the extent of the overlap.  From this, compute the probability
      // that the values are different each time through.
      double probability_one_nonequal = 1 - confidence_one_nonequal();
      return Math.pow(probability_one_nonequal, samples);
    }
  }

  // The two ranges do overlap.  Determine the extent of each range and
  // the extent of the overlap.  From this, compute the probability
  // that the values are different each time through.
  private double confidence_one_nonequal() {
    if (override_range != 0) {
      return 1/(double)override_range;
    }

    PRIMITIVE overlap = Math.min(max1, max2) - Math.max(min1, min2);
    // Looks like we're comparing pointers.  Fix this later.
    if (overlap < 0)
      return Invariant.PROBABILITY_JUSTIFIED;

    Assert.assertTrue(overlap >= 0);
    overlap++;
    double range1 = (double)max1 - min1 + 1;
    double range2 = (double)max2 - min2 + 1;

    // probability of being equal by chance
    //  = (overlap/range1) * (overlap/range2) * (1/overlap)
    //  = overlap/(range1 * range2)

    // Hack; but this seems too stringent otherwise
    overlap *= 2;

    return ((double)overlap)/(range1 * range2);
  }


  public String repr() {
    return CLASSSTRING + ": "
      + ",min1=" + min1
      + ",min2=" + min2
      + ",max1=" + max1
      + ",max2=" + max2;
  }


  public boolean isSameFormula(CLASSNAME other)
  {
    return true;
  }

  public boolean isExclusiveFormula(Invariant other)
  {
    return false;
  }

  public boolean isExact() {
    return false;
  }

  /**
   * Suppress is not ok since we keep track of min/max values
   */
  public boolean inProcessSuppressOk() {
    return false;
  }

  /**
   * Merge the NonEqual cores in cores to form a new core.  This only
   * needs to merge the values for min1, min2, max1, max2, and samples
   * across the cores.  The merged core is returned.
   */
  public CLASSNAME merge (List cores, Invariant wrapper) {

    // Get a clone of the first core
    CLASSNAME result = (CLASSNAME) ((CLASSNAME) cores.get (0)).clone();
    result.wrapper = wrapper;

    // Loop through the remaining cores, modifying min/max as necessary and
    // incrementing samples
    for (int i = 1; i < cores.size(); i++) {
      CLASSNAME c = (CLASSNAME) cores.get (i);
      result.min1 = Math.min (result.min1, c.min1);
      result.max1 = Math.max (result.max1, c.max1);
      result.min2 = Math.min (result.min2, c.min2);
      result.max2 = Math.max (result.max2, c.max2);
      result.samples += c.samples;
    }

    return (result);
  }
}
