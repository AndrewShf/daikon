#if 0
// Do not attempt to compile this file with a Java compiler such as javac.
// You first need to preprocess it with cpp, the C preprocessor.
// The correct way to build the system is to run 'make'.
#endif

#if (defined(TYPELONG))
  #define CLASSNAME NumericInt
  #define SUPERCLASS TwoScalar
  #define PRIMITIVE long
  #define EQUALS(a,b) (a == b)
  #define VALUE_SET ValueSet.ValueSetScalarArray
  #define ONEOF OneOfScalar
  #define ONEOF_ZERO InvDef.elts_zero
  #define ONEOF_PLUS_MINUS_ONE InvDef.elts_plus_minus_one
  #define ONEOF_MINUS_ONE InvDef.elts_minus_one
  #define SEQ_SUBSCRIPT SequenceScalarSubscript
  #define EQUALITY IntEqual
#elif defined(TYPEDOUBLE)
  #define CLASSNAME NumericFloat
  #define SUPERCLASS TwoFloat
  #define PRIMITIVE double
  #define EQUALS(a,b) (Global.fuzzy.eq (a, b))
  #define VALUE_SET ValueSet.ValueSetFloatArray
  #define ONEOF OneOfFloat
  #define ONEOF_ZERO InvDef.elts_zero_float
  #define ONEOF_PLUS_MINUS_ONE InvDef.elts_plus_minus_one_float
  #define ONEOF_MINUS_ONE InvDef.elts_minus_one_float
  #define SEQ_SUBSCRIPT SequenceFloatSubscript
  #define EQUALITY FloatEqual
#elif defined(TYPELONGSEQ)
  #define SEQ
  #define CLASSNAME PairwiseNumericInt
  #define SUPERCLASS TwoSequence
  #define PRIMITIVE long
  #define EQUALS(a,b) (a == b)
  #define VALUE_SET ValueSet.ValueSetScalarArray
  #define ONEOF EltOneOf
  #define ONEOF_ZERO InvDef.elts_zero
  #define ONEOF_PLUS_MINUS_ONE InvDef.elts_plus_minus_one
  #define ONEOF_MINUS_ONE InvDef.elts_minus_one
  #define SEQ_SUBSEQUENCE SequenceScalarSubsequence
  #define EQUALITY PairwiseIntEqual
#elif defined(TYPEDOUBLESEQ)
  #define SEQ
  #define CLASSNAME PairwiseNumericFloat
  #define SUPERCLASS TwoSequenceFloat
  #define PRIMITIVE double
  #define EQUALS(a,b) (Global.fuzzy.eq (a, b))
  #define VALUE_SET ValueSet.ValueSetFloatArray
  #define ONEOF EltOneOfFloat
  #define ONEOF_ZERO InvDef.elts_zero_float
  #define ONEOF_PLUS_MINUS_ONE InvDef.elts_plus_minus_one_float
  #define ONEOF_MINUS_ONE InvDef.elts_minus_one_float
  #define SEQ_SUBSEQUENCE SequenceFloatSubsequence
  #define EQUALITY PairwiseFloatEqual
#else
  #error "TYPELONG, TYPEDOUBLE, TYPELONGSEQ, or TYPEDOUBLESEQ  must be defined"
#endif

#if (defined(SEQ))
  #define VAR1 x[]
  #define VAR2 y[]
  #define PACKAGE twoSequence
  #define COMMENT_TXT corresponding elements of two PRIMITIVE sequences
#else
  #define VAR1 x
  #define VAR2 y
  #define PACKAGE twoScalar
  #define COMMENT_TXT two PRIMITIVE scalars
#endif

// ***** This file is automatically generated from Numeric.java.jpp

package daikon.inv.binary.PACKAGE;

import daikon.*;
import daikon.inv.*;
#ifdef SEQ
import daikon.inv.unary.sequence.*;
import utilMDE.*;
#else
import daikon.inv.unary.scalar.*;
#endif
import daikon.derive.binary.*;
import daikon.suppress.*;

import java.util.*;

/**
 * Baseclass for binary numeric invariants.
 *
 * Each specific invariant is implemented in a subclass (typically, in
 * this file).  The subclass must provide the methods instantiate(),
 * check(), and format(). Symmetric functions should define
 * is_symmetric() to return true.
 **/
public abstract class CLASSNAME extends SUPERCLASS {

  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20040113L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff binary numeric invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  protected CLASSNAME(PptSlice ppt, boolean swap) {
    super(ppt);
    this.swap = swap;
  }

  /**
   * Returns true if it is ok to instantiate a numeric invariant over the
   * specified slice.
   */
  public static boolean instantiate_ok (PptSlice ppt, boolean swap) {
    if (!dkconfig_enabled) return false;
    #if !defined(SEQ)
      if (!ppt.var_infos[0].file_rep_type.isIntegral()
          || !ppt.var_infos[1].file_rep_type.isIntegral())
        return (false);
    #endif
    return (true);
  }

  public boolean isExact() {
    return true;
  }

  /**
   * Returns a string in the specified format that describes the invariant.
   *
   * The generic format string is obtained from the subclass specific
   * get_format_str().  Instances of %varN% are replaced by the variable
   * name in the specified format.  If the format is IOA, == is replaced
   * by =.
   */
  public String format_using(OutputFormat format) {

    String fmt_str = get_format_str (format);
    String v1 = null;
    String v2 = null;

    #if defined(SEQ)
      if (format == OutputFormat.ESCJAVA) {
        String[] form = VarInfoName.QuantHelper.format_esc(new VarInfoName[]
                              { var1().name, var2().name }, true);
        fmt_str = form[0] + "(" + fmt_str + ")" + form[3];
        v1 = form[1];
        v2 = form[2];
      } else if (format == OutputFormat.JML) {
        String form[] = VarInfoName.QuantHelper.format_jml(new VarInfoName[]
                              { var1().name, var2().name }, true);
        fmt_str = form[0] + " " + fmt_str + " " + form[3];
        v1 = form[1];
        v2 = form[2];
      } else if (format == OutputFormat.SIMPLIFY) {
        String[] form =
          VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
            { var1().name, var2().name }, true); // elementwise
        fmt_str = form[0] + " " + fmt_str + " " + form[3];
        v1 = form[1];
        v2 = form[2];
      } else if (format == OutputFormat.IOA) {
        fmt_str += " ***";
      } else if (format == OutputFormat.DAIKON) {
        fmt_str += " (elementwise)";
      }
    #endif

    if (v1 == null)
      v1 = var1().name.name_using(format, var1());
    if (v2 == null)
      v2 = var2().name.name_using(format, var2());

    fmt_str = fmt_str.replaceAll ("%var1%", v1);
    fmt_str = fmt_str.replaceAll ("%var2%", v2);
    if (format == OutputFormat.IOA)
      fmt_str = fmt_str.replaceAll ("==", "=");
    else if (false && (format == OutputFormat.DAIKON)) {
      fmt_str = "[" + getClass() + "]" + fmt_str + " ("
             + var1().get_value_info() + ", " + var2().get_value_info() +  ")";
    }
    return (fmt_str);
  }

  /**
   * Calls the function specific equal check and returns the correct
   * status
   */
#if (defined(SEQ))
  public InvariantStatus check_modified(PRIMITIVE[] x, PRIMITIVE[] y,
                                        int count) {
    if (x.length != y.length)
      return (InvariantStatus.FALSIFIED);

    if (Debug.logDetail()) {
      log ("testing values " + ArraysMDE.toString (x) + ", "
           + ArraysMDE.toString(y));
    }

    try {
      for (int i = 0; i < x.length; i++) {
        if (!eq_check (x[i], y[i]))
          return (InvariantStatus.FALSIFIED);
      }
      return (InvariantStatus.NO_CHANGE);
    } catch (Exception e) {
      return (InvariantStatus.FALSIFIED);
    }
  }
#else
  public InvariantStatus check_modified(PRIMITIVE x, PRIMITIVE y, int count) {

    try {
      if (eq_check (x, y))
        return (InvariantStatus.NO_CHANGE);
      else
        return (InvariantStatus.FALSIFIED);
    } catch (Exception e) {
      return (InvariantStatus.FALSIFIED);
    }
  }
#endif

#if defined(SEQ)
  /**
   * Checks to see if this invariant is over subsequences and if the
   * same relationship holds over the full sequence.  This is obvious
   * if it does.  For example 'x[foo..] op y[bar..]' would be obvious
   * if 'x[] op y[]'  This can't fully be handled as a suppression since
   * a suppression needs to insure that foo == bar as well.  But that
   * is not a requirement here (the fact that 'x[] op y[]' implies that
   * foo == bar when x[] and y[] are not missing)
   */
  public DiscardInfo is_subsequence (VarInfo[] vis) {

    VarInfo v1 = var1(vis);
    VarInfo v2 = var2(vis);

    // Make sure each var is a sequence subsequence
    if (!v1.isDerived() || !(v1.derived instanceof SEQ_SUBSEQUENCE))
      return (null);
    if (!v2.isDerived() || !(v2.derived instanceof SEQ_SUBSEQUENCE))
      return (null);

    SEQ_SUBSEQUENCE der1 = (SEQ_SUBSEQUENCE) v1.derived;
    SEQ_SUBSEQUENCE der2 = (SEQ_SUBSEQUENCE) v2.derived;

    // Both of the indices must be either from the start or up to the end.
    // It is not necessary to check that they match in any other way since
    // if the supersequence holds, that implies that the sequences are
    // of the same length.  Thus any subsequence that starts from the
    // beginning or finishes at the end must end or start at the same
    // spot (or it would have been falsified when it didn't)
    if (der1.from_start != der2.from_start)
      return (null);

    // Look up this class over the sequence variables
    Invariant inv = find (getClass(), der1.seqvar(), der2.seqvar());
    if (inv == null)
      return (null);
    return new DiscardInfo(this, DiscardCode.obvious, "Implied by " +
                           inv.format());
  }
#endif

#if !defined(SEQ)
  /**
   * Checks to see if 'x[a] op y[b]' where 'x[] op y[]' and 'a == b'
   * Doesn't catch the case where a = b+1
   */
  public DiscardInfo is_subscript (VarInfo[] vis) {

    VarInfo v1 = var1(vis);
    VarInfo v2 = var2(vis);

    // Make sure each var is a sequence subscript
    if (!v1.isDerived() || !(v1.derived instanceof SEQ_SUBSCRIPT))
      return (null);
    if (!v2.isDerived() || !(v2.derived instanceof SEQ_SUBSCRIPT))
      return (null);

    SEQ_SUBSCRIPT der1 = (SEQ_SUBSCRIPT) v1.derived;
    SEQ_SUBSCRIPT der2 = (SEQ_SUBSCRIPT) v2.derived;

    // Make sure the shifts match
    if (der1.index_shift != der2.index_shift)
      return (null);

    // Look for this invariant over a sequence
    String cstr = getClass().getName();
    cstr = cstr.replaceFirst ("Numeric", "PairwiseNumeric");
    cstr = cstr.replaceFirst ("twoScalar", "twoSequence");
    cstr = cstr.replaceFirst ("twoFloat", "twoSequence");
    Class pairwise_class;
    try {
      pairwise_class = Class.forName (cstr);
    } catch (Exception e) {
      throw new Error ("can't create class for " + cstr + " - " + e);
    }
    Invariant inv = find (pairwise_class, der1.seqvar(), der2.seqvar());
    if (inv == null)
      return (null);

    // Look to see if the subscripts are equal
    Invariant subinv = find (EQUALITY.class, der1.sclvar(), der2.sclvar());
    if (subinv == null)
      return (null);

    return new DiscardInfo(this, DiscardCode.obvious, "Implied by " +
                           inv.format() + " and " + subinv.format());
  }
#endif

  public DiscardInfo isObviousDynamically (VarInfo[] vis) {

    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null)
      return super_result;

    #if (defined (SEQ))
      // any elementwise relation across subsequences is made obvious by
      // the same relation across the original sequence
      DiscardInfo result = is_subsequence (vis);
      if (result != null) return result;
    #else
      // any relation across subscripts is made obvious by the same
      // relation across the original sequence if the subscripts are equal
      DiscardInfo result = is_subscript (vis);
      if (result != null) return result;
    #endif

    return (null);
  }


  /**
   * Return a format string for the specified output format.  Each instance
   * of %varN% will be replaced by the correct name for varN.
   */
  public abstract String get_format_str (OutputFormat format);

  /**
   * Returns true if x and y don't invalidate the invariant
   */
  public abstract boolean eq_check (PRIMITIVE x, PRIMITIVE y);

  /**
   * Returns a list of all of the numeric invariants instantiated
   * for the specified slice
   */
  public static List instantiate_all (PptSlice slice) {

    List result = new ArrayList();
    result.add (Divides.instantiate (slice, false));
    result.add (Divides.instantiate (slice, true));
    result.add (Square.instantiate (slice, false));
    result.add (Square.instantiate (slice, true));
    #if defined(TYPELONG) || defined(TYPELONGSEQ)
      result.add (BitwiseComplement.instantiate (slice));
      result.add (BitwiseSubset.instantiate (slice, false));
      result.add (BitwiseSubset.instantiate (slice, true));
    #endif
    return (result);
  }

  //
  // Int and Float Numeric Invariants
  //

  /**
   * Represents the divides without remainder invariant between
   * COMMENT_TXT.  Prints as ' VAR1 % VAR2 == 0'
   */
  public static class Divides extends CLASSNAME {

    protected Divides (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    public static Divides instantiate(PptSlice ppt, boolean swap) {
      if (!instantiate_ok(ppt, swap)) return null;
      return new Divides (ppt, swap);
    }

    public String get_format_str (OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY)
        return ("(EQ 0 (MOD %var1% %var2%))");
      else
        return ("%var1% % %var2% == 0");
    }

    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      if (x < y)
        return (false);
      return (EQUALS (0, (x % y)));
    }

    public SuppressionFactory[] getSuppressionFactories() {
      return new SuppressionFactory[] {
        // suppress if var2 == 1 or -1
        new SuppressionDef (new InvDef (var2(), ONEOF.class,
                            ONEOF_PLUS_MINUS_ONE)),
        // suppress if var1 == var2
        new SuppressionDef (new InvDef (var1(), var2(), EQUALITY.class)),

      };
    }

  }

  /**
   * Represents the square invariant between
   * COMMENT_TXT.  Prints as ' VAR1 = VAR2**2'
   **/
  public static class Square extends CLASSNAME {

    protected Square (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    public static Square instantiate(PptSlice ppt, boolean swap) {
      if (!instantiate_ok(ppt, swap)) return null;
      return new Square (ppt, swap);
    }

    public String get_format_str (OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY)
        return ("(EQ %var1% (* %var2% %var2))");
      else
        return ("%var1% == %var2%**2");
    }

    /** Check to see if x == y squared **/
    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return (EQUALS (x, y*y));
    }
  }

#if defined(TYPELONG) || defined(TYPELONGSEQ)

  /**
   * Represents the bitwise complement invariant between
   * COMMENT_TXT. Prints as ' VAR1 = ~VAR2 '
   **/
  public static class BitwiseComplement extends CLASSNAME {

    protected BitwiseComplement (PptSlice ppt) {
      super(ppt, false);
    }

    public static BitwiseComplement instantiate(PptSlice ppt) {
      if (!instantiate_ok (ppt, false)) return null;
      return new BitwiseComplement (ppt);
    }

    public boolean is_symmetric() {
      return (true);
    }

    public String get_format_str (OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY)
        return ("(EQ %var1% (~ %var2%))");
      else
        return ("%var1% == ~%var2%");
    }

    /** Check to see if x == ~y **/
    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return (EQUALS (x, ~y));
    }
  }

  /**
   * Represents the bitwise subset invariant between
   * COMMENT_TXT. Prints as ' VAR1 = VAR2 | VAR1 '
   **/
  public static class BitwiseSubset extends CLASSNAME {

    protected BitwiseSubset (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    public static BitwiseSubset instantiate(PptSlice ppt, boolean swap) {
      if (!instantiate_ok (ppt, swap)) return null;
      return new BitwiseSubset (ppt, swap);
    }

    public String get_format_str (OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY)
        return ("(EQ %var1% (|java-bitwise-or| %var2% %var1%))");
      else if (format == OutputFormat.DAIKON)
        return ("%var2% is a bitwise subset of %var1%");
      else
        return ("%var1% == %var2% | %var1%");
    }

    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return (EQUALS (x, (y | x)));
    }

    public SuppressionFactory[] getSuppressionFactories() {
      return new SuppressionFactory[] {
        // suppress if var2 == 0
        new SuppressionDef (new InvDef (var2(), ONEOF.class, ONEOF_ZERO)),
        // suppress if var1 == -1 (all of its bits are on)
        new SuppressionDef (new InvDef (var1(), ONEOF.class, ONEOF_MINUS_ONE)),
        // suppress if var1 == var2
        new SuppressionDef (new InvDef (var1(), var2(), EQUALITY.class)),
      };
    }
  }

#endif


}
