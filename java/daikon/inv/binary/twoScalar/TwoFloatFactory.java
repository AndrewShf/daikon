// ***** This file is automatically generated from TwoScalarFactory.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.*;

import utilMDE.*;
import org.apache.log4j.Category;

import org.apache.log4j.Category;

import java.util.*;

public final class TwoFloatFactory  {

  /** Debugging tracer. **/
  public static final Category debug
    = Category.getInstance("daikon.inv.binary.twoScalar.TwoFloatFactory");

  // Adds the appropriate new Invariant objects to the specified Invariants
  // collection.
  public static Vector instantiate(PptSlice ppt) {

    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];

    if (debug.isDebugEnabled()) {
      debug.debug ("Trying to instantiate for " + ppt.ppt_name + ": " + var1.name  + " and " + var2.name);
    }

    // Assert.assertTrue((! var1.rep_type.isArray()) && (! var2.rep_type.isArray()));

    Assert.assertTrue(var1.rep_type.isFloat());
    Assert.assertTrue(var2.rep_type.isFloat());

    if (! var1.compatible(var2)) {
      debug.debug ("Not comparable, returning");
      return null;
    }

    // In V3, we are more ambitious and will do inference over static
    // constants.  In any case, this test belongs in PptTopLevel anyway.
    // if (var1.isStaticConstant() || var2.isStaticConstant()) {
    //   return null;
    // }

    boolean integral = var1.file_rep_type. isFloat()  && var2.file_rep_type. isFloat() ;

    Vector result = new Vector();

    result.add(FloatEqual.instantiate(ppt));

    result.add(FloatNonEqual.instantiate(ppt));
    result.add(FloatLessThan.instantiate(ppt));
    result.add(FloatLessEqual.instantiate(ppt));
    result.add(FloatGreaterThan.instantiate(ppt));
    result.add(FloatGreaterEqual.instantiate(ppt));

    // Skip LineayBinary and FunctionUnary unless vars are integral
    if (!integral) {
      Global.subexact_noninstantiated_invariants += 1;
      Global.subexact_noninstantiated_invariants += FunctionsFloat.unaryFunctionNames.length;
    } else {
      result.add(LinearBinaryFloat.instantiate(ppt));
      for (int i=0; i<2; i++) {
        boolean invert = (i==1);
        for (int j=0; j< FunctionsFloat.unaryFunctionNames.length; j++) {
          result.add(FunctionUnaryFloat.instantiate(ppt, FunctionsFloat.unaryFunctionNames[j], j, invert));
        }
      }
    }
    return result;
  }

  private TwoFloatFactory () {
  }

}
