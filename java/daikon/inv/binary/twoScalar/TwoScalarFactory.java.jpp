#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif


#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
#error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if (defined(TYPELONG))
  #define CLASSNAME TwoScalarFactory
  #define CLASSSTRING "TwoScalarFactory"
  #define ISTYPE isIntegral()
  #define TYPECOMPARISON Int
  #define FUNCTIONS Functions
  #define FUNCTIONUNARY FunctionUnary
  #define LINEARBINARY LinearBinary
  #define INTEQUAL IntEqual
#elif (defined(TYPEDOUBLE))
  #define CLASSNAME TwoFloatFactory
  #define CLASSSTRING "TwoFloatFactory"
  #define ISTYPE isFloat()
  #define TYPECOMPARISON Float
  #define FUNCTIONS FunctionsFloat
  #define FUNCTIONUNARY FunctionUnaryFloat
  #define LINEARBINARY LinearBinaryFloat
  #define INTEQUAL FloatEqual
#endif

// ***** This file is automatically generated from TwoScalarFactory.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.inv.*;

import utilMDE.*;
import org.apache.log4j.Logger;

import java.util.*;

public final class CLASSNAME {

  /** Debugging tracer. **/
  public static final Logger debug
    = Logger.getLogger("daikon.inv.binary.twoScalar." + CLASSSTRING);

  // Adds the appropriate new Invariant objects to the specified Invariants
  // collection.
  public static Vector instantiate(PptSlice ppt) {

    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];

    if (debug.isDebugEnabled()) {
      debug.debug ("Trying to instantiate for " + ppt.ppt_name + ": " + var1.name  + " and " + var2.name);
    }

    // Assert.assertTrue((! var1.rep_type.isArray()) && (! var2.rep_type.isArray()));
#if defined(TYPELONG)
    Assert.assertTrue(var1.rep_type.isScalar());
    Assert.assertTrue(var2.rep_type.isScalar());
#elif defined(TYPEDOUBLE)
    Assert.assertTrue(var1.rep_type.isFloat());
    Assert.assertTrue(var2.rep_type.isFloat());
#endif
    if (! var1.compatible(var2)) {
      debug.debug ("Not comparable, returning");
      return null;
    }

    // In V3, we are more ambitious and will do inference over static
    // constants.  In any case, this test belongs in PptTopLevel anyway.
    // if (var1.isStaticConstant() || var2.isStaticConstant()) {
    //   return null;
    // }

    boolean integral = var1.file_rep_type.ISTYPE && var2.file_rep_type.ISTYPE;

    Vector result = new Vector();

    result.add(INTEQUAL.instantiate(ppt));

#if defined(TYPELONG)
    result.add(IntNonEqual.instantiate(ppt));
    result.add(IntLessThan.instantiate(ppt));
    result.add(IntLessEqual.instantiate(ppt));
    result.add(IntGreaterThan.instantiate(ppt));
    result.add(IntGreaterEqual.instantiate(ppt));
#elif defined(TYPEDOUBLE)
    result.add(FloatNonEqual.instantiate(ppt));
    result.add(FloatLessThan.instantiate(ppt));
    result.add(FloatLessEqual.instantiate(ppt));
    result.add(FloatGreaterThan.instantiate(ppt));
    result.add(FloatGreaterEqual.instantiate(ppt));
#endif

    // Skip LineayBinary and FunctionUnary unless vars are integral
    if (!integral) {
      Global.subexact_noninstantiated_invariants += 1;
      Global.subexact_noninstantiated_invariants += FUNCTIONS.unaryFunctionNames.length;
    } else {
      result.add(LINEARBINARY.instantiate(ppt));
      int numFunctions = FUNCTIONS.unaryFunctionNames.length;
      for (int i=0; i<2; i++) {
        boolean invert = (i==1);
        for (int j=0; j<numFunctions; j++) {
          result.add(FUNCTIONUNARY.instantiate(ppt, FUNCTIONS.unaryFunctionNames[j], j, invert));
        }
      }
    }
    return result;
  }

  private CLASSNAME() {
  }

}
