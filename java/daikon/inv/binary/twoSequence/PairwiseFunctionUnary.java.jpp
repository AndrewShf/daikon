#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPEDOUBLE) || defined(TYPELONG))
  #error "TYPEDOUBLE or TYPELONG must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME PairwiseFunctionUnary
  #define SUPERCLASS TwoSequence
  #define PRIMITIVE long
  #define CORECLASS FunctionUnaryCore
  #define CLASSSTRING "PairwiseFunctionUnary"
  #define FUNCTION_LIST ~
#elif defined(TYPEDOUBLE)
  #define CLASSNAME PairwiseFunctionUnaryFloat
  #define SUPERCLASS TwoSequenceFloat
  #define PRIMITIVE double
  #define CORECLASS FunctionUnaryCoreFloat
  #define CLASSSTRING "PairwiseFunctionUnaryFloat"
  #define FUNCTION_LIST none
#endif

// ***** This file is automatically generated from PairwiseFunctionUnary.java.jpp

package daikon.inv.binary.twoSequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.DiscardInfo;
import daikon.inv.DiscardCode;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoScalar.*;
import java.lang.reflect.*;
import java.util.logging.Level;

/**
 * Represents an invariant between corresponding elements of two
 * PRIMITIVE sequences by applying a function to one of the elements.
 * The length of the sequences must match for the invariant to hold.
 * The function is applied to each (x[i], y[i]) pair.  Prints as
 * either "x[] == function(y[])" or "x[] = [op] y[]" depending upon
 * whether it is an actual function call or a unary operator.
 *
 * Current PRIMITIVE Functions are: FUNCTION_LIST
 **/
public class CLASSNAME
  extends SUPERCLASS
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff PairwiseFunctionUnary invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  public CORECLASS core;

  protected CLASSNAME(PptSlice ppt, String[] methodname, int function, boolean inverse) {
    super(ppt);
    core = new CORECLASS(this, methodname, function, inverse);
  }

  public static CLASSNAME instantiate(PptSlice ppt, String[] methodname, int methodnumber, boolean inverse) {
    if (!dkconfig_enabled) return null;
     CLASSNAME result =
      new CLASSNAME(ppt, methodname, methodnumber, inverse);
    // Don't instantiate if the variables can't have order
    if (!result.var1().aux.getFlag(VarInfoAux.HAS_ORDER) ||
        !result.var2().aux.getFlag(VarInfoAux.HAS_ORDER)) {
      if (debug.isLoggable(Level.FINE)) {
        debug.fine ("Not instantitating for because order has no meaning: " +
                     result.var1().name + " and " + result.var2().name);
      }
      return null;
    }
    return result;
  }

  protected Object clone() {
    CLASSNAME result = (CLASSNAME) super.clone();
    result.core = (CORECLASS) core.clone();
    result.core.wrapper = result;
    return result;
  }

  protected Invariant resurrect_done_swapped() {
    core.swap();
    return this;
  }

  public String repr() {
    return CLASSSTRING + varNames() + ": " + core.repr();
  }

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.IOA) {
      return format_ioa();
    } else if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }

    return core.format_using(format, var1().name, var1(), var2().name, var2());
  }

  public String format_simplify() {
    if (!core.methodname[1].equals(""))
      return format_unimplemented(OutputFormat.SIMPLIFY);
    String[] form;
    if (core.inverse) {
      // var1[i] = fn(var2[i])
      form = VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
        { var2().name, var1().name }, true); // elementwise
    } else {
      // var2[i] = fn(var1[i])
      form = VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
        { var1().name, var2().name }, true); // elementwise
    }
    return form[0] + "(EQ (" + core.methodname[0] + " " + form[1]
      + ") " + form[2] + ")" + form[3];
  }

  /* IOA */
  public String format_ioa() {
    if (var1().isIOASet() || var2().isIOASet())
      return "Not valid for sets: " + format();
    VarInfoName.QuantHelper.IOAQuantification quant1 = new VarInfoName.QuantHelper.IOAQuantification(var1());
    VarInfoName.QuantHelper.IOAQuantification quant2 = new VarInfoName.QuantHelper.IOAQuantification(var2());

    return quant1.getQuantifierExp()
      + core.format_using(OutputFormat.IOA,
                          quant1.getVarName(0), null,
                          quant2.getVarName(0), null)
      + quant1.getClosingExp();
  }

  public InvariantStatus add_modified(PRIMITIVE[] x_arr, PRIMITIVE[] y_arr, int count) {
    if (x_arr.length != y_arr.length) {
      // destroyAndFlow();
      return InvariantStatus.FALSIFIED;
    }
    int len = x_arr.length;
    // int len = Math.min(x_arr.length, y_arr.length);
    for (int i=0; i<len; i++) {
      PRIMITIVE x  = x_arr[i];
      PRIMITIVE y = y_arr[i];

      if (core.add_modified(x, y, count) == InvariantStatus.FALSIFIED) {
      //if (falsified)
        return InvariantStatus.FALSIFIED;
      }
    }
    return InvariantStatus.NO_CHANGE;
  }

  protected double computeConfidence() {
    return core.computeConfidence();
  }

  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((CLASSNAME) other).core);
  }

}
