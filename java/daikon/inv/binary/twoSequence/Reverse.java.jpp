#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined."
#endif

#if defined(TYPELONG)
  #define CLASSNAME Reverse
  #define SUPERCLASS TwoSequence
  #define PRIMITIVE long
  #define CLASSSTRING "Reverse"
  #define EQUAL(a,b) ((a) == (b))
#elif defined(TYPEDOUBLE)
  #define CLASSNAME ReverseFloat
  #define SUPERCLASS TwoSequenceFloat
  #define PRIMITIVE double
  #define CLASSSTRING "ReverseFloat"
  #define EQUAL(a,b) Global.fuzzy.eq(a, b)
#endif

// ***** This file is automatically generated from Reverse.java.jpp

package daikon.inv.binary.twoSequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import utilMDE.Assert;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * Represents two PRIMITIVE sequences where one is in the reverse order
 * of the other.  Prints as "x[] is the reverse of y[]"
 **/
public class CLASSNAME
  extends SUPERCLASS
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  public static final Logger debug =
    Logger.getLogger("daikon.inv.binary.twoSequence." + CLASSSTRING);

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff Reverse invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  protected CLASSNAME(PptSlice ppt) {
    super(ppt);
  }

  public static CLASSNAME instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    CLASSNAME result = new CLASSNAME(ppt);
    // Don't instantiate if the variables can't have order
    if (!result.var1().aux.getFlag(VarInfoAux.HAS_ORDER) ||
        !result.var2().aux.getFlag(VarInfoAux.HAS_ORDER)) {
      if (debug.isLoggable(Level.FINE)) {
        debug.fine ("Not instantitating for" + CLASSSTRING + " because order has no meaning: " +
                     result.var1().name + " and " + result.var2().name);
      }
      return null;
    }
    return result;
  }

  protected Invariant resurrect_done_swapped() {
    // "reverse of" is symmetric
    return this;
  }

  public String repr() {
    return CLASSSTRING + varNames() + ": "
      + "falsified=" + falsified;
  }

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.DAIKON) return format_daikon();
    if (format == OutputFormat.IOA) return format_ioa();
    if (format == OutputFormat.JAVA) return format_java();
    if (format == OutputFormat.JML) return format_jml();
    if (format == OutputFormat.SIMPLIFY) return format_simplify();

    return format_unimplemented(format);
  }

  public String format_daikon() {
    return var1().name.name() + " is the reverse of " + var2().name.name();
  }

  /* IOA */
  public String format_ioa() {
    return "Not valid for Sets or Arrays: " + format();
  }

  public String format_java() {
    // ( (new StringBuffer (var1().name.name())).reverse().toString(
    //       ).equals (var2().name.name()))
    return "( (new StringBuffer(" + var1().name.name() + ")).reverse().toString().equals (" + var2().name.name() + ")";
  }

  public String format_jml() {
    // The following line of code does not correctly indicate that one array is the reverse of the other
    // return "(new StringBuffer(" + var1().name.name() + ")).reverse().toString().equals(" + var2().name.name() + ")";

    VarInfoName name1,name2;
    name1 = var1().name;
    name2 = var2().name;

    String upperExtent = ""; // Pacify javac with the initialization

    VarInfoName seq = name2;
    String preTag = "", postTag = "";

    if (seq instanceof VarInfoName.Prestate) {
      seq = ((VarInfoName.Prestate)seq).term;
      preTag += "\\old(";
      postTag += ")";
    } else if (seq instanceof VarInfoName.Poststate) {
      return "inexpressible, daikon rep = " + format_daikon();
    }

    if (seq instanceof VarInfoName.Elements) {
    } else if (seq instanceof VarInfoName.Slice) {
      seq = ((VarInfoName.Slice)seq).sequence;
    } else { // Should never happen
      throw new IllegalStateException();
    }

    if (name2 instanceof VarInfoName.Slice && ((VarInfoName.Slice)name2).j != null)
      upperExtent = ((VarInfoName.Slice)name2).j.jml_name();
    else
      upperExtent = seq.applySize().jml_name();

    VarInfoName.QuantHelper.QuantifyReturn qret = VarInfoName.QuantHelper.quantify(new VarInfoName [] {name1});
    String results[] = VarInfoName.QuantHelper.format_jml(qret,true);

    VarInfoName index = ((VarInfoName [])qret.bound_vars.get(0))[0];

    // Would normally create a new VarInfoName for the subscript and then use applySubscript, but
    // parse appears to choke on that output... until it works, using this
    return results[0] + results[1] + " == " + preTag + ((VarInfoName.Elements)seq).term.jml_name() + "[" + upperExtent + "-1-" + index.jml_name() + "]" + postTag + results[2];
  }

  public String format_simplify() {
    if (Invariant.dkconfig_simplify_define_predicates)
      return format_simplify_defined();
    else
      return format_simplify_explicit();
  }

  private String format_simplify_defined() {
    VarInfo onevar = var1();
    VarInfo othervar = var2();
    String[] one_name =
      VarInfoName.QuantHelper.simplifyNameAndBounds(onevar.name);
    String[] other_name =
      VarInfoName.QuantHelper.simplifyNameAndBounds(othervar.name);

    if (one_name == null || other_name == null) {
      return "format_simplify() can't handle one of these sequences: "
        + format();
    }

    return "(|is-reverse-of| " +
      one_name[0] + " " + one_name[1] + " " + one_name[2] + " " +
      other_name[0] + " " + other_name[1] + " " + other_name[2] + ")";
  }

  private String format_simplify_explicit() {
    return "format_simplify() for Reverse needs to be implemented "
      + "for the non-defined-predicate case";
  }

  public void add_modified(PRIMITIVE[] a1, PRIMITIVE[] a2, int count) {
    if (a1.length != a2.length) {
      destroyAndFlow();
      discardCode = DiscardCode.bad_sample;
      String var1Name = var1().name.name();
      String var2Name = var2().name.name();
      discardString = var1Name + "==" + utilMDE.ArraysMDE.toString(a1) + " has length " + a1.length +
        " while " + var2Name + "==" + utilMDE.ArraysMDE.toString(a2) + " has length " + a2.length;
      return;
    }
    int len = a1.length;
    for (int i=0, j=len-1; i<len; i++, j--)
      if (!EQUAL (a1[i], a2[j])) {
        destroyAndFlow();
        discardCode = DiscardCode.bad_sample;
        String var1Name = var1().name.name();
        String var2Name = var2().name.name();
        discardString = var1Name+"["+i+"]="+a1[i]+" does not equal "+var2Name+"["+j+"]="+a2[j];
        return;
      }
  }


  protected double computeProbability() {
    if (falsified)
      return Invariant.PROBABILITY_NEVER;
    else
      return Invariant.PROBABILITY_JUSTIFIED;
  }

  public boolean isSameFormula(Invariant other)
  {
    Assert.assertTrue(other instanceof CLASSNAME);
    return true;
  }

}
