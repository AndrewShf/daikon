#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING) || defined(LESSTHAN) || defined(LESSTHANFLOAT) || defined(LESSTHANSTRING) || defined(GREATERTHAN) || defined(GREATERTHANFLOAT) || defined(GREATERTHANSTRING) || defined(LESSEQUAL) || defined(LESSEQUALFLOAT) || defined(LESSEQUALSTRING) || defined(GREATEREQUAL) || defined(GREATEREQUALFLOAT) || defined(GREATEREQUALSTRING))
  #error "EQUAL, EQUALFLOAT, EQUALSTRING, LESSTHAN, LESSTHANFLOAT, LESSTHANSTRING, GREATERTHAN, GREATERTHANFLOAT, GREATERTHANSTRING, LESSEQUAL, LESSEQUALFLOAT, LESSEQUALSTRING, GREATEREQUAL, GREATEREQUALFLOAT, or GREATEREQUALSTRING must be defined"
#endif

#if (defined(EQUAL) || defined(LESSTHAN) || defined(GREATERTHAN) || defined(LESSEQUAL) || defined(GREATEREQUAL))
  #define SUPERCLASS TwoSequence
  #define PRIMITIVE long
  #define ARRAYCOMPARATOR new ArraysMDE.LongArrayComparatorLexical()
  #define ELEM_MATCH_COMPARE(v1, v2) (ArraysMDE.isSubset (v1, v2) && \
                                      ArraysMDE.isSubset (v2, v1))
  #define SUBSEQUENCE SubSequence
  #define BASEISTYPE baseIsIntegral()
  #define VALUETRACKER ValueTracker
  #define SEQ_SUBSEQUENCE SequenceScalarSubsequence
  #define PAIRWISECOMP_EQ PairwiseIntEqual
  #define PAIRWISECOMP_LT PairwiseIntLessThan
  #define PAIRWISECOMP_GT PairwiseIntGreaterThan
  #define PAIRWISECOMP_LE PairwiseIntLessEqual
  #define PAIRWISECOMP_GE PairwiseIntGreaterEqual
  #define SEQSEQ_EQ       SeqSeqIntEqual
  #define SEQSEQ_LT       SeqSeqIntLessThan
  #define SEQSEQ_GT       SeqSeqIntGreaterThan
  #define SEQSEQ_LE       SeqSeqIntLessEqual
  #define SEQSEQ_GE       SeqSeqIntGreaterEqual
#elif (defined(EQUALFLOAT) || defined(LESSTHANFLOAT) || defined(GREATERTHANFLOAT) || defined(LESSEQUALFLOAT) || defined(GREATEREQUALFLOAT))
  #define SUPERCLASS TwoSequenceFloat
  #define PRIMITIVE double
  #define ARRAYCOMPARATOR Global.fuzzy.new DoubleArrayComparatorLexical()
  #define ELEM_MATCH_COMPARE(v1, v2) Global.fuzzy.isElemMatch (v1, v2)
  #define SUBSEQUENCE SubSequenceFloat
  #define BASEISTYPE baseIsFloat()
  #define VALUETRACKER FloatValueTracker
  #define SEQ_SUBSEQUENCE SequenceFloatSubsequence
  #define PAIRWISECOMP_EQ PairwiseFloatEqual
  #define PAIRWISECOMP_LT PairwiseFloatLessThan
  #define PAIRWISECOMP_GT PairwiseFloatGreaterThan
  #define PAIRWISECOMP_LE PairwiseFloatLessEqual
  #define PAIRWISECOMP_GE PairwiseFloatGreaterEqual
  #define SEQSEQ_EQ       SeqSeqFloatEqual
  #define SEQSEQ_LT       SeqSeqFloatLessThan
  #define SEQSEQ_GT       SeqSeqFloatGreaterThan
  #define SEQSEQ_LE       SeqSeqFloatLessEqual
  #define SEQSEQ_GE       SeqSeqFloatGreaterEqual
#elif (defined(EQUALSTRING) || defined(LESSTHANSTRING) || defined(GREATERTHANSTRING) || defined(LESSEQUALSTRING) || defined(GREATEREQUALSTRING))
  #define SUPERCLASS TwoSequenceString
  #define PRIMITIVE String
  #define ARRAYCOMPARATOR new ArraysMDE.StringArrayComparatorLexical()
  #define ELEM_MATCH_COMPARE(v1, v2) (ArraysMDE.isSubset (v1, v2) && \
                                      ArraysMDE.isSubset (v2, v1))
  #define SUBSEQUENCE SubSequenceString
  #define BASEISTYPE baseIsString()
  #define VALUETRACKER StringValueTracker
  #define SEQ_SUBSEQUENCE SequenceStringSubsequence
  #define PAIRWISECOMP_EQ PairwiseStringEqual
  #define PAIRWISECOMP_LT PairwiseStringLessThan
  #define PAIRWISECOMP_GT PairwiseStringGreaterThan
  #define PAIRWISECOMP_LE PairwiseStringLessEqual
  #define PAIRWISECOMP_GE PairwiseStringGreaterEqual
  #define SEQCOMPAR_EQ SeqSeqStringEqual
  #define SEQCOMPAR_LT SeqSeqStringLessThan
  #define SEQCOMPAR_GT SeqSeqStringGreaterThan
  #define SEQCOMPAR_LE SeqSeqStringLessEqual
  #define SEQCOMPAR_GE SeqSeqStringGreaterEqual
#endif

#if defined(EQUAL)
  #define SEQSEQINTEQUAL SeqSeqIntEqual
  #define SEQSEQINTEQUALstring "SeqSeqIntEqual"
  #define COMPAREQUALS(a,b) (a == b)
  #define COMPARE ==
  #define EQUALSstring "=="
  #define EQUALSIOAstring "="
  #define PAIRWISEINTEQUAL PairwiseIntEqual
#elif defined(EQUALFLOAT)
  #define SEQSEQINTEQUAL SeqSeqFloatEqual
  #define SEQSEQINTEQUALstring "SeqSeqFloatEqual"
  #define COMPAREQUALS(a,b) (a == b)
  #define COMPARE ==
  #define EQUALSstring "=="
  #define EQUALSIOAstring "="
  #define PAIRWISEINTEQUAL PairwiseFloatEqual
#elif defined(EQUALSTRING)
  #define SEQSEQINTEQUAL SeqSeqStringEqual
  #define SEQSEQINTEQUALstring "SeqSeqStringEqual"
  #define COMPAREQUALS(a,b) (a == b)
  #define COMPARE ==
  #define EQUALSstring "=="
  #define EQUALSIOAstring "="
  #define PAIRWISEINTEQUAL PairwiseStringEqual
#elif defined(LESSTHAN)
  #define SEQSEQINTEQUAL SeqSeqIntLessThan
  #define SEQSEQINTEQUALstring "SeqSeqIntLessThan"
  #define SEQCOMPAR_SWAP SeqSeqIntGreaterThan
  #define COMPAREQUALS(a,b) (a < b)
  #define COMPARE <
  #define EQUALSstring "<"
  #define EQUALSIOAstring "<"
  #define PAIRWISEINTEQUAL PairwiseIntLessThan
#elif defined(LESSTHANFLOAT)
  #define SEQSEQINTEQUAL SeqSeqFloatLessThan
  #define SEQSEQINTEQUALstring "SeqSeqFloatLessThan"
  #define SEQCOMPAR_SWAP SeqSeqFloatGreaterThan
  #define COMPAREQUALS(a,b) (a < b)
  #define COMPARE <
  #define EQUALSstring "<"
  #define EQUALSIOAstring "<"
  #define PAIRWISEINTEQUAL PairwiseFloatLessThan
#elif defined(LESSTHANSTRING)
  #define SEQSEQINTEQUAL SeqSeqStringLessThan
  #define SEQSEQINTEQUALstring "SeqSeqStringLessThan"
  #define SEQCOMPAR_SWAP SeqSeqStringGreaterThan
  #define COMPAREQUALS(a,b) (a < b)
  #define COMPARE <
  #define EQUALSstring "<"
  #define EQUALSIOAstring "<"
  #define PAIRWISEINTEQUAL PairwiseStringLessThan
#elif defined(GREATERTHAN)
  #define SEQSEQINTEQUAL SeqSeqIntGreaterThan
  #define SEQSEQINTEQUALstring "SeqSeqIntGreaterThan"
  #define SEQCOMPAR_SWAP SeqSeqIntLessThan
  #define COMPAREQUALS(a,b) (a > b)
  #define COMPARE >
  #define EQUALSstring ">"
  #define EQUALSIOAstring ">"
  #define PAIRWISEINTEQUAL PairwiseIntGreaterThan
#elif defined(GREATERTHANFLOAT)
  #define SEQSEQINTEQUAL SeqSeqFloatGreaterThan
  #define SEQSEQINTEQUALstring "SeqSeqFloatGreaterThan"
  #define SEQCOMPAR_SWAP SeqSeqFloatLessThan
  #define COMPAREQUALS(a,b) (a > b)
  #define COMPARE >
  #define EQUALSstring ">"
  #define EQUALSIOAstring ">"
  #define PAIRWISEINTEQUAL PairwiseFloatGreaterThan
#elif defined(GREATERTHANSTRING)
  #define SEQSEQINTEQUAL SeqSeqStringGreaterThan
  #define SEQSEQINTEQUALstring "SeqSeqStringGreaterThan"
  #define SEQCOMPAR_SWAP SeqSeqStringLessThan
  #define COMPAREQUALS(a,b) (a > b)
  #define COMPARE >
  #define EQUALSstring ">"
  #define EQUALSIOAstring ">"
  #define PAIRWISEINTEQUAL PairwiseStringGreaterThan
#elif defined(LESSEQUAL)
  #define SEQSEQINTEQUAL SeqSeqIntLessEqual
  #define SEQSEQINTEQUALstring "SeqSeqIntLessEqual"
  #define SEQCOMPAR_SWAP SeqSeqIntGreaterEqual
  #define COMPAREQUALS(a,b) (a <= b)
  #define COMPARE <=
  #define EQUALSstring "<="
  #define EQUALSIOAstring "<="
  #define PAIRWISEINTEQUAL PairwiseIntLessEqual
#elif defined(LESSEQUALFLOAT)
  #define SEQSEQINTEQUAL SeqSeqFloatLessEqual
  #define SEQSEQINTEQUALstring "SeqSeqFloatLessEqual"
  #define SEQCOMPAR_SWAP SeqSeqFloatGreaterEqual
  #define COMPAREQUALS(a,b) (a <= b)
  #define COMPARE <=
  #define EQUALSstring "<="
  #define EQUALSIOAstring "<="
  #define PAIRWISEINTEQUAL PairwiseFloatLessEqual
#elif defined(LESSEQUALSTRING)
  #define SEQSEQINTEQUAL SeqSeqStringLessEqual
  #define SEQSEQINTEQUALstring "SeqSeqStringLessEqual"
  #define SEQCOMPAR_SWAP SeqSeqStringGreaterEqual
  #define COMPAREQUALS(a,b) (a <= b)
  #define COMPARE <=
  #define EQUALSstring "<="
  #define EQUALSIOAstring "<="
  #define PAIRWISEINTEQUAL PairwiseStringLessEqual
#elif defined(GREATEREQUAL)
  #define SEQSEQINTEQUAL SeqSeqIntGreaterEqual
  #define SEQSEQINTEQUALstring "SeqSeqIntGreaterEqual"
  #define SEQCOMPAR_SWAP SeqSeqIntLessEqual
  #define COMPAREQUALS(a,b) (a >= b)
  #define COMPARE >=
  #define EQUALSstring ">="
  #define EQUALSIOAstring ">="
  #define PAIRWISEINTEQUAL PairwiseIntGreaterEqual
#elif defined(GREATEREQUALFLOAT)
  #define SEQSEQINTEQUAL SeqSeqFloatGreaterEqual
  #define SEQSEQINTEQUALstring "SeqSeqFloatGreaterEqual"
  #define SEQCOMPAR_SWAP SeqSeqFloatLessEqual
  #define COMPAREQUALS(a,b) (a >= b)
  #define COMPARE >=
  #define EQUALSstring ">="
  #define EQUALSIOAstring ">="
  #define PAIRWISEINTEQUAL PairwiseFloatGreaterEqual
#elif defined(GREATEREQUALSTRING)
  #define SEQSEQINTEQUAL SeqSeqStringGreaterEqual
  #define SEQSEQINTEQUALstring "SeqSeqStringGreaterEqual"
  #define SEQCOMPAR_SWAP SeqSeqStringLessEqual
  #define COMPAREQUALS(a,b) (a >= b)
  #define COMPARE >=
  #define EQUALSstring ">="
  #define EQUALSIOAstring ">="
  #define PAIRWISEINTEQUAL PairwiseStringGreaterEqual
#endif

// ***** This file is automatically generated from SeqComparison.java.jpp

package daikon.inv.binary.twoSequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.binary.twoString.*;
import daikon.suppress.*;
import daikon.derive.*;
import daikon.derive.ternary.*;
import daikon.derive.binary.*;

import utilMDE.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.*;


/**
 * Represents invariants between two PRIMITIVE sequences.  If order
 * matters for each variable (which it does by default), then the
 * sequences are compared lexically.  Prints as 'x[] COMPARE y[] lexically'
 *
#if (defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING))
 * If order doesn't matter for each variable, then the sequences
 * are compared to see if they are set equivalent.  Prints as
 * "x[] == y[]"
#endif
 *
 * If the auxillary information (eg, order matters) doesn't match then
 * no comparison is made at all.
 **/
public class SEQSEQINTEQUAL
  extends SUPERCLASS
  implements Comparison
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030715L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff SEQSEQINTEQUAL invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  /**
   * Debugging logger.
   **/
  final static Logger debug = Logger.getLogger ("daikon.inv.binary.twoSequence."
                                                + SEQSEQINTEQUALstring);

  static Comparator comparator = ARRAYCOMPARATOR;

  boolean orderMatters;

  protected VALUETRACKER values_cache = new VALUETRACKER(8);

  protected SEQSEQINTEQUAL(PptSlice ppt, boolean order) {
    super(ppt);
    orderMatters = order;
  }

  #if !(defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING))
  protected SEQSEQINTEQUAL(SEQCOMPAR_SWAP seq_swap) {
    super(seq_swap.ppt);
    orderMatters = seq_swap.orderMatters;
    values_cache = (VALUETRACKER)seq_swap.values_cache.clone();
  }
  #endif

  //   public static SEQSEQINTEQUAL instantiate(PptSlice ppt) {
  //     return instantiate (ppt, false);
  //   }

  public static SEQSEQINTEQUAL instantiate(PptSlice ppt, boolean onlyEq) {
    if (!dkconfig_enabled) return null;

    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];

    // System.out.println("Ppt: " + ppt.name);
    // System.out.println("vars[0]: " + var1.type.format() + " " + var1.name + " " + var1.aux);
    // System.out.println("vars[1]: " + var2.type.format() + " " + var2.name + " " + var2.aux);

    ProglangType type1 = var1.type;
    ProglangType type2 = var2.type;

    #if !(defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING))
    // This intentonally checks dimensions(), not pseudoDimensions.
    boolean only_eq = (! ((type1.dimensions() == 1)
                          && type1.BASEISTYPE
                          && (type2.dimensions() == 1)
                          && type2.BASEISTYPE));
    if (only_eq) return null;
    #endif

    SEQSEQINTEQUAL result;
    if (var1.aux.getFlag(VarInfoAux.HAS_ORDER)
        && var2.aux.getFlag(VarInfoAux.HAS_ORDER)) {
      result = new SEQSEQINTEQUAL(ppt, true);
    } else {
      #if !(defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING))
      return null;
      #else
      result = new SEQSEQINTEQUAL(ppt, false);
      #endif
    }
    // System.out.println("SEQSEQINTEQUAL.instantiate => " + result.repr());
    return result;
  }

  protected Object clone() {
    SEQSEQINTEQUAL result = (SEQSEQINTEQUAL) super.clone();
    result.values_cache = (VALUETRACKER) values_cache.clone();
    return result;
  }

  /**
   * Suppress is not ok since we keep track of values with ValueTracker
   */
  public boolean inProcessSuppressOk() {
    return false;
  }

  protected Invariant resurrect_done_swapped() {
    #if (defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING))
    return this;
    #else
    return new SEQCOMPAR_SWAP(this);
    #endif
  }

  public String repr() {
    return SEQSEQINTEQUALstring + varNames() + ": "
      + ",orderMatters=" + orderMatters
      + ",enoughSamples=" + enoughSamples()
      ;
  }

  public String format_using(OutputFormat format) {
    // System.out.println("Calling " + SEQSEQINTEQUALstring + ".format for: " + repr());

    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }

    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.JAVA))
    {
      String name1 = var1().name.name_using(format);
      String name2 = var2().name.name_using(format);
      #if (! (defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING)))
      String lexically = (var1().aux.getFlag(VarInfoAux.HAS_ORDER)
                          ? " (lexically)"
                          : "");

      return name1 + " " + EQUALSstring + " " + name2 + lexically;
      #else
      return name1 + " " + EQUALSstring + " " + name2;
      #endif
    }

    if (format == OutputFormat.IOA) {
      if (var1().isIOASet() || var2().isIOASet()) {
        return "Not valid for Sets: " + format();
      }
      String name1 = var1().name.name_using(format);
      String name2 = var2().name.name_using(format);
      return name1 + " " + EQUALSIOAstring + " " + name2 + " ***";
    }

    if (format == OutputFormat.JML) { // Must complete
      String quantResult[] = VarInfoName.QuantHelper.format_jml(new VarInfoName[] {var1().name,var2().name},true);
      return quantResult[0] + quantResult[1] + EQUALSstring + quantResult[2] + quantResult[3];
    }
    return format_unimplemented(format);
  }

  public String format_simplify() {
    if (Invariant.dkconfig_simplify_define_predicates)
      return format_simplify_defined();
    else
      return format_simplify_explicit();
  }

  private String format_simplify_defined() {
    String[] var1_name =
      VarInfoName.QuantHelper.simplifyNameAndBounds(var1().name);
    String[] var2_name =
      VarInfoName.QuantHelper.simplifyNameAndBounds(var2().name);
    if (var1_name == null || var2_name == null) {
      return "format_simplify can't handle one of these sequences: "
        + format();
    }
    return "(|lexical-" + EQUALSstring + "| " +
      var1_name[0] + " " + var1_name[1] + " " + var1_name[2] + " " +
      var2_name[0] + " " + var2_name[1] + " " + var2_name[2] + ")";
  }

  private String format_simplify_explicit() {
    #if (defined(EQUAL) || defined(EQUALSTRING) || defined(EQUALFLOAT))
      // A simple case: if two sequences are lexically equal iff they
      // are elementwise equal.
      String[] form =
        VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
          { var1().name, var2().name }, true); // elementwise
      return form[0] +
        "(EQ " + form[1] + " " + form[2] + ")" + form[3];
    #else
      String classname = this.getClass().toString().substring(6);
      return "warning: method " + classname
        + ".format_simplify_explicit() needs to be implemented: " + format();
    #endif
  }

  public void add_modified(PRIMITIVE[] v1, PRIMITIVE[] v2, int count) {
    /// This does not do the right thing; I really want to avoid comparisons
    /// if one is missing, but not if one is zero-length.
    // // Don't make comparisons with empty arrays.
    // if ((v1.length == 0) || (v2.length == 0)) {
    //   return;
    // }

    int comparison = 0;
    if (orderMatters) {
      // Standard element wise comparison
       comparison = comparator.compare(v1, v2);
    } else {
      // Do a double subset comparison
      comparison = ELEM_MATCH_COMPARE(v1, v2) ? 0 : -1;
    }

    if (logDetail())
      log ("add_modified (" + ArraysMDE.toString(v1) + ", " +
           ArraysMDE.toString(v2) + ") " + comparison);
    if (! COMPAREQUALS(comparison,0) ) {
      destroyAndFlow();
      discardCode = DiscardCode.bad_sample;
      String var1 = ppt.var_infos[0].name.name();
      String var2 = ppt.var_infos[1].name.name();
      discardString = "Falsified by sample: " + var1 + "==" + ArraysMDE.toString(v1) +
        ", " + var2 + "==" + ArraysMDE.toString(v2);
      return;
    }
    values_cache.add(v1, v2);
  }

  protected double computeProbability() {
    if (falsified) {
      return Invariant.PROBABILITY_NEVER;
    } else {
      #if !(defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING))
      return Math.pow(.5, ppt.num_values());
      #else
      if (ppt.num_samples() == 0) {
        discardCode = DiscardCode.not_enough_samples;
        discardString = "0 samples seen";
        return Invariant.PROBABILITY_UNJUSTIFIED;
      } else {
        return Invariant.PROBABILITY_JUSTIFIED;
      }
      #endif
    }
  }

  // For Comparison interface
  public double eq_probability() {
    #if (defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING))
      return computeProbability();
    #else
      return Invariant.PROBABILITY_NEVER;
    #endif
  }

  public boolean isSameFormula(Invariant o)
  {
    return true;
  }

  public boolean isExclusiveFormula(Invariant o)
  {
    return false;
  }

  /**
   *  Since this invariant can be a postProcessed equality, we have to
   *  handle isObvious especially to avoid circular isObvious
   *  relations.
   **/
  public VarInfo[] isObviousStatically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      if (isObviousStatically (this.ppt.var_infos)) {
        return this.ppt.var_infos;
      } else {
        return null;
      }
    } else {
      return super.isObviousStatically_SomeInEquality();
    }
  }

  /**
   *  Since this invariant can be a postProcessed equality, we have to
   *  handle isObvious especially to avoid circular isObvious
   *  relations.
   **/
  public VarInfo[] isObviousDynamically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      if (isObviousDynamically (this.ppt.var_infos)) {
        return this.ppt.var_infos;
      } else {
        return null;
      }
    } else {
      return super.isObviousDynamically_SomeInEquality();
    }
  }

  public boolean isObviousStatically(VarInfo[] vis) {
    #if (! (defined(EQUALSTRING) || defined(LESSTHANSTRING) || defined(GREATERTHANSTRING) || defined(LESSEQUALSTRING) || defined(GREATEREQUALSTRING)) )
      VarInfo var1 = vis[0];
      VarInfo var2 = vis[1];
      Object[] obv1 = SUBSEQUENCE.isObviousSubSequence(var1, var2);
      Object[] obv2 = SUBSEQUENCE.isObviousSubSequence(var2, var1);
      if ((obv1[1] != null) || (obv2[1] != null)) {
        return true;
      }
    #endif
    return super.isObviousStatically (vis);
  }

  public boolean isObviousDynamically(VarInfo[] vis) {
    #if (! (defined(EQUALSTRING) || defined(LESSTHANSTRING) || defined(GREATERTHANSTRING) || defined(LESSEQUALSTRING) || defined(GREATEREQUALSTRING)) )

      Debug debug = new Debug (getClass(), ppt, vis);

      if (logOn())
        debug.log ("Checking IsObviousDynamically");

      PptSlice ppt = this.ppt.parent.findSlice_unordered (vis);
      if (ppt!=null) {
        Invariant pic = PAIRWISEINTEQUAL.find(ppt);
        if (pic != null) {
          if (logOn())
            debug.log ("Obvious Dynamic from " + pic.format());
            return true;
        }
      }

      // If either variable is a subsequence and the original arrays
      // are related elementwise this isn't interesting
      VarInfo v1 = vis[0];
      VarInfo v2 = vis[1];
      VarInfo arr1 = v1;
      VarInfo arr2 = v2;
      if (v1.derived instanceof SEQ_SUBSEQUENCE)
        arr1 = ((SEQ_SUBSEQUENCE) v1.derived).seqvar();
      if (v2.derived instanceof SEQ_SUBSEQUENCE)
        arr2 = ((SEQ_SUBSEQUENCE) v2.derived).seqvar();
      if (!isEqual() && ((arr1 != v1) || (arr2 != v2))) {
        VarInfo[] avis = new VarInfo [] {arr1, arr2};
        ppt = this.ppt.parent.findSlice_unordered (avis);
        if (ppt != null) {
          PAIRWISECOMP_EQ picEQ = PAIRWISECOMP_EQ.find(ppt);
          PAIRWISECOMP_LT picLT = PAIRWISECOMP_LT.find(ppt);
          PAIRWISECOMP_GT picGT = PAIRWISECOMP_GT.find(ppt);
          PAIRWISECOMP_LE picLE = PAIRWISECOMP_LE.find(ppt);
          PAIRWISECOMP_GE picGE = PAIRWISECOMP_GE.find(ppt);
          if ((picEQ!= null) || (picLT!=null) || (picGT!=null) || (picLE!=null) || (picGE!=null)) {
            // if (logOn())
            //  debug.log ("Obvious Dynamic from " + pic.format());
            return (true);
          }
        }
      }

      // Similarly, if either variable is a subsequence and the original
      // arrays are related lexically this isn't interesting
      if ((arr1 != v1) || (arr2 != v2)) {
        if (arr1 == arr2) {
          debug.log ("Obvious Dynamic- subsequence from same array");
          return (true);
        }
        VarInfo[] avis = {arr1, arr2};
        //debug.log ("looking for " + avis[0].name.name()
        //     + " " + avis[1].name.name());
        ppt = this.ppt.parent.findSlice_unordered (avis);
        if (ppt != null) {
          List found = new ArrayList();
          found.add (SEQSEQ_EQ.find(ppt));
          found.add (SEQSEQ_LT.find(ppt));
          found.add (SEQSEQ_GT.find(ppt));
          found.add (SEQSEQ_LE.find(ppt));
          found.add (SEQSEQ_GE.find(ppt));
          for (int i = 0; i < found.size(); i++) {
            Invariant inv = (Invariant) found.get (i);
            if (inv != null) {
              if (logOn())
                debug.log ("Obvious Dynamic from " + inv.format());
              return (true);
            }
          }
        }
      }

      // Check to see if these variables are obviously related
      if (v1.isDerived() || v2.isDerived()) {
        if (SUBSEQUENCE.isObviousSubSequenceDynamically (this, v1, v2)
          || SUBSEQUENCE.isObviousSubSequenceDynamically (this, v2, v1)) {
          if (logOn())
            debug.log ("Obvious SubSequence Dynamically");
          return (true);
        }
      }

    #endif
    return super.isObviousDynamically(vis);
  }

  public void repCheck() {
    super.repCheck();
    /*
      This code is no longer needed now that the can_be_x's are gone
    if (! (this.can_be_eq || this.can_be_lt || this.can_be_gt)
        && ppt.num_samples() != 0) {
      System.err.println (this.repr());
      System.err.println (this.ppt.num_samples());
      throw new Error();
    }
    */
  }

  public boolean isEqual() {
    #if (defined(EQUAL) || defined(EQUALFLOAT) || defined(EQUALSTRING))
    return true;
    #else
    return false;
    #endif
  }

  // Look up a previously instantiated invariant.
  public static SEQSEQINTEQUAL find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 2);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof SEQSEQINTEQUAL)
        return (SEQSEQINTEQUAL) inv;
    }
    return null;
  }

#if !(defined(EQUALSTRING) || defined(LESSTHANSTRING) || defined(GREATERTHANSTRING) || defined(LESSEQUALSTRING) || defined(GREATEREQUALSTRING))

  // Create a suppression factory for pairwise and lexical
  #define FACTORY_CNT       2
  #define FACTORY1          pairwise_suppress
  #define FACTORY1_INV_CNT  1
  #define FACTORY1_VAR_INFO {new VarInfo[2]}
  #define FACTORY2          lexical_suppress
  #define FACTORY2_INV_CNT  1
  #define FACTORY2_VAR_INFO {new VarInfo[2]}
  #include "daikon/inv/suppressionFactory.java.jpp"

  /**
   * Suppression of lexical comparison by elementwise comparison for all
   * comparison operators except ==.  This can occur in two ways: <ol>
   *
   *    <li> The same arrays have the same elementwise comparison
   *
   *    <li> Subsequences of arrays with the same starting and ending
   *    index have the same element wise comparison over the entire
   *    array.  Note that both the start and end must match becaue of
   *    the way that lexical comparisons handle arrays of unequal length
   *    (the longer one is greater)
   *</ol>
   *
   * Note that all of these look for the entire arrays as a pairwise
   * comparison.  It is arguable that we should look for other enclosing
   * subsequences as well.
   */

  public static SuppressionLink pairwise_suppress (Invariant arg,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    // We should only be called with our own invariant
    Assert.assertTrue (arg instanceof SEQSEQINTEQUAL);
    SEQSEQINTEQUAL inv = (SEQSEQINTEQUAL) arg;

    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();

    if (logOn())
      inv.log ("Considering suppression by PairwiseComparison (x[], y[])");

    // This is not done for equals since the two comparisons are the
    // same in that case
    if (inv.isEqual())
      return (null);

    // Build the suppression template based on the arguments
    if (!v1.isDerived() && !v2.isDerived()) {
      supTemplate.set (0, PAIRWISEINTEQUAL.class, v1, v2);
    } else if (v1.isDerived() && v2.isDerived()) {

      // Make sure the variables are SEQ_SUBSEQUENCE with the same start/end
      if (!(v1.derived instanceof SEQ_SUBSEQUENCE))
        return (null);
      if (!(v1.derived instanceof SEQ_SUBSEQUENCE))
        return (null);
      SEQ_SUBSEQUENCE der1 = (SEQ_SUBSEQUENCE) v1.derived;
      SEQ_SUBSEQUENCE der2 = (SEQ_SUBSEQUENCE) v2.derived;
      if ((der1.sclvar() != der2.sclvar())
        || (der1.from_start != der2.from_start)
        || (der1.index_shift != der2.index_shift))
        return (null);
      supTemplate.set (0, PAIRWISEINTEQUAL.class, der1.seqvar(), der2.seqvar());
    } else // can't be matching subsequence
      return (null);

    // Any matches must have the same state as this one
    SuppressionLink sl = sfact.findTemplate (supTemplate, inv);
    if (sl != null) {
      PAIRWISEINTEQUAL pw = (PAIRWISEINTEQUAL) supTemplate.results[0];
      if (pw == null) {
        System.out.println ("pairwise_suppress: Unexpected null in supTemplate.results[0]");
        return (null);
      }

      if (logOn())
        inv.log (((sl != null) ? " " : " Not ") + " Suppressed by '"
                  + pw.format() + "'");
    }
    return (sl);
  }

  /**
   * Suppression of lexical subsequence comparison by lexical
   * comparison over the entire sequence.  Each subsequence must have
   * the same beginning and ending indices.  The beginning index must
   * match because the subsequence will be completely different if
   * they start at a different spot.  The end index must also match
   * because lexical comparisons will create different results if the
   * sequences are not of the same length (even, if for example, the
   * sequence would be otherwise equal.
   *
   * Note that only the entire arrays is searched for.  It is arguable
   * that we should look for other enclosing subsequences as well.
   *
   * We should also expand this to include cases where the indices are
   * not the same variable but are equal.
   */

  public static SuppressionLink lexical_suppress (Invariant arg,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    // We should only be called with our own invariant
    Assert.assertTrue (arg instanceof SEQSEQINTEQUAL);
    SEQSEQINTEQUAL inv = (SEQSEQINTEQUAL) arg;

    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();

    if (logOn())
      inv.log ("Consider subsequence suppression by SeqComparison (x[], y[])");

    // Each var must be a subsequence with the same indices
    if (!v1.isDerived() || !v2.isDerived())
      return (null);
    if (!(v1.derived instanceof SEQ_SUBSEQUENCE))
      return (null);
    if (!(v1.derived instanceof SEQ_SUBSEQUENCE))
      return (null);
    SEQ_SUBSEQUENCE der1 = (SEQ_SUBSEQUENCE) v1.derived;
    SEQ_SUBSEQUENCE der2 = (SEQ_SUBSEQUENCE) v2.derived;
    if ((der1.sclvar() != der2.sclvar())
      || (der1.from_start != der2.from_start)
      || (der1.index_shift != der2.index_shift))
      return (null);
    supTemplate.set (0, SEQSEQINTEQUAL.class, der1.seqvar(), der2.seqvar());

    // Look for a matching SeqComparison
    SuppressionLink sl = sfact.findTemplate (supTemplate, inv);
    SEQSEQINTEQUAL seqcmp = (SEQSEQINTEQUAL) supTemplate.results[0];
    if (sl != null) {
      if (seqcmp == null) {
        System.out.println (SEQSEQINTEQUALstring +
                            "Unexpected null in supTemplate.results[0]");
        return (null);
      }

      if (logOn())
        inv.log ("== " + ((sl != null) ? " " : " Not ") + " Suppressed by '"
                  + seqcmp.format() + "'");
    }
    return (sl);
  }

#endif
}
