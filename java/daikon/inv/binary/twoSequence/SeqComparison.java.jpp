#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPEDOUBLE) || defined(TYPELONG) || defined(TYPESTRING))
  #error "TYPEDOUBLE, TYPELONG, or TYPESTRING must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME SeqComparison
  #define SUPERCLASS TwoSequence
  #define PRIMITIVE long
  #define ARRAYCOMPARATOR new ArraysMDE.LongArrayComparatorLexical()
  #define ELEM_MATCH_COMPARE(v1, v2) (ArraysMDE.isSubset (v1, v2) && \
                                      ArraysMDE.isSubset (v2, v1))
  #define SUBSEQUENCE SubSequence
  #define BASEISTYPE baseIsIntegral()
  #define PAIRWISECOMP PairwiseIntComparison
  #define CLASSSTRING "SeqComparison"
  #define INTCOMPARISONCORE IntComparisonCore
  #define VALUETRACKER ValueTracker
#elif defined(TYPEDOUBLE)
  #define CLASSNAME SeqComparisonFloat
  #define SUPERCLASS TwoSequenceFloat
  #define PRIMITIVE double
  #define ARRAYCOMPARATOR Global.fuzzy.new DoubleArrayComparatorLexical()
  #define ELEM_MATCH_COMPARE(v1, v2) Global.fuzzy.isElemMatch (v1, v2)
  #define SUBSEQUENCE SubSequenceFloat
  #define BASEISTYPE baseIsFloat()
  #define PAIRWISECOMP PairwiseFloatComparison
  #define CLASSSTRING "SeqComparisonFloat"
  #define INTCOMPARISONCORE FloatComparisonCore
  #define VALUETRACKER FloatValueTracker
#elif defined(TYPESTRING)
  #define CLASSNAME SeqComparisonString
  #define SUPERCLASS TwoSequenceString
  #define PRIMITIVE String
  #define ARRAYCOMPARATOR new ArraysMDE.StringArrayComparatorLexical()
  #define ELEM_MATCH_COMPARE(v1, v2) (ArraysMDE.isSubset (v1, v2) && \
                                      ArraysMDE.isSubset (v2, v1))
  #define SUBSEQUENCE SubSequenceString
  #define BASEISTYPE baseIsString()
  #define PAIRWISECOMP PairwiseStringComparison
  #define CLASSSTRING "SeqComparisonString"
  #define INTCOMPARISONCORE StringComparisonCore
  #define VALUETRACKER StringValueTracker
#endif

// ***** This file is automatically generated from SeqComparison.java.jpp

package daikon.inv.binary.twoSequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.binary.twoString.*;

import utilMDE.*;
import org.apache.log4j.Logger;
import java.util.*;


/**
 * Represents invariants between two PRIMITIVE sequences.  If order
 * matters for each variable (which it does by default), then the
 * sequences are compared lexically.  Prints as "x[] [cmp] y[] lexically"
 * where [cmp] can be == < <= > >=.
 *
 * If order doesn't matter for each variable, then the sequences
 * are compared to see if they are set equivalent.  Prints as
 * "x[] == y[]"
 *
 * If the auxillary information (eg, order matters) doesn't match then
 * no comparison is made at all.
 **/
public class CLASSNAME
  extends SUPERCLASS
  implements Comparison
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030402L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff CLASSNAME invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  /**
   * Debugging logger.
   **/
  final static Logger debug = Logger.getLogger ("daikon.inv.binary.twoSequence."
                                                + CLASSSTRING);

  static Comparator comparator = ARRAYCOMPARATOR;

  public final boolean only_check_eq;

  public boolean can_be_eq = false;
  public boolean can_be_lt = false;
  public boolean can_be_gt = false;

  boolean orderMatters;

  private VALUETRACKER values_cache = new VALUETRACKER(8);

  protected CLASSNAME(PptSlice ppt, boolean only_eq, boolean order) {
    super(ppt);
    only_check_eq = only_eq;
    orderMatters = order;
  }

  //   public static CLASSNAME instantiate(PptSlice ppt) {
  //     return instantiate (ppt, false);
  //   }

  public static CLASSNAME instantiate(PptSlice ppt, boolean onlyEq) {
    if (!dkconfig_enabled) return null;

    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];

    // System.out.println("Ppt: " + ppt.name);
    // System.out.println("vars[0]: " + var1.type.format() + " " + var1.name + " " + var1.aux);
    // System.out.println("vars[1]: " + var2.type.format() + " " + var2.name + " " + var2.aux);

    ProglangType type1 = var1.type;
    ProglangType type2 = var2.type;
    // This intentonally checks dimensions(), not pseudoDimensions.
    boolean only_eq = (! ((type1.dimensions() == 1)
                          && type1.BASEISTYPE
                          && (type2.dimensions() == 1)
                          && type2.BASEISTYPE));
    if (onlyEq) only_eq = true;
    // System.out.println("only_eq: " + only_eq);
    CLASSNAME result;
    if (var1.aux.getFlag(VarInfoAux.HAS_ORDER)
        && var2.aux.getFlag(VarInfoAux.HAS_ORDER)) {
      result = new CLASSNAME(ppt, only_eq, true);
    } else {
      result = new CLASSNAME(ppt, true, false);
    }
    // System.out.println("CLASSNAME.instantiate => " + result.repr());
    return result;
  }

  protected Object clone() {
    CLASSNAME result = (CLASSNAME) super.clone();
    result.values_cache = (VALUETRACKER) values_cache.clone();
    return result;
  }

  protected Invariant resurrect_done_swapped() {
    boolean tmp = can_be_lt;
    can_be_lt = can_be_gt;
    can_be_gt = tmp;
    return this;
  }

  public String repr() {
    return CLASSSTRING + varNames() + ": "
      + "can_be_eq=" + can_be_eq
      + ",can_be_lt=" + can_be_lt
      + ",can_be_gt=" + can_be_gt
      + ",only_check_eq=" + only_check_eq
      + ",orderMatters=" + orderMatters
      + ",enoughSamples=" + enoughSamples()
      ;
  }

  public String format_using(OutputFormat format) {
    // System.out.println("Calling " + CLASSSTRING + ".format for: " + repr());

    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }

    String comparator = IntComparisonCore.format_comparator
      (format, can_be_lt, can_be_eq, can_be_gt);

    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.JAVA))
    {
      String name1 = var1().name.name_using(format);
      String name2 = var2().name.name_using(format);
      String lexically = (var1().aux.getFlag(VarInfoAux.HAS_ORDER)
                          ? " (lexically)"
                          : "");

#ifdef JHP
      // Lexically equal is equal by any definition
      if (comparator == "==")   // "interned"
        lexically = "";
#endif

      return name1 + " " + comparator + " " + name2 + lexically;
    }

    if (format == OutputFormat.IOA) {
      if (var1().isIOASet() || var2().isIOASet()) {
        return "Not valid for Sets: " + format();
      }
      String name1 = var1().name.name_using(format);
      String name2 = var2().name.name_using(format);
      return name1 + " " + comparator + " " + name2 + " ***";
    }

    if (format == OutputFormat.JML) { // Must complete
      String quantResult[] = VarInfoName.QuantHelper.format_jml(new VarInfoName[] {var1().name,var2().name},true);
      return quantResult[0] + quantResult[1] + comparator + quantResult[2] + quantResult[3];
    }
    return format_unimplemented(format);
  }

  public String format_simplify() {
    if (Invariant.dkconfig_simplify_define_predicates)
      return format_simplify_defined();
    else
      return format_simplify_explicit();
  }

  private String format_simplify_defined() {
    String comparator =
      INTCOMPARISONCORE.format_comparator(OutputFormat.SIMPLIFY,
                                          can_be_lt, can_be_eq, can_be_gt);
    String[] var1_name =
      VarInfoName.QuantHelper.simplifyNameAndBounds(var1().name);
    String[] var2_name =
      VarInfoName.QuantHelper.simplifyNameAndBounds(var2().name);
    if (var1_name == null || var2_name == null) {
      return "format_simplify can't handle one of these sequences: "
        + format();
    }
    return "(|lexical-" + comparator + "| " +
      var1_name[0] + " " + var1_name[1] + " " + var1_name[2] + " " +
      var2_name[0] + " " + var2_name[1] + " " + var2_name[2] + ")";
  }

  private String format_simplify_explicit() {
    if (can_be_eq && !can_be_lt && !can_be_gt) {
      // A simple case: if two sequences are lexically equal iff they
      // are elementwise equal.
      String[] form =
        VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
          { var1().name, var2().name }, true); // elementwise
      return form[0] +
        "(EQ " + form[1] + " " + form[2] + ")" + form[3];
    } else {
      String classname = this.getClass().toString().substring(6);
      return "warning: method " + classname
        + ".format_simplify_explicit() needs to be implemented: " + format();
    }
  }


  public void add_modified(PRIMITIVE[] v1, PRIMITIVE[] v2, int count) {
    /// This does not do the right thing; I really want to avoid comparisons
    /// if one is missing, but not if one is zero-length.
    // // Don't make comparisons with empty arrays.
    // if ((v1.length == 0) || (v2.length == 0)) {
    //   return;
    // }
    int comparison = 0;
    if (orderMatters) {
      // Standard element wise comparison
       comparison = comparator.compare(v1, v2);
    } else {
      // Do a double subset comparison
      comparison = ELEM_MATCH_COMPARE(v1, v2) ? 0 : -1;
    }


    // System.out.println(CLASSSTRING + varNames() + ": "
    //                    + "compare(" + ArraysMDE.toString(v1)
    //                    + ", " + ArraysMDE.toString(v2) + ") = " + comparison);

    boolean new_can_be_eq = can_be_eq;
    boolean new_can_be_lt = can_be_lt;
    boolean new_can_be_gt = can_be_gt;
    boolean changed = false;
    if (comparison == 0) {
      new_can_be_eq = true;
      if (!can_be_eq) changed = true;
    } else if (comparison < 0) {
      new_can_be_lt = true;
      if (!can_be_lt) changed = true;
    } else {
      new_can_be_gt = true;
      if (!can_be_gt) changed = true;
    }

    if (! changed) {
      values_cache.add(v1, v2);
      return;
    }

    if ((new_can_be_lt && new_can_be_gt)
        || (only_check_eq && (new_can_be_lt || new_can_be_gt))) {
      destroyAndFlow();
      return;
    }

    // changed but didn't die
    cloneAndFlow();
    can_be_eq = new_can_be_eq;
    can_be_lt = new_can_be_lt;
    can_be_gt = new_can_be_gt;

    values_cache.add(v1, v2);
    Assert.assertTrue (!(can_be_lt && can_be_gt));
    Assert.assertTrue (can_be_gt || can_be_lt || can_be_eq);
  }

  protected double computeProbability() {
    if (falsified) {
      return Invariant.PROBABILITY_NEVER;
    } else if (can_be_lt || can_be_gt) {
      // System.out.println("prob = " + Math.pow(.5, ppt.num_values()) + " for " + format());
      return Math.pow(.5, values_cache.num_values());
    } else if (ppt.num_samples() == 0) {
      return Invariant.PROBABILITY_UNJUSTIFIED;
    } else {
      return Invariant.PROBABILITY_JUSTIFIED;
    }
  }

  // For Comparison interface
  public double eq_probability() {
    if (can_be_eq && (!can_be_lt) && (!can_be_gt))
      return computeProbability();
    else
      return Invariant.PROBABILITY_NEVER;
  }

  public boolean isSameFormula(Invariant o)
  {
    CLASSNAME other = (CLASSNAME) o;
    return
      (can_be_eq == other.can_be_eq) &&
      (can_be_lt == other.can_be_lt) &&
      (can_be_gt == other.can_be_gt);
  }

  public boolean isExclusiveFormula(Invariant o)
  {
    if (o instanceof CLASSNAME) {
      CLASSNAME other = (CLASSNAME) o;
      return (! ((can_be_eq && other.can_be_eq)
                 || (can_be_lt && other.can_be_lt)
                 || (can_be_gt && other.can_be_gt)));
    }
    return false;
  }

  /**
   *  Since this invariant can be a postProcessed equality, we have to
   *  handle isObvious especially to avoid circular isObvious
   *  relations.
   **/
  public VarInfo[] isObviousStatically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      if (isObviousStatically (this.ppt.var_infos)) {
        return this.ppt.var_infos;
      } else {
        return null;
      }
    } else {
      return super.isObviousStatically_SomeInEquality();
    }
  }

  /**
   *  Since this invariant can be a postProcessed equality, we have to
   *  handle isObvious especially to avoid circular isObvious
   *  relations.
   **/
  public VarInfo[] isObviousDynamically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      if (isObviousDynamically (this.ppt.var_infos)) {
        return this.ppt.var_infos;
      } else {
        return null;
      }
    } else {
      return super.isObviousDynamically_SomeInEquality();
    }
  }

  public boolean isObviousStatically(VarInfo[] vis) {
    #if !defined (TYPESTRING)
      VarInfo var1 = vis[0];
      VarInfo var2 = vis[1];
      if ((SUBSEQUENCE.isObviousSubSequence(var1, var2))
          || (SUBSEQUENCE.isObviousSubSequence(var2, var1))) {
        return true;
      }
    #endif
    return super.isObviousStatically (vis);
  }

  public boolean isObviousDynamically(VarInfo[] vis) {
    #if !defined (TYPESTRING)
      PptSlice ppt = this.ppt.parent.findSlice_unordered (vis);
      if (ppt != null) {
         PAIRWISECOMP pic = PAIRWISECOMP.find(ppt);
         if ((pic != null)
             && (pic.core.can_be_eq == can_be_eq)
             && (pic.core.can_be_lt == can_be_lt)
             && (pic.core.can_be_gt == can_be_gt)) {
           return true;
         }
      }
    #endif
    return super.isObviousDynamically(vis);
  }

  public void repCheck() {
    super.repCheck();
    if (! (this.can_be_eq || this.can_be_lt || this.can_be_gt)
        && ppt.num_samples() != 0) {
      System.err.println (this.repr());
      System.err.println (this.ppt.num_samples());
      throw new Error();
    }
  }
}
