#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
#error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
#define CLASSNAME TwoSequenceFactory
#define PRIMITIVE long
#define PROGLANGTYPE INT_ARRAY
#define LINEARBINARY LinearBinary
#define SEQCOMPARISON SeqComparison
#define REVERSE Reverse
#define SUBSEQUENCE SubSequence
#define PAIRWISEINTCOMPARISON PairwiseIntComparison
#define PAIRWISELINEARBINARY PairwiseLinearBinary
#define PAIRWISEFUNCTIONUNARY PairwiseFunctionUnary
#define FUNCTIONS Functions
#define SUBSET SubSet
#elif defined(TYPEDOUBLE)
#define CLASSNAME TwoSequenceFactoryFloat
#define PRIMITIVE double
#define PROGLANGTYPE DOUBLE_ARRAY
#define LINEARBINARY LinearBinaryFloat
#define SEQCOMPARISON SeqComparisonFloat
#define REVERSE ReverseFloat
#define SUBSEQUENCE SubSequenceFloat
#define PAIRWISEINTCOMPARISON PairwiseFloatComparison
#define PAIRWISELINEARBINARY PairwiseLinearBinaryFloat
#define PAIRWISEFUNCTIONUNARY PairwiseFunctionUnaryFloat
#define FUNCTIONS FunctionsFloat
#endif

// ***** This file is automatically generated from TwoSequenceFactory.java.jpp

package daikon.inv.binary.twoSequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.binary.twoScalar.*;

import utilMDE.*;

import org.apache.log4j.Category;

import java.util.*;

public final class CLASSNAME {

  /**
   * Debug tracer
   **/
  public static final Category debug = Category.getInstance ("daikon.inv.binary.twoSequence.TwoSequenceFactory");

  // Add the appropriate new Invariant objects to the specified Invariants
  // collection.
  public static Vector instantiate(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 2);
    // Not really the right place for these tests
    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];

    Assert.assertTrue((var1.rep_type == ProglangType.PROGLANGTYPE)
                  && (var2.rep_type == ProglangType.PROGLANGTYPE));

    if (! var1.compatible(var2))
      return null;

    VarInfo super1 = var1.isDerivedSubSequenceOf();
    if (super1 == null)
      super1 = var1;
    VarInfo super2 = var2.isDerivedSubSequenceOf();
    if (super2 == null)
      super2 = var2;

    if (debug.isDebugEnabled()) {
      debug.debug ("Instantiating for ppt " + ppt.name);
      debug.debug ("name1 " + super1.repr());
      debug.debug ("name2 " + super2.repr());
    }


    Vector result = new Vector();
    { // previously only if (pass == 1)
      // This was test disabled because it resulted in preventing a comparison for
      // this.theArray[this.front..], this.theArray[orig(this.front)+1..]
      // which are actually equal.
      // I decided that the latter shouldn't even be generated -- we should
      // know the relationship between "this.front" and
      // "orig(this.front)+1" -- and re-enabled the test.
      if (super1 == super2) {
        Global.implied_false_noninstantiated_invariants++;
        // System.out.println("No SeqComparison because same super for " + ppt.name);
        LINEARBINARY lb = LINEARBINARY.find(ppt);
        if (lb != null)
          System.out.println("  " + lb.format());
      } else {
        result.add(SEQCOMPARISON.instantiate(ppt));
      }
    }
    { // previously (pass == 2)
      result.add(REVERSE.instantiate(ppt));
      if (super1 == super2) {
        Global.subexact_noninstantiated_invariants += 2;
        Global.implied_false_noninstantiated_invariants += 2 + 2 * FUNCTIONS.unaryFunctionNames.length;
      } else {
        Assert.assertTrue(Intern.isInterned(super1.name));
        Assert.assertTrue(Intern.isInterned(super2.name));
        // If the variables (super1 and super2) are different, then their
        // names must be different, too.  In other words. no two distinct
        // variables have the same names.

        Assert.assertTrue(super1.name != super2.name);

        // SeqNonEqual.instantiate(ppt);
        result.add(SUBSEQUENCE.instantiate(ppt));
#if defined(TYPELONG)
        result.add(SUBSET.instantiate(ppt));
#endif
        result.add(PAIRWISEINTCOMPARISON.instantiate(ppt));
        result.add(PAIRWISELINEARBINARY.instantiate(ppt));
        for (int i=0; i<2; i++) {
          boolean invert = (i==1);
          VarInfo arg = (invert ? var1 : var2);
          // Don't bother to check arg.isConstant():  we really want to
          // know whether the elements of arg are constant.
          for (int j=0; j<FUNCTIONS.unaryFunctionNames.length; j++) {
            result.add(PAIRWISEFUNCTIONUNARY.instantiate(ppt, FUNCTIONS.unaryFunctionNames[j], j, invert));
          }
        }
      }
    }
    return result;
  }

  private CLASSNAME() {
  }

}
