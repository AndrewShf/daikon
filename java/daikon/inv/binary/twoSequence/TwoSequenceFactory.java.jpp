#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME TwoSequenceFactory
  #define PRIMITIVE long
  #define PROGLANGTYPE INT_ARRAY
  #define LINEARBINARY LinearBinary
  #define SEQCOMPARISON_EQ SeqSeqIntEqual
  #define SEQCOMPARISON_LT SeqSeqIntLessThan
  #define SEQCOMPARISON_GT SeqSeqIntGreaterThan
  #define SEQCOMPARISON_LE SeqSeqIntLessEqual
  #define SEQCOMPARISON_GE SeqSeqIntGreaterEqual
  #define REVERSE Reverse
  #define SUBSEQUENCE SubSequence
  #define PAIRWISELINEARBINARY PairwiseLinearBinary
  #define PAIRWISEFUNCTIONUNARY PairwiseFunctionUnary
  #define FUNCTIONS Functions
  #define SUBSET SubSet
  #define SUPERSET SuperSet
#elif defined(TYPEDOUBLE)
  #define CLASSNAME TwoSequenceFactoryFloat
  #define PRIMITIVE double
  #define PROGLANGTYPE DOUBLE_ARRAY
  #define LINEARBINARY LinearBinaryFloat
  #define SEQCOMPARISON_EQ SeqSeqFloatEqual
  #define SEQCOMPARISON_LT SeqSeqFloatLessThan
  #define SEQCOMPARISON_GT SeqSeqFloatGreaterThan
  #define SEQCOMPARISON_LE SeqSeqFloatLessEqual
  #define SEQCOMPARISON_GE SeqSeqFloatGreaterEqual
  #define REVERSE ReverseFloat
  #define SUBSEQUENCE SubSequenceFloat
  #define PAIRWISELINEARBINARY PairwiseLinearBinaryFloat
  #define PAIRWISEFUNCTIONUNARY PairwiseFunctionUnaryFloat
  #define FUNCTIONS FunctionsFloat
#endif

// ***** This file is automatically generated from TwoSequenceFactory.java.jpp

package daikon.inv.binary.twoSequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.binary.twoScalar.*;

import utilMDE.*;

import java.util.logging.Logger;
import java.util.logging.Level;

import java.util.*;

public final class CLASSNAME {

  /**
   * Debug tracer
   **/
  public static final Logger debug = Logger.getLogger("daikon.inv.binary.twoSequence.TwoSequenceFactory");

  // Add the appropriate new Invariant objects to the specified Invariants
  // collection.
  public static Vector instantiate(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 2);
    // Not really the right place for these tests
    VarInfo var1 = ppt.var_infos[0];
    VarInfo var2 = ppt.var_infos[1];

    // System.out.println ("instantiate: " + ppt.name() + " (pass " + pass + ")");

    Assert.assertTrue((var1.rep_type == ProglangType.PROGLANGTYPE)
                      && (var2.rep_type == ProglangType.PROGLANGTYPE));

    if (! var1.compatible(var2))
      return null;

    VarInfo super1 = var1.isDerivedSubSequenceOf();
    if (super1 == null)
      super1 = var1;
    VarInfo super2 = var2.isDerivedSubSequenceOf();
    if (super2 == null)
      super2 = var2;

    if (debug.isLoggable(Level.FINE)) {
      debug.fine ("Instantiating for ppt " + ppt.name());
      debug.fine ("name1 " + super1.repr());
      debug.fine ("name2 " + super2.repr());
    }


    Vector result = new Vector();
    { // previously only if (pass == 1)
      // This was test disabled because it resulted in preventing a comparison for
      // this.theArray[this.front..], this.theArray[orig(this.front)+1..]
      // which are actually equal.
      // I decided that the latter shouldn't even be generated -- we should
      // know the relationship between "this.front" and
      // "orig(this.front)+1" -- and re-enabled the test.
      // I re-disabled the test, because equality invariants are special:
      // they are required for setting of equal_to slots.  -MDE 7/30/2002
      if (false && super1 == super2) {
        // This invariant should not be instantiated because if super1 ==
        // super2, then the invariant will be something like a[i..] ==
        // a[j..], which should be obvious from knowledge about i and j.
        Global.implied_false_noninstantiated_invariants++;
        // System.out.println("No SeqComparison because same super for " + ppt.name());
        LINEARBINARY lb = LINEARBINARY.find(ppt);
        if (lb != null)
          System.out.println("  " + lb.format());
      } else {
        result.add(SEQCOMPARISON_EQ.instantiate(ppt, false));
        result.add(SEQCOMPARISON_LT.instantiate(ppt, false));
        result.add(SEQCOMPARISON_GT.instantiate(ppt, false));
        result.add(SEQCOMPARISON_LE.instantiate(ppt, false));
        result.add(SEQCOMPARISON_GE.instantiate(ppt, false));
      }
    }
    { // previously (pass == 2)
      result.add(REVERSE.instantiate(ppt));
      // SeqNonEqual.instantiate(ppt);
      result.add(SUBSEQUENCE.instantiate(ppt));
#if defined(TYPELONG)
      result.add(SUBSET.instantiate(ppt));
      result.add(SUPERSET.instantiate(ppt));
      result.add(PairwiseIntEqual.instantiate(ppt));
      result.add(PairwiseIntLessThan.instantiate(ppt));
      result.add(PairwiseIntGreaterThan.instantiate(ppt));
      result.add(PairwiseIntLessEqual.instantiate(ppt));
      result.add(PairwiseIntGreaterEqual.instantiate(ppt));
#else
      result.add(PairwiseFloatEqual.instantiate(ppt));
      result.add(PairwiseFloatLessThan.instantiate(ppt));
      result.add(PairwiseFloatGreaterThan.instantiate(ppt));
      result.add(PairwiseFloatLessEqual.instantiate(ppt));
      result.add(PairwiseFloatGreaterEqual.instantiate(ppt));
#endif
      result.add(PAIRWISELINEARBINARY.instantiate(ppt));
      int numFunctions = FUNCTIONS.unaryFunctionNames.length;
      for (int i=0; i<2; i++) {
        boolean invert = (i==1);
        VarInfo arg = (invert ? var1 : var2);
        // Don't bother to check arg.isConstant():  we really want to
        // know whether the elements of arg are constant.
        for (int j=0; j<numFunctions; j++) {
          result.add(PAIRWISEFUNCTIONUNARY.instantiate
                     (ppt, FUNCTIONS.unaryFunctionNames[j], j, invert));
        }
      }
    }
    return result;
  }

  private CLASSNAME() {
  }

}
