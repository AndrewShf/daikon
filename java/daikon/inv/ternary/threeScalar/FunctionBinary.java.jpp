#if 0
  // Do not attempt to compile this file with a Java compiler such as javac.
  // You first need to preprocess it with cpp, the C preprocessor.
  // The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME FunctionBinary
  #define SUPERCLASS ThreeScalar
  #define PRIMITIVE long
  #define PRIMITIVE_CNAME Long
  #define EQUAL(a,b) ((a) == (b))
  #define POW MathMDE.pow
  #define EQUALITY IntEqual
#elif defined(TYPEDOUBLE)
  #define CLASSNAME FunctionBinaryFloat
  #define SUPERCLASS ThreeFloat
  #define PRIMITIVE double
  #define PRIMITIVE_CNAME Double
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
  #define POW Math.pow
  #define EQUALITY FloatEqual
#else
  #error "bad def"
#endif

#define PERM_XYZ 1
#define PERM_YXZ 2
#define PERM_ZXY 3
#define PERM_XZY 4
#define PERM_YZX 5
#define PERM_ZYX 6

#if 0
  // CNAME macro builds the class name from the function, Primitive type,
  // and permutation.
#endif
#define CNAME(func, permute) func ## PRIMITIVE_CNAME ## permute

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.OneOf;
import daikon.inv.unary.scalar.OneOfScalar;
import daikon.inv.unary.scalar.OneOfFloat;
import daikon.inv.binary.twoScalar.*;
import daikon.derive.*;
import daikon.derive.unary.*;
import daikon.suppress.*;
import utilMDE.*;
import java.lang.reflect.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * Base class for each of the FunctionBinary functions and permutatons.
 * Most of the work is done here.  The subclasses basically define the
 * function and return information describing the function and permutation
 * to these methods
 */
public abstract class CLASSNAME extends SUPERCLASS {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20031030L;

  public static boolean dkconfig_enabled = true;

  public static Logger debug
    = Logger.getLogger("daikon.inv.ternary.threeScalar.#CLASSNAME");

  final static int[][] var_indices;
  static {
    var_indices = new int[7][];
    var_indices[PERM_XYZ] = new int[] { 0, 1, 2 };
    var_indices[PERM_YXZ] = new int[] { 1, 0, 2 };
    var_indices[PERM_ZXY] = new int[] { 2, 0, 1 };
    var_indices[PERM_XZY] = new int[] { 0, 2, 1 };
    var_indices[PERM_YZX] = new int[] { 1, 2, 0 };
    var_indices[PERM_ZYX] = new int[] { 2, 1, 0 };
  }

  protected CLASSNAME (PptSlice ppt) {
    super (ppt);
  }

  abstract PRIMITIVE func (PRIMITIVE arg1, PRIMITIVE arg2);
  abstract boolean is_symmetric();
  abstract String[] get_method_name();
  abstract int get_var_order();
  abstract CLASSNAME instantiate (PptSlice slice);
  abstract void set_function_id (int function_id);
  abstract int get_function_id ();

  /**
   * Map from function name (eg, MultiplyLong, MinimumFloat) to an array
   * of instances (one for each valid permutation) for that function
   */
  private static Map functions = null;

  /**
   * A list indexed by function number to an array of instances (one for
   * each valid permutation) for that function.  The array is the same
   * one as is stored in the functions Map.  This provides a faster access
   * mechanism once we have the function id (which are calculated the first
   * time through)
   */
  private static List func_list = new ArrayList();

  private static void build_func_list() {
    // Build the map of functions to array of instances for that function
    debug.fine ("Processing " + #CLASSNAME);
    functions = new LinkedHashMap();
    Class[] subclasses = CLASSNAME.class.getDeclaredClasses();
    for (int ii = 0; ii < subclasses.length; ii++) {
      Class subc = subclasses[ii];
      String function = subc.getName();
      function = function.replaceFirst (".*FunctionBinary\\$", "");
      function = function.replaceFirst ("_.*", "");
      if (function.equals ("SubClass"))
        continue;
      CLASSNAME[] fb_arr = (CLASSNAME[]) functions.get (function);
      if (fb_arr == null) {
        fb_arr = new CLASSNAME[7];
        functions.put (function, fb_arr);
        func_list.add (fb_arr);
      }
      int func_id = func_list.indexOf (fb_arr);
      CLASSNAME fb = null;
      try {
        Constructor con = subc.getDeclaredConstructor (new Class[] {});
        fb = (CLASSNAME) con.newInstance (new Object[] {});

        // Field var_order_field = subc.getDeclaredField ("var_order");
        // var_order = var_order_field.getInt (null);
        // Field func_id_field = subc.getDeclaredField ("function_id");
        // func_id_field.setInt (null, func_list.size() - 1);
      }  catch (Exception e) {
        throw new Error (" can't create instance for " + subc.getName());
      }
      Assert.assertTrue (fb_arr[fb.get_var_order()] == null);
      fb_arr[fb.get_var_order()] = fb;
      fb.set_function_id (func_id);
      debug.fine ("Adding " + function + " " + fb.getClass().getName()
                  + " " + fb.get_var_order() + " " + fb.get_function_id());
    }
  }

  /**
   * Returns a list of all of the FunctionBinary invariants setup for the
   * specified slice.
   */
  public static List instantiate_all (PptSlice slice) {

    // If this is the first call
    if (functions == null) {
      build_func_list();
    }

    // Instantiate all of the subclasses and return them
    List result = new ArrayList();
    for (int ii = 0; ii < func_list.size(); ii++) {
      CLASSNAME[] fb_arr = (CLASSNAME[]) func_list.get (ii);
      for (int jj = 1; jj < fb_arr.length; jj++) {
        if (fb_arr[jj] != null) {
          result.add (fb_arr[jj].instantiate (slice));
        }
      }
    }

    return (result);
  }

  /** permuted result var */
  public VarInfo resultVar() {
    return ppt.var_infos[var_indices[get_var_order()][0]];
  }

  /** permuted arg1 var */
  public VarInfo argVar1() {
    return ppt.var_infos[var_indices[get_var_order()][1]];
  }

  /** permuted arg2 var */
  public VarInfo argVar2() {
    return ppt.var_infos[var_indices[get_var_order()][2]];
  }

  /**
   * Apply the specified sample to the function, returning the result
   * The caller is responsible for permuting the arguments
   */
  public InvariantStatus add_ordered (PRIMITIVE result, PRIMITIVE arg1,
                                      PRIMITIVE arg2, int count) {

    try {
      if (!EQUAL (result, func (arg1, arg2)))
        return InvariantStatus.FALSIFIED;
    } catch (Exception e) {
        return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  /**
   * Reorganize our already-seen state as if the variables had shifted
   * order underneath us (re-arrangement given by the permutation).
   * We accomplish this by returning the class that corresponds to the
   * the new permutation
   */
  protected Invariant resurrect_done (int[] permutation) {

    Assert.assertTrue(permutation.length == 3);
    Assert.assertTrue(ArraysMDE.fn_is_permutation(permutation));

    int[] new_order = new int[3];
    int[] old_order = var_indices[get_var_order()];

    // "permutation" is a permutation on the var_info array. old_order
    // was the permutation that took the formatted invariant to the
    // var_info array, so old_order^-1 is the permutation from the
    // var_info array to the old formatted invariant. We want to find
    // a new_order so that when we first do "permutation", then
    // apply the new permutation from the var_info array to the
    // formatted invariant, we get the same formatted invariant.
    // What we want, then. is:
    //    new_order^-1 o permutation = old_order^-1
    // rearranging, this is equivalent to
    //    new_order = permutation o old_order
    new_order[0] = permutation[old_order[0]];
    new_order[1] = permutation[old_order[1]];
    new_order[2] = permutation[old_order[2]];

    // Force symmetric functions into a canonical form so that
    // we can match them when necessary and they always print the same.
    // For example, order of 0, 1, 2 and 0, 2, 1 represent the same
    // invariant for a symmetric function.  This forces them to always
    // be represented as 0, 1, 2
    if (is_symmetric ()) {
      if (new_order[2] < new_order[1]) {
        int tmp = new_order[2];
        new_order[2] = new_order[1];
        new_order[1] = tmp;
      }
    }

    // Look for the new order in the list of possible orders
    int var_order = -1;
    for (int i=0; i < var_indices.length; i++) {
      if (Arrays.equals(new_order, var_indices[i])) {
        var_order = i;
        break;
      }
    }
    Assert.assertTrue (var_order != -1);

    // If the var order hasn't changed, we don't need to do anything
    if (var_order == get_var_order())
      return (this);

    // Find the class that corresponds to the new order
    if (functions == null)
      build_func_list();
    int func_id = get_function_id();
    CLASSNAME[] fb_arr = (CLASSNAME[]) func_list.get (func_id);
    Assert.assertTrue (fb_arr != null);
    for (int ii = 0; ii < fb_arr.length; ii++)
      if ((fb_arr[ii] != null) && (fb_arr[ii].get_var_order() == var_order))
        return (fb_arr[ii].instantiate (ppt));

    throw new Error ("Could not find new ordering");
  }

  public String repr() {
    return format();
  }

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }

    int var_order = get_var_order();
    String[] methodname = get_method_name();

    VarInfo argresultvi = ppt.var_infos[var_indices[var_order][0]];
    VarInfoName argresult = argresultvi.name;
    VarInfo arg1vi = ppt.var_infos[var_indices[var_order][1]];
    VarInfoName arg1 = arg1vi.name;
    VarInfo arg2vi = ppt.var_infos[var_indices[var_order][2]];
    VarInfoName arg2 = arg2vi.name;

    String argresult_name = argresult.name_using(format, argresultvi);
    String arg1_name = arg1.name_using(format, arg1vi);
    String arg2_name = arg2.name_using(format, arg2vi);

    if (format == OutputFormat.DAIKON
        || format == OutputFormat.JML
        || format == OutputFormat.DBCJAVA) {  // RRN: verify the validity of this.
      return argresult_name + " == " + methodname[0] + arg1_name
             + methodname[1] + arg2_name + methodname[2];
    }

    if (format == OutputFormat.IOA) {
      return argresult_name + " = " + methodname[0] + arg1_name
                + methodname[1] + arg2_name + methodname[2] + " ***";
    }

    return format_unimplemented(format);
  }

  public String format_simplify() {
    int var_order = get_var_order();
    String[] methodname = get_method_name();
    VarInfo[] vis = ppt.var_infos;

    String result = vis[var_indices[var_order][0]].simplifyFixedupName();
    String arg1 =   vis[var_indices[var_order][1]].simplifyFixedupName();
    String arg2 =   vis[var_indices[var_order][2]].simplifyFixedupName();
    String func = null;
    if (methodname[1].equals(" * ")) {
      func = "*";
    } else if (methodname[1].equals(" | ")) {
      func = "|java-bitwise-or|";
    } else if (methodname[1].equals(" || ")) {
      func = "|java-logical-or|";
    } else if (methodname[1].equals(", ")) {
      if (methodname[0].equals("java.lang.Math.min("))
        func = "min";
      else if (methodname[0].equals("java.lang.Math.max("))
        func = "max";
      else if (methodname[0].equals("utilMDE.MathMDE.gcd("))
        func = "gcd";
      else if (methodname[0].equals("java.lang.Math.pow("))
        func = "pow";
      else if (methodname[0].equals("utilMDE.MathMDE.logicalXor("))
        func = "|java-logical-xor|";
    } else {
      Assert.assertTrue(methodname[0].equals(""));
      Assert.assertTrue(methodname[2].equals(""));
      func = "|java-" + methodname[1].trim() + "|";
    }
    if (func == null)
      return "format_simplify() doesn't know function " + methodname[0] + "-" +
        methodname[1] + "-" + methodname[2];
    return "(EQ " + result + " (" + func + " " + arg1 + " " + arg2 + "))";
  }

  // If our classes match, we must match
  public boolean isSameFormula(Invariant other) {
    return true;
  }
  public double computeConfidence() {
    if (logOn()) {
      VarInfo v1 = ppt.var_infos[0];
      VarInfo v2 = ppt.var_infos[1];
      VarInfo v3 = ppt.var_infos[2];
      log("computeConfidence(" + format()
         + ": num_values = " + ppt.num_values()
         + ", num_values(" + v1.name.name() + ")=" + ppt.parent.num_values(v1)
         + ", num_values(" + v2.name.name() + ")=" + ppt.parent.num_values(v2)
         + ", num_values(" + v3.name.name() + ")=" + ppt.parent.num_values(v3));
    }
    return Invariant.conf_is_ge(ppt.num_values(), 5);
  }

  public double computeProbability() {
    return Invariant.prob_is_ge (ppt.num_values(), 5);
  }

  /**
   * If the arg is a sequence size, return the sequence; otherwise return null.
   **/
  private VarInfo sized_sequence(VarInfo size) {
    if (size.derived instanceof SequenceLength) {
      return ((SequenceLength)size.derived).base;
    }
    return null;
  }

  public DiscardInfo isObviousDynamically(VarInfo[] vis) {

    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    // Discard if any two of the three variables are the sizes of the
    // same arrays.
    VarInfo arr1 = sized_sequence(vis[0]);
    VarInfo arr2 = sized_sequence(vis[1]);
    VarInfo arr3 = sized_sequence(vis[2]);
    if (((arr1 != null) && (arr1 == arr2))
        || ((arr1 != null) && (arr1 == arr3))
        || ((arr2 != null) && (arr2 == arr3))) {
      return new DiscardInfo(this, DiscardCode.obvious,
                    "two are sizes of same array:  "
                    + vis[0].name.name() + " "
                    + vis[1].name.name() + " "
                    + vis[2].name.name());
    }

    return null;
  }


  /**
   * Suppress 'z = func(x, y)' by 'z == x == y' where func is bitwiseAnd,
   * bitwiseOr, min, max, or gcd.  equality_suppress_args_samevar is used
   * when x and y are the same variable; equality_suppress_distinct_args
   * works when x and y are distinct.  This is necessary because there are
   * assertions elsewhere that don't allow us to include the same invariant
   * twice as a suppressor.  And that is what happens if x, y, and z
   * actually refer to the same variable:  we get var == var and var == var
   * as our two suppressors.
   **/
  public static SuppressionLink equality_suppress_repeated_arg (CLASSNAME inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    // If the variables are not all the same, give up and let the second
    // factory handle this.
    if ((inv.var1() != inv.var2()) || (inv.var2() != inv.var3()))
      return (null);

    // Build the tempmlate and look for matches
    supTemplate.set (0, EQUALITY.class, inv.var2(), inv.var3());
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    return (sl);
  }

  /**
   * See comment for equality_suppress_repeated_arg.
   **/
  public static SuppressionLink equality_suppress_distinct_args (CLASSNAME inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    // If all the variables are the same, let
    // equality_suppress_repeated_arg handle it.  (Actually, this should
    // never get called in that case, right?)
    if ((inv.var1() == inv.var2()) && (inv.var2() == inv.var3()))
      return (null);

    // Pick pairs of variables that don't match
    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();
    VarInfo v3 = inv.var3();
    if (v1 == v3) {
      VarInfo tmp = v2;
      v2 = v3;
      v3 = tmp;
    }

    // Build the template and look for matches
    supTemplate.set (0, EQUALITY.class, v1, v2);
    supTemplate.set (1, EQUALITY.class, v2, v3);
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    return (sl);
  }

  // Only for getting the equality part, not other parts of the full
  // suppression.
  private static SuppressionTemplate equality_min_max_template
                                                = new SuppressionTemplate(1);

  // Suppress "a = min(a, b)" or "a = max(a, b)".
  public static SuppressionLink equality_suppress_min_max (CLASSNAME inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    VarInfo resultVar = inv.resultVar();
    VarInfo argVar1 = inv.argVar1();
    VarInfo argVar2 = inv.argVar2();

    SuppressionTemplate st = equality_min_max_template;
    SuppressionLink eq_sl;

    // Suppress "r = min(arg1, arg2) by "r == arg1 && r <= arg2".
    // Suppress "r = max(arg1, arg2) by "r == arg1 && arg2 <= r".
    st.set(0, EQUALITY.class, resultVar, argVar1);
    eq_sl = SuppressionFactory.linkFromUnfilledTemplate(st, inv);
    if (eq_sl != null) {
      SuppressionLink le_sl;
      if (inv.isMinimum())
        le_sl = SuppressionFactory.findLessEqualInt(inv, resultVar, argVar2,0);
      else
        le_sl = SuppressionFactory.findLessEqualInt(inv, argVar2, resultVar,0);
      if (le_sl != null) {
        return SuppressionLink.combine(eq_sl, le_sl);
      }
    }

    // Suppress "r = min(arg1, arg2) by "r == arg2 && r <= arg1".
    // Suppress "r = max(arg1, arg2) by "r == arg2 && arg1 <= r".
    st.set(0, EQUALITY.class, resultVar, argVar2);
    eq_sl = SuppressionFactory.linkFromUnfilledTemplate(st, inv);
    if (eq_sl != null) {
      SuppressionLink le_sl;
      if (inv.isMinimum())
        le_sl = SuppressionFactory.findLessEqualInt(inv, resultVar, argVar1, 0);
      else
        le_sl = SuppressionFactory.findLessEqualInt(inv, argVar1, resultVar, 0);
      if (le_sl != null) {
        return SuppressionLink.combine(eq_sl, le_sl);
      }
    }

    return null;
  }


// This (incorrect) SuppressionFactory for FunctionBinary invariants
// suppresses all FunctionBinary such that one of the members is a
// constant.  This isn't correct for suppression, since constants
// don't logiclaly imply FunctionBinary.  However, a FunctionBinary invariant
// that results from constant components is uninteresting, so this
// should later be used in filtering for printing.
/*
  static class FunctionBinarySuppressionFactory extends SuppressionFactory {

    public static final Logger debug = Logger.getLogger ("daikon.suppress.factories.FunctionBinarySuppressionFactory");

    public static final FunctionBinarySuppressionFactory theInstance =
      new FunctionBinarySuppressionFactory();

    private FunctionBinarySuppressionFactory() {

    }

    public static SuppressionFactory getInstance() {
      return theInstance;
    }

    public Object readResolve() {
      return theInstance;
    }

    public SuppressionLink generateSuppressionLink (Invariant arg) {
      if (debug.isLoggable(Level.FINE)) {
        debug.fine ("Attempting to generate suppression link for: " + arg.repr());
      }

      Assert.assertTrue (arg instanceof FunctionBinary);

      FunctionBinary inv = (FunctionBinary) arg;

      // We will make a template for all possible constants.
      SuppressionTemplate supTemplate = new SuppressionTemplate();

      supTemplate.invTypes = new Class[] {ONEOF.class};
      supTemplate.varInfos = new VarInfo [][] {new VarInfo[1]};

      VarInfo[] vis = new VarInfo[] {inv.var1(), inv.var2(), inv.var3()};
      for (int i = 0; i < vis.length; i++) {
        supTemplate.varInfos[0][0] = vis[i];
        supTemplate.resetResults();
        supTemplate.fill(inv.ppt.parent);
        if (supTemplate.results[0] != null) {
          OneOf suppressor = (OneOf) supTemplate.results[0];
          if (suppressor.num_elts() <= 1) {
            List suppressors = new ArrayList();
            suppressors.add (suppressor);
            SuppressionLink sl = new SuppressionLink (this, inv, suppressors);
            if (debug.isLoggable(Level.FINE)) {
              debug.fine ("Success: " + supTemplate.results[0].repr());
            }
            return sl;
          }
        }
      }
      return null;
    }
  }
*/


#ifdef 0
  // Each of the functions is defined below.  Each must define the following
  // preprocessor variables:
  //
  //    FUNCTION    - Name of the function to be included in the classname
  //    FUNC        - Binary function to perform.  Must return a result
  //    METHOD_NAME - Initialization for a 3 element string array used to
  //                  print the invariants.  Invariants are formatted as:
  //
  //         'result = method_name[1] arg1 method_name[2] arg2 method_name[3]'
  //
  // There are also several optional variables that can be defined:
  //
  //    EQUALITY_SUPPRESS           - suppresses the invariant if all of its
  //                                  arguments are equal
  //    EQUALITY_MIN_MAX_SUPPRESS   - EQUALITY_SUPPRESS plus a suppression
  //                                  of min and max invariants when the
  //                                  result equals one of the args and
  //                                  is always greater than or less than
  //                                  the other argument.
  //    ARG1_BOUND                  - Specifies the lower and upper bound
  //                                  (inclusive) for arg1.  If the bound
  //                                  is violated, the invariant is destroyed
  //    ARG2_BOUND                  - Specifies the lower and upper bound
  //                                  (inclusive) for arg2.  If the bound
  //                                  is violated, the invariant is destroyed
  //    BOOLEAN_ARGS                - Specifies each argument is boolean.
  //                                  Any value other than 0 or 1 will
  //                                  destroy the invariant.
  //
  // After defining the appropriate variables, include
  // FunctionBinarySymmetric.java.jpp for symmetric functions or
  // FunctionBinaryNonSymmetric.java.jpp for non-symmetric functions.
#endif

#define FUNCTION Multiply
#define FUNC(arg1,arg2) arg1 * arg2
#define METHOD_NAME {"", " * ", ""}
#include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

#define FUNCTION Minimum
#define EQUALITY_MIN_MAX_SUPPRESS
#define FUNC(arg1, arg2) Math.min (arg1, arg2)
#define METHOD_NAME {"java.lang.Math.min(", ", ", ")"}
#include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

#define FUNCTION Maximum
#define EQUALITY_MIN_MAX_SUPPRESS
#define FUNC(arg1, arg2) Math.max (arg1, arg2)
#define METHOD_NAME {"java.lang.Math.max(", ", ", ")"}
#include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

#define FUNCTION Division
#define FUNC(arg1, arg2) (arg1 / arg2)
#define METHOD_NAME {"", " / ", ""}
#include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

#define FUNCTION Power
#define FUNC(arg1, arg2) POW (arg1, arg2)
#define METHOD_NAME {"java.lang.Math.pow(", ", ", ")"}
#include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

#if defined(TYPELONG)

  #define FUNCTION BitwiseAnd
  #define EQUALITY_SUPPRESS 1
  #define FUNC(arg1,arg2) (arg1 & arg2)
  #define METHOD_NAME {"", " & ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION LogicalAnd
  #define BOOLEAN_ARGS 1
  #define FUNC(arg1,arg2) (((arg1 != 0) && (arg2 != 0)) ? 1 : 0)
  #define METHOD_NAME {"", " && ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION BitwiseXor
  #define FUNC(arg1,arg2) (arg1 ^ arg2)
  #define METHOD_NAME {"", " ^ ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION LogicalXor
  #define BOOLEAN_ARGS 1
  #define FUNC(arg1,arg2) (((arg1 != 0) ^ (arg2 != 0)) ? 1 : 0)
  // #define METHOD_NAME {"", " ^ ", ""}
  #define METHOD_NAME {"utilMDE.MathMDE.logicalXor(", ", ", ")"}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION BitwiseOr
  #define EQUALITY_SUPPRESS 1
  #define FUNC(arg1,arg2) (arg1 | arg2)
  #define METHOD_NAME {"", " | ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION LogicalOr
  #define BOOLEAN_ARGS 1
  #define FUNC(arg1,arg2) (((arg1 != 0) || (arg2 != 0)) ? 1 : 0)
  #define METHOD_NAME {"", " || ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION Gcd
  #define EQUALITY_SUPPRESS 1
  #define FUNC(arg1,arg2) MathMDE.gcd (arg1, arg2)
  #define METHOD_NAME {"utilMDE.MathMDE.gcd(", ", ", ")"}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION Mod
  #define FUNC(arg1,arg2) (arg1 % arg2)
  #define METHOD_NAME {"", " % ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

  #define FUNCTION Lshift
  #define ARG2_BOUND {0, 63}
  #define FUNC(arg1,arg2) (arg1 << arg2)
  #define METHOD_NAME {"", " << ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

  #define FUNCTION RshiftSigned
  #define ARG2_BOUND {0, 63}
  #define FUNC(arg1,arg2) (arg1 >> arg2)
  #define METHOD_NAME {"", " >> ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

  #define FUNCTION RshiftUnsigned
  #define ARG2_BOUND {0, 63}
  #define FUNC(arg1,arg2) (arg1 >>> arg2)
  #define METHOD_NAME {"", " >>> ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

#endif
}
