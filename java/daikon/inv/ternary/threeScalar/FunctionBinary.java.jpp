#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif



#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG OR DOUBLETYPE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME FunctionBinary
  #define CORECLASSNAME FunctionBinaryCore
  #define PRIMITIVE long
  #define SUPERCLASS ThreeScalar
  #define FUNCTIONS Functions
  #define ONEOF OneOfScalar
  #define CLASSSTRING "FunctionBinary"
  #define OP_LIST * / % << >> >>> & && ^ | ||
  #define FUNCTION_LIST min max gcd pow
  #define EQ_FUNC_NUMS 1, 5, 7, 8, 9
  #define LOGICAL_FUNC_NUMS 2, 4, 6
  #define EQUALITY IntEqual
#elif defined(TYPEDOUBLE)
  #define CLASSNAME FunctionBinaryFloat
  #define CORECLASSNAME FunctionBinaryCoreFloat
  #define PRIMITIVE double
  #define SUPERCLASS ThreeFloat
  #define FUNCTIONS FunctionsFloat
  #define ONEOF OneOfFloat
  #define CLASSSTRING "FunctionBinaryFloat"
  #define OP_LIST * /
  #define FUNCTION_LIST min max pow
  #define EQ_FUNC_NUMS 1, 2
  #define EQUALITY FloatEqual
#else
  #error "bad def"
#endif

// ***** This file is automatically generated from FunctionBinary.java.jpp

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.OneOf;
import daikon.inv.unary.scalar.OneOfScalar;
import daikon.inv.unary.scalar.OneOfFloat;
import daikon.inv.binary.twoScalar.*;
import daikon.derive.*;
import daikon.derive.unary.*;
import daikon.suppress.*;
import utilMDE.*;
import java.lang.reflect.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;


/**
 * Represents an invariant between three PRIMITIVE scalars by applying
 * a function to two of the scalars.  Prints as either "x  == function (y, z)"
 * or as "x == y op z" depending upon whether it is an actual function call
 * or a binary operator.
 *
 * Current PRIMITIVE operators are: OP_LIST <br>
 * Current PRIMITIVE functions are: FUNCTION_LIST
 **/

public class CLASSNAME
  extends SUPERCLASS
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff CLASSNAME invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  public static Logger debug = Logger.getLogger("daikon.inv.ternary.threeScalar." + CLASSSTRING);

  public CORECLASSNAME core;

  protected CLASSNAME(PptSlice ppt, String[] methodname, int methodNumber, int var_order) {
    super(ppt);
    core = new CORECLASSNAME(this, methodname, methodNumber, var_order);
  }

  public static CLASSNAME instantiate(PptSlice ppt, String[] methodname, int methodNumber, int var_order) {
    if (!dkconfig_enabled)
      return null;

    {
      int[] indices = CORECLASSNAME.var_indices[var_order];
      VarInfo argresult = ppt.var_infos[indices[0]];
      VarInfo arg1 = ppt.var_infos[indices[1]];
      VarInfo arg2 = ppt.var_infos[indices[2]];
      if (logOn() && is_debug_method (methodname))
        Debug.log (CLASSNAME.class, ppt, "Instantiate vars "
                  + indices[0] + ", " + indices[1] + ", " + indices[2]);
      if (debug.isLoggable(Level.FINE))
        debug.fine (CLASSSTRING + ".instantiate(" + ppt.name() + ", "
                    + methodname + " (#" + methodNumber + "), "
                    + argresult.name + "="
                    + "f(" + arg1.name + "," + arg2.name + ")");
    }

    // SUPPRESS INVARIANT: if any var is constant, suppress CLASSNAME;
    // skip if the arguments are constant (but not if the result is
    // constant, as we might get something like y=abs(x)).  (Actually, for
    // now I'm skipping if the result is constant, too: that's a
    // relationship over the two arguments, not a ternary relationship.)
    /* [INCR]
    int[] indices = CORECLASSNAME.var_indices[var_order];
    VarInfo resultvar = ppt.var_infos[indices[0]];
    VarInfo arg1 = ppt.var_infos[indices[1]];
    VarInfo arg2 = ppt.var_infos[indices[2]];
    if (resultvar.isConstant() || (arg1.isConstant() && arg2.isConstant())) {
      if (debug.isLoggable(Level.FINE))
        debug.fine (CLASSSTRING + ".instantiate: both args are constant");
      Global.subexact_noninstantiated_invariants++;
      return null;
    }
    */

    return new CLASSNAME(ppt, methodname, methodNumber, var_order);
  }

  public VarInfo resultVar() { return core.resultVar(); }
  public VarInfo argVar1() { return core.argVar1(); }
  public VarInfo argVar2() { return core.argVar2(); }

  public Object clone() {
    CLASSNAME result = (CLASSNAME) super.clone();
    result.core = (CORECLASSNAME) core.clone();
    result.core.wrapper = result;
    return result;
  }

  protected Invariant resurrect_done(int[] permutation) {
    core.permute(permutation);
    return this;
  }

  public String repr() {
    return CLASSSTRING  + varNames() + ": " + core.repr();
  }

  public String format_using(OutputFormat format) {
    return core.format_using(format);
  }

  public InvariantStatus add_modified(PRIMITIVE x, PRIMITIVE y, PRIMITIVE z, int count) {
    return core.add_modified(x, y, z, count);
  }

  protected double computeConfidence() {
    return core.computeConfidence();
  }

  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((CLASSNAME) other).core);
  }

  // // For testing only; to be commented out
  // public void destroy() {
  //   if (debug.isLoggable(Level.FINE)) {
  //     Method function = core.function;
  //     int var_order = core.var_order;
  //     int[] indices = CORECLASSNAME.var_indices[var_order];
  //     VarInfo argresult = ppt.var_infos[indices[0]];
  //     VarInfo arg1 = ppt.var_infos[indices[1]];
  //     VarInfo arg2 = ppt.var_infos[indices[2]];
  //     debug.fine ("CLASSNAME.destroy: "
  //                        + argresult.name + " = "
  //                        + function.getName() + "(" + arg1.name + ", " + arg2.name + ")");
  //   }
  //   super.destroy();
  // }


  /**
   * If the arg is a sequence size, return the sequence; otherwise return null.
   **/
  private VarInfo sized_sequence(VarInfo size) {
    if (size.derived instanceof SequenceLength) {
      return ((SequenceLength)size.derived).base;
    }
    return null;
  }



  public DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    // Discard if any two of the three invariants are the sizes of the
    // same arrays.
    VarInfo arr1 = sized_sequence(vis[0]);
    VarInfo arr2 = sized_sequence(vis[1]);
    VarInfo arr3 = sized_sequence(vis[2]);
    if (((arr1 != null) && (arr1 == arr2))
        || ((arr1 != null) && (arr1 == arr3))
        || ((arr2 != null) && (arr2 == arr3))) {
      return new DiscardInfo(this, DiscardCode.obvious, "two are sizes of same array:  " + vis[0].name.name() + " " + vis[1].name.name() + " " + vis[2].name.name());
    }

#if defined(TYPELONG)
    // Discard if a logical Boolean operation, but the arguments are not 0
    // or 1.
    if (ArraysMDE.indexOf (logical_func_nums, core.methodNumber) != -1) {
      // System.out.println("considering non-logical-function suppression: " + format());
      VarInfo arg1 = argVar1();
      VarInfo arg2 = argVar2();
      SuppressionLink sl1 = SuppressionFactory.findInRange(this, arg1, 0, 1);
      SuppressionLink sl2 = SuppressionFactory.findInRange(this, arg1, 0, 1);
      if ((sl1 == null) || (sl2 == null)) {
        // System.out.println("one or both args aren't boolean: " + arg1.name.name() + " " + arg2.name.name());
        return new DiscardInfo(this, DiscardCode.obvious, "one or both args aren't boolean: " + arg1.name.name() + " " + arg2.name.name());
      }
    }
#endif

    return null;
  }


// This (incorrect) SuppressionFactory for FunctionBinary invariants
// suppresses all FunctionBinary such that one of the members is a
// constant.  This isn't correct for suppression, since constants
// don't logiclaly imply FunctionBinary.  However, a FunctionBinary invariant
// that results from constant components is uninteresting, so this
// should later be used in filtering for printing.
/*
  static class FunctionBinarySuppressionFactory extends SuppressionFactory {

    public static final Logger debug = Logger.getLogger ("daikon.suppress.factories.FunctionBinarySuppressionFactory");

    public static final FunctionBinarySuppressionFactory theInstance =
      new FunctionBinarySuppressionFactory();

    private FunctionBinarySuppressionFactory() {

    }

    public static SuppressionFactory getInstance() {
      return theInstance;
    }

    public Object readResolve() {
      return theInstance;
    }

    public SuppressionLink generateSuppressionLink (Invariant arg) {
      if (debug.isLoggable(Level.FINE)) {
        debug.fine ("Attempting to generate suppression link for: " + arg.repr());
      }

      Assert.assertTrue (arg instanceof FunctionBinary);

      FunctionBinary inv = (FunctionBinary) arg;

      // We will make a template for all possible constants.
      SuppressionTemplate supTemplate = new SuppressionTemplate();

      supTemplate.invTypes = new Class[] {ONEOF.class};
      supTemplate.varInfos = new VarInfo [][] {new VarInfo[1]};

      VarInfo[] vis = new VarInfo[] {inv.var1(), inv.var2(), inv.var3()};
      for (int i = 0; i < vis.length; i++) {
        supTemplate.varInfos[0][0] = vis[i];
        supTemplate.resetResults();
        supTemplate.fill(inv.ppt.parent);
        if (supTemplate.results[0] != null) {
          OneOf suppressor = (OneOf) supTemplate.results[0];
          if (suppressor.num_elts() <= 1) {
            List suppressors = new ArrayList();
            suppressors.add (suppressor);
            SuppressionLink sl = new SuppressionLink (this, inv, suppressors);
            if (debug.isLoggable(Level.FINE)) {
              debug.fine ("Success: " + supTemplate.results[0].repr());
            }
            return sl;
          }
        }
      }
      return null;
    }
  }
*/

  // Create a suppression factory for functionBinary
  #define FACTORY_INVCLASS  CLASSNAME
  #define FACTORY_CNT       4
  #define FACTORY1          equality_suppress_repeated_arg
  #define FACTORY1_INV_CNT  1
  #define FACTORY1_VAR_INFO {new VarInfo[2]}
  #define FACTORY2          equality_suppress_distinct_args
  #define FACTORY2_INV_CNT  2
  #define FACTORY2_VAR_INFO {new VarInfo[2], new VarInfo[2]}
  #define FACTORY3          equality_suppress_min_max
  #define FACTORY3_INV_CNT  2
  #define FACTORY3_VAR_INFO {new VarInfo[2], new VarInfo[2]}
  #define FACTORY4          suppress_zero_result
  #define FACTORY4_INV_CNT  2
  #define FACTORY4_VAR_INFO {new VarInfo[1], new VarInfo[2]}
  #include "daikon/inv/suppressionFactory.java.jpp"


  static int[] eq_func_nums = new int[] {EQ_FUNC_NUMS};
#if defined(TYPELONG)
  static int[] logical_func_nums = new int[] {LOGICAL_FUNC_NUMS};
#endif

  /**
   * Suppress 'z = func(x, y)' by 'z == x == y' where func is bitwiseAnd,
   * bitwiseOr, min, max, or gcd.  equality_suppress_args_samevar is used
   * when x and y are the same variable; equality_suppress_distinct_args
   * works when x and y are distinct.  This is necessary because there are
   * assertions elsewhere that don't allow us to include the same invariant
   * twice as a suppressor.  And that is what happens if x, y, and z
   * actually refer to the same variable:  we get var == var and var == var
   * as our two suppressors.
   **/
  public static SuppressionLink equality_suppress_repeated_arg (CLASSNAME inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    // Check the method type for those implied by equality
    if (ArraysMDE.indexOf (eq_func_nums, inv.core.methodNumber) == -1)
      return (null);

    // If the variables are not all the same, give up and let the second
    // factory handle this.
    if ((inv.var1() != inv.var2()) || (inv.var2() != inv.var3()))
      return (null);

    // Build the tempmlate and look for matches
    supTemplate.set (0, EQUALITY.class, inv.var2(), inv.var3());
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    return (sl);
  }

  /**
   * See comment for equality_suppress_repeated_arg.
   **/
  public static SuppressionLink equality_suppress_distinct_args (CLASSNAME inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    // Check the method type for those implied by equality
    if (ArraysMDE.indexOf (eq_func_nums, inv.core.methodNumber) == -1)
      return (null);

    // If all the variables are the same, let
    // equality_suppress_repeated_arg handle it.  (Actually, this should
    // never get called in that case, right?)
    if ((inv.var1() == inv.var2()) && (inv.var2() == inv.var3()))
      return (null);

    // Pick pairs of variables that don't match
    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();
    VarInfo v3 = inv.var3();
    if (v1 == v3) {
      VarInfo tmp = v2;
      v2 = v3;
      v3 = tmp;
    }

    // Build the template and look for matches
    supTemplate.set (0, EQUALITY.class, v1, v2);
    supTemplate.set (1, EQUALITY.class, v2, v3);
    SuppressionLink sl = sfact.linkFromUnfilledTemplate (supTemplate, inv);
    return (sl);
  }

  // Only for getting the equality part, not other parts of the full suppression.
  private static SuppressionTemplate equality_min_max_template = new SuppressionTemplate(1);

  // Suppress "a = min(a, b)" or "a = max(a, b)".
  public static SuppressionLink equality_suppress_min_max (CLASSNAME inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {

    // Yuck, hard-coded constants for min and max.
    if (! ((inv.core.methodNumber == 7) // min
           || (inv.core.methodNumber == 8) // max
           )) {
      return null;
    }

    VarInfo v1 = inv.var1();
    VarInfo v2 = inv.var2();
    VarInfo v3 = inv.var3();

    SuppressionTemplate st = equality_min_max_template;
    SuppressionLink eq_sl;

    // Suppress "v1 = min(v2, v3) by "v1 == v2 && v1 <= v3".
    // Suppress "v1 = max(v2, v3) by "v1 == v2 && v3 <= v1".
    st.set(0, EQUALITY.class, v1, v2);
    eq_sl = SuppressionFactory.linkFromUnfilledTemplate(st, inv);
    if (eq_sl != null) {
      SuppressionLink le_sl;
      if (inv.core.methodNumber == 7) // min
        le_sl = SuppressionFactory.findLessEqualInt(inv, v1, v3, 0);
      else
        le_sl = SuppressionFactory.findLessEqualInt(inv, v3, v1, 0);
      if (le_sl != null) {
        return SuppressionLink.combine(eq_sl, le_sl);
      }
    }

    // Suppress "v1 = min(v2, v3) by "v1 == v3 && v1 <= v2".
    // Suppress "v1 = max(v2, v3) by "v1 == v3 && v2 <= v1".
    st.set(0, EQUALITY.class, v1, v3);
    eq_sl = SuppressionFactory.linkFromUnfilledTemplate(st, inv);
    if (eq_sl != null) {
      SuppressionLink le_sl;
      if (inv.core.methodNumber == 7) // min
        le_sl = SuppressionFactory.findLessEqualInt(inv, v1, v2, 0);
      else
        le_sl = SuppressionFactory.findLessEqualInt(inv, v2, v1, 0);
      if (le_sl != null) {
        return SuppressionLink.combine(eq_sl, le_sl);
      }
    }

    return null;
  }

  private static SuppressionTemplate suppress_zero_result_zero_template = new SuppressionTemplate(1);

  // Suppress 0 == fn(a, b).
  public static SuppressionLink suppress_zero_result (CLASSNAME inv,
                  SuppressionTemplate supTemplate, SuppressionFactory sfact) {
    SuppressionLink sl_result_zero
      = SuppressionFactory.findConstantInt(inv, inv.resultVar(), 0);
    if (sl_result_zero == null) {
      return null;
    }

    // Examples:
    // 0 == a / b	a < b

    return null;
  }


  /// Debugging code

  private static boolean is_debug_method (String[] methodname) {
    if (Debug.function_binary_method != null) {
      if (methodname[0].equals (Debug.function_binary_method)
        || methodname[1].equals (Debug.function_binary_method))
        return (true);
      else
        return (false);
    }
    return (true);
  }

 /**
  * Logs a description of the invariant and the specified msg via the
  * log4j logger as described in {@link daikon.Debug#log(Logger, Class, Ppt,
  * VarInfo[], String)}
  *
  * This version is specific to FunctionBinary and allows us to restrict
  * logging to a particular function
  *
  * @return whether or not it logged anything
  */
  public boolean log (String msg) {

    if (is_debug_method (core.methodname))
      return (Debug.log (getClass(), ppt, "var_order=" + core.var_order
              + " " + msg));
    else
      return (false);
  }

  /**
   * Logs a description of the invariant and the specified msg via the
   * log4j logger as described in {@link daikon.Debug#log(Logger, Class, Ppt,
   * VarInfo[], String)}
   *
   * This version is specific to FunctionBinary and allows us to restrict
   * logging to a particular function
   */
  public void log (Logger debug, String msg) {

    if (is_debug_method (core.methodname))
      Debug.log (debug, getClass(), ppt, "var_order=" + core.var_order
                + " " + msg);
  }


}
