#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif



#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
#error "TYPELONG OR DOUBLETYPE must be defined"
#endif

#if defined(TYPELONG)
#define CLASSNAME FunctionBinary
#define CORECLASSNAME FunctionBinaryCore
#define PRIMITIVE long
#define SUPERCLASS ThreeScalar
#define FUNCTIONS Functions
#define ONEOF OneOfScalar
#define CLASSSTRING "FunctionBinary"
#elif defined(TYPEDOUBLE)
#define CLASSNAME FunctionBinaryFloat
#define CORECLASSNAME FunctionBinaryCoreFloat
#define PRIMITIVE double
#define SUPERCLASS ThreeFloat
#define FUNCTIONS FunctionsFloat
#define CLASSSTRING "FunctionBinaryFloat"
#define ONEOF OneOfFloat
#else
#error "bad def"
#endif

// ***** This file is automatically generated from FunctionBinary.java.jpp

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.inv.Invariant;
import daikon.inv.OneOf;
import daikon.inv.unary.scalar.OneOfScalar;
import daikon.inv.unary.scalar.OneOfFloat;
import daikon.suppress.*;
import utilMDE.Assert;
import java.lang.reflect.*;
import java.util.*;
import org.apache.log4j.Category;


public class CLASSNAME
  extends SUPERCLASS
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff CLASSNAME invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  public static Category debug = Category.getInstance("daikon.inv.ternary.threeScalar." + CLASSSTRING);

  public CORECLASSNAME core;

  protected CLASSNAME(PptSlice ppt, String[] methodname, int methodNumber, int var_order) {
    super(ppt);
    core = new CORECLASSNAME(this, methodname, methodNumber, var_order);
  }

  public static CLASSNAME instantiate(PptSlice ppt, String[] methodname, int methodNumber, int var_order) {
    if (!dkconfig_enabled)
      return null;

    {
      int[] indices = CORECLASSNAME.var_indices[var_order];
      VarInfo argresult = ppt.var_infos[indices[0]];
      VarInfo arg1 = ppt.var_infos[indices[1]];
      VarInfo arg2 = ppt.var_infos[indices[2]];
      if (debug.isDebugEnabled())
        debug.debug(CLASSSTRING + ".instantiate(" + ppt.name + ", "
                    + methodname + " (#" + methodNumber + "), "
                    + argresult.name + "="
                    + "f(" + arg1.name + "," + arg2.name + ")");
    }

    // SUPPRESS INVARIANT: if any var is constant, suppress CLASSNAME;
    // skip if the arguments are constant (but not if the result is
    // constant, as we might get something like y=abs(x)).  (Actually, for
    // now I'm skipping if the result is constant, too: that's a
    // relationship over the two arguments, not a ternary relationship.)
    /* [INCR]
    int[] indices = CORECLASSNAME.var_indices[var_order];
    VarInfo resultvar = ppt.var_infos[indices[0]];
    VarInfo arg1 = ppt.var_infos[indices[1]];
    VarInfo arg2 = ppt.var_infos[indices[2]];
    if (resultvar.isConstant() || (arg1.isConstant() && arg2.isConstant())) {
      if (debug.isDebugEnabled())
        debug.debug(CLASSSTRING + ".instantiate: both args are constant");
      Global.subexact_noninstantiated_invariants++;
      return null;
    }
    */

    return new CLASSNAME(ppt, methodname, methodNumber, var_order);
  }

  protected Object clone() {
    CLASSNAME result = (CLASSNAME) super.clone();
    result.core = (CORECLASSNAME) core.clone();
    result.core.wrapper = result;
    return result;
  }

  protected Invariant resurrect_done(int[] permutation) {
    core.permute(permutation);
    return this;
  }

  public String repr() {
    return CLASSSTRING  + varNames() + ": " + core.repr();
  }

  public String format_using(OutputFormat format) {
    return core.format_using(format);
  }

  public void add_modified(PRIMITIVE x, PRIMITIVE y, PRIMITIVE z, int count) {
    core.add_modified(x, y, z, count);
  }


  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((CLASSNAME) other).core);
  }

  // // For testing only; to be commented out
  // public void destroy() {
  //   if (debug.isDebugEnabled()) {
  //     Method function = core.function;
  //     int var_order = core.var_order;
  //     int[] indices = CORECLASSNAME.var_indices[var_order];
  //     VarInfo argresult = ppt.var_infos[indices[0]];
  //     VarInfo arg1 = ppt.var_infos[indices[1]];
  //     VarInfo arg2 = ppt.var_infos[indices[2]];
  //     debug.debug("CLASSNAME.destroy: "
  //                        + argresult.name + " = "
  //                        + function.getName() + "(" + arg1.name + ", " + arg2.name + ")");
  //   }
  //   super.destroy();
  // }

  private static final SuppressionFactory[] suppressionFactories =
    new SuppressionFactory[] {};

  // Disabled because this factory doesn't do suppression.
  // new SuppressionFactory[] {FunctionBinarySuppressionFactory.getInstance()};

  public SuppressionFactory[] getSuppressionFactories() {
    return suppressionFactories;
  }



// SuppressionFactory for FunctionBinary invariants.  Right now, we
// suppress all FunctionBinary such that one of the members is a
// constant.  This isn't correct for suppression, since constants
// don't imply FunctionBinary.  However, a FunctionBinary invariant
// that results from constant components is uninteresting, so this
// should later be used in filtering for printing.
/*
  static class FunctionBinarySuppressionFactory extends SuppressionFactory {

    public static final Category debug = Category.getInstance ("daikon.suppress.factories.FunctionBinarySuppressionFactory");

    public static final FunctionBinarySuppressionFactory theInstance =
      new FunctionBinarySuppressionFactory();

    private FunctionBinarySuppressionFactory() {

    }

    public static SuppressionFactory getInstance() {
      return theInstance;
    }

    public Object readResolve() {
      return theInstance;
    }

    public SuppressionLink generateSuppressionLink (Invariant arg) {
      if (debug.isDebugEnabled()) {
        debug.debug ("Attempting to generate suppression link for: " + arg.repr());
      }

      Assert.assertTrue (arg instanceof FunctionBinary);

      FunctionBinary inv = (FunctionBinary) arg;

      // We will make a template for all possible constants.
      SuppressionTemplate template = new SuppressionTemplate();

      template.invTypes = new Class[] {ONEOF.class};
      template.varInfos = new VarInfo [][] {new VarInfo[1]};

      VarInfo[] vis = new VarInfo[] {inv.var1(), inv.var2(), inv.var3()};
      for (int i = 0; i < vis.length; i++) {
        template.varInfos[0][0] = vis[i];
        template.resetResults();
        inv.ppt.parent.fillSuppressionTemplate (template);
        if (template.results[0] != null) {
          OneOf suppressor = (OneOf) template.results[0];
          if (suppressor.num_elts() <= 1) {
            List suppressors = new ArrayList();
            suppressors.add (suppressor);
            SuppressionLink sl = new SuppressionLink (this, inv, suppressors);
            if (debug.isDebugEnabled()) {
              debug.debug ("Success: " + template.results[0].repr());
            }
            return sl;
          }
        }
      }
      return null;
    }
  }
*/

}
