#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME FunctionBinaryCore
  #define NUMWRAPPER  Long
  #define PRIMITIVE long
  #define FUNCTIONS Functions
  #define CLASSSTRING "FunctionBinaryCore"
  #define EQUAL(a,b) ((a) == (b))
#elif defined(TYPEDOUBLE)
  #define CLASSNAME FunctionBinaryCoreFloat
  #define NUMWRAPPER Double
  #define PRIMITIVE double
  #define FUNCTIONS FunctionsFloat
  #define CLASSSTRING "FunctionBinaryCoreFloat"
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
#else
  #error "bad def"
#endif

// ***** This file is automatically generated from FunctionBinaryCore.java.jpp

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import java.util.Arrays;
import utilMDE.*;
import java.io.Serializable;

// See FunctionUnaryCore for discussion of tradeoffs between constructing
// from java.lang.reflect.Method objects vs. Invokable objects.
public final class CLASSNAME
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

 // transient public Method function;
  public final String[] methodname;
  // see "Variable order"
  public int var_order;
  public int methodNumber;

  public Invariant wrapper;

  public CLASSNAME(Invariant wrapper, String[] methodname, int methodNumber, int var_order) {
    this.wrapper = wrapper;
    this.methodname = methodname;
    this.methodNumber = methodNumber;
    this.var_order = var_order;
    Assert.assertTrue(methodname.length == 3);
  }

  public Object clone() {
    try {
      CLASSNAME result = (CLASSNAME) super.clone();
      return result;
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  /**
   * Reorganize our already-seen state as if the variables had shifted
   * order underneath us (rearrangement given by the permutation).
   **/
  public void permute(int[] permutation) {
    Assert.assertTrue(permutation.length == 3);
    Assert.assertTrue(ArraysMDE.fn_is_permutation(permutation));
    int[] new_order = new int[3];
    int[] old_order = var_indices[var_order];

    // "permutation" is a permutation on the var_info array. old_order
    // was the permutation that took the formatted invariant to the
    // var_info array, so old_order^-1 is the permutation from the
    // var_info array to the old formatted invariant. We want to find
    // a new_order so that when we first do "permutation", then
    // apply the new permutation from the var_info array to the
    // formatted invariant, we get the same formatted invariant.
    // What we want, then. is:
    //    new_order^-1 o permutation = old_order^-1
    // rearranging, this is equivalent to
    //    new_order = permutation o old_order
    new_order[0] = permutation[old_order[0]];
    new_order[1] = permutation[old_order[1]];
    new_order[2] = permutation[old_order[2]];

    // Force symmetric functions into a canonical form so that
    // we can match them when necessary and they always print the same.
    // For example, order of 0, 1, 2 and 0, 2, 1 represent the same
    // invariant for a symmetric function.  This forces them to always
    // be represented as 0, 1, 2
    if (FUNCTIONS.is_symmetric (methodNumber)) {
      if (methodname[1].equals (" / ")) {
        System.out.println ("methodNumber = " + methodNumber + " methodname = "
                            + methodname[0] + methodname[1] + methodname[2]);
        Assert.assertTrue(false);
      }
      if (new_order[2] < new_order[1]) {
        int tmp = new_order[2];
        new_order[2] = new_order[1];
        new_order[1] = tmp;
      }
    }

    // Look for the new order in the list of possible orders
    for (int i=0; i < var_indices.length; i++) {
      if (Arrays.equals(new_order, var_indices[i])) {
        var_order = i;
        return;
      }
    }
    Assert.assertTrue(false, "Could not find new ordering");
  }

 public InvariantStatus check_modified(PRIMITIVE x, PRIMITIVE y, PRIMITIVE z, int count) {
    PRIMITIVE result;
    PRIMITIVE arg1;
    PRIMITIVE arg2;

    if (var_order == order_xyz) {
      result = x; arg1 = y; arg2 = z;
    } else if (var_order == order_yxz) {
      result = y; arg1 = x; arg2 = z;
    } else if (var_order == order_zxy) {
      result = z; arg1 = x; arg2 = y;
    } else if (var_order == order_xzy) {
      result = x; arg1 = z; arg2 = y;
    } else if (var_order == order_yzx) {
      result = y; arg1 = z; arg2 = x;
    } else if (var_order == order_zyx) {
      result = z; arg1 = y; arg2 = x;
    } else {
      throw new Error("Bad var_order: " + var_order);
    }
    try {
      if (!EQUAL (result, FUNCTIONS.invokeBinary(methodNumber, arg1, arg2))) {
        return InvariantStatus.FALSIFIED;
        }
    } catch (RuntimeException e) {
      return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  public InvariantStatus add_modified(PRIMITIVE x, PRIMITIVE y, PRIMITIVE z, int count) {
    PRIMITIVE result;
    PRIMITIVE arg1;
    PRIMITIVE arg2;

    // Will be changed after figuring out the var order
    String name1="";
    String name2="";
    String name3="";

    String n1 = wrapper.ppt.var_infos[0].name.name();
    String n2 = wrapper.ppt.var_infos[1].name.name();
    String n3 = wrapper.ppt.var_infos[2].name.name();

    if (var_order == order_xyz) {
      result = x; arg1 = y; arg2 = z;
      name1 = n1;
      name2 = n2;
      name3 = n3;
    } else if (var_order == order_yxz) {
      result = y; arg1 = x; arg2 = z;
      name1 = n2;
      name2 = n1;
      name3 = n3;
    } else if (var_order == order_zxy) {
      result = z; arg1 = x; arg2 = y;
      name1 = n3;
      name2 = n1;
      name3 = n2;
    } else if (var_order == order_xzy) {

      result = x; arg1 = z; arg2 = y;
      name1 = n1;
      name2 = n3;
      name3 = n2;
    } else if (var_order == order_yzx) {
      result = y; arg1 = z; arg2 = x;
      name1 = n2;
      name2 = n3;
      name3 = n1;
    } else if (var_order == order_zyx) {
      result = z; arg1 = y; arg2 = x;
      name1 = n3;
      name2 = n2;
      name3 = n1;
    } else {
      throw new Error("Bad var_order: " + var_order);
    }
    try {
      if (!EQUAL (result, FUNCTIONS.invokeBinary(methodNumber, arg1, arg2))) {
          // System.out.println(CLASSSTRING +  " failed: "
          //                    + result + " != " + function + "(" + arg1 + ", " + arg2 + ")"
          //                    + " ; " + var_order_string[var_order]);
        // wrapper.destroyAndFlow();
        return InvariantStatus.FALSIFIED;
        }
    } catch (RuntimeException e) {
      return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  public double computeConfidence() {
    if (wrapper.logOn()) {
      VarInfo v1 = wrapper.ppt.var_infos[0];
      VarInfo v2 = wrapper.ppt.var_infos[1];
      VarInfo v3 = wrapper.ppt.var_infos[2];
      wrapper.log("computeConfidence(" + wrapper.format()
                  + ": num_values = " + wrapper.ppt.num_values()
                  + ", num_values(" + v1.name.name() + ")=" + wrapper.ppt.parent.num_values(v1)
                  + ", num_values(" + v2.name.name() + ")=" + wrapper.ppt.parent.num_values(v2)
                  + ", num_values(" + v3.name.name() + ")=" + wrapper.ppt.parent.num_values(v3));
    }
    return Invariant.conf_is_ge(wrapper.ppt.num_values(), 5);
  }



  /// Variable order

  // These constants indicate which are the arguments.
  // For instance, "order_xyz" indicates the relationship is x=f(y,z).
  final static int order_xyz = 0; // x = f(y,z)
  final static int order_yxz = 1; // y = f(x,z)
  final static int order_zxy = 2; // z = f(x,y)
  final static int order_xzy = 3; // x = f(z,y)
  final static int order_yzx = 4; // y = f(z,x)
  final static int order_zyx = 5; // z = f(y,x)
  final static int order_symmetric_start = order_xyz;
  final static int order_symmetric_max = order_zxy;
  final static int order_nonsymmetric_start = order_xyz;
  final static int order_nonsymmetric_max = order_zyx;

  // Be careful keeping track of the sense of the permutation the
  // var_indices values represent. As a function on the set {0,1,2},
  // an array var_indices[order_foo] goes from a position in the
  // formatted invariant, to a position in the var_info array. If you
  // want to get from a position in the var_info array to position in
  // the formatted invariant, you need the inverse permutation.
  final static int[][] var_indices;
  static {
    var_indices = new int[order_nonsymmetric_max+1][];
    var_indices[order_xyz] = new int[] { 0, 1, 2 };
    var_indices[order_yxz] = new int[] { 1, 0, 2 };
    var_indices[order_zxy] = new int[] { 2, 0, 1 };
    var_indices[order_xzy] = new int[] { 0, 2, 1 };
    var_indices[order_yzx] = new int[] { 1, 2, 0 };
    var_indices[order_zyx] = new int[] { 2, 1, 0 };
  }

  final static String[] var_order_string = { "x=f(y,z)",
                                             "y=f(x,z)",
                                             "z=f(x,y)",
                                             "x=f(z,y)",
                                             "y=f(z,x)",
                                             "z=f(y,x)" };

  public String repr() {
    return CLASSSTRING + wrapper.varNames() + ": "
      + "methodname=(" + methodname[0] + "," + methodname[1] + "," + methodname[2] + ")"
      + ";var_order=" + var_order;
  }

  public VarInfo resultVar() {
    return wrapper.ppt.var_infos[var_indices[var_order][0]];
  }
  public VarInfo argVar1() {
    return wrapper.ppt.var_infos[var_indices[var_order][1]];
  }
  public VarInfo argVar2() {
    return wrapper.ppt.var_infos[var_indices[var_order][2]];
  }

  // Perhaps this should take arguments rather than looking into the wrapper.
  public String format_using(OutputFormat format) {
    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }

    PptSlice ppt = wrapper.ppt;
    VarInfo argresultvi = ppt.var_infos[var_indices[var_order][0]];
    VarInfoName argresult = argresultvi.name;
    VarInfo arg1vi = ppt.var_infos[var_indices[var_order][1]];
    VarInfoName arg1 = arg1vi.name;
    VarInfo arg2vi = ppt.var_infos[var_indices[var_order][2]];
    VarInfoName arg2 = arg2vi.name;

    String argresult_name = argresult.name_using(format, argresultvi);
    String arg1_name = arg1.name_using(format, arg1vi);
    String arg2_name = arg2.name_using(format, arg2vi);

    if (format == OutputFormat.DAIKON) {
        //        || format == OutputFormat.JML) {
      return argresult_name + " == " + methodname[0] + arg1_name + methodname[1] + arg2_name + methodname[2];
    }

    if (format.isJavaFamily()) {

      if (methodname[1].equals(" || ")
          || methodname[1].equals(" && ")) {
        return
          "(" + argresult_name + " != 0)"
          + " == "
          + methodname[0]
          + "(" + arg1_name + " != 0)"
          + methodname[1]
          + "(" + arg2_name + " != 0)"
          + methodname[2];
      }
      if (methodname[1].equals(" * ")
          || methodname[1].equals(" / ")
          || methodname[1].equals(" % ")
          || methodname[1].equals(" | ")
          || methodname[1].equals(" & ")
          || methodname[1].equals(" ^ ")
          || methodname[1].equals(" << ")
          || methodname[1].equals(" >> ")
          || methodname[1].equals(" >>> ")) {
        return
          argresult_name + " == (" + arg1_name + methodname[1] + arg2_name + ")";
      }
      if (methodname[0].equals("java.lang.Math.min(")
          || methodname[0].equals("java.lang.Math.max(")
          || methodname[0].equals("java.lang.Math.pow(")
          || methodname[0].equals("utilMDE.MathMDE.gcd(")
          || methodname[0].equals("utilMDE.MathMDE.logicalXor(")) {
        return argresult_name + " == " + methodname[0] + arg1_name + ", " + arg2_name + ")";
      }
      return wrapper.format_unimplemented(format);
    }

    if (format == OutputFormat.IOA) {
      return argresult_name + " = " + methodname[0] + arg1_name + methodname[1] + arg2_name + methodname[2] + " ***";
    }

    return wrapper.format_unimplemented(format);
  }

  public String format_simplify() {
    PptSlice ppt = wrapper.ppt;
    String result = ppt.var_infos[var_indices[var_order][0]].simplifyFixedupName();
    String arg1 = ppt.var_infos[var_indices[var_order][1]].simplifyFixedupName();
    String arg2 = ppt.var_infos[var_indices[var_order][2]].simplifyFixedupName();
    String func = null;
    if (methodname[1].equals(" * ")) {
      func = "*";
    } else if (methodname[1].equals(" % ")) {
      func = "MOD";
    } else if (methodname[1].equals(" | ")) {
      func = "|java-bitwise-or|";
    } else if (methodname[1].equals(" || ")) {
      func = "|java-logical-or|";
    } else if (methodname[1].equals(", ")) {
      if (methodname[0].equals("java.lang.Math.min("))
        func = "min";
      else if (methodname[0].equals("java.lang.Math.max("))
        func = "max";
      else if (methodname[0].equals("utilMDE.MathMDE.gcd("))
        func = "gcd";
      else if (methodname[0].equals("java.lang.Math.pow("))
        func = "pow";
      else if (methodname[0].equals("utilMDE.MathMDE.logicalXor("))
        func = "|java-logical-xor|";
    } else {
      Assert.assertTrue(methodname[0].equals(""));
      Assert.assertTrue(methodname[2].equals(""));
      func = "|java-" + methodname[1].trim() + "|";
    }
    if (func == null)
      return "format_simplify() doesn't know function " + methodname[0] + "-" +
        methodname[1] + "-" + methodname[2];
    return "(EQ " + result + " (" + func + " " + arg1 + " " + arg2 + "))";
  }


  public boolean isSameFormula(CLASSNAME other) {
    return ((methodNumber == other.methodNumber)
            && (var_order == other.var_order));

    // Old version, not clear why var_order is not included or why methodname
    // is used rather than methodNumber (jhp 7/31/03)
    //     for (int i=0; i<3; i++) {
    //       if (! methodname[i].equals(other.methodname[i])) {
    //         return false;
    //       }
    //     }
    //     return true;
  }

}
