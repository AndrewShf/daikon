#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "Either TYPELONG or TYPEDOUBLE must be defined"
#endif

#if (defined(TYPELONG))
  #define CLASSNAME LinearTernaryCore
  #define PRIMITIVE long
  #define LINEAR_BINARY LinearBinary
  #define ONEOF OneOfScalar
  #define CLASSSTRING "LinearTernaryCore"
  // #define EQUAL(a,b) ((a) == (b))
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
  #define GET_VAL(a) (((Long)a).longValue())
#elif (defined(TYPEDOUBLE))
  #define CLASSNAME LinearTernaryCoreFloat
  #define PRIMITIVE double
  #define LINEAR_BINARY LinearBinaryFloat
  #define ONEOF OneOfFloat
  #define CLASSSTRING "LinearTernaryCoreFloat"
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
  #define GET_VAL(a) (((Double)a).doubleValue())
#else
  #error "Either TYPELONG or TYPEDOUBLE must be defined"
#endif

// ***** This file is automatically generated from LinearTernaryCore.java.jpp

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.unary.scalar.*;
import utilMDE.*;
import java.io.Serializable;

import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;


public final class CLASSNAME
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  /** Debug tracer **/
  final static Logger debug = Logger.getLogger("daikon.inv.ternary.threeScalar." + CLASSSTRING);

  // ax + by + cz + d = 0; first argument is x, second is y, third is z
  public double a = 0, b = 0, c = 0, d = 0;
  public double min_a, max_a, min_b, max_b, min_c, max_c, min_d, max_d;
  public double separation = 0;

  // Inner class to store points in for more convenient access.
  public static class Point implements Serializable, Cloneable {
    public PRIMITIVE x;
    public PRIMITIVE y;
    public PRIMITIVE z;
    public Point () {
      this (0, 0, 0);
    }
    public Point (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {
      this.x = x; this.y = y; this.z = z;
    }
    public boolean equals (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {
      return ((this.x == x) && (this.y == y) && (this.z == z));
    }
    protected Object clone() throws CloneNotSupportedException {
      return super.clone();
    }
    public String toString() {
      return ("(" + x + ", " + y + " ," + z + ")");
    }
  }

  // Points that define the plane.  The first three are normally the
  // current definition.  The next is a new point for consideration.
  // However, any slot may be set to null at any time, and points may be
  // duplicated at any time.
  public Point[] def_points = new Point[MINTRIPLES];

  public Invariant wrapper;

  // The number of distinct values (not samples) seen.
  public int values_seen = 0;

  final static int MINTRIPLES = 5;

  public CLASSNAME(Invariant wrapper) {
    this.wrapper = wrapper;
  }

  public Object clone() {
    try {
      CLASSNAME result = (CLASSNAME) super.clone();
      result.def_points = new Point[MINTRIPLES];
      for (int i=0; i<MINTRIPLES; i++) {
        Point p = def_points[i];
        if (p != null) {
          result.def_points[i] = (Point) p.clone();
        }
      }
      return result;
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  /**
   * Reorganize our already-seen state as if the variables had shifted
   * order underneath us (rearrangement given by the permutation).
   **/
  public void permute(int[] permutation) {
    Assert.assertTrue(permutation.length == 3);
    Assert.assertTrue(ArraysMDE.fn_is_permutation(permutation));
    // Fix a, b, c
    double[] clever = new double[] { a, b, c };
    double[] pclever = new double[3];
    pclever[permutation[0]] = clever[0];
    pclever[permutation[1]] = clever[1];
    pclever[permutation[2]] = clever[2];
    if (values_seen >= MINTRIPLES) {
      // Seen enough values, so permuting a, b, c is useful
       if (a == 0 || b == 0 || c == 0) {
        // Can't handle this form once rotated.  But if we've seen
        // enough values, yet a or b is zero, then this is covered by
        // a LinearBinary or a constant, so let me just destroy myself
        values_seen = Integer.MAX_VALUE;
        a = b = c = d = 0;
        if (debug.isLoggable(Level.FINE)) {
          debug.fine ("  Ternary invariant destroyed because a, b, or c = 0");
        }
        return;
      } else {
        // double d = -1.0 / pclever[2];
        a = pclever[0];
        b = pclever[1];
        c = pclever[2];

        // We need to force C to always be -1 (as it is originally calculated)
        // so that we always get the same equation
        double div = c / -1.0;
        a = a / div;
        b = b / div;
        c = c / div;
        d = d / div;
      }
    }

    // Fix caches
    {
      PRIMITIVE[] temp = new PRIMITIVE[3];
      for (int i=0; i<MINTRIPLES; i++) {
        Point p = def_points[i];
        if (p == null)
          continue;
        wrapper.log ("orig def_points["+i+"] = " + p);
        temp[permutation[0]] = p.x;
        temp[permutation[1]] = p.y;
        temp[permutation[2]] = p.z;
        p.x = temp[0];
        p.y = temp[1];
        p.z = temp[2];
        wrapper.log ("permuted def_points["+i+"] = " + p);
      }
    }
    // Assert that caches sync with a,b,c?
    // This would be a good sanity check, but it would be nontrivial
    // because we don't keep track of when a, b, and c are really
    // valid for all the of the points we've cached. If we were
    // falsified and then resurrected, we might have samples that
    // didn't fit even before the permutation. -smcc
  }

  /**
   * Returns whether or not the invariant is currently active.  We become
   * active after MINTRIPLES values have been seen and a plane calculated.
   * Before that, a, b, and c are uninitialized
   */
  public boolean isActive() {
    return (values_seen >= MINTRIPLES);
  }

  /**
   * LinearTernay can't be flowed because it keeps samples to build the
   * plane.  These sample can't be flowed from ppt to ppt (since they probably
   * didn't occur at the lower ppt).
   */
  public boolean isFlowable() {
    return (false);
  }

  /**
   * Sets up the invariant from a LinearBinary invariant and a constant
   * value for the third variable.  Points are taken from the LinearBinary
   * cache and its min_x/y and max_x/y points and combined with the
   * constant value.
   *
   * @return InvariantStatus.NO_CHANGE if the invariant is valid,
   * InvariantStatus.FALSIFIED if one of the points invalidated the
   * LinearTernary invariant
   */
  public InvariantStatus setup (LINEAR_BINARY lb, VarInfo con_var,
                                PRIMITIVE con_val) {

    if (Debug.logOn())
      wrapper.log ("setup from lb " + lb + " con var " + con_var +
                   " con_val " + con_val);

    int con_index = con_var.varinfo_index;
    int lb_v1_index = lb.ppt.var_infos[0].varinfo_index;
    int lb_v2_index = lb.ppt.var_infos[1].varinfo_index;

    PRIMITIVE[] con_vals = new PRIMITIVE [lb.core.values_seen+2];
    PRIMITIVE[] lb1_vals = new PRIMITIVE [lb.core.values_seen+2];
    PRIMITIVE[] lb2_vals = new PRIMITIVE [lb.core.values_seen+2];

    int mi = lb.core.values_seen;
    for (int i = 0; i < mi; i++) {
      con_vals[i] = con_val;
      lb1_vals[i] = lb.core.x_cache[i];
      lb2_vals[i] = lb.core.y_cache[i];
    }
    if (lb.isActive()) {
      con_vals[mi] = con_val;
      lb1_vals[mi] = lb.core.min_x;
      lb2_vals[mi] = lb.core.min_y;
      con_vals[mi+1] = con_val;
      lb1_vals[mi+1] = lb.core.max_x;
      lb2_vals[mi+1] = lb.core.max_y;
      mi += 2;
    }

    InvariantStatus sts = InvariantStatus.NO_CHANGE;
    for (int i = 0; i < mi; i++ ) {
      if (con_index < lb_v1_index) {
        sts = add_modified (con_vals[i], lb1_vals[i], lb2_vals[i], 1);
      } else if (con_index < lb_v2_index) {
        sts = add_modified (lb1_vals[i], con_vals[i], lb2_vals[i], 1);
      } else {
        sts = add_modified (lb1_vals[i], lb2_vals[i], con_vals[i], 1);
      }
      if (sts != InvariantStatus.NO_CHANGE)
        break;
    }

    if (sts != InvariantStatus.NO_CHANGE) {
      Fmt.pf ("lb.core.values_seen=" + lb.core.values_seen);
      for (int i = 0; i < mi; i++ )
        Fmt.pf ("LTCore: vals %s %s %s", "" + con_vals[i], "" + lb1_vals[i],
                "" + lb2_vals[i]);
      Fmt.pf ("in inv " + wrapper.format() + " " + wrapper.ppt);
      Assert.assertTrue (sts == InvariantStatus.NO_CHANGE);
    }
    return (sts);
  }

  /**
   * Sets up the invariant from a OneOf and a two constants
   * Points are taken from the OneOf cache and the constant values
   *
   * @return InvariantStatus.NO_CHANGE if the invariant is valid,
   * InvariantStatus.FALSIFIED if one of the points invalidated the
   * LinearTernary invariant
   */
  public InvariantStatus setup (ONEOF oo, VarInfo v1, PRIMITIVE con1,
                                VarInfo v2, PRIMITIVE con2) {

    int oo_index = oo.ppt.var_infos[0].varinfo_index;
    int con1_index = v1.varinfo_index;
    int con2_index = v2.varinfo_index;

    InvariantStatus sts = InvariantStatus.NO_CHANGE;
    for (int i = 0; i < oo.num_elts(); i++ ) {
      if (oo_index < con1_index) {
        sts = add_modified (GET_VAL(oo.elt(i)), con1, con2, 1);
      } else if (oo_index < con2_index) {
        sts = add_modified (con1, GET_VAL(oo.elt(i)), con2, 1);
    } else
        sts = add_modified (con1, con2, GET_VAL(oo.elt(i)), 1);
      if (sts != InvariantStatus.NO_CHANGE)
        break;
    }

    if (Debug.logOn())
      wrapper.log ("setup from OneOf " +  oo + " v1=" + con1 +
                   " v2=" + con2 + " status = " + sts);

    return (sts);
  }

  /**
   * Looks for points that define a plane (ax + by + cz + d = 0).  Collects
   * MINTRIPLE points before attempting to define the plane (to
   * hopefully get at least some spread between the points, so that
   * small errors don't get magnified).  Once the equation for the
   * plane is found, each subsequent point is compared to it.  If the
   * point does not match the point is examined to see if it would is
   * maximally separated when compared to the points originally used
   * to define the plane.  If it is, it is used to recalcalulate the
   * coefficients (a, b, c).  If those coefficients are relatively close
   * to the original coefficients (within the ratio defined by Global.fuzzy)
   * then the new coefficients are used.
   *
   * @see FuzzyFloat
   */
  public InvariantStatus add_modified(PRIMITIVE x, PRIMITIVE y, PRIMITIVE z, int count) {
    // XXX TODO FIXME: This method does not correctly deal with
    // calling addToFlow.  A proper clone, etc. should be created and
    // dealt with.  This will complicate the logic below, I'll bet.

    if (Debug.logDetail())
      wrapper.log ("Adding point, x=" + x + " y=" + y + " z=" + z);

    if (values_seen < MINTRIPLES) {
      // We delay computation of a and b until we have seen several triples
      // so that we can compute a and b based on a far-separated triple.  If
      // the points in a triple are nearby, then roundoff errors in the
      // computation of the slope can be non-negligible.

      // skip points we've already seen
      for (int i = 0; i < values_seen; i++)
        if (def_points[i].equals (x, y, z))
          return InvariantStatus.NO_CHANGE;

      def_points[values_seen] = new Point (x, y, z);
      values_seen++;

      // if we've seen enough values to create the equation
      if (values_seen == MINTRIPLES) {

        // Find the three points with the maximum separation
        maxsep_triples (def_points);
        if (def_points[0] == null) {
          return InvariantStatus.FALSIFIED;
        }

        // calculate the coefficients of the equation (a, b, c, d)
        double coef[];
        try {
          coef = calc_tri_linear (def_points);
        } catch (ArithmeticException e) {
          return InvariantStatus.FALSIFIED;
        }
        a = coef[0];
        b = coef[1];
        c = coef[2];
        d = coef[3];

        // If one of these coefficients is zero (except for d), this should be a
        // LinearBinary, not a LinearTernary, term.  (It might not show up
        // as LinearBinary because there might not have been enough samples;
        // but a random varying third variable can create enough samples.)
        // Also, throw out the invariant if any of the coefficients would
        // be infinite or not-a-number.
        if ((a == 0) || (b == 0) || (c == 0) ||
            (Math.abs(a) >= Double.MAX_VALUE) ||
            (Math.abs(b) >= Double.MAX_VALUE) ||
            (Math.abs(c) >= Double.MAX_VALUE) ||
            Double.isNaN(a) || Double.isNaN(b) || Double.isNaN(c)) {
          return InvariantStatus.FALSIFIED;
        }

        // Check all values against a, b, and c.
        if (!wrapper.is_false()) {
          for (int i=0; i<MINTRIPLES; i++) { // values_seen == MINTRIPLES
            // Global.fuzzy.eq works by comparing ratios between numbers,
            // so comparing the sum of everything to 0 won't work.
            if (!EQUAL (-c * def_points[i].z,
                        a*def_points[i].x + b*def_points[i].y + d)) {
              if (Debug.logOn() || debug.isLoggable(Level.FINE)) {
                wrapper.log (debug, "Destroying at index " + i + ": "
                            + "0 != "
                            + a + "*" + def_points[i].x
                            + "+" + b + "*" + def_points[i].y + "+" + c
                            + "*" + def_points[i].z
                            + "+" + d);
              }
              return InvariantStatus.FALSIFIED;
            }
          }
          if (Debug.logOn())
            wrapper.log ("equation = " + a + "*x " + b + "*y" + c + "*z = "
                          + (-d));

          // Discard the points not used to define the coefficients.
          for (int ii = 3; ii < MINTRIPLES; ii++)
            def_points[ii] = null;

          // check to see if this alread exists at the global ppt, it it
          // does, falsify it here to eliminate the duplicate copy.  This
          // is not the best place to do this, but easy for now
          PptSlice gslice = wrapper.ppt.find_global_slice
                                                    (wrapper.ppt.var_infos);
          if (gslice != null) {
            if (gslice.contains_inv_exact (wrapper)) {
              if (Debug.logOn())
                wrapper.log ("Matched at global");
              return InvariantStatus.FALSIFIED;
            }
          }

        }
      }
    } else {
      // If the new value doesn't fit the equation
      if (!EQUAL (-c*z, a*x+b*y+d)) {

        // Try to find small changes that will fit better.
        if (!try_new_equation (x, y, z)) {
          if (wrapper.logOn() || debug.isLoggable(Level.FINE)) {
            wrapper.log (debug, "destroying  (" + wrapper.format()
                  + ") where x=" + x + " y=" + y + " z=" + z
                         + " a=" + a + " b=" + b + " c=" + c
                         + " values_seen=" + values_seen);
          }
          return InvariantStatus.FALSIFIED;
        }
      }
    }
    return InvariantStatus.NO_CHANGE;
  }

  /**
   *  Calculates new coefficients that for the new point.  Uses the
   *  new coefficients if they are relatively close to to the previous
   *  ones.  Kills off the invariant if they are not.
   *
   *  @return true if the new equation worked, false otherwise.
   */

  public boolean try_new_equation (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {

    // Calculate max separation using this point and the existing 3 points.
    def_points[3] = new Point (x, y, z);
    double sep = maxsep_triples (def_points);

    // If this point increased the separation, recalculate a, b, and c.
    if (sep > separation) {
      separation = sep;
      double coef[];
      try {
        coef = calc_tri_linear (def_points);
        if (Debug.logDetail())
          wrapper.log ("Calc new plane with points " + def_points[0] + " " +
                       def_points[1] + " " + def_points[2] + " " +
                       def_points[3]);
      } catch (Exception e) {
        return (false);
      }

      // if the a, b, or c is a new min/max remember it.
      if (coef[0] < min_a) min_a = coef[0];
      if (coef[0] > max_a) max_a = coef[0];
      if (coef[1] < min_b) min_b = coef[1];
      if (coef[1] > max_b) max_b = coef[1];
      if (coef[2] < min_c) min_c = coef[2];
      if (coef[2] > max_c) max_c = coef[2];
      if (coef[3] < min_d) min_d = coef[3];
      if (coef[3] > max_d) max_d = coef[3];

      // Pick a new a, b, and c as the average of their endpoints
      a = (min_a + max_a) / 2;
      b = (min_b + max_b) / 2;
      c = (min_c + max_c) / 2;
      d = (min_d + max_d) / 2;
      if (wrapper.logOn() || debug.isLoggable(Level.FINE))
        wrapper.log (debug, wrapper.ppt.name() + ": Trying new a (" + a +
                    "), b (" + b + "), c (" + c + "), and d (" + d + ")");

      // if the new coefficients are 'equal' to their min and max and
      // this point fits, then this new equation is good enough both
      // for existing points and the new point.
      if (Global.fuzzy.eq(a, min_a) && Global.fuzzy.eq(a, max_a) &&
          Global.fuzzy.eq(b, min_b) && Global.fuzzy.eq(b, max_b) &&
          Global.fuzzy.eq(c, min_c) && Global.fuzzy.eq(c, max_c) &&
          Global.fuzzy.eq(d, min_d) && Global.fuzzy.eq(d, max_d) &&
          EQUAL (-c*z, a*x+b*y+d)) {
        if (debug.isLoggable(Level.FINE))
          debug.fine (wrapper.ppt.name() + ": New a (" + a + ") and b ("
                       + b + ") and c (" + c + ")");
        return (true);
      } else {
        return (false);
      }
    } else { // this point doesn't increase the separation

      return (false);
    }
  }


  /**
   * Calculates the square of the separation between p1 and p2
   *
   * @param p1  First point
   * @param p2  Second point
   *
   * @return square of the distance between p1 and p2
   */
  double separation(Point p1, Point p2) {
    #if defined(TYPELONG)
      // These variable Types are double so the values won't wrap around.
    #elif defined(TYPEDOUBLE)
      // Potential problem:  This may return 0, for two reasons.  First, x1-x2
      // might be zero due to underflow, even if x1!=x2.  Second, squaring a
      // small x1-x2 might result in 0, even if x1-x2!=0.
    #endif

    // make sure both points are specified
    if ((p1 == null) || (p2 == null)) {
      return (0);
    }

    double xsep = (p1.x - p2.x);
    double ysep = (p1.y - p2.y);
    double zsep = (p1.z - p2.z);
    return xsep*xsep + ysep*ysep + zsep*zsep;
  }

  /**
   * Calculates the three points that have the maximum separation in pa and
   * places them as the first three elements of pa.
   *
   * @param pa  Array of points.  Must have at least 3 elements.  Can be any
   *            length and can contain nulls (which will be ignored).
   *            Is side-effected so that the first three elements contain the
   *            points with the maximum total separation; this may introduce
   *            duplicates into the array.
   *
   * @return the maximum separation found.
   */
  double maxsep_triples (Point[] pa) {

    Point p1 = null, p2 = null, p3 = null;

    // cache values for the (square of the) distance between each pair of
    // points, to avoid duplicating work
    double[][] separations = new double[pa.length][pa.length];
    for (int i=0; i<pa.length-1; i++) {
      for (int j=i+1; j<pa.length; j++) {
        separations[i][j] = separation(pa[i], pa[j]);
      }
    }

    // max_separation is the separation metric for the most separated
    // triple of points.  We use the sum of the separations as the
    // metric.  (The metric "min of the three separations" does not work
    // because it doesn't choose a unique set of points, making the
    // result dependent on the order in which the points are seen; more
    // seriously, it may choose a collinear set of points even when a
    // non-collinear set exists.)
    double max_separation = Double.MIN_VALUE;

    for (int i=0; i < pa.length-2; i++) {
      for (int j=i+1; j < pa.length-1; j++) {
        double sep_i_j = separations[i][j];
        for (int k = j+1; k < pa.length; k++) {
          double separation = sep_i_j + separations[i][k] + separations[j][k];
          if (separation > max_separation) {
            max_separation = separation;
            p1 = pa[i];
            p2 = pa[j];
            p3 = pa[k];
          }
        }
      }
    }

    pa[0] = p1;
    pa[1] = p2;
    pa[2] = p3;

    if (Debug.logDetail())
      wrapper.log ("maxsep_triples = " + pa[0] + " " + pa[1] + " " + pa[2]);
    return (max_separation);
  }


  // Given ((x0,y0,z0),(x1,y1,z1)), calculate a, b, and c
  // such that ax + by + cz + d = 0.
  //
  // if no such (a, b, c) exists, it will throw an exception, otherwise
  // an array of doubles will be returned with 3 elements (a, b, c).
  //
  // Given a set of equations
  //    z0 = a x0 + b y0 + c
  //    z1 = a x1 + b y1 + c
  //    z2 = a x2 + b y2 + c
  // where (x, y, z) are known and we are solving for (a, b, c):
  //      | z0 y0 1 |
  //      | z1 y1 1 |
  //      | z2 y2 1 |
  // a = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //
  //      | x0 z0 1 |
  //      | x1 z1 1 |
  //      | x2 z2 1 |
  // b = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //
  //      | x0 y0 z0 |
  //      | x1 y1 z1 |
  //      | x2 y2 z2 |
  // c = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //

  /**
   * Calculates the coefficients for the equation ax + by + cz + d = 0 for the
   * first three points in points.
   *
   * @param points  array of points to use to calculate the coefficents.  Only
   *                the first three points are used
   *
   * @return a three element array where a is the first element, b the second,
   * and c the third.
   */
  public double[] calc_tri_linear(Point[] points) throws ArithmeticException {

    Point p0 = points[0];
    Point p1 = points[1];
    Point p2 = points[2];

    float denominator = (float) ((p1.x * p2.y - p2.x * p1.y)
                       - (p0.x * p2.y - p2.x * p0.y)
                       + (p0.x * p1.y - p1.x * p0.y));
    if (denominator == 0)
      throw new ArithmeticException();
    double a_numerator = (double) ((p1.z * p2.y - p2.z * p1.y)
                                - (p0.z * p2.y - p2.z * p0.y)
                                + (p0.z * p1.y - p1.z * p0.y));
    double b_numerator = (double) ((p1.x * p2.z - p2.x * p1.z)
                                - (p0.x * p2.z - p2.x * p0.z)
                                + (p0.x * p1.z - p1.x * p0.z));
    double c_numerator = (double) (p0.z * (p1.x * p2.y - p2.x * p1.y)
                                - p1.z * (p0.x * p2.y - p2.x * p0.y)
                                + p2.z * (p0.x * p1.y - p1.x * p0.y));
    double[] coef = new double[] { a_numerator / denominator,
                                  b_numerator / denominator,
                                  -1, c_numerator / denominator };
    return (coef);
  }



// The old (Python) code that computed a, b, and c looked like this:
//     (x1, y1, z1) = triple1
//     (x2, y2, z2) = triple2
//     (x3, y3, z3) = triple3
//     # Possibly reorder the triples to avoid division-by-zero problems.
//     if (y2 == y3) or (x2 == x3):
//         return (0,0,0)
//     try:
//         y1323 = float(y1-y3)/(y2-y3)
//         a_numerator = z3-z1+(z2-z3)*y1323
//         a_denominator = x3-x1+(x2-x3)*y1323
//
//         x1323 = float(x1-x3)/(x2-x3)
//         b_numerator = z3-z1+(z2-z3)*x1323
//         b_denominator = y3-y1+(y2-y3)*x1323
//     except OverflowError:
//         return (0,0,0)
//     if (a_denominator == 0) or (b_denominator == 0):
//         return (0,0,0)
//     a = a_numerator/a_denominator
//     b = b_numerator/b_denominator
//     c = z3-a*x3-b*y3



  public boolean enoughSamples() {
    return values_seen >= MINTRIPLES;
  }

  public double computeConfidence() {
    return Invariant.conf_is_ge(values_seen, MINTRIPLES);
  }

  public String repr() {
    return CLASSSTRING + wrapper.varNames() + ": "
      + "a=" + a
      + ",b=" + b
      + ",c=" + c
      + ",d=" + d
      + ",values_seen=" + values_seen;
  }

  public String point_repr(Point p) {
    if (p == null)
      return "null";
    else
      return "<" + p.x + "," + p.y + "," + p.z + ">";
  }

  public String cache_repr() {
    StringBuffer result = new StringBuffer();
    for (int i=0; i<MINTRIPLES; i++) {
      if (i!=0) result.append("; ");
      result.append(point_repr(def_points[i]));
    }
    return result.toString();
  }

  // In this class for convenience (avoid prefixing "LinearBinaryCore").
  static String formatTerm(OutputFormat format, double coeff, VarInfoName var, VarInfo vi, boolean first) {
    return LinearBinaryCore.formatTerm(format, coeff, var, vi, first);
  }

  public String format_using(OutputFormat format,
                             VarInfoName x, VarInfo xvi,
                             VarInfoName y, VarInfo yvi,
                             VarInfoName z, VarInfo zvi,
                             double a, double b, double c, double d)
  {
    if ((a == 0) && (b == 0) && (c == 0) && (d == 0)) {
      return wrapper.format_too_few_samples(format, null);
    }

    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify(x, y, z, a, b, c, d);
    }

    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.ESCJAVA)
        || (format == OutputFormat.IOA)
        || (format.isJavaFamily()))
    {
      String eq = " == ";
      if (format == OutputFormat.IOA) eq = " = ";

      return formatTerm(format, a, x, xvi, true)
        + formatTerm(format, b, y, yvi, (a == 0))
        + formatTerm(format, c, z, zvi, (a == 0) && (b == 0))
        + formatTerm(format, d, null, null, (a == 0) && (b == 0) && (c == 0))
        + eq + "0";
    }

    return null;
  }

  public static String format_simplify(VarInfoName x, VarInfoName y, VarInfoName z,
                                       double da, double db, double dc, double dd) {
    int ia = (int) da;
    int ib = (int) db;
    int ic = (int) dc;
    int id = (int) dd;

    String str_a, str_b, str_c, str_d;
    if (ia != da || ib != db || ic != dc || id != dd) {
      // floating point

      // Disabled for the moment, since mixing integers and floating
      // literals seems to give Simplify indigestion. For instance:
      // (BG_PUSH (<= w 3))
      // (BG_PUSH (EQ 0 (* w 2.0d0)))
      // (<= w 1)

//       str_a = Invariant.simplify_format_double(da);
//       str_b = Invariant.simplify_format_double(db);
//       str_c = Invariant.simplify_format_double(dc);
//       str_d = Invariant.simplify_format_double(dd);
      return "(AND)"; // really s/b format_unimplemented
    } else {
      // integer
      str_a = Invariant.simplify_format_long(ia);
      str_b = Invariant.simplify_format_long(ib);
      str_c = Invariant.simplify_format_long(ic);
      str_d = Invariant.simplify_format_long(id);
    }

    // ax + by + cz + d = 0
    String str_z = z.simplify_name();
    String str_x = x.simplify_name();
    String str_y = y.simplify_name();
    String str_ax = (da == 1.0) ? str_x : "(* " + str_a + " " + str_x + ")";
    String str_by = (db == 1.0) ? str_y : "(* " + str_b + " " + str_y + ")";
    String str_cz = (dc == 1.0) ? str_z : "(* " + str_c + " " + str_z + ")";
    String str_axPbyPcz = "(+ " + str_ax + " " + str_by + " " + str_cz + ")";
    String str_axPbyPczPd = (dd == 0.0) ? str_axPbyPcz :
      "(+ " + str_axPbyPcz + " " + str_d + ")";
    return "(EQ 0 " + str_axPbyPczPd + ")";
  }

  public String format_using(OutputFormat format,
                             VarInfoName x, VarInfo xvi,
                             VarInfoName y, VarInfo yvi,
                             VarInfoName z, VarInfo zvi)
  {
    String result = format_using(format, x, xvi, y, yvi, z, zvi, a, b, c, d);
    if (result != null) {
      return result;
    }

    return wrapper.format_unimplemented(format);
  }


  // // Format as "x = cy+d" instead of as "y = ax+b".
  // public String format_reversed(String x, String y) {
  //   Assert.assertTrue(a == 1 || a == -1);
  //   return format(y, x, a, -b/a);
  // }

  public boolean isSameFormula(CLASSNAME other)
  {
    boolean inactive_can_match = true;

    // If we are matching up those that have not seen enough values yet
    if (inactive_can_match) {

      // If both have yet to see enough valus
      if ((values_seen < MINTRIPLES) && (other.values_seen < MINTRIPLES)) {

        // Same formula if all of the points match
        if (values_seen != other.values_seen)
          return (false);
        for (int ii = 0; ii < values_seen; ii++) {
          if (def_points[ii] != other.def_points[ii])
            return (false);
        }
        return (true);

      } else {
        return ((values_seen >= MINTRIPLES)
                && (other.values_seen >= MINTRIPLES)
                && (a == other.a)
                && (b == other.b)
                && (c == other.c)
                && (d == other.d));
      }
    } else {

      boolean thisMeaningless =
        values_seen < MINTRIPLES ||
        (a == 0 && b == 0 && c == 0 && d == 0) ||
        Math.abs(a) >= Double.MAX_VALUE ||
        Math.abs(b) >= Double.MAX_VALUE ||
        Math.abs(c) >= Double.MAX_VALUE ||
        Math.abs(d) >= Double.MAX_VALUE
        ;
      boolean otherMeaningless =
        other.values_seen < MINTRIPLES ||
        (other.a == 0 && other.b == 0 && other.c == 0 || other.d == 0) ||
        Math.abs(other.a) >= Double.MAX_VALUE ||
        Math.abs(other.b) >= Double.MAX_VALUE ||
        Math.abs(other.c) >= Double.MAX_VALUE ||
        Math.abs(other.d) >= Double.MAX_VALUE
        ;

      if (thisMeaningless && otherMeaningless) {
        return true;
      } else {
        return ((values_seen >= MINTRIPLES)
                && (other.values_seen >= MINTRIPLES)
                && (a == other.a)
                && (b == other.b)
                && (c == other.c)
                && (d == other.d));
      }
    }
  }

  public boolean isExclusiveFormula(CLASSNAME other)
  {
    if ((values_seen < MINTRIPLES) ||
        (other.values_seen < MINTRIPLES)) {
      return false;
    }

    return ((a == other.a)
            && (b != other.b)
            && (c != other.c)
            && (d != other.d));
  }


  /**
   * In general, we can't merge formulas, but we can merge invariants with
   * too few samples to have formed a plane with invariants with enough
   * samples.  And those will appear to have different formulas.
   */
  public boolean mergeFormulasOk() {
    return (true);
  }

  /**
   * Merge the linear ternary cores in cores to form a new core. Any
   * core in the list that has seen enough points to define a
   * plane, must define the same plane. Any cores that have not
   * yet seen enough points, will have each of their points applied to
   * that invariant.  The merged core is returned.  Null is
   * returned if the cores don't describe the same plane
   *
   * @param cores   List of LinearTernary cores to merge.  They should
   *                all be permuted to match the variable order in
   *                ppt.
   */
  public CLASSNAME merge (List cores, Invariant wrapper) {

    // Look for any active planes.  All must define the same plane
    CLASSNAME first = null;
    for (int i = 0; i < cores.size(); i++) {
      CLASSNAME c = (CLASSNAME) cores.get (i);
      if (!c.isActive())
        continue;
      if (first == null)
        first = (CLASSNAME) c.clone();
      else {
        if (!Global.fuzzy.eq (first.a, c.a)
            || !Global.fuzzy.eq (first.b, c.b)
            || !Global.fuzzy.eq (first.c, c.c)
            || !Global.fuzzy.eq (first.d, c.d))
          return (null);
      }
    }

    // If no active planes were found, created an empty core
    if (first == null)
      first = new CLASSNAME (wrapper);
    else
      first.wrapper = wrapper;

    // Merge in any points from non-active cores
    for (int i = 0; i < cores.size(); i++) {
      CLASSNAME c = (CLASSNAME) cores.get (i);
      if (c.isActive())
        continue;
      for (int j = 0; j < c.values_seen; j++) {
        Point cp = c.def_points[j];
        if (Debug.logDetail())
          wrapper.log ("Adding point " + cp + " from " + c.wrapper.ppt);
        first.add_modified (cp.x, cp.y, cp.z, 1);
        if (wrapper.is_false())
          return (null);
      }
    }

    return (first);
  }



}
