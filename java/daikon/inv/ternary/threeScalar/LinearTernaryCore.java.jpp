#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "Either TYPELONG or TYPEDOUBLE must be defined"
#endif

#if (defined(TYPELONG))
  #define CLASSNAME LinearTernaryCore
  #define PRIMITIVE long
  #define LINEAR_BINARY LinearBinary
  #define ONEOF OneOfScalar
  #define CLASSSTRING "LinearTernaryCore"
  #if 0
  // #define EQUAL(a,b) ((a) == (b))
  #endif
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
  #define GET_VAL(a) (((Long)a).longValue())
#elif (defined(TYPEDOUBLE))
  #define CLASSNAME LinearTernaryCoreFloat
  #define PRIMITIVE double
  #define LINEAR_BINARY LinearBinaryFloat
  #define ONEOF OneOfFloat
  #define CLASSSTRING "LinearTernaryCoreFloat"
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
  #define GET_VAL(a) (((Double)a).doubleValue())
#else
  #error "Either TYPELONG or TYPEDOUBLE must be defined"
#endif

// ***** This file is automatically generated from LinearTernaryCore.java.jpp

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.unary.scalar.*;
import utilMDE.*;
import java.io.Serializable;

import java.util.*;
import java.util.logging.Logger;
import java.util.logging.Level;


public final class CLASSNAME
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  /** Debug tracer. **/
  static final Logger debug = Logger.getLogger("daikon.inv.ternary.threeScalar." + CLASSSTRING);

  // ax + by + cz + d = 0; first argument is x, second is y, third is z
  public double a = 0, b = 0, c = 0, d = 0;
  public double min_a, max_a, min_b, max_b, min_c, max_c, min_d, max_d;
  public double separation = 0;

  //indcates whether a line exists in the 3D space instead of a plane (-1 means no line exists)
  //determines which values in constants is valid; see calc_bi_linear()
  public int line_flag = -1;

  //constants and coefficients for a line in 3D space
  public double[] constants = new double[4];

  // Inner class to store points in for more convenient access.
  public static class Point implements Serializable, Cloneable {
    public PRIMITIVE x;
    public PRIMITIVE y;
    public PRIMITIVE z;
    public Point () {
      this (0, 0, 0);
    }
    public Point (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {
      this.x = x; this.y = y; this.z = z;
    }
    public boolean equals (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {
      return ((this.x == x) && (this.y == y) && (this.z == z));
    }
    protected Object clone() throws CloneNotSupportedException {
      return super.clone();
    }
    public String toString() {
      return ("(" + x + ", " + y + " ," + z + ")");
    }
  }


  // Points that define the plane.  The first three are normally the
  // current definition.  The next is a new point for consideration.
  // However, any slot may be set to null at any time, and points may be
  // duplicated at any time.
  public Point[] def_points = new Point[MINTRIPLES];

  public Invariant wrapper;

  // The number of distinct values (not samples) seen.
  public int values_seen = 0;

  static final int MINTRIPLES = 5;

  public CLASSNAME(Invariant wrapper) {
    this.wrapper = wrapper;
  }

  public Object clone() {
    try {
      CLASSNAME result = (CLASSNAME) super.clone();
      result.def_points = new Point[MINTRIPLES];
      for (int i=0; i<MINTRIPLES; i++) {
        Point p = def_points[i];
        if (p != null) {
          result.def_points[i] = (Point) p.clone();
        }
      }
      return result;
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  /**
   * Reorganize our already-seen state as if the variables had shifted
   * order underneath us (rearrangement given by the permutation).
   **/
  public void permute(int[] permutation) {
    Assert.assertTrue(permutation.length == 3);
    Assert.assertTrue(ArraysMDE.fn_is_permutation(permutation));
    // Fix a, b, c
    double[] clever = new double[] { a, b, c };
    double[] pclever = new double[3];
    pclever[permutation[0]] = clever[0];
    pclever[permutation[1]] = clever[1];
    pclever[permutation[2]] = clever[2];
    if (isActive()) {
      // Seen enough values, so permuting a, b, c is useful
       if (a == 0 || b == 0 || c == 0) {
        // Can't handle this form once rotated.  But if we've seen
        // enough values, yet a or b is zero, then this is covered by
        // a LinearBinary or a constant, so let me just destroy myself.
        values_seen = Integer.MAX_VALUE;
        a = b = c = d = 0;
        if (debug.isLoggable(Level.FINE)) {
          debug.fine ("  Ternary invariant destroyed because a, b, or c = 0");
        }
        return;
      } else {
        // double d = -1.0 / pclever[2];
        a = pclever[0];
        b = pclever[1];
        c = pclever[2];

        // We need to force C to always be -1 (as it is originally calculated)
        // so that we always get the same equation
        // now that we do not guarantee C to be -1; the following is not
        // necessary, right? CX 8/9/04
        
       // double div = c / -1.0;
       // a = a / div;
       // b = b / div;
       // c = c / div;
       // d = d / div;
      }
    }

    // Fix caches
    {
      PRIMITIVE[] temp = new PRIMITIVE[3];
      for (int i=0; i<MINTRIPLES; i++) {
        Point p = def_points[i];
        if (p == null)
          continue;
        wrapper.log ("orig def_points["+i+"] = " + p);
        temp[permutation[0]] = p.x;
        temp[permutation[1]] = p.y;
        temp[permutation[2]] = p.z;
        p.x = temp[0];
        p.y = temp[1];
        p.z = temp[2];
        wrapper.log ("permuted def_points["+i+"] = " + p);
      }
    }
    // Assert that caches sync with a,b,c?
    // This would be a good sanity check, but it would be nontrivial
    // because we don't keep track of when a, b, and c are really
    // valid for all the of the points we've cached. If we were
    // falsified and then resurrected, we might have samples that
    // didn't fit even before the permutation. -smcc
  }

 
   
  /**
   * Returns whether or not the invariant is currently active.  We become
   * active after MINTRIPLES values have been seen and a line is not calculated.
   * Before that, a, b, and c are uninitialized
   */
   // this is the check used throughout the file as a shortcut because 
   // the invariant must have seen enough samples and not be a line for all the
   // other calculations and comparisons done to be sensible
  public boolean isActive() {
   return (line_flag == -1 && values_seen >= MINTRIPLES);
  }

  /**
   * LinearTernary can't be flowed because it keeps samples to build the
   * plane.  These sample can't be flowed from ppt to ppt (since they probably
   * didn't occur at the lower ppt).
   */
  public boolean isFlowable() {
    return (false);
  }

  /**
   * Sets up the invariant from a LinearBinary invariant and a constant
   * value for the third variable.  Points are taken from the LinearBinary
   * cache and its min_x/y and max_x/y points and combined with the
   * constant value.
   *
   * @return InvariantStatus.NO_CHANGE if the invariant is valid,
   * InvariantStatus.FALSIFIED if one of the points invalidated the
   * LinearTernary invariant
   */
  public InvariantStatus setup (LINEAR_BINARY lb, VarInfo con_var,
                                PRIMITIVE con_val) {

    if (Debug.logOn())
      wrapper.log ("setup from lb " + lb + " con var " + con_var +
                   " con_val " + con_val);

    int con_index = con_var.varinfo_index;
    int lb_v1_index = lb.ppt.var_infos[0].varinfo_index;
    int lb_v2_index = lb.ppt.var_infos[1].varinfo_index;

    PRIMITIVE[] con_vals = new PRIMITIVE [lb.core.values_seen+2];
    PRIMITIVE[] lb1_vals = new PRIMITIVE [lb.core.values_seen+2];
    PRIMITIVE[] lb2_vals = new PRIMITIVE [lb.core.values_seen+2];

    int mi = lb.core.values_seen;
    for (int i = 0; i < mi; i++) {
      con_vals[i] = con_val;
      lb1_vals[i] = lb.core.x_cache[i];
      lb2_vals[i] = lb.core.y_cache[i];
    }
    if (lb.isActive()) {
      con_vals[mi] = con_val;
      lb1_vals[mi] = lb.core.min_x;
      lb2_vals[mi] = lb.core.min_y;
      con_vals[mi+1] = con_val;
      lb1_vals[mi+1] = lb.core.max_x;
      lb2_vals[mi+1] = lb.core.max_y;
      mi += 2;
    }

    InvariantStatus sts = InvariantStatus.NO_CHANGE;


    for (int i = 0; i < mi; i++ ) {
      if (con_index < lb_v1_index) {
        sts = add_modified (con_vals[i], lb1_vals[i], lb2_vals[i], 1);

      } else if (con_index < lb_v2_index) {
        sts = add_modified (lb1_vals[i], con_vals[i], lb2_vals[i], 1);

      } else {
        sts = add_modified (lb1_vals[i], lb2_vals[i], con_vals[i], 1);

      }
      if (sts != InvariantStatus.NO_CHANGE)
        break;
    }

    if (sts != InvariantStatus.NO_CHANGE) {
      Fmt.pf ("lb.core.values_seen=" + lb.core.values_seen);
      for (int i = 0; i < mi; i++ )
        Fmt.pf ("LTCore: vals %s %s %s", "" + con_vals[i], "" + lb1_vals[i],
                "" + lb2_vals[i]);
      Fmt.pf ("in inv " + wrapper.format() + " " + wrapper.ppt);
      Assert.assertTrue (sts == InvariantStatus.NO_CHANGE);
    }


    return (sts);
  }

  /**
   * Sets up the invariant from a OneOf and a two constants.
   * Points are taken from the OneOf cache and the constant values.
   *
   * @return InvariantStatus.NO_CHANGE if the invariant is valid, or
   * InvariantStatus.FALSIFIED if one of the points invalidated the
   * LinearTernary invariant
   */
   
  public InvariantStatus setup (ONEOF oo, VarInfo v1, PRIMITIVE con1,
                                VarInfo v2, PRIMITIVE con2) {

    int oo_index = oo.ppt.var_infos[0].varinfo_index;
    int con1_index = v1.varinfo_index;
    int con2_index = v2.varinfo_index;

    InvariantStatus sts = InvariantStatus.NO_CHANGE;
    for (int i = 0; i < oo.num_elts(); i++ ) {
      if (oo_index < con1_index) {
        sts = add_modified (GET_VAL(oo.elt(i)), con1, con2, 1);
      } else if (oo_index < con2_index) {
        sts = add_modified (con1, GET_VAL(oo.elt(i)), con2, 1);
    } else
        sts = add_modified (con1, con2, GET_VAL(oo.elt(i)), 1);
      if (sts != InvariantStatus.NO_CHANGE)
        break;
    }

    if (Debug.logOn())
      wrapper.log ("setup from OneOf " +  oo + " v1=" + con1 +
                   " v2=" + con2 + " status = " + sts);

    return (sts);
  }


  /**
   * Looks for points that define a plane (ax + by + cz + d = 0).  Collects
   * MINTRIPLE points before attempting to define a line through the points.
   * Once the equation for the line is found, each subsequent point is compared to
   * it.  If the point does not match, recalculates the maximally separated points
   * and attempts to fit the points to the new line.
   * If the points do not fit the line, attempts to define the plane (to
   * hopefully get at least some spread between the points, so that
   * small errors don't get magnified).  Once the equation for the
   * plane is found, each subsequent point is compared to it.  If the
   * point does not match the point is examined to see if it would is
   * maximally separated when compared to the points originally used
   * to define the plane.  If it is, it is used to recalcalulate the
   * coefficients (a, b, c).  If those coefficients are relatively close
   * to the original coefficients (within the ratio defined by Global.fuzzy)
   * then the new coefficients are used.
   *
   * @see FuzzyFloat
   */
  public InvariantStatus add_modified(PRIMITIVE x, PRIMITIVE y, PRIMITIVE z, int count) {
    // XXX TODO FIXME: This method does not correctly deal with
    // calling addToFlow.  A proper clone, etc. should be created and
    // dealt with.  This will complicate the logic below, I'll bet.

   if (Debug.logDetail())
      wrapper.log ("Adding point, x=" + x + " y=" + y + " z=" + z + " to invariant");

    if (values_seen < MINTRIPLES) {
      // We delay computation of a and b until we have seen several triples
      // so that we can compute a and b based on a far-separated triple.  If
      // the points in a triple are nearby, then roundoff errors in the
      // computation of the slope can be non-negligible.

      // skip points we've already seen
      for (int i = 0; i < values_seen; i++) 
        if (def_points[i].equals (x, y, z)) 
          return InvariantStatus.NO_CHANGE;
				
      def_points[values_seen] = new Point (x, y, z);
     
      values_seen++;
      
      // if we've seen enough values to create the equation
      if (values_seen == MINTRIPLES) {

		//try to fit the points to a line first
		linearIntervention(def_points);

		//if line can not be formed, try to form a plane
		if(line_flag == -1) {
		InvariantStatus stat = planarIntervention(def_points);
    	return stat;
      	
      	} else {
      	
      	// points fit in a line
      	return InvariantStatus.NO_CHANGE;
      	}
      } else  {
      
      // still haven't still enough values
      return InvariantStatus.NO_CHANGE;
    	}
    } else {

	//at this point either a line or a plane must have been formed
		
	
	// if line already broken, fit to plane equation			
    if(line_flag == -1) {
      // If the new value doesn't fit the equation
      if (!EQUAL (-c*z, a*x+b*y+d)) {

        // Try to find small changes that will fit better.
        if (!try_new_equation (x, y, z)) {
          if (wrapper.logOn() || debug.isLoggable(Level.FINE)) {
            wrapper.log (debug, "destroying  (" + wrapper.format()
                  + ") where x=" + x + " y=" + y + " z=" + z
                         + " a=" + a + " b=" + b + " c=" + c
                         + " values_seen=" + values_seen);
          }
          // jiggling the values did not work
          return InvariantStatus.FALSIFIED;
        }
      } else {
      
      // point fits the current plane equation
      return InvariantStatus.NO_CHANGE;
      }
    } else {
    	
    	// try to fit to the current line 		
    	if(!try_points(x, y, z)) {
    		//put the crucial point in, so that it can be tested against the new line
    		def_points[MINTRIPLES-1] = new Point (x, y, z);
    		
    		// try to fit the points onto a line again (not sure if this
    		// is really necessary, maybe the fuzzy equals really does
    		// make a difference)
    		linearIntervention(def_points);
    	}
		
		// new point has broken the line, try to fit to a plane
    	if(line_flag == -1) {
    	InvariantStatus stat = planarIntervention(def_points);
    	return stat;
    	} else {
    		
    		// fuzzy equals does make a difference
    		return InvariantStatus.NO_CHANGE;
    	}

    	}

    }
    //should never get here because values_seen is either < or >= MINTRIPLES
    return InvariantStatus.NO_CHANGE;
  }
	
 /**
   * Attempts to fit the points in def_point to a plane and calculates the
   * coefficients (a, b, c, d) if possible.  
   *
   * @param def_point  Array of points.  Must have at least 3 elements.  
   * 
   * @return the status of the invariant 
   *		 (whether the plane fitting was successful)
   */
	private InvariantStatus planarIntervention(Point[] def_point) {
	
	// Find the three points with the maximum separation
        maxsep_triples (def_point);
        if (def_point[0] == null) {
        	// this should never be the problem since we check for a line
        	// first
          return InvariantStatus.FALSIFIED;
        } else {

		wrapper.log("Definitive point1: " + def_point[0]);
		wrapper.log("Definitive point2: " + def_point[1]);
		wrapper.log("Definitive point3: " + def_point[2]);
		}
		
        // calculate the coefficients of the equation (a, b, c, d)
        double[] coef = calc_tri_linear (def_point);
     
        a = coef[0];
        b = coef[1];
        c = coef[2];
        d = coef[3];

        // If one of these coefficients is zero (except for d), this should be a
        // LinearBinary, not a LinearTernary, term.  (It might not show up
        // as LinearBinary because there might not have been enough samples;
        // but a random varying third variable can create enough samples.)
        // Also, throw out the invariant if any of the coefficients would
        // be infinite or not-a-number.
        if ((a == 0) || (b == 0) || (c == 0) ||
            (Math.abs(a) >= Double.MAX_VALUE) ||
            (Math.abs(b) >= Double.MAX_VALUE) ||
            (Math.abs(c) >= Double.MAX_VALUE) ||
            Double.isNaN(a) || Double.isNaN(b) || Double.isNaN(c)) {

			wrapper.log("problematic coefficient: invariant falsified");
          return InvariantStatus.FALSIFIED;
        }

        // Check all values against a, b, and c.
        if (!wrapper.is_false()) {
          for (int i=0; i<values_seen; i++) { 
            // Global.fuzzy.eq works by comparing ratios between numbers,
            // so comparing the sum of everything to 0 won't work.
            if (!EQUAL (-c * def_point[i].z,
                        a*def_point[i].x + b*def_point[i].y + d)) {
              if (Debug.logOn() || debug.isLoggable(Level.FINE)) {
                wrapper.log (debug, "Destroying at index " + i + ": "
                            + "0 != "
                            + a + "*" + def_point[i].x
                            + "+" + b + "*" + def_point[i].y + "+" + c
                            + "*" + def_point[i].z
                            + "+" + d);
              }

              return InvariantStatus.FALSIFIED;
            }
          }
          if (Debug.logOn())
            wrapper.log ("equation = " + a + "*x " + b + "*y" + c + "*z = "
                          + (-d));

          // Discard the points not used to define the coefficients.
          for (int ii = 3; ii < MINTRIPLES; ii++)
            def_point[ii] = null;

          // check to see if this already exists at the global ppt, it it
          // does, falsify it here to eliminate the duplicate copy.  This
          // is not the best place to do this, but easy for now
          PptSlice gslice = wrapper.ppt.find_global_slice
                                                    (wrapper.ppt.var_infos);
          if (gslice != null) {
            if (gslice.contains_inv_exact (wrapper)) {
              if (Debug.logOn())
                wrapper.log ("Matched at global");
              return InvariantStatus.FALSIFIED;
            }
          }

        }
	
		//if it passes all the checks, then no change to the Invariant
		return InvariantStatus.NO_CHANGE;
	}

	
 /**
   * Attempts to fit the points in def_point to a line and calculates the
   * the corresponding line classification (line_flag) and constants 
   * (constants[]) if possible.  If not (points in def_point form a plane)
   * resets line_flag to -1 and constants[] elements to -999.
   *
   * @param def_point  Array of points.  Must have at least 2 elements.  
   *
   */
   private void linearIntervention(Point[] def_point) {

	
	// make a copy of the array so that the points don't get clobbered because 
	// if a line fails to form; the calc_tri_linear code will need an 
	// unmodified copy of def_point
	
		Point[] dummy = new Point[def_point.length];
		for (int i = 0; i < def_point.length; i++)
			dummy[i] = def_point[i];
			
		// find the max separation points		
		maxsep_doubles(dummy);

		//dummy[0] could be null when all the points are NaN
		if(dummy[0] != null) {
		//find the equation (constants and coeffs now stored in constants[])
		calc_bi_linear(dummy);
		
		
		//check the other points against the constants and coefficients
		for(int i = 0; i < def_point.length; i++) {
			//try to fit the current point to the current line
			boolean ok = try_points(def_point[i].x, def_point[i].y, def_point[i].z);
			
			if(!ok) {
			
			line_flag = -1;
			for(int j = 0; j < constants.length; j++)
				constants[j] = -999;		//reset constants array
			break;
			}
		}
		}
	}


	
 /**
   * Attempts to fit the new point (x,y,z) onto the current line 
   * (indicated by line_flag and constants[]).  Method should only be called
   * if the current points define a line (line_flag is not -1)
   *
   * @param x,y,z  x,y,z components of the point.    
   *
   */
	private boolean try_points(double x, double y, double z) {

	 switch (line_flag) {
	 case 0:
	 		if(!EQUAL(constants[0], x) || !EQUAL(constants[1], y)) {
	 			return false;
	 		} else
	 			return true;
	 case 1:
	 		if(!EQUAL(constants[0], x) || !EQUAL(constants[1], z)){
	 			return false;
	 		} else
	 			return true;
	 case 2:
	 		if(!EQUAL(constants[0], y) || !EQUAL(constants[1], z)) {
	 			return false;
	 		} else
	 			return true;
	 case 3:
	 		if(!EQUAL(constants[0], x) || !EQUAL(z, constants[1] * y + constants[2])) {
	 			return false;
	 		} else
	 			return true;
	 case 4:
	 		if(!EQUAL(constants[0], y) || !EQUAL(z, constants[1] * x + constants[2])) {
	 			return false;
	 		} else
	 			return true;
	 case 5:
	 		if(!EQUAL(constants[0], z) || !EQUAL(y, constants[1] * x + constants[2])) {
	 			return false;
	 		} else
	 			return true;
	 case 6:
           if(!EQUAL(y, constants[0] * x + constants[1]) || !EQUAL(z, constants[2] * x + constants[3])) {
	 			return false;
	 		} else
	 			return true;
        }

        //if it gets here; line_flag must be -1
	 	return false;
	}

 /**
   * Calculates the two points that have the maximum separation in pa and
   * places them as the first two elements of pa.
   *
   * @param ps  Array of points.  Must have at least 2 elements.  Can be any
   *            length and can contain nulls (which will be ignored).
   *            Is side-effected so that the first two elements contain the
   *            points with the maximum total separation; this may introduce
   *            duplicates into the array.
   *
   * @return the maximum separation found.
   */
    private double maxsep_doubles (Point[] pa) {

    Point p1 = null, p2 = null;

    // cache values for the (square of the) distance between each pair of
    // points, to avoid duplicating work
    double[][] separations = new double[pa.length][pa.length];
    for (int i=0; i<pa.length-1; i++) {
      for (int j=i+1; j<pa.length; j++) {
        separations[i][j] = separation(pa[i], pa[j]);
      }
    }

    // max_separation is the separation metric for the most separated
    // pair of points.  We use the sum of the separations as the
    // metric.
    double max_separation = Double.MIN_VALUE;

    for (int i=0; i < pa.length-2; i++) {
      for (int j=i+1; j < pa.length-1; j++) {
          double separation = separations[i][j];
          if (separation > max_separation) {
            max_separation = separation;
            p1 = pa[i];
            p2 = pa[j];

          }
        }
      }

    pa[0] = p1;
    pa[1] = p2;


    if (Debug.logDetail())
      wrapper.log ("maxsep_doubles = " + pa[0] + " " + pa[1]);
    return (max_separation);
    }

 /**
   * Calculates the coefficients for the line in 3D using the first two points
   *
   * @param points  array of points to use to calculate the coefficents.  Only
   *                the first two points are used
   */
   	//
	//	the line can fall under 3 categories
    //
	//	1. parallel to an axis which means that 2 of the following is true
	//	x = A
	//	y = B
	//	z = C
	//
	//	and the two that are true form a line in the 3rd dimension (the one that's
	//	not constant)
	//
	//	2. parallel to the plane of an axis, which means that one of the following
	//	is true
	//	x = A
	//	y = B
	//	z = C
	//
	//	and the line is just a line in the non-constant variable plane projected
	//	onto the third dimension
	//	and the equation for that line is:
	//	x = A [supposing that x is the constant one]
	//	y = Bz + C
	//
	//
	//	3. none of the above and the equation of the line is just:
	//	y = Ax + B
	//	z = Cx + D


  private void calc_bi_linear(Point[] points) {
    Point p0 = points[0];
    Point p1 = points[1];

  if((p0.x == p1.x) && (p0.y == p1.y) && (p0.z != p1.z)) {
  	//x = A, y = B
  	line_flag = 0;
  	constants[0] = p0.x;
  	constants[1] = p0.y;
  	}
  if((p0.x == p1.x) && (p0.z == p1.z) && (p0.y != p1.y)) {
  	//x = A, z = C
  	line_flag = 1;
  	constants[0] = p0.x;
  	constants[1] = p0.z;
  	}
  if((p0.y == p1.y) && (p0.z == p1.z) && (p0.x != p1.x)) {
  	//y = B, z = C
  	line_flag = 2;
  	constants[0] = p0.y;
  	constants[1] = p0.z;
  	}
  if((p0.x == p1.x) && (p0.y != p1.y) && (p0.z != p1.z)) {
  	//x = A, z = By + C
  	line_flag = 3;
  	constants[0] = p0.x;
    constants[1] = (p1.z-p0.z)/(double) (p1.y-p0.y);
    constants[2] = (p0.z*p1.y-p0.y*p1.z)/(double)(p1.y-p0.y);
  	}
  if((p0.y == p1.y) && (p0.x != p1.x) && (p0.z != p1.z)) {
  	//y = B, z = Ax + C
  	line_flag = 4;
  	constants[0] = p0.y;
    constants[1] = (p1.z-p0.z)/(double) (p1.x-p0.x);
    constants[2] = (p0.z*p1.x-p0.x*p1.z)/(double)(p1.x-p0.x);
  	}
  if((p0.z == p1.z) && (p0.x != p1.x) && (p0.y != p1.y)) {
  	//z = C, y = Ax + B
  	line_flag = 5;
  	constants[0] = p0.z;
	constants[1] = (p1.y-p0.y)/(double) (p1.x-p0.x);
    constants[2] = (p0.y*p1.x-p0.x*p1.y)/(double)(p1.x-p0.x);
  	}
  if((p0.x != p1.x) && (p0.y != p1.y) && (p0.z != p1.z)) {
  	//y = Ax + B, z = Cx + D
  	line_flag = 6;
  	constants[0] = (p1.y-p0.y)/(double) (p1.x-p0.x);
    constants[1] = (p0.y*p1.x-p0.x*p1.y)/(double)(p1.x-p0.x);
    constants[2] = (p1.z-p0.z)/(double) (p1.x-p0.x);
    constants[3] = (p0.z*p1.x-p0.x*p1.z)/(double)(p1.x-p0.x);
  	}
  }



  /**
   *  Calculates new coefficients that for the new point.  Uses the
   *  new coefficients if they are relatively close to to the previous
   *  ones.  Kills off the invariant if they are not.
   *
   *  @return true if the new equation worked, false otherwise.
   */

  public boolean try_new_equation (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {

    // Calculate max separation using this point and the existing 3 points.
    def_points[3] = new Point (x, y, z);
    double sep = maxsep_triples (def_points);

    // If this point increased the separation, recalculate a, b, and c.
    if (sep > separation) {
      separation = sep;
      double[] coef;
      try {
        coef = calc_tri_linear (def_points);
        if (Debug.logDetail())
          wrapper.log ("Calc new plane with points " + def_points[0] + " " +
                       def_points[1] + " " + def_points[2] + " " +
                       def_points[3]);
      } catch (Exception e) {
        return (false);
      }

      // if the a, b, or c is a new min/max remember it.
      if (coef[0] < min_a) min_a = coef[0];
      if (coef[0] > max_a) max_a = coef[0];
      if (coef[1] < min_b) min_b = coef[1];
      if (coef[1] > max_b) max_b = coef[1];
      if (coef[2] < min_c) min_c = coef[2];
      if (coef[2] > max_c) max_c = coef[2];
      if (coef[3] < min_d) min_d = coef[3];
      if (coef[3] > max_d) max_d = coef[3];

      // Pick a new a, b, and c as the average of their endpoints
      a = (min_a + max_a) / 2;
      b = (min_b + max_b) / 2;
      c = (min_c + max_c) / 2;
      d = (min_d + max_d) / 2;
      if (wrapper.logOn() || debug.isLoggable(Level.FINE))
        wrapper.log (debug, wrapper.ppt.name() + ": Trying new a (" + a +
                    "), b (" + b + "), c (" + c + "), and d (" + d + ")");

      // if the new coefficients are 'equal' to their min and max and
      // this point fits, then this new equation is good enough both
      // for existing points and the new point.
      if (Global.fuzzy.eq(a, min_a) && Global.fuzzy.eq(a, max_a) &&
          Global.fuzzy.eq(b, min_b) && Global.fuzzy.eq(b, max_b) &&
          Global.fuzzy.eq(c, min_c) && Global.fuzzy.eq(c, max_c) &&
          Global.fuzzy.eq(d, min_d) && Global.fuzzy.eq(d, max_d) &&
          EQUAL (-c*z, a*x+b*y+d)) {
        if (debug.isLoggable(Level.FINE))
          debug.fine (wrapper.ppt.name() + ": New a (" + a + ") and b ("
                       + b + ") and c (" + c + ")");
        return (true);
      } else {
        return (false);
      }
    } else { // this point doesn't increase the separation

      return (false);
    }
  }


  /**
   * Calculates the separation between p1 and p2.
   *
   * @param p1  First point
   * @param p2  Second point
   *
   * @return the distance between p1 and p2
   */
  double separation(Point p1, Point p2) {
    #if defined(TYPELONG)
      // These variable Types are double so the values won't wrap around.
    #elif defined(TYPEDOUBLE)
      // Potential problem:  This may return 0, for two reasons.  First, x1-x2
      // might be zero due to underflow, even if x1!=x2.  Second, squaring a
      // small x1-x2 might result in 0, even if x1-x2!=0.
    #endif

    // make sure both points are specified
    if ((p1 == null) || (p2 == null)) {
      return (0);
    }

    double xsep = (p1.x - p2.x);
    double ysep = (p1.y - p2.y);
    double zsep = (p1.z - p2.z);
    return Math.sqrt(xsep*xsep + ysep*ysep + zsep*zsep);
    
  }

 /**
  * Calculates the three points that have the maximum separation in pa and
  * places them as the first three elements of pa.
  *
  * @param pa  Array of points.  Must have at least 3 elements.  Can be any
  *            length and can contain nulls (which will be ignored).
  *            Is side-effected so that the first three elements contain the
  *            points with the maximum total separation; this may introduce
  *            duplicates into the array.
  *
  * @return the maximum separation found.
  */
 double maxsep_triples (Point[] pa) {

   Point p1 = null, p2 = null, p3 = null;

   // cache values for the (square of the) distance between each pair of
   // points, to avoid duplicating work
   double[][] separations = new double[pa.length][pa.length];
   for (int i=0; i<pa.length-1; i++) {
	 for (int j=i+1; j<pa.length; j++) {
	   separations[i][j] = separation(pa[i], pa[j]);
	 }
   }

   // max_separation is the separation metric for the most separated
   // triple of points.  We use the sum of the separations as the
   // metric.  (The metric "min of the three separations" does not work
   // because it doesn't choose a unique set of points, making the
   // result dependent on the order in which the points are seen; more
   // seriously, it may choose a collinear set of points even when a
   // non-collinear set exists.)
   double max_separation = Double.MIN_VALUE;

   for (int i=0; i < pa.length-2; i++) {
	 for (int j=i+1; j < pa.length-1; j++) {
	   double sep_i_j = separations[i][j];
	   for (int k = j+1; k < pa.length; k++) {
	   
	   	// using the sum of separations is valid, as long as separation is
	   	// the actual distance between points and not the square of the distance
		 double separation = sep_i_j + separations[i][k] + separations[j][k];
		 if (separation > max_separation) {
		   max_separation = separation;
		   p1 = pa[i];
		   p2 = pa[j];
		   p3 = pa[k];
		 }
	   }
	 }
   }

   pa[0] = p1;
   pa[1] = p2;
   pa[2] = p3;

   if (Debug.logDetail())
	 wrapper.log ("maxsep_triples = " + pa[0] + " " + pa[1] + " " + pa[2]);
   return (max_separation);
    
 }


 

  // Given ((x0,y0,z0),(x1,y1,z1), (x2,y2,z2), calculate a, b, c and d
  // such that ax + by + cz + d = 0.
  // a, b, c and d are mutually prime, integers and a is positive.
  //
  // A visual explanation of the math can be found in:
  // http://www.efm.leeds.ac.uk/CIVE/CIVE2599/cive2599-summary-overheads-full.pdf
  //
  // The standard form of a plane can be calculated using a vector normal "n"
  // <n1, n2, n3> to the plane and a vector from the origin to the plane "r"
  // e.g. <x0, y0, z0>.
  //
  // The vector normal to the plane can be calculated by doing the cross product
  // of two line segments on the plane (<point2 - point0> and <point1 - point0>)
  //
  // Given the normal vector and and a point on the plane, the standard form 
  // of the plane is:
  // n1*x + n2*y + n3*z = p where p is the dot product of r and n
  //
  //
  
  /**
   * Calculates the coefficients for the equation ax + by + cz + d = 0 for the
   * first three points in points.
   *
   * @param points  array of points to use to calculate the coefficents.  Only
   *                the first three points are used
   *
   * @return a four element array where a is the first element, b the second,
   * c the third, and d is the fourth.  All elements are mutually prime, integers
   * and a is positive
   */
  public double[] calc_tri_linear(Point[] points) {

    Point p0 = points[0];
    Point p1 = points[1];
    Point p2 = points[2];


// the following code is taken from the source page of 
// http://jblanco_60.tripod.com/plane.html (the math behind the implementation
// is detailed above)

double px = p0.x;
double py = p0.y;
double pz = p0.z;
double qx = p1.x;
double qy = p1.y;
double qz = p1.z;
double rx = p2.x;
double ry = p2.y;
double rz = p2.z;
	
// define the i, j, k components of the two line segments on the plane
double a1 = (qx - px);
double a2 = (qy - py);
double a3 = (qz - pz);

double b1 = (rx - px);
double b2 = (ry - py);
double b3 = (rz - pz);


// calculate the i, j, k components of the cross product
double i_var = (a2 * b3) - (b2 * a3);
double j_var = -((a1 * b3) - (b1 * a3));
double k_var = (a1 * b2) - (b1 * a2);



// Calculate the value of the constant.  Note that given the format
// of the point-normal form, we multiply by the negative of P(x,y,z)

double Stand_const = ((i_var*(-px)) + (j_var*(-py)) + (k_var*(-pz)));


// call gcd function to get the greatest common divisor of the output
// and put the coefficients in lowest terms
double myGCD = MathMDE.gcd(MathMDE.gcd((int)i_var, (int)j_var) , MathMDE.gcd((int)k_var, (int)Stand_const));

double standard_i_var = 0;
double standard_j_var = 0;
double standard_k_var = 0;
double standard_Stand_const = 0;
	

// check to see if the "x" term is negative.  If it is,
// divide all terms by -1.  Also reduce all terms by dividing by
// the gcd.  If the gcd is 1, no harm done -- divide by 1.
// ensures postive x coefficient

if(i_var == 0) {
	standard_i_var = 0;
	standard_j_var = (j_var)/(myGCD);
	standard_k_var = (k_var)/(myGCD);
	standard_Stand_const = Stand_const/myGCD;
}
else if(i_var < 0) {
		standard_i_var = -(i_var)/myGCD;
		standard_j_var = -(j_var)/myGCD;
		standard_k_var = -(k_var)/myGCD;
		standard_Stand_const = -(Stand_const)/myGCD;
} else if(i_var > 0) {
	standard_i_var = i_var/myGCD;
	standard_j_var = j_var/myGCD;
	standard_k_var = k_var/myGCD;
	standard_Stand_const = Stand_const/myGCD;
}

double[] coef = new double[] {standard_i_var,
							 standard_j_var,
								  standard_k_var, standard_Stand_const };
								  								  
return coef;
	
}

// old version of calculating the coefficients
// new version does not throw any exceptions, able to handle 0 coeff possibility   
// Given ((x0,y0,z0),(x1,y1,z1)), calculate a, b, and c
  // such that ax + by + cz + d = 0.
  //
  // if no such (a, b, c) exists, it will throw an exception, otherwise
  // an array of doubles will be returned with 3 elements (a, b, c).
  //
  // Given a set of equations
  //    z0 = a x0 + b y0 + c
  //    z1 = a x1 + b y1 + c
  //    z2 = a x2 + b y2 + c
  // where (x, y, z) are known and we are solving for (a, b, c):
  //      | z0 y0 1 |
  //      | z1 y1 1 |
  //      | z2 y2 1 |
  // a = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //
  //      | x0 z0 1 |
  //      | x1 z1 1 |
  //      | x2 z2 1 |
  // b = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //
  //      | x0 y0 z0 |
  //      | x1 y1 z1 |
  //      | x2 y2 z2 |
  // c = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //


//	  float denominator = (float) ((p1.x * p2.y - p2.x * p1.y)
//						 - (p0.x * p2.y - p2.x * p0.y)
//						 + (p0.x * p1.y - p1.x * p0.y));
//	  if (denominator == 0)
//		throw new ArithmeticException();
//	  double a_numerator = (double) ((p1.z * p2.y - p2.z * p1.y)
//								  - (p0.z * p2.y - p2.z * p0.y)
//								  + (p0.z * p1.y - p1.z * p0.y));
//	  double b_numerator = (double) ((p1.x * p2.z - p2.x * p1.z)
//								 - (p0.x * p2.z - p2.x * p0.z)
//								  + (p0.x * p1.z - p1.x * p0.z));
//	 double c_numerator = (double) (p0.z * (p1.x * p2.y - p2.x * p1.y)
//								  - p1.z * (p0.x * p2.y - p2.x * p0.y)
//								 + p2.z * (p0.x * p1.y - p1.x * p0.y));
//	  double[] coef = new double[] { a_numerator / denominator,
//									b_numerator / denominator,
//								   -1, c_numerator / denominator };
//	  return (coef);
  



// The old (Python) code that computed a, b, and c looked like this:
//     (x1, y1, z1) = triple1
//     (x2, y2, z2) = triple2
//     (x3, y3, z3) = triple3
//     # Possibly reorder the triples to avoid division-by-zero problems.
//     if (y2 == y3) or (x2 == x3):
//         return (0,0,0)
//     try:
//         y1323 = float(y1-y3)/(y2-y3)
//         a_numerator = z3-z1+(z2-z3)*y1323
//         a_denominator = x3-x1+(x2-x3)*y1323
//
//         x1323 = float(x1-x3)/(x2-x3)
//         b_numerator = z3-z1+(z2-z3)*x1323
//         b_denominator = y3-y1+(y2-y3)*x1323
//     except OverflowError:
//         return (0,0,0)
//     if (a_denominator == 0) or (b_denominator == 0):
//         return (0,0,0)
//     a = a_numerator/a_denominator
//     b = b_numerator/b_denominator
//     c = z3-a*x3-b*y3



  public boolean enoughSamples() {
    return isActive();
  }

	//if it's a line, we have no confidence that it's a plane
  public double computeConfidence() {
  	if(isActive()) {
    return Invariant.conf_is_ge(values_seen, MINTRIPLES);
    } else 
    return 0;
    
  }

  public String repr() {
    return CLASSSTRING + wrapper.varNames() + ": "
      + "a=" + a
      + ",b=" + b
      + ",c=" + c
      + ",d=" + d
      + ",values_seen=" + values_seen;
  }

  public String point_repr(Point p) {
    if (p == null)
      return "null";
    else
      return "<" + p.x + "," + p.y + "," + p.z + ">";
  }

  public String cache_repr() {
    StringBuffer result = new StringBuffer();
    for (int i=0; i<MINTRIPLES; i++) {
      if (i!=0) result.append("; ");
      result.append(point_repr(def_points[i]));
    }
    return result.toString();
  }

  // In this class for convenience (avoid prefixing "LinearBinaryCore").
  static String formatTerm(OutputFormat format, double coeff, VarInfoName var, VarInfo vi, boolean first) {
    return LinearBinaryCore.formatTerm(format, coeff, var, vi, first);
  }

  public String format_using(OutputFormat format,
                             VarInfoName x, VarInfo xvi,
                             VarInfoName y, VarInfo yvi,
                             VarInfoName z, VarInfo zvi,
                             double a, double b, double c, double d) {
    if ((a == 0) && (b == 0) && (c == 0) && (d == 0)) {
      return wrapper.format_too_few_samples(format, null);
    }

    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify(x, y, z, a, b, c, d);
    }

    if ((format.isJavaFamily()))
    {
      #if defined(TYPEDOUBLE)
      return
        // Add a 1 to each side of the equation because FuzzyFloat
        // doesn't treat 0 as 'fuzzy' when compared against another
        // number.
        "daikon.Quant.fuzzy.eq("
        + formatTerm(format, a, x, xvi, true)
        + formatTerm(format, b, y, yvi, (a == 0))
        + formatTerm(format, c, z, zvi, (a == 0) && (b == 0))
        + formatTerm(format, d, null, null, (a == 0) && (b == 0) && (c == 0))
        + " + 1, 1)";
      #else
      return formatTerm(format, a, x, xvi, true)
        + formatTerm(format, b, y, yvi, (a == 0))
        + formatTerm(format, c, z, zvi, (a == 0) && (b == 0))
        + formatTerm(format, d, null, null, (a == 0) && (b == 0) && (c == 0))
        + " == 0";
      #endif
    }


    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.ESCJAVA)
        || (format == OutputFormat.IOA))
    {
      String eq = " == ";
      if (format == OutputFormat.IOA) eq = " = ";

      return formatTerm(format, a, x, xvi, true)
        + formatTerm(format, b, y, yvi, (a == 0))
        + formatTerm(format, c, z, zvi, (a == 0) && (b == 0))
        + formatTerm(format, d, null, null, (a == 0) && (b == 0) && (c == 0))
        + eq + "0";
    }

    return null;
  }

  public static String format_simplify(VarInfoName x, VarInfoName y, VarInfoName z,
                                       double da, double db, double dc, double dd) {
    int ia = (int) da;
    int ib = (int) db;
    int ic = (int) dc;
    int id = (int) dd;

    String str_a, str_b, str_c, str_d;
    if (ia != da || ib != db || ic != dc || id != dd) {
      // floating point

      // Disabled for the moment, since mixing integers and floating
      // literals seems to give Simplify indigestion. For instance:
      // (BG_PUSH (<= w 3))
      // (BG_PUSH (EQ 0 (* w 2.0d0)))
      // (<= w 1)

//       str_a = Invariant.simplify_format_double(da);
//       str_b = Invariant.simplify_format_double(db);
//       str_c = Invariant.simplify_format_double(dc);
//       str_d = Invariant.simplify_format_double(dd);
      return "(AND)"; // really s/b format_unimplemented
    } else {
      // integer
      str_a = Invariant.simplify_format_long(ia);
      str_b = Invariant.simplify_format_long(ib);
      str_c = Invariant.simplify_format_long(ic);
      str_d = Invariant.simplify_format_long(id);
    }

    // ax + by + cz + d = 0
    String str_z = z.simplify_name();
    String str_x = x.simplify_name();
    String str_y = y.simplify_name();
    String str_ax = (da == 1.0) ? str_x : "(* " + str_a + " " + str_x + ")";
    String str_by = (db == 1.0) ? str_y : "(* " + str_b + " " + str_y + ")";
    String str_cz = (dc == 1.0) ? str_z : "(* " + str_c + " " + str_z + ")";
    String str_axPbyPcz = "(+ " + str_ax + " " + str_by + " " + str_cz + ")";
    String str_axPbyPczPd = (dd == 0.0) ? str_axPbyPcz :
      "(+ " + str_axPbyPcz + " " + str_d + ")";
    return "(EQ 0 " + str_axPbyPczPd + ")";
  }

  public String format_using(OutputFormat format,
                             VarInfoName x, VarInfo xvi,
                             VarInfoName y, VarInfo yvi,
                             VarInfoName z, VarInfo zvi) {
    String result = format_using(format, x, xvi, y, yvi, z, zvi, a, b, c, d);
    if (result != null) {
      return result;
    }

    return wrapper.format_unimplemented(format);
  }


  // // Format as "x = cy+d" instead of as "y = ax+b".
  // public String format_reversed(String x, String y) {
  //   Assert.assertTrue(a == 1 || a == -1);
  //   return format(y, x, a, -b/a);
  // }

  public boolean isSameFormula(CLASSNAME other) {
    boolean inactive_can_match = true;

    // If we are matching up those that have not seen enough values yet
    if (inactive_can_match) {

      // If both have yet to see enough values
      if (!isActive() && !other.isActive()) {

        // Same formula if all of the points match
        if (values_seen != other.values_seen)
          return (false);
        for (int ii = 0; ii < values_seen; ii++) {
          if (def_points[ii] != other.def_points[ii])
            return (false);
        }
        return (true);

      } else {
        return ((values_seen >= MINTRIPLES)
                && (other.values_seen >= MINTRIPLES)
                && (a == other.a)
                && (b == other.b)
                && (c == other.c)
                && (d == other.d));
      }
    } else {

      boolean thisMeaningless =
        values_seen < MINTRIPLES ||
        (a == 0 && b == 0 && c == 0 && d == 0) ||
        Math.abs(a) >= Double.MAX_VALUE ||
        Math.abs(b) >= Double.MAX_VALUE ||
        Math.abs(c) >= Double.MAX_VALUE ||
        Math.abs(d) >= Double.MAX_VALUE
        ;
      boolean otherMeaningless =
        other.values_seen < MINTRIPLES ||
        (other.a == 0 && other.b == 0 && other.c == 0 || other.d == 0) ||
        Math.abs(other.a) >= Double.MAX_VALUE ||
        Math.abs(other.b) >= Double.MAX_VALUE ||
        Math.abs(other.c) >= Double.MAX_VALUE ||
        Math.abs(other.d) >= Double.MAX_VALUE
        ;

      if (thisMeaningless && otherMeaningless) {
        return true;
      } else {
        return ((values_seen >= MINTRIPLES)
                && (other.values_seen >= MINTRIPLES)
                && (a == other.a)
                && (b == other.b)
                && (c == other.c)
                && (d == other.d));
      }
    }
  }

  public boolean isExclusiveFormula(CLASSNAME other) {
    if (!isActive() ||
       !other.isActive()) {
      return false;
    }

    return ((a == other.a)
            && (b != other.b)
            && (c != other.c)
            && (d != other.d));
  }


  /**
   * In general, we can't merge formulas, but we can merge invariants with
   * too few samples to have formed a plane with invariants with enough
   * samples.  And those will appear to have different formulas.
   */
  public boolean mergeFormulasOk() {
    return (true);
  }

  /**
   * Merge the linear ternary cores in cores to form a new core. Any
   * core in the list that has seen enough points to define a
   * plane, must define the same plane. Any cores that have not
   * yet seen enough points, will have each of their points applied to
   * that invariant.  The merged core is returned.  Null is
   * returned if the cores don't describe the same plane
   *
   * @param cores   List of LinearTernary cores to merge.  They should
   *                all be permuted to match the variable order in
   *                ppt.
   */
  public CLASSNAME merge (List cores, Invariant wrapper) {

    // Look for any active planes.  All must define the same plane
    CLASSNAME first = null;
    for (int i = 0; i < cores.size(); i++) {
      CLASSNAME c = (CLASSNAME) cores.get (i);
      if (!c.isActive())
        continue;
      if (first == null)
        first = (CLASSNAME) c.clone();
      else {
        if (!Global.fuzzy.eq (first.a, c.a)
            || !Global.fuzzy.eq (first.b, c.b)
            || !Global.fuzzy.eq (first.c, c.c)
            || !Global.fuzzy.eq (first.d, c.d))
          return (null);
      }
    }

    // If no active planes were found, created an empty core
    if (first == null)
      first = new CLASSNAME (wrapper);
    else
      first.wrapper = wrapper;

    // Merge in any points from non-active cores
    for (int i = 0; i < cores.size(); i++) {
      CLASSNAME c = (CLASSNAME) cores.get (i);
      if (c.isActive())
        continue;
      for (int j = 0; j < c.values_seen; j++) {
        Point cp = c.def_points[j];
        if (Debug.logDetail())
          wrapper.log ("Adding point " + cp + " from " + c.wrapper.ppt);
        first.add_modified (cp.x, cp.y, cp.z, 1);
        if (wrapper.is_false())
          return (null);
      }
    }

    return (first);
  }



}
