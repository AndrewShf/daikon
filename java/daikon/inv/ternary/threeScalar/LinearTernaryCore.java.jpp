#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "Either TYPELONG or TYPEDOUBLE must be defined"
#endif

#if (defined(TYPELONG))
  #define CLASSNAME LinearTernaryCore
  #define PRIMITIVE long
  #define CLASSSTRING "LinearTernaryCore"
  #define EQUAL(a,b) ((a) == (b))
#elif (defined(TYPEDOUBLE))
  #define CLASSNAME LinearTernaryCoreFloat
  #define PRIMITIVE double
  #define CLASSSTRING "LinearTernaryCoreFloat"
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
#else
  #error "Either TYPELONG or TYPEDOUBLE must be defined"
#endif

// ***** This file is automatically generated from LinearTernaryCore.java.jpp

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoScalar.LinearBinaryCore;
import utilMDE.*;
import java.io.Serializable;

import org.apache.log4j.Logger;


public final class CLASSNAME
  implements Serializable, Cloneable
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030413L;

  /** Debug tracer **/
  final static Logger debug = Logger.getLogger("daikon.inv.ternary.threeScalar." + CLASSSTRING);

  // z == ax + by + c; first argument is x, second is y, third is z
  public double a = 0, b = 0, c = 0;
  public double min_a, max_a, min_b, max_b, min_c, max_c;
  public double separation = 0;

  //inner class to store points in for more convenient access
  public static class Point implements Serializable, Cloneable {
    public PRIMITIVE x;
    public PRIMITIVE y;
    public PRIMITIVE z;
    public Point () {
      this (0, 0, 0);
    }
    public Point (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {
      this.x = x; this.y = y; this.z = z;
    }
    public boolean equals (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {
      return ((this.x == x) && (this.y == y) && (this.z == z));
    }
    protected Object clone() throws CloneNotSupportedException {
      return super.clone();
    }
  };

  // Points that define the plane.  The first three are normally the
  // current definition.  The next is a new point for consideration.
  // However, any slot may be set to null at any time, and points may be
  // duplicated at any time.
  public Point[] def_points = new Point[MINTRIPLES];

  public Invariant wrapper;

  public int values_seen = 0;

  final static int MINTRIPLES = 5;

  public CLASSNAME(Invariant wrapper) {
    this.wrapper = wrapper;
  }

  public Object clone() {
    try {
      CLASSNAME result = (CLASSNAME) super.clone();
      result.def_points = new Point[MINTRIPLES];
      for (int i=0; i<MINTRIPLES; i++) {
        Point p = def_points[i];
        if (p != null) {
          result.def_points[i] = (Point) p.clone();
        }
      }
      return result;
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  /**
   * Reorganize our already-seen state as if the variables had shifted
   * order underneath us (rearrangement given by the permutation).
   **/
  public void permute(int[] permutation) {
    Assert.assertTrue(permutation.length == 3);
    Assert.assertTrue(ArraysMDE.fn_is_permutation(permutation));
    // Fix a, b, c
    // clever because a*v0 + b*v1 - v2 = -c
    double[] clever = new double[] { a, b, -1.0 };
    double[] pclever = new double[3];
    pclever[permutation[0]] = clever[0];
    pclever[permutation[1]] = clever[1];
    pclever[permutation[2]] = clever[2];
    if (values_seen >= MINTRIPLES) {
      // Seen enough values, so permuting a, b, c is useful
      // This is needed so we don't have div by 0 errors
      //      if (pclever[2] == 0) {
      if (a == 0 || b == 0) { // Means a bit more than above, but this
                              // should be okay
        // Can't handle this form once rotated.  But if we've seen
        // enough values, yet a or b is zero, then this is covered by
        // a LinearBinary or a constant, so let me just destroy myself
        values_seen = Integer.MAX_VALUE;
        a = b = c = 0;
        if (debug.isDebugEnabled()) {
          debug.debug ("  Ternary invariant destroyed because a or b = 0");
        }
        return;
      } else {
        double d = -1.0 / pclever[2];
        a = pclever[0] * d;
        b = pclever[1] * d;
        c = c * d;
      }
    }
    // Fix caches
    {
      PRIMITIVE[] temp = new PRIMITIVE[3];
      for (int i=0; i<MINTRIPLES; i++) {
        Point p = def_points[i];
        if (p == null)
          continue;
        temp[permutation[0]] = p.x;
        temp[permutation[1]] = p.y;
        temp[permutation[2]] = p.z;
        p.x = temp[0];
        p.y = temp[1];
        p.z = temp[2];
      }
    }
    // Could assert that caches sync with a,b,c (?)
  }

  /**
   * Returns whether or not the invariant is currently active.  We become
   * active after MINTRIPLES values have been seen and a plane calculated.
   * Before that, a, b, and c are uninitialized
   */
  public boolean isActive() {
    return (values_seen >= MINTRIPLES);
  }

  /**
   * Looks for points that define a plane (y = ax + by + c).  Collects
   * MINTRIPLE points before attempting to define the plane (to
   * hopefully get at least some spread between the points, so that
   * small errors don't get magnified).  Once the equation for the
   * plane is found, each subsequent point is compared to it.  If the
   * point does not match the point is examined to see if it would is
   * maximally separated when compared to the points originally used
   * to define the plane.  If it is, it is used to recalcalulate the
   * coefficients (a, b, c).  If those coefficients are relatively close
   * to the original coefficients (within the ratio defined by Global.fuzzy)
   * then the new coefficients are used.
   *
   * @see FuzzyFloat
   */

  public void add_modified(PRIMITIVE x, PRIMITIVE y, PRIMITIVE z, int count) {
    // XXX TODO FIXME: This method does not correctly deal with
    // calling addToFlow.  A proper clone, etc. should be created and
    // dealt with.  This will complicate the logic below, I'll bet.

    if (values_seen < MINTRIPLES) {
      // We delay computation of a and b until we have seen several triples
      // so that we can compute a and b based on a far-separated triple.  If
      // the points in a triple are nearby, then roundoff errors in the
      // computation of the slope can be non-negligible.

      // skip points we've already seen
      for (int i=0; i<values_seen; i++)
        if (def_points[i].equals (x, y, z))
          return;

      def_points[values_seen] = new Point (x, y, z);
      values_seen++;

      // if we've seen enough values to create the equation
      if (values_seen == MINTRIPLES) {

        // Find the three points with the maximum separation
        maxsep_triples (def_points);
        if (def_points[0] == null) {
          wrapper.destroyAndFlow();
          return;
        }

        // calculate the coefficients of the equation (a, b, c)
        double coef[];
        try {
          coef = calc_tri_linear (def_points);
        } catch (Exception e) {
          wrapper.destroyAndFlow();
          return;
        }
        a = coef[0];
        b = coef[1];
        c = coef[2];

        // If one of these coefficients is zero, this should be a
        // LinearBinary, not a LinearTernary, term.  (It might not show up
        // as LinearBinary because there might not have been enough samples;
        // but a random varying third variable can create enough samples.)
        if ((a == 0) || (b == 0) ||
            (Math.abs(a) >= Double.MAX_VALUE) ||
            (Math.abs(b) >= Double.MAX_VALUE)) {
          wrapper.destroyAndFlow();
          return;
        }

        // Check all values against a, b, and c.
        if (!wrapper.falsified) {
          for (int i=0; i<MINTRIPLES; i++) { // values_seen == MINTRIPLES
            if (!EQUAL (def_points[i].z,
                        a*def_points[i].x + b*def_points[i].y + c)) {
              if (debug.isDebugEnabled()) {
                debug.debug("Suppressing " + CLASSSTRING + " at index " + i + ": "
                            + def_points[i].z + " != "
                            + a + "*" + def_points[i].x
                            + "+" + b + "*" + def_points[i].y + "+" + c);
              }
              wrapper.destroyAndFlow();
              return;
            }
          }

          // Discard the points not used to define the coefficients.
          for (int ii = 3; ii < MINTRIPLES; ii++)
            def_points[ii] = null;
        }
      }
    } else {
      // If the new value doesn't fit the equation
      if (!EQUAL (z, a*x+b*y+c)) {

        // Try to find small changes that will fit better.
        if (!try_new_equation (x, y, z)) {
          if (debug.isDebugEnabled()) {
            debug.debug("Suppressing " + CLASSSTRING + " (" +
                        wrapper.format() + ") at new value: "
                        + y + " != " + a + "*" + x + "+" + b);
          }
          wrapper.destroyAndFlow();
          return;
        }
      }
    }
  }

  /**
   *  Calculates new coefficients that for the new point.  Uses the
   *  new coefficients if they are relatively close to to the previous
   *  ones.  Kills off the invariant if they are not.
   *
   *  @return true if the new equation worked, false otherwise.
   */

  public boolean try_new_equation (PRIMITIVE x, PRIMITIVE y, PRIMITIVE z) {

    // Calculate max separation using this point and the existing 3 points.
    def_points[3] = new Point (x, y, z);
    double sep = maxsep_triples (def_points);

    // If this point increased the separation, recalculate a, b, and c.
    if (sep > separation) {
      separation = sep;
      double coef[];
      try {
        coef = calc_tri_linear (def_points);
      } catch (Exception e) {
        return (false);
      }

      // if the a, b, or c is a new min/max remember it.
      if (coef[0] < min_a) min_a = coef[0];
      if (coef[0] > max_a) max_a = coef[0];
      if (coef[1] < min_b) min_b = coef[1];
      if (coef[1] > max_b) max_b = coef[1];
      if (coef[2] < min_c) min_c = coef[2];
      if (coef[2] > max_c) max_c = coef[2];

      // Pick a new a, b, and c as the average of their endpoints
      a = (min_a + max_a) / 2;
      b = (min_b + max_b) / 2;
      c = (min_c + max_c) / 2;
      if (debug.isDebugEnabled())
        debug.debug (wrapper.ppt.name + ": Trying new a (" + a +
                     "), b (" + b + ") and c (" + c + ")");

      // if the new coefficients are 'equal' to their min and max and
      // this point fits, then this new equation is good enough both
      // for existing points and the new point.
      if (Global.fuzzy.eq(a, min_a) && Global.fuzzy.eq(a, max_a) &&
          Global.fuzzy.eq(b, min_b) && Global.fuzzy.eq(b, max_b) &&
          Global.fuzzy.eq(c, min_c) && Global.fuzzy.eq(c, max_c) &&
          EQUAL (z, a*x+b*y+c)) {
        if (debug.isDebugEnabled())
          debug.debug (wrapper.ppt.name + ": New a (" + a + ") and b ("
                       + b + ")");
        return (true);
      } else {
        return (false);
      }
    } else { // this point doesn't increase the separation

      return (false);
    }
  }


  /**
   * Calculates the square of the separation between p1 and p2
   *
   * @param p1  First point
   * @param p2  Second point
   *
   * @return square of the distance between p1 and p2
   */
  double separation(Point p1, Point p2) {
    #if defined(TYPELONG)
      // These variable Types are double so the values won't wrap around.
    #elif defined(TYPEDOUBLE)
      // Potential problem:  This may return 0, for two reasons.  First, x1-x2
      // might be zero due to underflow, even if x1!=x2.  Second, squaring a
      // small x1-x2 might result in 0, even if x1-x2!=0.
    #endif

    // make sure both points are specified
    if ((p1 == null) || (p2 == null)) {
      return (0);
    }

    double xsep = (p1.x - p2.x);
    double ysep = (p1.y - p2.y);
    double zsep = (p1.z - p2.z);
    return xsep*xsep + ysep*ysep + zsep*zsep;
  }

  /**
   * Calculates the three points that have the maximum separation in pa and
   * places them as the first three elements of pa.
   *
   * @param pa  Array of points.  Must have at least 3 elements.  Can be any
   *            length and can contain nulls (which will be ignored).
   *            Is side-effected so that the first three elements contain the
   *            points with the maximum total separation; this may introduce
   *            duplicates into the array.
   *
   * @return the maximum separation found.
   */
  double maxsep_triples (Point[] pa) {

    Point p1 = null, p2 = null, p3 = null;

    // cache values for the (square of the) distance between each pair of
    // points, to avoid duplicating work
    double[][] separations = new double[pa.length][pa.length];
    for (int i=0; i<pa.length-1; i++) {
      for (int j=i+1; j<pa.length; j++) {
        separations[i][j] = separation(pa[i], pa[j]);
      }
    }

    // max_separation is the separation metric for the most separated
    // triple of points.  We use the sum of the separations as the
    // metric.  (The metric "min of the three separations" does not work
    // because it doesn't choose a unique set of points, making the
    // result dependent on the order in which the points are seen; more
    // seriously, it may choose a collinear set of points even when a
    // non-collinear set exists.)
    double max_separation = Double.MIN_VALUE;

    for (int i=0; i < pa.length-2; i++) {
      for (int j=i+1; j < pa.length-1; j++) {
        double sep_i_j = separations[i][j];
        for (int k = j+1; k < pa.length; k++) {
          double separation = sep_i_j + separations[i][k] + separations[j][k];
          if (separation > max_separation) {
            max_separation = separation;
            p1 = pa[i];
            p2 = pa[j];
            p3 = pa[k];
          }
        }
      }
    }

    pa[0] = p1;
    pa[1] = p2;
    pa[2] = p3;

    return (max_separation);
  }


  // Given ((x0,y0,z0),(x1,y1,z1)), calculate a, b, and c
  // such that z = ax + by + c.
  //
  // if no such (a, b, c) exists, it will throw an exception, otherwise
  // an array of doubles will be returned with 3 elements (a, b, c).
  //
  // Given a set of equations
  //    z0 = a x0 + b y0 + c
  //    z1 = a x1 + b y1 + c
  //    z2 = a x2 + b y2 + c
  // where (x, y, z) are known and we are solving for (a, b, c):
  //      | z0 y0 1 |
  //      | z1 y1 1 |
  //      | z2 y2 1 |
  // a = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //
  //      | x0 z0 1 |
  //      | x1 z1 1 |
  //      | x2 z2 1 |
  // b = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //
  //      | x0 y0 z0 |
  //      | x1 y1 z1 |
  //      | x2 y2 z2 |
  // c = -------------
  //      | x0 y0 1 |
  //      | x1 y1 1 |
  //      | x2 y2 1 |
  //

  /**
   * Calculates the coefficients for the equation z = ax + by +c for the
   * first three points in points.
   *
   * @param points  array of points to use to calculate the coefficents.  Only
   *                the first three points are used
   *
   * @return a three element array where a is the first element, b the second,
   * and c the third.
   */
  public double[] calc_tri_linear(Point[] points) {

    Point p0 = points[0];
    Point p1 = points[1];
    Point p2 = points[2];

    float denominator = (float) ((p1.x * p2.y - p2.x * p1.y)
                       - (p0.x * p2.y - p2.x * p0.y)
                       + (p0.x * p1.y - p1.x * p0.y));
    float a_numerator = (float) ((p1.z * p2.y - p2.z * p1.y)
                                - (p0.z * p2.y - p2.z * p0.y)
                                + (p0.z * p1.y - p1.z * p0.y));
    float b_numerator = (float) ((p1.x * p2.z - p2.x * p1.z)
                                - (p0.x * p2.z - p2.x * p0.z)
                                + (p0.x * p1.z - p1.x * p0.z));
    float c_numerator = (float) (p0.z * (p1.x * p2.y - p2.x * p1.y)
                                - p1.z * (p0.x * p2.y - p2.x * p0.y)
                                + p2.z * (p0.x * p1.y - p1.x * p0.y));
    return new double[] { a_numerator / denominator, b_numerator / denominator,
                          c_numerator / denominator };
  }



// The old (Python) code that computed a, b, and c looked like this:
//     (x1, y1, z1) = triple1
//     (x2, y2, z2) = triple2
//     (x3, y3, z3) = triple3
//     # Possibly reorder the triples to avoid division-by-zero problems.
//     if (y2 == y3) or (x2 == x3):
//         return (0,0,0)
//     try:
//         y1323 = float(y1-y3)/(y2-y3)
//         a_numerator = z3-z1+(z2-z3)*y1323
//         a_denominator = x3-x1+(x2-x3)*y1323
//
//         x1323 = float(x1-x3)/(x2-x3)
//         b_numerator = z3-z1+(z2-z3)*x1323
//         b_denominator = y3-y1+(y2-y3)*x1323
//     except OverflowError:
//         return (0,0,0)
//     if (a_denominator == 0) or (b_denominator == 0):
//         return (0,0,0)
//     a = a_numerator/a_denominator
//     b = b_numerator/b_denominator
//     c = z3-a*x3-b*y3



  public boolean enoughSamples() {
    return values_seen >= MINTRIPLES;
  }

  public double computeProbability() {
    if (wrapper.falsified)
      return Invariant.PROBABILITY_NEVER;
    return Invariant.prob_is_ge(values_seen, MINTRIPLES);
  }

  public String repr() {
    return CLASSSTRING + wrapper.varNames() + ": "
      + "a=" + a
      + ",b=" + b
      + ",c=" + c
      + ",values_seen=" + values_seen;
  }

  public String point_repr(Point p) {
    if (p == null)
      return "null";
    else
      return "<" + p.x + "," + p.y + "," + p.z + ">";
  }

  public String cache_repr() {
    StringBuffer result = new StringBuffer();
    for (int i=0; i<MINTRIPLES; i++) {
      if (i!=0) result.append("; ");
      result.append(point_repr(def_points[i]));
    }
    return result.toString();
  }

  // In this class for convenience (avoid prefixing "LinearBinaryCore").
  static String formatTerm(OutputFormat format, double coeff, VarInfoName var, boolean first) {
    return LinearBinaryCore.formatTerm(format, coeff, var, first);
  }

  public static String format_using(OutputFormat format,
                                    VarInfoName x, VarInfoName y, VarInfoName z,
                                    double a, double b, double c)
  {
    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify(x, y, z, a, b, c);
    }

    if ((a == 0) && (b == 0) && (c == 0)) {
      // We have no information, so print something vacuously true
      return "Too few samples for linear relation: 0 * " + z
        + " == 0 * "+ x + " + 0 * " + y + " + 0";
    }

    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.ESCJAVA)
        || (format == OutputFormat.IOA)
        || (format == OutputFormat.JML))
    {
      String eq = " == ";
      if (format == OutputFormat.IOA) eq = " = ";

      // It shouldn't be the case that a or b is 0 for printed invariants;
      // but that can be true earlier on in processing.
      if ((a == 0) && (b == 0) && (c == 0)) {
        String xname = x.name_using(format);
        String yname = y.name_using(format);
        String zname = z.name_using(format);
        return zname + eq + "(? * " + xname + ") + (? * " + yname + ") + ?";
      }

      return z.name_using(format) + eq
        + formatTerm(format, a, x, true)
        + formatTerm(format, b, y, false)
        + formatTerm(format, c, null, false);
    }

    return null;
  }

  public static String format_simplify(VarInfoName x, VarInfoName y, VarInfoName z,
                                       double da, double db, double dc) {
    int ia = (int) da;
    int ib = (int) db;
    int ic = (int) dc;

    String str_a, str_b, str_c;
    if (da == 0 && db == 0 && dc == 0) {
      // no data
      return "(AND)"; // always true
    } else if (ia != da || ib != db || ic != dc) {
      // floating point
      str_a = Invariant.simplify_format_double(da);
      str_b = Invariant.simplify_format_double(db);
      str_c = Invariant.simplify_format_double(dc);
    } else {
      // integer
      str_a = ia + "";
      str_b = ib + "";
      str_c = ic + "";
    }

    // z == ax + by + c
    String str_z = z.simplify_name();
    String str_x = x.simplify_name();
    String str_y = y.simplify_name();
    String str_ax = (da == 1.0) ? str_x : "(* " + str_a + " " + str_x + ")";
    String str_by = (db == 1.0) ? str_y : "(* " + str_b + " " + str_y + ")";
    String str_axPby = "(+ " + str_ax + " " + str_by + ")";
    String str_axPbyPc = (dc == 0.0) ? str_axPby :
      "(+ " + str_axPby + " " + str_c + ")";
    return "(EQ " + str_z + " " + str_axPbyPc + ")";
  }

  public String format_using(OutputFormat format,
                             VarInfoName x, VarInfoName y, VarInfoName z)
  {
    String result = format_using(format, x, y, z, a, b, c);
    if (result != null) {
      return result;
    }

    return wrapper.format_unimplemented(format);
  }


  // // Format as "x = cy+d" instead of as "y = ax+b".
  // public String format_reversed(String x, String y) {
  //   Assert.assertTrue(a == 1 || a == -1);
  //   return format(y, x, a, -b/a);
  // }

  public boolean isSameFormula(CLASSNAME other)
  {
    boolean thisMeaningless =
      values_seen < MINTRIPLES ||
      (a == 0 && b == 0 && c == 0) ||
      Math.abs(a) >= Double.MAX_VALUE ||
      Math.abs(b) >= Double.MAX_VALUE
      ;
    boolean otherMeaningless =
      other.values_seen < MINTRIPLES ||
      (other.a == 0 && other.b == 0 && other.c == 0) ||
      Math.abs(other.a) >= Double.MAX_VALUE ||
      Math.abs(other.b) >= Double.MAX_VALUE
      ;

    if (thisMeaningless && otherMeaningless) {
      return true;
    } else {
      return ((values_seen >= MINTRIPLES)
              && (other.values_seen >= MINTRIPLES)
              && (a == other.a)
              && (b == other.b)
              && (c == other.c));
    }
  }

  public boolean isExclusiveFormula(CLASSNAME other)
  {
    if ((values_seen < MINTRIPLES) ||
        (other.values_seen < MINTRIPLES)) {
      return false;
    }

    return ((a == other.a)
            && (b != other.b)
            && (c != other.c));
  }

}
