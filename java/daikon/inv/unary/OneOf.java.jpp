#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(SCALAR) || defined(STRING) || defined(FLOAT) \
      || defined(SEQUENCE) || defined(STRINGSEQUENCE) || defined(FLOATSEQUENCE) \
      || defined(ELT) || defined(ELTSTRING) || defined(ELTFLOAT))
#error "One of SCALAR, STRING, FLOAT, SEQUENCE, STRINGSEQUENCE, FLOATSEQUENCE, ELT, ELTSTRING, or ELTFLOAT should be defined"
#endif

#if defined(SCALAR) || defined(STRING) || defined(FLOAT)
#  define IS_SCALAR
#  if defined(SCALAR) || defined(FLOAT)
#    define IS_NUMERIC
#  endif
#elif defined(SEQUENCE) || defined(STRINGSEQUENCE) || defined(FLOATSEQUENCE)
#  define IS_SEQUENCE
#  if defined(SEQUENCE) || defined(FLOATSEQUENCE)
#    define IS_SEQUENCE_NUMERIC
#  endif
#elif defined(ELT) || defined(ELTSTRING) || defined(ELTFLOAT)
#  define IS_ELT
#  if defined(ELT) || defined(ELTFLOAT)
#    define IS_ELT_NUMERIC
#  endif
#else
#  error "Impossible"
#endif

#if defined(SCALAR) || defined(SEQUENCE) || defined(ELT)
#define BASE_INT
#define BASE_NUMERIC
#elif defined(FLOAT) || defined(FLOATSEQUENCE) || defined(ELTFLOAT)
#define BASE_FLOAT
#define BASE_NUMERIC
#elif defined(STRING) || defined(STRINGSEQUENCE) || defined(ELTSTRING)
#define BASE_STRING
#else
#error "Impossible"
#endif


#define EQUALS(a,b) (a == b)
#define JAVA_EQUALS_STRING(x) " == " + x

#if defined(SCALAR)
#  define SCALARPKG scalar
#  define INT long
#  define ONEOFSCALAR OneOfScalar
#  define ONEOFSCALAR_STRING "OneOfScalar"
#  define SINGLESCALAR SingleScalar
#  define NUMWRAPPER Long
#  if 0
     TOSTRING is never called for hashcodes: we never print actual values.
#  endif
#  define TOSTRING(x) ((Integer.MIN_VALUE <= x && x <= Integer.MAX_VALUE) ? String.valueOf(x) : (String.valueOf(x) + "L"))
#  define NAME var().name.name()
#  define JAVA_NAME var().name.java_name()
#  define NONZERO NonZero
#  define ELTONEOF EltOneOf
#  define LOWERBOUND LowerBound
#  define UPPERBOUND UpperBound
#elif defined(FLOAT)
#  undef EQUALS
#  define EQUALS(a,b) ((a == b) || (Double.isNaN(a) && Double.isNaN(b)))
#  undef JAVA_EQUALS_STRING
#  define JAVA_EQUALS_STRING(x) ".equals(" + x + ")"
#  define SCALARPKG scalar
#  define INT double
#  define ONEOFSCALAR OneOfFloat
#  define ONEOFSCALAR_STRING "OneOfFloat"
#  define SINGLESCALAR SingleFloat
#  define NUMWRAPPER Double
#  define TOSTRING(x) String.valueOf(x)
#  define NAME var().name.name()
#  define JAVA_NAME var().name.java_name()
#  define NONZERO NonZeroFloat
#  define ELTONEOF EltOneOfFloat
#  define LOWERBOUND LowerBoundFloat
#  define UPPERBOUND UpperBoundFloat
#elif defined(STRING)
#  define COMMENT No "EQUALS(a,b)" because we intern and so can use equality tests
#  undef JAVA_EQUALS_STRING
#  define JAVA_EQUALS_STRING(x) ".equals(" + x + ")"
#  define SCALARPKG string
#  define INT String
#  define ONEOFSCALAR OneOfString
#  define ONEOFSCALAR_STRING "OneOfString"
#  define SINGLESCALAR SingleString
#  define TOSTRING(x) ((x==null) ? "null" : "\"" + UtilMDE.quote(x) + "\"")
#  define NAME var().name.name()
#  define JAVA_NAME var().name.java_name()
#elif defined(SEQUENCE)
#  define SCALARPKG sequence
#  define INT long[]
#  define ONEOFSCALAR OneOfSequence
#  define ONEOFSCALAR_STRING "OneOfSequence"
#  define SINGLESCALAR SingleScalarSequence
#  define TOSTRING(x) ArraysMDE.toString(x)
#  define NAME var().name.name()
#  define JAVA_NAME var().name.java_name()
#elif defined(FLOATSEQUENCE)
#  define SCALARPKG sequence
#  define INT double[]
#  define ONEOFSCALAR OneOfFloatSequence
#  define ONEOFSCALAR_STRING "OneOfSequenceFloat"
#  define SINGLESCALAR SingleFloatSequence
#  define TOSTRING(x) ArraysMDE.toString(x)
#  define NAME var().name.name()
#  define JAVA_NAME var().name.java_name()
#elif defined(STRINGSEQUENCE)
#  define SCALARPKG stringsequence
#  define INT String[]
#  define ONEOFSCALAR OneOfStringSequence
#  define ONEOFSCALAR_STRING "OneOfStringSequence"
#  define SINGLESCALAR SingleStringSequence
#  define TOSTRING(x) ArraysMDE.toString(x)
#  define NAME var().name.name()
#  define JAVA_NAME var().name.java_name()
#elif defined(ELT)
#  define SCALARPKG sequence
#  define INT long
#  define NUMWRAPPER Long
#  define ONEOFSCALAR EltOneOf
#  define ONEOFSCALAR_STRING "EltOneOf"
#  define SINGLESCALAR SingleScalarSequence
#  define TOSTRING(x) (((x == 0) && (var().file_rep_type == ProglangType.HASHCODE_ARRAY)) ? "null" : ((Integer.MIN_VALUE <= x && x <= Integer.MAX_VALUE) ? String.valueOf(x) : (String.valueOf(x) + "L")))
#  define NAME var().name.name() + " elements"
#  define JAVA_NAME var().name.java_name()
#  define NONZERO EltNonZero
#  define LOWERBOUND LowerBound
#  define UPPERBOUND UpperBound
#elif defined(ELTFLOAT)
#  define SCALARPKG sequence
#  define INT double
#  define NUMWRAPPER Double
#  define ONEOFSCALAR EltOneOfFloat
#  define ONEOFSCALAR_STRING "EltOneOfFloat"
#  define SINGLESCALAR SingleFloatSequence
#  define TOSTRING(x) String.valueOf(x)
#  define NAME var().name.name() + " elements"
#  define JAVA_NAME var().name.java_name()
#  define NONZERO EltNonZeroFloat
#  define LOWERBOUND LowerBoundFloat
#  define UPPERBOUND UpperBoundFloat
#elif defined(ELTSTRING)
#  define SCALARPKG stringsequence
#  define INT String
#  define ONEOFSCALAR EltOneOfString
#  define ONEOFSCALAR_STRING "EltOneOfString"
#  define SINGLESCALAR SingleStringSequence
#  define TOSTRING(x) ((x==null) ? "null" : "\"" + UtilMDE.quote(x) + "\"")
#  define NAME var().name.name() + " elements"
#  define JAVA_NAME var().name.java_name()
#else
#error "One of SCALAR, STRING, FLOAT, SEQUENCE, STRINGSEQUENCE, FLOATSEQUENCE, ELT, ELTSTRING, or ELTFLOAT should be defined"
#endif

// ***** This file is automatically generated from OneOf.java.jpp

package daikon.inv.unary.SCALARPKG;

import daikon.*;
import daikon.inv.*;
import daikon.derive.unary.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.binary.sequenceScalar.*;
import daikon.inv.binary.twoSequence.SubSequence;

import utilMDE.*;

import java.util.*;
import java.io.*;

// States that the value is one of the specified values.

// This subsumes an "exact" invariant that says the value is always exactly
// a specific value.  Do I want to make that a separate invariant
// nonetheless?  Probably not, as this will simplify implication and such.

public final class ONEOFSCALAR
  extends SINGLESCALAR
  implements OneOf
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff OneOf invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  /**
   * Positive integer.  Specifies the maximum set size for this type
   * of invariant (x is one of 'n' items).
   **/
#if defined(STRINGSEQUENCE)
  public static int dkconfig_size = 2;
#else
  public static int dkconfig_size = 3;
#endif

  // Probably needs to keep its own list of the values, and number of each seen.
  // (That depends on the slice; maybe not until the slice is cleared out.
  // But so few values is cheap, so this is quite fine for now and long-term.)

  private INT[] elts;
  private int num_elts;
#ifdef BASE_INT
  /** Whether the variable's declared type is boolean. **/
  private boolean is_boolean;
  /** Whether the variable's declared type is hashcode. **/
  private boolean is_hashcode;
#endif

  public ONEOFSCALAR(PptSlice ppt) {
    super(ppt);
#if defined(IS_ELT) || defined(IS_SEQUENCE)
    Assert.assertTrue(var().type.isPseudoArray(),
                  "ProglangType must be pseudo-array for " + ONEOFSCALAR_STRING);
#endif
#if defined(SEQUENCE)
    // Elements are interned, so can test with ==
    // (in the general online case, it's not worth interning).
    elts = new long[dkconfig_size][];
#elif defined(FLOATSEQUENCE)
    // Elements are interned, so can test with == (except that NaN != NaN)
    // (in the general online case, it's not worth interning).
    elts = new double[dkconfig_size][];
#elif defined(STRINGSEQUENCE)
    // Elements are interned, so can test with ==
    // (in the general online case, it's not worth interning).
    elts = new String[dkconfig_size][];
#else
    elts = new INT[dkconfig_size];
#endif
    num_elts = 0;
#if defined(SCALAR)
    is_boolean = (var().file_rep_type == ProglangType.BOOLEAN);
    is_hashcode = (var().file_rep_type == ProglangType.HASHCODE);
#elif defined(ELT) || defined(SEQUENCE)
    is_boolean = (var().file_rep_type.elementType() == ProglangType.BOOLEAN);
    is_hashcode = (var().file_rep_type.elementType() == ProglangType.HASHCODE);
    // System.out.println("is_hashcode=" + is_hashcode + " for " + format()
    //                    + "; file_rep_type=" + var().file_rep_type.format());
#endif
  }

  public static ONEOFSCALAR instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    return new ONEOFSCALAR(ppt);
  }

  protected Object clone() {
    ONEOFSCALAR result = (ONEOFSCALAR) super.clone();
    result.elts = (INT[]) elts.clone();
#ifdef IS_SEQUENCE
    for (int i=0; i < num_elts; i++) {
      result.elts[i] = (INT) elts[i].clone();
    }
#endif
    result.num_elts = this.num_elts;
#ifdef BASE_INT
    result.is_boolean = this.is_boolean;
    result.is_hashcode = this.is_hashcode;
#endif
    return result;
  }

  public int num_elts() {
    return num_elts;
  }

  public Object elt() {
    if (num_elts != 1)
      throw new Error("Represents " + num_elts + " elements");
#if defined(SCALAR) || defined(ELT)
    // Not sure whether interning is necessary (or just returning an Integer
    // would be sufficient), but just in case...
    return Intern.internedLong(elts[0]);
#elif defined(FLOAT) || defined(ELTFLOAT)
    return Intern.internedDouble(elts[0]);
#else
    return elts[0];
#endif
  }

#if defined(STRING) || defined(ELTSTRING)
  static Comparator comparator = new UtilMDE.NullableStringComparator();
#  define COMPARATOR_ARG , comparator
#elif defined(SEQUENCE)
  static Comparator comparator = new ArraysMDE.LongArrayComparatorLexical();
#define COMPARATOR_ARG , comparator
#elif defined(FLOATSEQUENCE)
  static Comparator comparator = new ArraysMDE.DoubleArrayComparatorLexical();
#define COMPARATOR_ARG , comparator
#elif defined(STRINGSEQUENCE)
  static Comparator comparator = new ArraysMDE.ComparableArrayComparatorLexical();
#  define COMPARATOR_ARG , comparator
#else
#  define COMPARATOR_ARG
#endif

  private void sort_rep() {
    Arrays.sort(elts, 0, num_elts COMPARATOR_ARG);
  }

  public INT min_elt() {
    if (num_elts == 0)
      throw new Error("Represents no elements");
    sort_rep();
    return elts[0];
  }

  public INT max_elt() {
    if (num_elts == 0)
      throw new Error("Represents no elements");
    sort_rep();
    return elts[num_elts-1];
  }

  // Assumes the other array is already sorted
  public boolean compare_rep(int num_other_elts, INT[] other_elts) {
    if (num_elts != num_other_elts)
      return false;
    sort_rep();
    for (int i=0; i < num_elts; i++)
      if (! EQUALS(elts[i],other_elts[i])) // elements are interned
        return false;
    return true;
  }

  private String subarray_rep() {
    // Not so efficient an implementation, but simple;
    // and how often will we need to print this anyway?
    sort_rep();
    StringBuffer sb = new StringBuffer();
    sb.append("{ ");
    for (int i=0; i<num_elts; i++) {
      if (i != 0)
        sb.append(", ");
      sb.append(TOSTRING(elts[i]));
    }
    sb.append(" }");
    return sb.toString();
  }

  public String repr() {
    return ONEOFSCALAR_STRING + varNames() + ": "
      + "falsified=" + falsified
      + ", num_elts=" + num_elts
      + ", elts=" + subarray_rep();
  }

#if defined(IS_SEQUENCE_NUMERIC)
  private boolean all_nulls(int value_no) {
    INT seq = elts[value_no];
    for (int i=0; i<seq.length; i++) {
      if (seq[i] != 0) return false;
    }
    return true;
  }
  private boolean no_nulls(int value_no) {
    INT seq = elts[value_no];
    for (int i=0; i<seq.length; i++) {
      if (seq[i] == 0) return false;
    }
    return true;
  }
#endif


  public String format_using(OutputFormat format) {
    sort_rep();
    if (format == OutputFormat.DAIKON) {
      return format_daikon();
    } else if (format == OutputFormat.JAVA) {
      return format_java();
    } else if (format == OutputFormat.IOA) {
      return format_ioa();
    } else if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    } else if (format == OutputFormat.ESCJAVA) {
      return format_esc();
    } else if (format == OutputFormat.JML) {
      return format_jml();
    } else {
      return format_unimplemented(format);
    }
  }

  public String format_daikon() {
    String varname = NAME;
    if (num_elts == 1) {
#if defined(SCALAR) || defined(ELT)
      if (is_boolean) {
        Assert.assertTrue((elts[0] == 0) || (elts[0] == 1));
        return varname + " == " + ((elts[0] == 0) ? "false" : "true");
      } else if (is_hashcode) {
        if (elts[0] == 0) {
          return varname + " == " + "null";
        } else {
          return varname + " has only one value"
            // + " (hashcode=" + elts[0] + ")"
            ;
        }
      } else {
        return varname + " == " + TOSTRING(elts[0]);
      }
#elif defined(SEQUENCE)
      if (is_hashcode) {
        // we only have one value, because add_modified dies if more
        Assert.assertTrue(num_elts == 1);
        INT value = elts[0];
        if (value.length == 0) {
          return varname + " == []";
        } else if ((value.length == 1) && (value[0] == 0)) {
          return varname + " == [null]";
        } else if (no_nulls(0)) {
          return varname + " contains no nulls and has only one value, of length " + value.length;
        } else if (all_nulls(0)) {
          return varname + " contains only nulls and has only one value, of length " + value.length;
        } else {
          return varname + " has only one value, of length " + value.length;
        }
      } else {
        return varname + " == " + TOSTRING(elts[0]);
      }
#else
      return varname + " == " + TOSTRING(elts[0]);
#endif
    } else {
      return varname + " one of " + subarray_rep();
    }
  }


#if defined(STRING) || defined(ELTSTRING)
  private boolean is_type() {
    return var().name.hasNodeOfType(VarInfoName.TypeOf.class);
  }
#endif

  /*
    public String format_java() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < num_elts; i++) {
    sb.append (" || (" + JAVA_NAME + JAVA_EQUALS_STRING(TOSTRING(elts[i])));
    sb.append (")");
    }
    // trim off the && at the beginning for the first case
    return sb.toString().substring (4);
    }
  */

  public String format_java() {
    // have to take a closer look at this!
    sort_rep();
#if defined(IS_ELT)
    String[] form = VarInfoName.QuantHelper.format_java(new VarInfoName[] { var().name } );
    String varname = form[1];
#elif defined(IS_SCALAR)
    String varname = var().name.java_name();
#endif
    String result;

#if defined(STRING) || defined(ELTSTRING)
    result = "";
    boolean is_type = is_type();
    for (int i=0; i<num_elts; i++) {
      if (i != 0) { result += " || "; }
      result += varname;
      String str = elts[i];
      if (!is_type) {
        result += JAVA_EQUALS_STRING(TOSTRING(str));
      } else {
        result += " == ";
        if ((str == null) || "null".equals(str)) {
          result += "== null)";
        } else if (str.startsWith("[")) {
          result += "(" + UtilMDE.classnameFromJvm(str) + ")";
        } else {
          if (str.startsWith("\"") && str.endsWith("\"")) {
            str = str.substring(1, str.length()-1);
          }
          result += "(" + str + ")";
        }
      }
    }
#elif defined(IS_NUMERIC) || defined(IS_ELT_NUMERIC)
#if defined(BASE_INT)
    if (is_boolean) {
      Assert.assertTrue(num_elts == 1);
      Assert.assertTrue((elts[0] == 0) || (elts[0] == 1));
      result = varname + " == " + ((elts[0] == 0) ? "false" : "true");
    } else if (is_hashcode) {
      if (num_elts == 2) {
        return "true";          // one elt is null, the other is non-null
      } else if (elts[0] == 0) {
        result = varname + " == " + "null";
      } else {
        result = varname + " != null";
          // varname + " has only one value"
          // + " (hashcode=" + elts[0] + ")"
          ;
      }
    } else
#endif
    {
      result = "";
      for (int i=0; i<num_elts; i++) {
        if (i != 0) { result += " || "; }
        // Not quite right for the case of NaN, I think.
        result += varname + " == " + TOSTRING(elts[i]);
      }
    }
#elif defined(IS_SEQUENCE_NUMERIC)
    String length = "";
    String forall = "";
#if defined(SEQUENCE)
    if (is_hashcode) {
      if (num_elts == 0)  {
        String classname = this.getClass().toString().substring(6); // remove leading "class"
        result = "warning: method " + classname + ".format_java() needs to be implemented: " + format();
      } else {
        Assert.assertTrue(num_elts == 1);
        // we only have one value, because add_modified dies if more
        INT value = elts[0];
        if (var().name.isApplySizeSafe()) {
          length = var().name.applySize().java_name() + " == " + value.length;
        }
        if (no_nulls(0)) {
          String[] form = VarInfoName.QuantHelper.format_java(new VarInfoName[] { var().name } );
          forall = form[0] + "(" + form[1] + " != null)" + form[2];
        } else if (all_nulls(0)) {
          String[] form = VarInfoName.QuantHelper.format_java(new VarInfoName[] { var().name } );
          forall = form[0] + "(" + form[1] + " == null)" + form[2];
        }
      }
    }
#endif
    if (length == "" && forall == "") { // interned
      String classname = this.getClass().toString().substring(6); // remove leading "class"
      result = "warning: method " + classname + ".format_java() needs to be implemented: " + format();
    } else if (length == "") { // interned
      result = forall;
    } else if (forall == "") { // interned
      result = length;
    } else {
      result = "(" + length + ") && (" + forall + ")";
    }
#else
    String classname = this.getClass().toString().substring(6); // remove leading "class"
    result = "warning: method " + classname + ".format_java() needs to be implemented: " + format();
#endif
#if defined(IS_ELT)
    result = form[0] + "(" + result + ")" + form[2];
#endif
    return result;
  }

  /* IOA */
  public String format_ioa() {
    sort_rep();
#if defined(IS_ELT)
    VarInfoName.QuantHelper.IOAQuantification quant =
      new VarInfoName.QuantHelper.IOAQuantification (new VarInfo[] {var()});
    String varname = quant.getVarName(0).ioa_name();
#elif defined(IS_SCALAR)
    String varname = var().name.ioa_name();
#endif
    String result;

#if defined(STRING) || defined(ELTSTRING)
    result = "";
    for (int i=0; i<num_elts; i++) {
      if (i != 0) { result += " \\/ ("; }
      result += varname + " = " + TOSTRING(elts[i]) + ")";
    }
    result += ")";


    /*
    result = "(";
    for (int i=0; i<num_elts; i++) {
      if (i != 0) { result += " \\/ ("; }
      result += varname + " = ";
      String str = elts[i];
      if (!is_type()) {
        result += TOSTRING(str);
      } else {
        if ((str == null) || "null".equals(str)) {
          result += "\\typeof(null)";
        } else if (str.startsWith("[")) {
          result += "\\type(" + UtilMDE.classnameFromJvm(str) + ")";
        } else {
          if (str.startsWith("\"") && str.endsWith("\"")) {
            str = str.substring(1, str.length()-1);
          }
          result += "\\type(" + str + ")";
        }
        result += "***";   // to denote that it's not correct IOA syntax
      }
      result += ")";
    } // end for
    */

#elif defined(SCALAR) || defined(ELT) || defined(FLOAT) || defined(ELTFLOAT)
#if defined(SCALAR) || defined(ELT)
    if (is_boolean) {
      Assert.assertTrue(num_elts == 1);
      Assert.assertTrue((elts[0] == 0) || (elts[0] == 1));
      result = varname + " = " + ((elts[0] == 0) ? "false" : "true");
    } else if (is_hashcode) {
      Assert.assertTrue(num_elts == 1);
      if (elts[0] == 0) {
        result = varname + " = " + "null";
      } else {
        result = varname + " = " + "{one value}";
      }
    } else
#endif
    {
      result = "";
      for (int i=0; i<num_elts; i++) {
        if (i != 0) { result += " \\/ "; }
        result += "(" + varname + " = " + TOSTRING(elts[i]) + ")";
      }
    }
#elif defined(IS_SEQUENCE_NUMERIC)
    String length = "";
    String forall = "";
#if defined(SEQUENCE)
    if (is_hashcode) {
      // we only have one value, because add_modified dies if more
      Assert.assertTrue(num_elts == 1);
      INT value = elts[0];
      if (var().name.isApplySizeSafe()) {
        length = "size(" + var().name.ioa_name() + ") = " + value.length;
      }
      VarInfoName.QuantHelper.IOAQuantification quant = new VarInfoName.QuantHelper.IOAQuantification (var ());
      if (no_nulls(0)) {
        forall = quant.getQuantifierExp() + quant.getVarIndexed(0) + " ~= null " + quant.getClosingExp();
      } else if (all_nulls(0)) {
        forall = quant.getQuantifierExp() + quant.getVarIndexed(0) + " = null " + quant.getClosingExp();
      }
    }
#endif
    if (length == "" && forall == "") { // interned; can't say anything about size or elements
      String thisclassname = this.getClass().getName();
      result = "warning: " + thisclassname + ".format_ioa() " + " needs to be implemented: " + format();
    } else if (length == "") { // interned; can't say anything about size
      result = forall;
    } else if ((forall == "") || (elts[0].length == 0)) { // interned; can't say anything about elements
      result = length;
    } else { // Default, can say about both length and elements
      result = "(" + length + ") /\\ (" + forall + ")";
    }
#elif defined(STRINGSEQUENCE)
    INT value = elts[0];
    if (var().name.isApplySizeSafe())
      result = "size(" + var().name.ioa_name() + ") = " + value.length;
    else {
      String thisclassname = this.getClass().getName();
      result = "warning: " + thisclassname + ".format_ioa() needs to be implemented: " + format();
    }
#endif
#if defined(IS_ELT)
    result = quant.getQuantifierExp() + quant.getMembershipRestriction(0) + " => " + result + quant.getClosingExp();
#endif
    return result;
  }

#if defined(BASE_STRING)
  private static String format_esc_string2type(String str) {
    if ((str == null) || "null".equals(str)) {
      return "\\typeof(null)";
    } else if (str.startsWith("[")) {
      return "\\type(" + UtilMDE.classnameFromJvm(str) + ")";
    } else {
      if (str.startsWith("\"") && str.endsWith("\"")) {
        str = str.substring(1, str.length()-1);
      }
      return "\\type(" + str + ")";
    }
  }
#endif

#if defined(ELTSTRING) || defined(STRINGSEQUENCE)
  public boolean isValidEscExpression() {
    // format_esc will look at the particulars and decide
    return true;
  }
#endif

  public String format_esc() {
    sort_rep();
#if defined(IS_ELT)
    String[] form = VarInfoName.QuantHelper.format_esc(new VarInfoName[] { var().name } );
    String varname = form[1];
#elif defined(IS_SCALAR)
    String varname = var().name.esc_name();
#endif
    String result;
#if defined(ELTSTRING)
    // We cannot say anything about Strings in ESC, just types (which
    // Daikon stores as Strings).
    boolean valid = false;
    result = null;
    if (is_type() && num_elts == 1) {
      VarInfoName hunt = var().name;
      if (hunt instanceof VarInfoName.Prestate) {
        hunt = ((VarInfoName.Prestate) hunt).term;
      }
      if (hunt instanceof VarInfoName.TypeOf) {
        hunt = ((VarInfoName.TypeOf) hunt).term;
        if (hunt instanceof VarInfoName.Elements) {
          VarInfoName contents = ((VarInfoName.Elements) hunt).term;
          VarInfo elems_var = ppt.parent.findVar(hunt);
          if (elems_var != null) {
            if (! elems_var.type.isArray()) {
              varname = contents.esc_name();
              String type = format_esc_string2type(elts[0]);
              result = varname + ".elementType == " + type;
              // Do not use the \forall, return this directly
              return result;
            } else {
              valid = true;
              result = "";
              for (int i=0; i<num_elts; i++) {
                if (i != 0) { result += " || "; }
                result += varname + " == " + format_esc_string2type(elts[i]);
              }
            }
          }
        }
      }
    }
    if (! valid) {
      result = format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
    }
#elif defined(STRING)
    // We cannot say anything about Strings in ESC, just types (which
    // Daikon stores as Strings).
    if (! is_type()) {
      result = format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
    }

    // Format   \typeof(theArray) = "[Ljava.lang.Object;"
    //   as     \typeof(theArray) == \type(java.lang.Object[])
    // ... but still ...
    // format   \typeof(other) = "package.SomeClass;"
    //   as     \typeof(other) == \type(package.SomeClass)

    result = "";
    for (int i=0; i<num_elts; i++) {
      if (i != 0) { result += " || "; }
      result += varname + " == " + format_esc_string2type(elts[i]);
    }

    // Inner classes
    result = result.replace('$', '.');
#elif defined(SCALAR) || defined(ELT) || defined(FLOAT) || defined(ELTFLOAT)
#if defined(SCALAR) || defined(ELT)
    if (is_boolean) {
      Assert.assertTrue(num_elts == 1);
      Assert.assertTrue((elts[0] == 0) || (elts[0] == 1));
      result = varname + " == " + ((elts[0] == 0) ? "false" : "true");
    } else if (is_hashcode) {
      if (num_elts == 1) {
        if (elts[0] == 0) {
          result = varname + " == " + "null";
        } else {
          result = varname + " != null";
          // varname + " has only one value"
          // + " (hashcode=" + elts[0] + ")"
          ;
        }
      } else if (num_elts == 2) {
        // add_modified allows two elements iff one is null
        Assert.assertTrue(elts[0] == 0);
        Assert.assertTrue(elts[1] != 0);
        return format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
      } else if (num_elts == 0) {
        // Do nothing
        return format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
      } else {
        throw new Error ("Contains more than 2 elements");
      }
    } else
#endif
    {
      result = "";
      for (int i=0; i<num_elts; i++) {
        if (i != 0) { result += " || "; }
        result += varname + " == " + TOSTRING(elts[i]);
      }
    }
#elif defined(IS_SEQUENCE_NUMERIC)
    String length = "";
    String forall = "";
#if defined(SEQUENCE)
    if (is_hashcode) {
      // we only have one value, because add_modified dies if more
      Assert.assertTrue(num_elts == 1);
      INT value = elts[0];
      if (var().type.isArray()) {
        if (var().name.isApplySizeSafe()) {
          length = var().name.applySize().esc_name() + " == " + value.length;
        }
        if (no_nulls(0)) {
          String[] form = VarInfoName.QuantHelper.format_esc(new VarInfoName[] { var().name } );
          forall = form[0] + "(" + form[1] + " != null)" + form[2];
        } else if (all_nulls(0)) {
          String[] form = VarInfoName.QuantHelper.format_esc(new VarInfoName[] { var().name } );
          forall = form[0] + "(" + form[1] + " == null)" + form[2];
        }
      }
    }
#endif
    if (length == "" && forall == "") { // interned
      return format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
    } else if (length == "") { // interned
      result = forall;
    } else if (forall == "") { // interned
      result = length;
    } else {
      result = "(" + length + ") && (" + forall + ")";
    }
#elif defined(STRINGSEQUENCE)
    // If the variable expression is a raw sequence, examine its
    // element type(s).
    if (var().name instanceof VarInfoName.TypeOf) {
      VarInfoName term = ((VarInfoName.TypeOf) var().name).term;
      if (term instanceof VarInfoName.Elements) {
        String varname = ((VarInfoName.Elements) term).term.esc_name();
        String type = null;
        boolean consistent = true;
        for (int i=0; consistent && i<num_elts; i++) {
          String[] elt = elts[i];
          for (int j=0; consistent && j<elt.length; j++) {
            String maybe = format_esc_string2type(elt[j]);
            if (type == null) {
              type = maybe;
            } else {
              consistent &= type.equals(maybe);
            }
          }
        }
        if (consistent && (type != null)) {
          VarInfo term_var = ppt.parent.findVar(term);
          if (term_var != null) {
            if (term_var.type.isArray()) {
              return "\\elemtype(" + varname + ") == " + type;
            } else {
              return varname + ".elementType == " + type;
            }
          }
        }
      }
    }
    result = format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
#endif
#if defined(IS_ELT)
    result = form[0] + "(" + result + ")" + form[2];
#endif
    return result;
  }

  public String format_jml() {
#if defined(IS_ELT)
    String[] form = VarInfoName.QuantHelper.format_jml(new VarInfoName[] { var().name } );
    String varname = form[1];
#elif defined(IS_SCALAR)
    String varname = var().name.JMLElementCorrector().jml_name();
#endif
    String result;
#if defined(STRING) || defined(ELTSTRING)

    result = "";
    boolean is_type = is_type();
    for (int i=0; i<num_elts; i++) {
      if (i != 0) { result += " || "; }
      result += varname;
      String str = elts[i];
      if (!is_type) {
        result += JAVA_EQUALS_STRING(TOSTRING(str));
      } else {
        result += " == \\type";
        if ((str == null) || "null".equals(str)) {
          // "null" is not a type... Going to print as Object... should actually not print
          result += "(java.lang.Object)";
        } else if (str.startsWith("[")) {
          result += "(" + UtilMDE.classnameFromJvm(str) + ")";
        } else {
          if (str.startsWith("\"") && str.endsWith("\"")) {
            str = str.substring(1, str.length()-1);
          }
          result += "(" + str + ")";
        }
      }
    }
#elif defined(SCALAR) || defined(ELT) || defined(FLOAT) || defined(ELTFLOAT)
#if defined(SCALAR) || defined(ELT)
    if (is_boolean) {
      Assert.assertTrue(num_elts == 1);
      Assert.assertTrue((elts[0] == 0) || (elts[0] == 1));
      result = varname + " == " + ((elts[0] == 0) ? "false" : "true");
    } else if (is_hashcode) {
      if (num_elts == 2) {
        return "true";          // one elt is null, the other is non-null
      } else if (elts[0] == 0) {
        result = varname + " == " + "null";
      } else {
        result = varname + " != null";
          // varname + " has only one value"
          // + " (hashcode=" + elts[0] + ")"
          ;
      }
    } else
#endif
    {
      result = "";
      for (int i=0; i<num_elts; i++) {
        if (i != 0) { result += " || "; }
        result += varname + " == " + TOSTRING(elts[i]);
      }
    }
#elif defined(SEQUENCE) || defined(FLOATSEQUENCE)
    String length = "";
    String forall = "";
#if defined(SEQUENCE)
    if (is_hashcode) {
      if (num_elts == 0)  {
        String classname = this.getClass().toString().substring(6); // remove leading "class"
        result = "warning: method " + classname + ".format_jml() needs to be implemented: " + format();
      } else {
        Assert.assertTrue(num_elts == 1);
        // we only have one value, because add_modified dies if more
        INT value = elts[0];
        if (var().name.isApplySizeSafe()) {
          length = var().name.applySize().jml_name() + " == " + value.length;
        }
        if (no_nulls(0)) {
          String[] form = VarInfoName.QuantHelper.format_jml(new VarInfoName[] { var().name } );
          forall = form[0] + form[1] + " != null" + form[2];
        } else if (all_nulls(0)) {
          String[] form = VarInfoName.QuantHelper.format_jml(new VarInfoName[] { var().name } );
          forall = form[0] + form[1] + " == null" + form[2];
        }
      }
    }
#endif
    if (length == "" && forall == "") { // interned
      String classname = this.getClass().toString().substring(6); // remove leading "class"
      result = "warning: method " + classname + ".format_jml() needs to be implemented: " + format();
    } else if (length == "") { // interned
      result = forall;
    } else if (forall == "") { // interned
      result = length;
    } else {
      result = "(" + length + ") && (" + forall + ")";
    }
#else
    String classname = this.getClass().toString().substring(6); // remove leading "class"
    result = "warning: method " + classname + ".format_jml() needs to be implemented: " + format();
#endif
#if defined(IS_ELT)
    result = form[0] + result + form[2];
#endif
    return result;
  }

  public String format_simplify() {
#if defined(FLOAT)
    return "format_simplify failed: " +
      "Simplify can't express floating point constants";
#else
    sort_rep();
#if defined(IS_ELT)
    String[] form = VarInfoName.QuantHelper.format_simplify(new VarInfoName[] { var().name } );
    String varname = form[1];
#elif defined(IS_SCALAR)
    String varname =
      var().simplifyFixup(var().name.name_using(OutputFormat.SIMPLIFY));
#endif
    String result;
#if defined(STRING) || defined(ELTSTRING)
    result = "";
    boolean is_type = is_type();
    if (!is_type) {
      return "format_simplify " + this.getClass() + " cannot express Strings";
    }
    for (int i=0; i<num_elts; i++) {
      String value = elts[i];
      if (value == null) {
        // do nothing
      } else if (value.startsWith("[")) {
        value = UtilMDE.classnameFromJvm(value);
      } else if (value.startsWith("\"") && value.endsWith("\"")) {
        value = value.substring(1, value.length()-1);
      }
      value = "|T_" + value + "|";
      result += " (EQ " + varname + " " + value + ")";
    }
    if (num_elts > 1) {
      result = "(OR" + result + ")";
    } else {
      // chop leading space
      result = result.substring(1);
    }
#elif defined(SCALAR) || defined(ELT) || defined(FLOAT) || defined(ELTFLOAT)
#if defined(SCALAR) || defined(ELT)
    if (is_boolean) {
      Assert.assertTrue(num_elts == 1);
      Assert.assertTrue((elts[0] == 0) || (elts[0] == 1));
      result = "(EQ " + varname + " " + ((elts[0] == 0) ? "|@false|" : "|@true|") + ")";
    } else if (is_hashcode) {
      if (num_elts == 1) {
        result = "(EQ " + varname + " " + ((elts[0] == 0) ? "null" : ("|hash_" + elts[0] + "|")) + ")";
      } else if (num_elts == 2) {
        // add_modified allows two elements iff one is null
        Assert.assertTrue(elts[0] == 0);
        Assert.assertTrue(elts[1] != 0);
        result = "(OR (EQ " + varname + " null) (EQ " + varname + "|hash_" + elts[1] + "|))";
      } else if (num_elts == 0) {
        return format_unimplemented(OutputFormat.SIMPLIFY); // "needs to be implemented"
      } else {
        throw new Error ("Contains more than 2 elements");
      }
    } else
#endif
    {
      result = "";
      for (int i=0; i<num_elts; i++) {
        result += " (EQ " + varname + " " + TOSTRING(elts[i]) + ")";
      }
      if (num_elts > 1) {
        result = "(OR" + result + ")";
      } else {
        // chop leading space
        result = result.substring(1);
      }
    }
#elif defined(SEQUENCE)
    String length = "";
    String forall = "";
    if (is_hashcode) {
      // we only have one value, because add_modified dies if more
      Assert.assertTrue(num_elts == 1);
      INT value = elts[0];
      if (var().name.isApplySizeSafe()) {
        length = "(EQ " + var().name.applySize().simplify_name() + " " + value.length + ")";
      }
      if (no_nulls(0)) {
        String[] form = VarInfoName.QuantHelper.format_simplify(new VarInfoName[] { var().name } );
        forall = form[0] + "(NEQ " + form[1] + "  null)" + form[2];
      } else if (all_nulls(0)) {
        String[] form = VarInfoName.QuantHelper.format_simplify(new VarInfoName[] { var().name } );
        forall = form[0] + "(EQ " + form[1] + "  null)" + form[2];
      }
    }
    if (length == "" && forall == "") { // interned
      String classname = this.getClass().toString().substring(6); // remove leading "class"
      result = "warning: method " + classname + ".format_simplify() needs to be implemented: " + format();
    } else if (length == "") { // interned
      result = forall;
    } else if (forall == "") { // interned
      result = length;
    } else {
      result = "(AND " + length + " " + forall + ")";
    }
#else
    String classname = this.getClass().toString().substring(6); // remove leading "class"
    result =  "warning: method " + classname + ".format_simplify() needs to be implemented: " + format();
#endif
#if defined(IS_ELT)
    result = form[0] + result + form[2];
#endif
    return result;
#endif
  }

#if defined(IS_ELT)
  public void add_modified(INT[] a, int count) {
  OUTER:
   for (int ai=0; ai<a.length; ai++) {
    INT v = a[ai];
#else
  public void add_modified(INT v, int count) {
#if !(defined(SCALAR) || defined(FLOAT))
    Assert.assertTrue(Intern.isInterned(v));
#endif
#endif
    for (int i=0; i<num_elts; i++)
      if (elts[i] == v) {
#if defined(IS_ELT)
        continue OUTER;
#else
        return;
#endif
      }
    if (num_elts == dkconfig_size) {
      destroyAndFlow();
      return;
    }
#if defined(STRING) || defined(ELTSTRING)
    if (is_type() && (num_elts == 1)) {
      destroyAndFlow();
      return;
    }
#elif defined(SEQUENCE)
    if (is_hashcode && (num_elts == 1)) {
      destroyAndFlow();
      return;
    }
#elif defined(SCALAR) || defined(ELT)
    if ((is_boolean && (num_elts == 1))
        || (is_hashcode && (num_elts == 2))) {
      destroyAndFlow();
      return;
    }
    if (is_hashcode && (num_elts == 1)) {
      // Permit two object values only if one of them is null
      if ((elts[0] != 0) && (v != 0)) {
        destroyAndFlow();
        return;
      }
    }
#endif
    // We are significantly changing our state (not just zeroing in on
    // a constant), so we have to flow a copy before we do so.  We even
    // need to clone if this has 0 elements becuase otherwise, lower
    // ppts will get versions of this with multiple elements once this is
    // expanded.
    cloneAndFlow();

    elts[num_elts] = v;
    num_elts++;
#if defined(IS_ELT)
   }
  }
#else
  }
#endif

#if defined(IS_ELT)
  // It is possible to have seen many (array) samples, but no (INT)
  // array element values.
  public boolean enoughSamples() {
    return num_elts > 0;
  }
#endif

  protected double computeProbability() {
    // This is not ideal.
    if (num_elts == 0) {
      return Invariant.PROBABILITY_UNJUSTIFIED;
#if defined(SCALAR) || defined(ELT)
    } else if (is_hashcode && (num_elts > 1)) {
      // This should never happen
      return Invariant.PROBABILITY_UNJUSTIFIED;
#endif
    } else {
      return Invariant.PROBABILITY_JUSTIFIED;
    }
  }

  public boolean isObviousStatically() {
    // Static constants are necessarily OneOf precisely one value.
    // This removes static constants from the output, which might not be
    // desirable if the user doesn't know their actual value.
    if (var().isStaticConstant()) {
      Assert.assertTrue(num_elts <= 1);
      return true;
    }
    return super.isObviousStatically();
  }

#if defined(IS_NUMERIC)
  public boolean isObviousDynamically() {
    VarInfo v = var();
    if (v.isDerived() && (v.derived instanceof SequenceLength)) {
      SequenceLength sl = (SequenceLength) v.derived;
      if (sl.shift != 0) {
        return true;
      }
    }

    // For every ELTONEOF at this program point, see if this variable is
    // an obvious member of that sequence.
    PptTopLevel parent = ppt.parent;
    for (Iterator itor = parent.invariants_iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if ((inv instanceof ELTONEOF) && inv.enoughSamples()) {
        VarInfo v1 = var();
        VarInfo v2 = inv.ppt.var_infos[0];
        // System.out.println("isObviousImplied: calling  Member.isObviousMember(" + v1.name + ", " + v2.name + ")");
        // Don't use isEqualToObviousMember:  that is too subtle
        // and eliminates desirable invariants such as "return == null".
        if (Member.isObviousMember(v1, v2)) {
          ELTONEOF other = (ELTONEOF) inv;
          if (num_elts == other.num_elts()) {
            sort_rep();
            if (other.compare_rep(num_elts, elts)) {
              // System.out.println("isObviousImplied true");
              return true;
            }
          }
        }
      }
    }

    return super.isObviousDynamically();
  }
#elif defined(IS_ELT_NUMERIC)
  public boolean isObviousDynamically() {
    VarInfo v = var();
    // Look for the same property over a supersequence of this one.
    PptTopLevel pptt = ppt.parent;
    for (Iterator inv_itor = pptt.invariants_iterator(); inv_itor.hasNext(); ) {
      Invariant inv = (Invariant) inv_itor.next();
      if (inv == this) {
        continue;
      }
      if (inv instanceof ONEOFSCALAR) {
        ONEOFSCALAR other = (ONEOFSCALAR) inv;
        if (isSameFormula(other)
            && SubSequence.isObviousDerived(v, other.var())) {
          return true;
        }
      }
    }

    return super.isObviousDynamically();
  }
#endif

  public boolean isSameFormula(Invariant o)
  {
    ONEOFSCALAR other = (ONEOFSCALAR) o;
    if (num_elts != other.num_elts)
      return false;
    if (num_elts == 0 && other.num_elts == 0)
      return true;

    sort_rep();
    other.sort_rep();

#if defined(SCALAR) || defined(ELT)
    // All nonzero hashcode values should be considered equal to each other
    //
    // Examples:
    // inv1  inv2  result
    // ----  ----  ------
    // 19    0     false
    // 19    22    true
    // 0     0     true

    if (is_hashcode && other.is_hashcode) {
      if (num_elts == 1 && other.num_elts == 1) {
        return ((elts[0] == 0 && other.elts[0] == 0) ||
                (elts[0] != 0 && other.elts[0] != 0));
      } else if (num_elts == 2 && other.num_elts == 2) {
        // add_modified allows two elements iff one is null
        Assert.assertTrue(elts[0] == 0);
        Assert.assertTrue(other.elts[0] == 0);
        Assert.assertTrue(elts[1] != 0);
        Assert.assertTrue(other.elts[1] != 0);

        // Since we know the first elements of each invariant are
        // zero, and the second elements are nonzero, we can immediately
        // return true
        return true;
      } else {
        return false;
      }
    }
#elif defined(SEQUENCE)
    // All nonzero hashcode values should be considered equal to each other
    //
    // Examples:
    // inv1     inv2     result
    // -------  -------  ------
    // {19,23}  {91,0}   false
    // {19,23}  {91,32}  true
    // {19,0}   {91,0}   true
    // {0,0}    {0,0}    true

    if (is_hashcode && other.is_hashcode) {
      // we only have one value, because add_modified dies if more
      Assert.assertTrue(num_elts == 1 && other.num_elts == 1);

      INT thisSeq = elts[0];
      INT otherSeq = other.elts[0];
      if (thisSeq.length != otherSeq.length) {
        return false;
      }

      for (int i=0; i < thisSeq.length; i++) {
        if ((thisSeq[i] == 0 && otherSeq[i] != 0) ||
            (thisSeq[i] != 0 && otherSeq[i] == 0)) {
          return false;
        }
      }

      return true;
    }
#endif

    for (int i=0; i < num_elts; i++) {
      if (! EQUALS(elts[i],other.elts[i]))
        return false;
    }

    return true;
  }

  public boolean isExclusiveFormula(Invariant o)
  {
    if (o instanceof ONEOFSCALAR) {
      ONEOFSCALAR other = (ONEOFSCALAR) o;

      for (int i=0; i < num_elts; i++) {
        for (int j=0; j < other.num_elts; j++) {
          if (EQUALS(elts[i],other.elts[j])) // elements are interned
            return false;
        }
      }
#if defined(SCALAR) || defined(ELT)
      // Don't consider two instances of "non-null" as exclusive.
      if (is_hashcode && num_elts == 1
          && other.is_hashcode && other.num_elts == 1
          && elts[0] != 0 && other.elts[0] != 0) {
        return false;
      }
#endif

      return true;
    }
#if defined(IS_NUMERIC) || defined(IS_ELT_NUMERIC)
    // Many more checks can be added here:  against nonzero, modulus, etc.
    if ((o instanceof NONZERO) && (num_elts == 1) && (elts[0] == 0)) {
      return true;
    }
    INT elts_min = NUMWRAPPER.MAX_VALUE;
    INT elts_max = NUMWRAPPER.MIN_VALUE;
    for (int i=0; i < num_elts; i++) {
      elts_min = Math.min(elts_min, elts[i]);
      elts_max = Math.max(elts_max, elts[i]);
    }
    if ((o instanceof LOWERBOUND) && (elts_max < ((LOWERBOUND)o).core.min1))
      return true;
    if ((o instanceof UPPERBOUND) && (elts_min > ((UPPERBOUND)o).core.max1))
      return true;
#endif

    return false;
  }

  // OneOf invariants that indicate a small set of possible values are
  // uninteresting.  OneOf invariants that indicate exactly one value
  // are interesting.
  public boolean isInteresting() {
    if (num_elts() > 1) {
      return false;
    } else {
      return true;
    }
  }

  // Look up a previously instantiated invariant.
  public static ONEOFSCALAR find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof ONEOFSCALAR)
        return (ONEOFSCALAR) inv;
    }
    return null;
  }

  // Interning is lost when an object is serialized and deserialized.
  // Manually re-intern any interned fields upon deserialization.
  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();
    for (int i=0; i < num_elts; i++)
      elts[i] = Intern.intern(elts[i]);
  }

}
