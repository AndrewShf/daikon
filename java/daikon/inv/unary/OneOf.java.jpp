#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(SCALAR) || defined(STRING) || defined(SEQUENCE) || defined(STRINGSEQUENCE) || defined(ELT) || defined(ELTSTRING))
#error "One of SCALAR, STRING, SEQUENCE, STRINGSEQUENCE, ELT, or ELTSTRING should be defined"
#endif

#if defined(SCALAR)
#define SCALARPKG scalar
#define INT long
#define ONEOFSCALAR OneOfScalar
#define ONEOFSCALARSTR "OneOfScalar"
#define SINGLESCALAR SingleScalar
#define TOSTRING(x) x
#define NAME var().name.name()
#define DEFLIMIT 5
#elif defined(STRING)
#define SCALARPKG string
#define INT String
#define ONEOFSCALAR OneOfString
#define ONEOFSCALARSTR "OneOfString"
#define SINGLESCALAR SingleString
#define TOSTRING(x) ((x==null) ? "null" : "\"" + UtilMDE.quote(x) + "\"")
#define NAME var().name.name()
#define DEFLIMIT 3
#elif defined(SEQUENCE)
#define SCALARPKG sequence
#define INT long[]
#define ONEOFSCALAR OneOfSequence
#define ONEOFSCALARSTR "OneOfSequence"
#define SINGLESCALAR SingleSequence
#define TOSTRING(x) ArraysMDE.toString(x)
#define NAME var().name.name()
#define DEFLIMIT 3
#elif defined(STRINGSEQUENCE)
#define SCALARPKG stringsequence
#define INT String[]
#define ONEOFSCALAR OneOfStringSequence
#define ONEOFSCALARSTR "OneOfStringSequence"
#define SINGLESCALAR SingleStringSequence
#define TOSTRING(x) ArraysMDE.toString(x)
#define NAME var().name.name()
#define DEFLIMIT 2
#elif defined(ELT)
#define SCALARPKG sequence
#define INT long
#define ONEOFSCALAR EltOneOf
#define ONEOFSCALARSTR "EltOneOf"
#define SINGLESCALAR SingleSequence
#define TOSTRING(x) ((!var().type.elementIsIntegral() && (x == 0)) ? "null" : (Long.toString(x)))
#define NAME var().name.name() + " elements"
#define DEFLIMIT 5
#elif defined(ELTSTRING)
#define SCALARPKG stringsequence
#define INT String
#define ONEOFSCALAR EltOneOfString
#define ONEOFSCALARSTR "EltOneOfString"
#define SINGLESCALAR SingleStringSequence
#define TOSTRING(x) ((x==null) ? "null" : "\"" + UtilMDE.quote(x) + "\"")
#define NAME var().name.name() + " elements"
#define DEFLIMIT 3
#else
#error "One of SCALAR, STRING, SEQUENCE, STRINGSEQUENCE, ELT, or ELTSTRING should be defined"
#endif

package daikon.inv.unary.SCALARPKG;

import daikon.*;
import daikon.inv.*;
import daikon.derive.unary.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.binary.sequenceScalar.*;

import utilMDE.*;

import java.util.*;
import java.io.*;

// *****
// Do not edit this file directly:
// it is automatically generated from OneOf.java.jpp
// *****

// States that the value is one of the specified values.

// This subsumes an "exact" invariant that says the value is always exactly
// a specific value.  Do I want to make that a separate invariant
// nonetheless?  Probably not, as this will simplify implication and such.

public final class ONEOFSCALAR extends SINGLESCALAR implements OneOf {
  final static int LIMIT = DEFLIMIT;	// maximum size for the one_of list
  // Probably needs to keep its own list of the values, and number of each seen.
  // (That depends on the slice; maybe not until the slice is cleared out.
  // But so few values is cheap, so this is quite fine for now and long-term.)

  private INT[] elts;
  private int num_elts;
#if defined(SCALAR) || defined(ELT) || defined(SEQUENCE)
  private boolean is_boolean;
  private boolean is_hashcode;
#endif

  ONEOFSCALAR(PptSlice ppt) {
    super(ppt);
#if defined(SEQUENCE)
    elts = new long[LIMIT][];    // elements are interned, so can test with ==
                                // (in the general online case, not worth interning)
#elif defined(STRINGSEQUENCE)
    elts = new String[LIMIT][];    // elements are interned, so can test with ==
                                // (in the general online case, not worth interning)
#else
    elts = new INT[LIMIT];
#endif
    num_elts = 0;
#if defined(SCALAR)
    is_boolean = (var().type == ProglangType.BOOLEAN);
    is_hashcode = var().type.isObject() || var().type.isArray();
#elif defined(ELT) || defined(SEQUENCE)
    Assert.assert(var().type.isPseudoArray(),
		  "ProglangType must be pseudo-array for EltOneOf or OneOfSequence");
    is_boolean = (var().type.elementType() == ProglangType.BOOLEAN);
    is_hashcode = var().type.elementType().isObject() || var().type.elementType().isArray();
#endif
  }

  public static ONEOFSCALAR instantiate(PptSlice ppt) {
    return new ONEOFSCALAR(ppt);
  }

  public int num_elts() {
    return num_elts;
  }

  public Object elt() {
    if (num_elts != 1)
      throw new Error("Represents " + num_elts + " elements");
#if defined(SCALAR) || defined(ELT)
    // Not sure whether interning is necessary (or just returning an Integer
    // would be sufficient), but just in case...
    return Intern.internedLong(elts[0]);
#else
    return elts[0];
#endif
  }

#if defined(STRING) || defined(ELTSTRING)
  static Comparator comparator = new UtilMDE.NullableStringComparator();
#define COMPARATOR_ARG , comparator
#elif defined(SEQUENCE)
  static Comparator comparator = new ArraysMDE.LongArrayComparatorLexical();
#define COMPARATOR_ARG , comparator
#elif defined(STRINGSEQUENCE)
  static Comparator comparator = new ArraysMDE.ComparableArrayComparatorLexical();
#define COMPARATOR_ARG , comparator
#else
#define COMPARATOR_ARG
#endif

  private void sort_rep() {
    Arrays.sort(elts, 0, num_elts COMPARATOR_ARG);
  }

  // Assumes the other array is already sorted
  public boolean compare_rep(int num_other_elts, INT[] other_elts) {
    if (num_elts != num_other_elts)
      return false;
    sort_rep();
    for (int i=0; i < num_elts; i++)
      if (elts[i] != other_elts[i]) // elements are interned
        return false;
    return true;
  }

  private String subarray_rep() {
    // Not so efficient an implementation, but simple;
    // and how often will we need to print this anyway?
    sort_rep();
    StringBuffer sb = new StringBuffer();
    sb.append("{ ");
    for (int i=0; i<num_elts; i++) {
      if (i != 0)
        sb.append(", ");
      sb.append(TOSTRING(elts[i]));
    }
    sb.append(" }");
    return sb.toString();
  }

  public String repr() {
    return ONEOFSCALARSTR + varNames() + ": "
      + "no_invariant=" + no_invariant
      + ", num_elts=" + num_elts
      + ", elts=" + subarray_rep();
  }

#if defined(SEQUENCE)
  private boolean all_nulls(int value_no) {
    INT seq = elts[value_no];
    for (int i=0; i<seq.length; i++) {
      if (seq[i] != 0) return false;
    }
    return true;
  }
  private boolean no_nulls(int value_no) {
    INT seq = elts[value_no];
    for (int i=0; i<seq.length; i++) {
      if (seq[i] == 0) return false;
    }
    return true;
  }
#endif

  public String format() {
    String varname = NAME;
    if (num_elts == 1) {
#if defined(SCALAR) || defined(ELT)
      if (is_boolean) {
        Assert.assert((elts[0] == 0) || (elts[0] == 1));
        return varname + " == " + ((elts[0] == 0) ? "false" : "true");
      } else if (is_hashcode) {
        if (elts[0] == 0) {
          return varname + " == " + "null";
        } else {
          return varname + " has only one value"
            // + " (hashcode=" + elts[0] + ")"
            ;
        }
      } else {
        return varname + " == " + TOSTRING(elts[0]);
      }
#elif defined(SEQUENCE)
      if (is_hashcode) {
	// we only have one value, b/c add_modified dies if more
	INT value = elts[0];
        if (value.length == 0) {
          return varname + " == []";
        } else if ((value.length == 1) && (value[0] == 0)) {
          return varname + " == [null]";
        } else if (no_nulls(0)) {
          return varname + " contains no nulls and has only one value, of length " + value.length;
        } else if (all_nulls(0)) {
          return varname + " contains only nulls and has only one value, of length " + value.length;
	} else {
          return varname + " has only one value, of length " + value.length;
        }
      } else {
        return varname + " == " + TOSTRING(elts[0]);
      }
#else
      return varname + " == " + TOSTRING(elts[0]);
#endif
    } else {
      return varname + " one of " + subarray_rep();
    }
  }

#if defined(STRING) || defined(ELTSTRING)
  private boolean is_type() {
    return var().name.hasNodeOfType(VarInfoName.TypeOf.class);
  }
#endif

  public String format_esc() {
#if defined(ELT) || defined(ELTSTRING)
    String[] form = VarInfoName.QuantHelper.format_esc(new VarInfoName[] { var().name } );
    String varname = form[1];
#elif defined(SCALAR) || defined(STRING)
    String varname = var().name.esc_name();
#endif
    String result;
#if defined(STRING) || defined(ELTSTRING)
    // Format   \typeof(theArray) = "[Ljava.lang.Object;"
    //   as     \typeof(theArray) == \type(java.lang.Object[])
    // ... but still ...
    // format   \typeof(other) = "package.SomeClass;"
    //   as     \typeof(other) == \type(package.SomeClass)

    result = "";
    boolean is_type = is_type();
    for (int i=0; i<num_elts; i++) {
      if (i != 0) { result += " || "; }
      result += varname + " == ";
      String str = elts[i];
      if (!is_type) {
	result += TOSTRING(str);
      } else {
	if ((str == null) || "null".equals(str)) {
	  result += "\\typeof(null)";
	} else if (str.startsWith("[")) {
	  result += "\\type(" + UtilMDE.classnameFromJvm(str) + ")";
	} else {
	  if (str.startsWith("\"") && str.endsWith("\"")) {
	    str = str.substring(1, str.length()-1);
	  }
	  result += "\\type(" + str + ")";
	}
      }
    }
#elif defined(SCALAR) || defined(ELT)
    if (is_boolean) {
      Assert.assert(num_elts == 1);
      Assert.assert((elts[0] == 0) || (elts[0] == 1));
      result = varname + " == " + ((elts[0] == 0) ? "false" : "true");
    } else if (is_hashcode) {
      Assert.assert(num_elts == 1);
      if (elts[0] == 0) {
        result = varname + " == " + "null";
      } else {
        result = varname + " has only one value"
          // + " (hashcode=" + elts[0] + ")"
          ;
      }
    } else {
      result = "";
      for (int i=0; i<num_elts; i++) {
        if (i != 0) { result += " || "; }
        result += varname + " == " + TOSTRING(elts[i]);
      }
    }
#elif defined(SEQUENCE)
    if (is_hashcode) {
      // we only have one value, b/c add_modified dies if more
      INT value = elts[0];
      result = var().name.applySize().esc_name() + " == " + value.length;
      if (no_nulls(0)) {
	String[] form = VarInfoName.QuantHelper.format_esc(new VarInfoName[] { var().name } );
	result = "(" + result + ") && " + form[0] + "(" + form[1] + " != null)" + form[2];
      } else if (all_nulls(0)) {
	String[] form = VarInfoName.QuantHelper.format_esc(new VarInfoName[] { var().name } );
	result = "(" + result + ") && " + form[0] + "(" + form[1] + " == null)" + form[2];
      }
    } else {
      result = "format_esc " + this.getClass() + " needs to be changed: " + format();
    }
#else
    result = "format_esc " + this.getClass() + " needs to be changed: " + format();
#endif
#if defined(ELT) || defined(ELTSTRING)
    result = form[0] + "(" + result + ")" + form[2];
#endif
    return result;
  }

  public String format_simplify() {
#if defined(ELT) || defined(ELTSTRING)
    String[] form = VarInfoName.QuantHelper.format_simplify(new VarInfoName[] { var().name } );
    String varname = form[1];
#elif defined(SCALAR) || defined(STRING)
    String varname = var().name.simplify_name();
#endif
    String result;
#if defined(STRING) || defined(ELTSTRING)
    result = "";
    boolean is_type = (var().name.hasNodeOfType(VarInfoName.TypeOf.class));
    if (!is_type) {
      return "format_simplify " + this.getClass() + " cannot express Strings";
    }
    for (int i=0; i<num_elts; i++) {
      String value = elts[i];
      if (value == null) {
        // do nothing
      } else if (value.startsWith("[")) {
	value = UtilMDE.classnameFromJvm(value);
      } else if (value.startsWith("\"") && value.endsWith("\"")) {
	value = value.substring(1, value.length()-1);
      }
      value = "|T_" + value + "|";
      result += " (EQ " + varname + " " + value + ")";
    }
    if (num_elts > 1) {
      result = "(OR" + result + ")";
    } else {
      // chop leading space
      result = result.substring(1);
    }
#elif defined(SCALAR) || defined(ELT)
    if (is_boolean) {
      Assert.assert(num_elts == 1);
      Assert.assert((elts[0] == 0) || (elts[0] == 1));
      result = "(EQ " + varname + " " + ((elts[0] == 0) ? "|@false|" : "|@true|") + ")";
    } else if (is_hashcode) {
      Assert.assert(num_elts == 1);
      result = "(EQ " + varname + " " + ((elts[0] == 0) ? "null" : ("hash_" + elts[0])) + ")";
    } else {
      result = "";
      for (int i=0; i<num_elts; i++) {
        result += " (EQ " + varname + " " + TOSTRING(elts[i]) + ")";
      }
      if (num_elts > 1) {
	result = "(OR" + result + ")";
      } else {
	// chop leading space
	result = result.substring(1);
      }
    }
#elif defined(SEQUENCE)
    if (is_hashcode) {
      // we only have one value, b/c add_modified dies if more
      INT value = elts[0];
      result = "(EQ " + var().name.applySize().simplify_name() + " " + value.length + ")";
      if (no_nulls(0)) {
	String[] form = VarInfoName.QuantHelper.format_simplify(new VarInfoName[] { var().name } );
	result = "(AND " + result + " " + form[0] + "(NEQ " + form[1] + "  null)" + form[2] + ")";
      } else if (all_nulls(0)) {
	String[] form = VarInfoName.QuantHelper.format_simplify(new VarInfoName[] { var().name } );
	result = "(AND " + result + " " + form[0] + "(EQ " + form[1] + "  null)" + form[2] + ")";
      }
    } else {
      result = "format_simplify " + this.getClass() + " needs to be changed: " + format();
    }
#else
    result =  "format_simplify " + this.getClass() + " needs to be changed: " + format();
#endif
#if defined(ELT) || defined(ELTSTRING)
    result = form[0] + result + form[2];
#endif
    return result;
  }

#if defined(ELT) || defined(ELTSTRING)
  public void add_modified(INT[] a, int count) {
  OUTER:
    for (int ai=0; ai<a.length; ai++) {
      INT v = a[ai];
#else
  public void add_modified(INT v, int count) {
#ifndef SCALAR
    Assert.assert(Intern.isInterned(v));
#endif
#endif
    for (int i=0; i<num_elts; i++)
      if (elts[i] == v) {
#if defined(ELT) || defined(ELTSTRING)
        continue OUTER;
#else
        return;
#endif
      }
    if (num_elts == LIMIT) {
      destroy();
      return;
    }
#if defined(STRING) || defined(ELTSTRING)
    if (is_type() && (num_elts == 1)) {
      destroy();
      return;
    }
#elif defined(SEQUENCE)
    if (is_hashcode && (num_elts == 1)) {
      destroy();
      return;
    }
#elif defined(SCALAR) || defined(ELT)
    if ((is_boolean && (num_elts == 1))
        || (is_hashcode && (num_elts == 2))) {
      destroy();
      return;
    }
    if (is_hashcode && (num_elts == 1)) {
      // Permit two object values only if one of them is null
      if ((elts[0] != 0) && (v != 0)) {
        destroy();
        return;
      }
    }
#endif    
    elts[num_elts] = v;
    num_elts++;
#if defined(ELT) || defined(ELTSTRING)
    }
  }
#else
  }
#endif


  protected double computeProbability() {
    // This is not ideal.
    if (num_elts == 0) {
      return Invariant.PROBABILITY_UNKNOWN;
#if defined(SCALAR) || defined(ELT)
    } else if (is_hashcode && (num_elts > 1)) {
      // This should never happen
      return Invariant.PROBABILITY_UNJUSTIFIED;
#endif
    } else {
      return Invariant.PROBABILITY_JUSTIFIED;
    }
  }

#ifdef SCALAR
  public boolean isObviousImplied() {
    VarInfo v = var();
    if (v.isDerived() && (v.derived instanceof SequenceLength)) {
      SequenceLength sl = (SequenceLength) v.derived;
      if (sl.shift != 0) {
        return true;
      }
    }

    // For every EltOneOf at this program point, see if this variable is
    // an obvious member of that sequence.
    PptTopLevel parent = (PptTopLevel)ppt.parent;
    for (Iterator itor = parent.invariants_iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if ((inv instanceof EltOneOf) && inv.enoughSamples()) {
        VarInfo v1 = var();
        VarInfo v2 = inv.ppt.var_infos[0];
        // System.out.println("isObviousImplied: calling  Member.isObviousMember(" + v1.name + ", " + v2.name + ")");
        // Don't use isEqualToObviousMember:  that is too subtle
        // and eliminates desirable invariants such as "return == null".
        if (Member.isObviousMember(v1, v2)) {
          EltOneOf other = (EltOneOf) inv;
          if (num_elts == other.num_elts()) {
            sort_rep();
            if (other.compare_rep(num_elts, elts)) {
              // System.out.println("isObviousImplied true");
              return true;
            }
          }
        }
      }
    }

    return false;
  }
#endif

  public boolean isSameFormula(Invariant o)
  {
    ONEOFSCALAR other = (ONEOFSCALAR) o;
    if (num_elts != other.num_elts)
      return false;

    sort_rep();
    other.sort_rep();
    for (int i=0; i < num_elts; i++)
      if (elts[i] != other.elts[i]) // elements are interned
	return false;

    return true;
  }

  public boolean isExclusiveFormula(Invariant o)
  {
    if (o instanceof ONEOFSCALAR) {
      ONEOFSCALAR other = (ONEOFSCALAR) o;

      for (int i=0; i < num_elts; i++) {
        for (int j=0; j < other.num_elts; j++) {
          if (elts[i] == other.elts[j]) // elements are interned
            return false;
        }
      }
      return true;
    }
#if defined(SCALAR) || defined(ELT)
    // Many more checks can be added here:  against nonzero, modulus, etc.
    if ((o instanceof NonZero) && (num_elts == 1) && (elts[0] == 0)) {
      return true;
    }
    long elts_min = Long.MAX_VALUE;
    long elts_max = Long.MIN_VALUE;
    for (int i=0; i < num_elts; i++) {
      elts_min = Math.min(elts_min, elts[i]);
      elts_max = Math.max(elts_max, elts[i]);
    }
    if ((o instanceof LowerBound) && (elts_max < ((LowerBound)o).core.min1))
      return true;
    if ((o instanceof UpperBound) && (elts_min > ((UpperBound)o).core.max1))
      return true;
#endif

    return false;
  }

  // OneOf invariants that indicate a small set of possible values are
  // uninteresting.  OneOf invariants that indicate exactly one value
  // are interesting.
  public boolean isInteresting() {
    if (num_elts() > 1) {
      return false;
    } else {
      return true;
    }
  }

  // Look up a previously instantiated invariant.
  public static ONEOFSCALAR find(PptSlice ppt) {
    Assert.assert(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof ONEOFSCALAR)
        return (ONEOFSCALAR) inv;
    }
    return null;
  }

  // Interning is lost when an object is serialized and deserialized.
  // Manually re-intern any interned fields upon deserialization.
  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();
    for (int i=0; i < num_elts; i++)
      elts[i] = Intern.intern(elts[i]);
  }

}


#if 0
// Local Variables:
// mode: java
// End:
#endif
