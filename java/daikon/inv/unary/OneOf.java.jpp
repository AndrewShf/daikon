#if !(defined(SCALAR) || defined(STRING) || defined(SEQUENCE) || defined(STRINGSEQUENCE) || defined(ELT) || defined(ELTSTRING))
#error "One of SCALAR, STRING, SEQUENCE, STRINGSEQUENCE, ELT, or ELTSTRING should be defined"
#endif

#if defined(SCALAR)
#define SCALARPKG scalar
#define INT long
#define ONEOFSCALAR OneOfScalar
#define ONEOFSCALARSTR "OneOfScalar"
#define SINGLESCALAR SingleScalar
#define TOSTRING(x) x
#define NAME var().name
#elif defined(STRING)
#define SCALARPKG string
#define INT String
#define ONEOFSCALAR OneOfString
#define ONEOFSCALARSTR "OneOfString"
#define SINGLESCALAR SingleString
#define TOSTRING(x) "\"" + UtilMDE.quote(x) + "\""
#define NAME var().name
#elif defined(SEQUENCE)
#define SCALARPKG sequence
#define INT long[]
#define ONEOFSCALAR OneOfSequence
#define ONEOFSCALARSTR "OneOfSequence"
#define SINGLESCALAR SingleSequence
#define TOSTRING(x) ArraysMDE.toString(x)
#define NAME var().name
#elif defined(STRINGSEQUENCE)
#define SCALARPKG stringsequence
#define INT String[]
#define ONEOFSCALAR OneOfStringSequence
#define ONEOFSCALARSTR "OneOfStringSequence"
#define SINGLESCALAR SingleStringSequence
#define TOSTRING(x) ArraysMDE.toString(x)
#define NAME var().name
#elif defined(ELT)
#define SCALARPKG sequence
#define INT long
#define ONEOFSCALAR EltOneOf
#define ONEOFSCALARSTR "EltOneOf"
#define SINGLESCALAR SingleSequence
#define TOSTRING(x) ((!var().type.isIntegral() && (x == 0)) ? "null" : (Long.toString(x)))
#define NAME var().name + " elements"
#elif defined(ELTSTRING)
#define SCALARPKG stringsequence
#define INT String
#define ONEOFSCALAR EltOneOfString
#define ONEOFSCALARSTR "EltOneOfString"
#define SINGLESCALAR SingleStringSequence
#define TOSTRING(x) "\"" + UtilMDE.quote(x) + "\""
#define NAME var().name + " elements"
#else
#error "One of SCALAR, STRING, SEQUENCE, STRINGSEQUENCE, ELT, or ELTSTRING should be defined"
#endif

package daikon.inv.unary.SCALARPKG;

import daikon.*;
import daikon.inv.*;

import utilMDE.*;

import java.util.*;

// *****
// Automatically generated from OneOf-cpp.java
// *****

// States that the value is one of the specified values.

// This subsumes an "exact" invariant that says the value is always exactly
// a specific value.  Do I want to make that a separate invariant
// nonetheless?  Probably not, as this will simplify implication and such.

public final class ONEOFSCALAR extends SINGLESCALAR implements OneOf {
  final static int LIMIT = 5;	// maximum size for the one_of list
  // Probably needs to keep its own list of the values, and number of each seen.
  // (That depends on the slice; maybe not until the slice is cleared out.
  // But so few values is cheap, so this is quite fine for now and long-term.)

  private INT[] elts;
  private int num_elts;
#if defined(SCALAR)
  private boolean is_boolean;
  private boolean is_object;
#endif

  ONEOFSCALAR(PptSlice ppt) {
    super(ppt);
#if defined(SEQUENCE)
    elts = new long[LIMIT][];    // elements are interned, so can test with ==
                                // (in the general online case, not worth interning)
#elif defined(STRINGSEQUENCE)
    elts = new String[LIMIT][];    // elements are interned, so can test with ==
                                // (in the general online case, not worth interning)
#else
    elts = new INT[LIMIT];
#endif
    num_elts = 0;
#if defined(SCALAR)
    is_boolean = (var().type == ProglangType.BOOLEAN);
    is_object = var().type.isObject();
#endif
  }

  public static ONEOFSCALAR instantiate(PptSlice ppt) {
    return new ONEOFSCALAR(ppt);
  }

  public int num_elts() {
    return num_elts;
  }

  public Object elt() {
    if (num_elts != 1)
      throw new Error("Represents " + num_elts + " elements");
#if defined(SCALAR) || defined(ELT)
    // Not sure whether interning is necessary (or just returning an Integer
    // would be sufficient), but just in case...
    return Intern.internedLong(elts[0]);
#else
    return elts[0];
#endif
  }


#if defined(SEQUENCE)
  static Comparator comparator = new ArraysMDE.LongArrayComparatorLexical();
#define COMPARATOR_ARG , comparator
#elif defined(STRINGSEQUENCE)
  static Comparator comparator = new ArraysMDE.ComparableArrayComparatorLexical();
#define COMPARATOR_ARG , comparator
#else
#define COMPARATOR_ARG
#endif

  private void sort_rep()
  {
    Arrays.sort(elts, 0, num_elts COMPARATOR_ARG);
  }

  private String subarray_rep() {
    // Not so efficient an implementation, but simple;
    // and how often will we need to print this anyway?
    sort_rep();
    StringBuffer sb = new StringBuffer();
    sb.append("{ ");
    for (int i=0; i<num_elts; i++) {
      if (i != 0)
        sb.append(", ");
      sb.append(TOSTRING(elts[i]));
    }
    sb.append(" }");
    return sb.toString();
  }

  public String repr() {
    double probability = getProbability();
    return ONEOFSCALARSTR + "(" + var().name + "): "
      + "no_invariant=" + no_invariant
      + ", num_elts=" + num_elts
      + ", elts=" + subarray_rep();
  }

  public String format() {
    if (num_elts == 1) {
#if defined(SCALAR)
      if (is_boolean) {
        Assert.assert((elts[0] == 0) || (elts[0] == 1));
        return NAME + " = " + ((elts[0] == 0) ? "false" : "true");
      } else if (is_object) {
        Assert.assert(elts[0] == 0);
        return NAME + " = " + "null";
      } else {
      return NAME + " = " + TOSTRING(elts[0]);
      }
#else
      return NAME + " = " + TOSTRING(elts[0]);
#endif
    } else {
      return NAME + " one of " + subarray_rep();
    }
  }


#if defined(ELT)
  public void add_modified(long[] a, int count) {
    for (int ai=0; ai<a.length; ai++) {
      long v = a[ai];
#elif defined(ELTSTRING)
  public void add_modified(String[] a, int count) {
    for (int ai=0; ai<a.length; ai++) {
      String v = a[ai];
#else
  public void add_modified(INT v, int count) {
#ifndef SCALAR
    Assert.assert(Intern.isInterned(v));
#endif
#endif
    for (int i=0; i<num_elts; i++)
      if (elts[i] == v)
        return;
    if (num_elts == LIMIT) {
      destroy();
      return;
    }
#if defined(SCALAR)
    if (is_boolean && (num_elts == 1)) {
      destroy();
      return;
    }
#endif
    elts[num_elts] = v;
    num_elts++;
#if defined(ELT)
    }
  }
#elif defined(ELTSTRING)
    }
  }
#else
  }
#endif


  protected double computeProbability() {
    // This is not ideal.
    if (num_elts == 0) {
      return Invariant.PROBABILITY_UNKNOWN;
    } else {
      return Invariant.PROBABILITY_JUSTIFIED;
    }
  }

  public boolean isSameFormula(Invariant o)
  {
    ONEOFSCALAR other = (ONEOFSCALAR) o;
    if (elts.length != other.elts.length)
      return false;

    sort_rep();
    other.sort_rep();
    for (int i=0; i < elts.length; i++)
      if (elts[i] != other.elts[i]) // elements are interned
	return false;

    return true;
  }

}
