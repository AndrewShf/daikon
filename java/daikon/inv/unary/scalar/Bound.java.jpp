#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(LOWER) || defined(UPPER) || defined(ELTLOWER) || defined(ELTUPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT) || defined(ELTUPPERFLOAT) || defined(ELTLOWERFLOAT))
#  error "LOWER, UPPER, ELTLOWER, or ELTUPPER should be defined"
#endif

#if (defined(LOWERFLOAT) || defined(UPPERFLOAT) || defined(ELTUPPERFLOAT) || defined(ELTLOWERFLOAT))
#  define BASE_FLOAT
#  define ONEOFSCALAR OneOfFloat
#  define MEMBER MemberFloat
#  define SUBSEQUENCE SubSequenceFloat
#  define INT(x) x ## Float
#  define PRIMITIVE Double
#  define LONGVALUE doubleValue()
#else
#  define BASE_INT
#  define ONEOFSCALAR OneOfScalar
#  define MEMBER Member
#  define SUBSEQUENCE SubSequence
#  define INT(x) x
#  define PRIMITIVE Long
#  define LONGVALUE longValue()
#endif

#if defined(LOWER) || defined(ELTLOWER) || defined(LOWERFLOAT) || defined(ELTLOWERFLOAT)
#  define LT <
#  define LTE <=
#  define GT >
#  define GTE >=
#  define MIN1 core.min1
#  define MAX max
#  if defined(BASE_INT)
#    define LONGMAX Long.MAX_VALUE
#    define LONGMIN Long.MIN_VALUE
#    define LOWERBOUNDCORE LowerBoundCore
#    define ELTLOWERBOUND EltLowerBound
#  else
#    define LONGMAX Double.MAX_VALUE
#    define LONGMIN Double.MIN_VALUE
#    define LOWERBOUNDCORE LowerBoundCoreFloat
#    define ELTLOWERBOUND EltLowerBoundFloat
#  endif
#  define SIGNADJUST
#  define MINSTR "min"
#  define MAXSTR "max"
#  define GTSTR ">"
#  define MAX1 core.max1
#  define MINELT min_elt
#  define MAXELT max_elt
#  if defined(LOWER)
#    define LOWERBOUND LowerBound
#    define LOWERBOUNDSTR "LowerBound"
#    define UPPERBOUND UpperBound
#    define ONEOF OneOfScalar
#  elif defined(LOWERFLOAT)
#    define LOWERBOUND LowerBoundFloat
#    define LOWERBOUNDSTR "LowerBoundFloat"
#    define UPPERBOUND UpperBoundFloat
#    define ONEOF OneOfFloat
#  elif defined(ELTLOWERFLOAT)
#    define LOWERBOUND EltLowerBoundFloat
#    define LOWERBOUNDSTR "EltLowerBoundFloat"
#    define UPPERBOUND EltUpperBoundFloat
#    define ONEOF EltOneOfFloat
#  else
#    define LOWERBOUND EltLowerBound
#    define LOWERBOUNDSTR "EltLowerBound"
#    define UPPERBOUND EltUpperBound
#    define ONEOF EltOneOf
#  endif
#elif defined(UPPER) || defined(ELTUPPER) || defined(UPPERFLOAT) || defined(ELTUPPERFLOAT)
#  define LT >
#  define LTE >=
#  define GT <
#  define GTE <=
#  define MIN1 core.max1
#  define MAX min
#  if defined(UPPER) || defined(ELTUPPER)
#    define LONGMAX Long.MIN_VALUE
#    define LONGMIN Long.MAX_VALUE
#    define LOWERBOUNDCORE UpperBoundCore
#    define ELTLOWERBOUND EltUpperBound
#  elif defined(UPPERFLOAT) || defined(ELTUPPERFLOAT)
#    define LONGMAX Double.MIN_VALUE
#    define LONGMIN Double.MAX_VALUE
#    define LOWERBOUNDCORE UpperBoundCoreFloat
#    define ELTLOWERBOUND EltUpperBoundFloat
#  endif
#  define SIGNADJUST -
#  define MINSTR "max"
#  define MAXSTR "min"
#  define GTSTR "<"
#  define MAX1 core.min1
#  define MINELT max_elt
#  define MAXELT min_elt
#  if defined(UPPER)
#    define LOWERBOUND UpperBound
#    define LOWERBOUNDSTR "UpperBound"
#    define UPPERBOUND LowerBound
#    define ONEOF OneOfScalar
#  elif defined(UPPERFLOAT)
#    define LOWERBOUND UpperBoundFloat
#    define LOWERBOUNDSTR "UpperBoundFloat"
#    define UPPERBOUND LowerBoundFloat
#    define ONEOF OneOfFloat
#  elif defined(ELTUPPERFLOAT)
#    define LOWERBOUND EltUpperBoundFloat
#    define LOWERBOUNDSTR "EltUpperBoundFloat"
#    define ONEOF EltOneOfFloat
#    define UPPERBOUND EltLowerBound
#  else
#    define LOWERBOUND EltUpperBound
#    define LOWERBOUNDSTR "EltUpperBound"
#    define UPPERBOUND EltLowerBound
#    define ONEOF EltOneOf
#  endif
#else
#  error "LOWER, UPPER, ELTLOWER, or ELTUPPER should be defined"
#endif
#if defined(LOWER) || defined(UPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT)
#  define SCALAR scalar
#  if defined(LOWER) || defined(UPPER)
#    define LONG long
#    define SINGLESCALAR SingleScalar
#  else
#    define LONG double
#    define SINGLESCALAR SingleFloat
#  endif
#else
#  define SCALAR sequence
#  if defined(ELTLOWER) || defined(ELTUPPER)
#    define LONG long[]
#    define SINGLESCALAR SingleScalarSequence
#  elif defined(ELTLOWERFLOAT) || defined(ELTUPPERFLOAT)
#    define LONG double[]
#    define SINGLESCALAR SingleFloatSequence
#  endif
#endif


// ***** This file is automatically generated from Bound.java.jpp

package daikon.inv.unary.SCALAR;

import daikon.*;
import daikon.inv.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.*;
import daikon.inv.binary.sequenceScalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.derive.unary.*;
import utilMDE.*;
import org.apache.log4j.Logger;

import java.util.*;

#if 0
I cannot use "x LT c" in the comment below, because substitution
would not happen in the string "x LT c"!
#endif
/**
 * LOWERBOUND represents the invariant 'x GT c', where c is a constant.
 * <p>
 * One reason not to combine LowerBound and UpperBound into a single range
 * invariant is that they have separate justifications:  one may be
 * justified when the other is not.
 **/
public class LOWERBOUND
  extends SINGLESCALAR
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff LOWERBOUND invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;
  /**
   * Long integer.  Together with maximal_interesting, specifies the
   * range of the computed constant that is "intersting" --- the range
   * that should be reported.  For instance, setting minimal_interesting
   * to -1 and maximal_interesting to 2 would only permit output of
   * LOWERBOUND invariants whose cutoff was one of (-1,0,1,2).
   **/
  public static long dkconfig_minimal_interesting = -1;
  /**
   * Long integer.  Together with minimal_interesting, specifies the
   * range of the computed constant that is "intersting" --- the range
   * that should be reported.  For instance, setting minimal_interesting
   * to -1 and maximal_interesting to 2 would only permit output of
   * LOWERBOUND invariants whose cutoff was one of (-1,0,1,2).
   **/
  public static long dkconfig_maximal_interesting = 2;

  public LOWERBOUNDCORE core;

  private LOWERBOUND(PptSlice ppt) {
    super(ppt);
    core = new LOWERBOUNDCORE(this);
  }

  protected Object clone() {
    LOWERBOUND result = (LOWERBOUND) super.clone();
    result.core = (LOWERBOUNDCORE) core.clone();
    result.core.wrapper = result;
    return result;
  }

  public static LOWERBOUND instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    VarInfo x = ppt.var_infos[0];
    if ((x.derived instanceof SequenceLength)
         && (((SequenceLength) x.derived).shift != 0)) {
      // Do not instantiate size(a[])-1 < 50. Instead, we rely on a
      // simpler invariant with a different constant, like
      // "size(a[]) < 51".
      Global.implied_noninstantiated_invariants += 1;
      return null;
    }
    return new LOWERBOUND(ppt);
  }

  public String repr() {
    return LOWERBOUNDSTR + varNames() + ": "
      + core.repr();
  }

#if (defined(LOWER) || defined(UPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT))
  public String format_using(OutputFormat format) {
    String name = var().name.name_using(format);

    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.ESCJAVA)
        || (format == OutputFormat.IOA)
        || (format == OutputFormat.JAVA)
        || (format == OutputFormat.JML))
    {
      return name + " " + GTSTR + "= " + MIN1;
    }

    if (format == OutputFormat.SIMPLIFY) {
      return "(" + GTSTR + "= " + name + " " + MIN1 + ")";
    }

    return format_unimplemented(format);
  }
#else

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.DAIKON) {
      return format_daikon();
    } else if (format == OutputFormat.IOA) {
      return format_ioa();
    } else if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    } else if (format == OutputFormat.JAVA) {
      return format_java();
    } else if (format == OutputFormat.ESCJAVA) {
      return format_esc();
    } else if (format == OutputFormat.JML) {
      return format_jml();
    }

    return format_unimplemented(format);
  }
  // ELTLOWEr || ELTUPPEr
  public String format_daikon() {
    return var().name.name() + " elements " + GTSTR + "= " + MIN1;
  }

  public String format_esc() {
    String[] form =
      VarInfoName.QuantHelper.format_esc(new VarInfoName[]
        { var().name });
    return form[0] + "(" + form[1] + " " + GTSTR + "= " + MIN1 + ")" + form[2];
  }

  public String format_jml() {
    String[] form =
      VarInfoName.QuantHelper.format_jml(new VarInfoName[]
        { var().name });
    return form[0] + "(" + form[1] + " " + GTSTR + "= " + MIN1 + ")" + form[2];
  }

  public String format_ioa() {
    VarInfoName.QuantHelper.IOAQuantification quant = new VarInfoName.QuantHelper.IOAQuantification (var());
    String result = quant.getQuantifierExp() + quant.getMembershipRestriction(0) +
      " => " + quant.getVarIndexed(0) + " " + GTSTR + "= " + MIN1 + quant.getClosingExp();
    return result;
  }


  public String format_simplify() {
    String[] form =
      VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
        { var().name });
    return form[0] + "(" + GTSTR + "= " + form[1] + " " + MIN1 + ")" + form[2];
  }

  public String format_java() {
    String[] form = VarInfoName.QuantHelper.format_java(new VarInfoName[]
      { var().name });
    return form[0] + "(" + form[1] + " " + GTSTR + "= " + MIN1 + ")" + form[2];
  }
#endif

  // XXX need to flow invariant if bound changed
  public void add_modified(LONG value, int count) {
    // System.out.println(LOWERBOUNDSTR + varNames() + ": "
    //                    + "add(" + value + ", " + modified + ", " + count + ")");

    // I must always clone myself because the cores keep track of many
    // statistics, not just the bounds.
    cloneAndFlow();
    core.changed = false;
#if (defined(LOWER) || defined(UPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT))
    core.add_modified(value, count);
#elif (defined(ELTLOWER) || defined(ELTUPPER) || defined(ELTUPPERFLOAT) || defined(ELTLOWERFLOAT))
    for (int i=0; i<value.length; i++) {
      core.add_modified(value[i], count);
      if (falsified)
        return;
    }
#endif
  }

  public boolean enoughSamples() {
    return core.enoughSamples();
  }

  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isExact() {
    return core.isExact();
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((LOWERBOUND) other).core);
  }


#if (defined(LOWER) || defined(UPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT))

  // XXX FIXME This looks like a hack that should be removed.  -MDE 6/13/2002
  public boolean isInteresting() {
    return (-1 < MIN1 && MIN1 < 2);
  }
#endif

  public boolean isObviousDynamically() {
    PptTopLevel pptt = ppt.parent;
    VarInfo v = var();
    
    // if the value is not in some range (like -1,0,1,2) then say that it is obvious
    if ((MIN1 < dkconfig_minimal_interesting) ||
        (MIN1 > dkconfig_maximal_interesting)) {
      return true;
    }
    ONEOF oo = ONEOF.find(ppt);
    if ((oo != null) && oo.enoughSamples() && oo.num_elts() > 0) {
      Assert.assertTrue (oo.var().isCanonical());
      // We could also use MIN1 == oo.MINELT(), since the LowerBound
      // will never have a MIN1 that does not appear in the OneOf.
      if (MIN1 LTE oo.MINELT()) {
        return true;
      }
    }

#if (defined(ELTLOWER) || defined(ELTUPPER) || defined(ELTLOWERFLOAT) || defined(ELTUPPERFLOAT))
    // Look for the same property over a supersequence of this one.
    for (Iterator inv_itor = pptt.invariants_iterator(); inv_itor.hasNext(); ) {
      Invariant inv = (Invariant) inv_itor.next();
      if (inv == this) {
        continue;
      }
      if (inv instanceof LOWERBOUND) {
        LOWERBOUND other = (LOWERBOUND) inv;
        if (isSameFormula(other)
            && SUBSEQUENCE.isObviousDerived(v, other.var())) {
          return true;
        }
      }
    }
#endif

#if defined(LOWER) || defined(LOWERFLOAT)
    if (v.isDerived() && (v.derived instanceof SequenceLength)) {
      // Invariants with over sequence lengths with vshift != 0 are
      // now no longer even instantiated.  However, the commented-out
      // assertion below would break reading old .inv files, so we'll
      // still do the check at runtime for the moment.
      int vshift = ((SequenceLength) v.derived).shift;
      // Assert.assertTrue(vshift == 0);
      if (vshift == 0 && MIN1 == 0) {
        // "size(a[]) >= 0" is obvious.
        return true;
      }
    }
#endif

    // For each sequence variable, if this is an obvious member/subsequence, and
    // it has the same invariant, then this one is obvious.
    for (int i=0; i<pptt.var_infos.length; i++) {
      VarInfo vi = pptt.var_infos[i];
#if (defined(LOWER) || defined(UPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT))
      if (MEMBER.isObviousMember(v, vi))
#else
      if (SUBSEQUENCE.isObviousDerived(v, vi))
#endif
      {
        PptSlice1 other_slice = pptt.findSlice(vi);
        if (other_slice != null) {
          ELTLOWERBOUND eb = ELTLOWERBOUND.find(other_slice);
          if ((eb != null)
              && eb.enoughSamples()
              && eb.MIN1 == MIN1) {
            return true;
          }
        }
      }
    }

    return super.isObviousDynamically();
  }


  public boolean isExclusiveFormula(Invariant other) {
    if (other instanceof UPPERBOUND) {
      if (MIN1 GT ((UPPERBOUND) other).MAX1)
        return true;
    }
    if (other instanceof ONEOFSCALAR) {
      return other.isExclusiveFormula(this);
    }
    return false;
  }

  // Look up a previously instantiated invariant.
  public static LOWERBOUND find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof LOWERBOUND)
        return (LOWERBOUND) inv;
    }
    return null;
  }

}
