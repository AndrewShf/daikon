#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(LOWER) || defined(UPPER) || defined(ELTLOWER) || defined(ELTUPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT) || defined(ELTUPPERFLOAT) || defined(ELTLOWERFLOAT))
  #error "LOWER, UPPER, ELTLOWER, or ELTUPPER must be defined"
#endif

#if (defined(LOWERFLOAT) || defined(UPPERFLOAT) || defined(ELTUPPERFLOAT) || defined(ELTLOWERFLOAT))
  #define BASE_FLOAT
  #define ONEOFSCALAR OneOfFloat
  #define MEMBER MemberFloat
  #define SUBSEQUENCE SubSequenceFloat
  #define INT(x) x ## Float
  #define PRIMITIVE Double
  #define LONGVALUE doubleValue()
#else
  #define BASE_INT
  #define ONEOFSCALAR OneOfScalar
  #define MEMBER Member
  #define SUBSEQUENCE SubSequence
  #define INT(x) x
  #define PRIMITIVE Long
  #define LONGVALUE longValue()
#endif

#if defined(LOWER) || defined(ELTLOWER) || defined(LOWERFLOAT) || defined(ELTLOWERFLOAT)
  #define LT <
  #define LTE <=
  #define GREATER greater
  #define GT >
  #define GTE >=
  #define MIN1 core.min1
  #define NUM_MIN1 core.num_min1
  #define MIN2 core.min2
  #define NUM_MIN2 core.num_min2
  #define MIN3 core.min3
  #define NUM_MIN3 core.num_min3
  #define MAX max
  #if defined(BASE_INT)
    #define LONGMAX Long.MAX_VALUE
    #define LONGMIN Long.MIN_VALUE
  #else
    #define LONGMAX Double.MAX_VALUE
    #define LONGMIN Double.MIN_VALUE
  #endif
  #define SIGNADJUST
  #define MINSTR "min"
  #define MAXSTR "max"
  #define GTESTR ">="
  #define LTESTR "<="
  #define MAX1 core.max1
  #define LOWERBOUNDCORE INT(LowerBoundCore)
  #define ELTLOWERBOUND INT(EltLowerBound)
  #define MINELT min_elt
  #define MAXELT max_elt
  #if defined(LOWER)
    #define LOWERBOUND LowerBound
    #define LOWERBOUNDSTR "LowerBound"
    #define UPPERBOUND UpperBound
    #define ONEOF OneOfScalar
  #elif defined(LOWERFLOAT)
    #define LOWERBOUND LowerBoundFloat
    #define LOWERBOUNDSTR "LowerBoundFloat"
    #define UPPERBOUND UpperBoundFloat
    #define ONEOF OneOfFloat
  #elif defined(ELTLOWERFLOAT)
    #define LOWERBOUND EltLowerBoundFloat
    #define LOWERBOUNDSTR "EltLowerBoundFloat"
    #define UPPERBOUND EltUpperBoundFloat
    #define ONEOF EltOneOfFloat
  #else
    #define LOWERBOUND EltLowerBound
    #define LOWERBOUNDSTR "EltLowerBound"
    #define UPPERBOUND EltUpperBound
    #define ONEOF EltOneOf
  #endif
#elif defined(UPPER) || defined(ELTUPPER) || defined(UPPERFLOAT) || defined(ELTUPPERFLOAT)
  #define LT >
  #define LTE >=
  #define GREATER less
  #define GT <
  #define GTE <=
  #define MIN1 core.max1
  #define NUM_MIN1 core.num_max1
  #define MIN2 core.max2
  #define NUM_MIN2 core.num_max2
  #define MIN3 core.max3
  #define NUM_MIN3 core.num_max3
  #define MAX min
  #if defined(UPPER) || defined(ELTUPPER)
    #define LONGMAX Long.MIN_VALUE
    #define LONGMIN Long.MAX_VALUE
    #define LOWERBOUNDCORE UpperBoundCore
    #define ELTLOWERBOUND EltUpperBound
  #elif defined(UPPERFLOAT) || defined(ELTUPPERFLOAT)
    #define LONGMAX Double.MIN_VALUE
    #define LONGMIN Double.MAX_VALUE
    #define LOWERBOUNDCORE UpperBoundCoreFloat
    #define ELTLOWERBOUND EltUpperBoundFloat
  #endif
  #define SIGNADJUST -
  #define MINSTR "max"
  #define MAXSTR "min"
  #define GTESTR "<="
  #define LTESTR ">="
  #define MAX1 core.min1
  #define LOWERBOUNDCORE INT(UpperBoundCore)
  #define ELTLOWERBOUND INT(EltUpperBound)
  #define MINELT max_elt
  #define MAXELT min_elt
  #if defined(UPPER)
    #define LOWERBOUND UpperBound
    #define LOWERBOUNDSTR "UpperBound"
    #define UPPERBOUND LowerBound
    #define ONEOF OneOfScalar
  #elif defined(UPPERFLOAT)
    #define LOWERBOUND UpperBoundFloat
    #define LOWERBOUNDSTR "UpperBoundFloat"
    #define UPPERBOUND LowerBoundFloat
    #define ONEOF OneOfFloat
  #elif defined(ELTUPPERFLOAT)
    #define LOWERBOUND EltUpperBoundFloat
    #define LOWERBOUNDSTR "EltUpperBoundFloat"
    #define ONEOF EltOneOfFloat
    #define UPPERBOUND EltLowerBound
  #else
    #define LOWERBOUND EltUpperBound
    #define LOWERBOUNDSTR "EltUpperBound"
    #define UPPERBOUND EltLowerBound
    #define ONEOF EltOneOf
  #endif
#else
  #error "LOWER, UPPER, ELTLOWER, or ELTUPPER must be defined"
#endif

#if defined(LOWER) || defined(UPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT)
  #define IS_SCALAR
  #define SCALAR scalar
  #if defined(LOWER) || defined(UPPER)
    #define LONG long
    #define SINGLESCALAR SingleScalar
  #else
    #define LONG double
    #define SINGLESCALAR SingleFloat
  #endif
#else
  #define IS_ELT
  #define SCALAR sequence
  #if defined(ELTLOWER) || defined(ELTUPPER)
    #define LONG long[]
    #define SINGLESCALAR SingleScalarSequence
  #elif defined(ELTLOWERFLOAT) || defined(ELTUPPERFLOAT)
    #define LONG double[]
    #define SINGLESCALAR SingleFloatSequence
  #endif
#endif


// ***** This file is automatically generated from Bound.java.jpp

package daikon.inv.unary.SCALAR;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.*;
import daikon.inv.binary.sequenceScalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.derive.unary.*;
import utilMDE.*;
import java.util.logging.Logger;
import java.util.logging.Level;

import java.util.*;

#if 0
I cannot use "x LT c" in the comment below, because substitution
would not happen in the string "x LT c"!
#endif
#if defined (IS_SCALAR)
  /**
   * Represents the invariant 'x GTE c', where c is a constant and x is
   * a LONG scalar.
   **/
#else
  /**
   * Represents the invariant that each element of a LONG sequence is
   * GREATER than or equal to a constant. Prints as 'x[] elements GTE
   * c'
   */
#endif
// One reason not to combine LowerBound and UpperBound into a single range
// invariant is that they have separate justifications:  one may be
// justified when the other is not.
public class LOWERBOUND
  extends SINGLESCALAR
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff LOWERBOUND invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;
  /**
   * Long integer.  Together with maximal_interesting, specifies the
   * range of the computed constant that is "intersting" --- the range
   * that should be reported.  For instance, setting minimal_interesting
   * to -1 and maximal_interesting to 2 would only permit output of
   * LOWERBOUND invariants whose cutoff was one of (-1,0,1,2).
   **/
  public static long dkconfig_minimal_interesting = -1;
  /**
   * Long integer.  Together with minimal_interesting, specifies the
   * range of the computed constant that is "intersting" --- the range
   * that should be reported.  For instance, setting minimal_interesting
   * to -1 and maximal_interesting to 2 would only permit output of
   * LOWERBOUND invariants whose cutoff was one of (-1,0,1,2).
   **/
  public static long dkconfig_maximal_interesting = 2;

  public LOWERBOUNDCORE core;

  private LOWERBOUND(PptSlice ppt) {
    super(ppt);
    core = new LOWERBOUNDCORE(this);
  }

  protected Object clone() {
    LOWERBOUND result = (LOWERBOUND) super.clone();
    result.core = (LOWERBOUNDCORE) core.clone();
    result.core.wrapper = result;
    return result;
  }

  public static LOWERBOUND instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    return new LOWERBOUND(ppt);
  }

  public String repr() {
    return LOWERBOUNDSTR + varNames() + ": "
      + core.repr();
  }

#if (defined(LOWER) || defined(UPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT))
  public String format_using(OutputFormat format) {
    String name = var().name.name_using(format);

    if ((format == OutputFormat.DAIKON)
        || (format == OutputFormat.ESCJAVA)
        || (format == OutputFormat.IOA)
        || (format == OutputFormat.JAVA)
        || (format == OutputFormat.JML)
        || (format == OutputFormat.DBCJAVA))
    {
      return name + " " + GTESTR + " " + MIN1;
    }

    if (format == OutputFormat.SIMPLIFY) {
#ifdef BASE_FLOAT
      return "(" + GTESTR + " " + name + " " + simplify_format_double(MIN1) + ")";
#else
      return "(" + GTESTR + " " + name + " " + simplify_format_long(MIN1) + ")";
#endif
    }

    return format_unimplemented(format);
  }
#else

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.DAIKON) {
      return format_daikon();
    } else if (format == OutputFormat.IOA) {
      return format_ioa();
    } else if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    } else if (format == OutputFormat.JAVA) {
      return format_java();
    } else if (format == OutputFormat.ESCJAVA) {
      return format_esc();
    } else if (format == OutputFormat.JML) {
      return format_jml();
    } else if (format == OutputFormat.DBCJAVA) {
      return format_dbc();
    }

    return format_unimplemented(format);
  }
  // ELTLOWEr || ELTUPPEr
  public String format_daikon() {
    return var().name.name() + " elements " + GTESTR + " " + MIN1;
  }

  public String format_esc() {
#ifdef IS_ELT
    String[] form =
      VarInfoName.QuantHelper.format_esc(new VarInfoName[]
        { var().name });
    return form[0] + "(" + form[1] + " " + GTESTR + " " + MIN1 + ")" + form[2];
#else
    String varname = var().name.esc_name();
    return varname + " " + GTESTR + " " + MIN1;
#endif
  }

  public String format_jml() {
    String[] form =
      VarInfoName.QuantHelper.format_jml(new VarInfoName[]
        { var().name });
    return form[0] + "(" + form[1] + " " + GTESTR + " " + MIN1 + ")" + form[2];
  }

  public String format_dbc() {
#ifdef IS_ELT
    return "warning: OutputFormat.DBCJAVA variable quantification must be implemented.";
#else
    String varname = var().name.dbc_name();
    return varname + " " + GTESTR + " " + MIN1;
#endif
  }

  public String format_ioa() {
#ifdef IS_ELT
    VarInfoName.QuantHelper.IOAQuantification quant =
      new VarInfoName.QuantHelper.IOAQuantification (var());
    String result = quant.getQuantifierExp()
      + quant.getMembershipRestriction(0)
      + " => " + quant.getVarIndexedString(0) + " " + GTESTR + " " + MIN1
      + quant.getClosingExp();
    return result;
#else
    String varname = var().name.ioa_name();
    return varname + " " + GTESTR + " " + MIN1;
#endif
  }

  public String format_simplify() {
#ifdef BASE_FLOAT
    String value = simplify_format_double(MIN1);
#else
    String value = simplify_format_long(MIN1);
#endif
#ifdef IS_ELT
    String[] form =
      VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
        { var().name });
    return form[0] + "(" + GTESTR + " " + form[1] + " " + value + ")"
      + form[2];
#else
    String varname = var().simplify_name();
    return "(" + GTESTR + " " + varname + " " + value + ")";
#endif
  }

  public String format_java() {
#ifdef IS_ELT

    String[] form = VarInfoName.QuantHelper.format_java(new VarInfoName[]
      { var().name });
    return form[0] + "(" + form[1] + " " + GTESTR + " " + MIN1 + ")" + form[2];
#else
    String varname = var().name.java_name();
    return varname + " " + GTESTR + " " + MIN1;
#endif
  }
#endif

  public InvariantStatus add_modified(LONG value, int count) {
    // System.out.println(LOWERBOUNDSTR + varNames() + ": "
    //              + "add(" + value + ", " + modified + ", " + count + ")");
    #ifndef IS_ELT
      if (core.wouldChange (value)) {
        cloneAndFlow();
      }
      return core.add_modified(value, count);
    #else
      boolean changed = false;
      InvariantStatus status = InvariantStatus.NO_CHANGE;
      for (int i=0; i<value.length; i++) {
        if (!changed && core.wouldChange (value[i])) {
          cloneAndFlow();
          changed = true;
          status = InvariantStatus.WEAKENED;
        }
        if (core.add_modified(value[i], count)  == InvariantStatus.FALSIFIED) {
          return InvariantStatus.FALSIFIED;
        }
      }
      return status;
#endif

  }

  public boolean enoughSamples() {
    return core.enoughSamples();
  }

  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isExact() {
    return core.isExact();
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((LOWERBOUND) other).core);
  }


#ifndef IS_ELT
  // XXX FIXME This looks like a hack that should be removed.  -MDE 6/13/2002
  // Use hasUninterestingConstant() instead. -SMcC 2/26/2003
  public boolean isInteresting() {
    return (-1 < MIN1 && MIN1 < 2);
  }
#endif

  public boolean hasUninterestingConstant() {
    // If the constant bound is not in some small range of interesting
    // values (by default {-1, 0, 1, 2}), call it uninteresting.
    if ((MIN1 < dkconfig_minimal_interesting) ||
        (MIN1 > dkconfig_maximal_interesting)) {
      return true;
    }
#if defined(BASE_FLOAT)
    else if (MIN1 != (int)MIN1) {
      // Non-integer bounds are uninteresting even if small.
      return true;
    }
#endif
    return false;
  }

  public DiscardInfo isObviousStatically (VarInfo[] vis) {
    VarInfo var = vis[0];
    if ((var.derived instanceof SequenceLength)
         && (((SequenceLength) var.derived).shift != 0)) {
      return new DiscardInfo(this, DiscardCode.obvious, "Bounds are preferrable over"
                             + " sequence lengths with no shift");
    }
    return super.isObviousStatically (vis);
  }

  public DiscardInfo isObviousDynamically(VarInfo[] vis) {
    PptTopLevel pptt = ppt.parent;

    // if the value is not in some range (like -1,0,1,2) then say that it is obvious
    if ((MIN1 < dkconfig_minimal_interesting) ||
        (MIN1 > dkconfig_maximal_interesting)) {
      // XXX This check doesn't really belong here. However It
      // shouldn't get removed until hasUninterestingConstant() is
      // suitable to be turned on everywhere by default. -SMcC
      // if the value is not in some range (like -1,0,1,2) then say that
      // it is obvious
      String discardString = "";
      if (MIN1 < dkconfig_minimal_interesting) {
        discardString = "MIN1="+MIN1+" is less than dkconfig_minimal_interesting=="
          + dkconfig_minimal_interesting;
      } else {
        discardString = "MIN1="+MIN1+" is greater than dkconfig_maximal_interesting=="+
          dkconfig_maximal_interesting;
      }
      return new DiscardInfo(this, DiscardCode.obvious, discardString);
    }
    ONEOF oo = ONEOF.find(ppt);
    if ((oo != null) && oo.enoughSamples() && oo.num_elts() > 0) {
      Assert.assertTrue (oo.var().isCanonical());
      // We could also use MIN1 == oo.MINELT(), since the LowerBound
      // will never have a MIN1 that does not appear in the OneOf.
      if (MIN1 LTE oo.MINELT()) {
        String varName = vis[0].name.name();
        String discardString = varName+LTESTR+MIN1+" is implied by "+varName+LTESTR+oo.MINELT();
        log (discardString);
        return new DiscardInfo(this, DiscardCode.obvious, discardString);
      }
    }

    // NOT: "VarInfo v = var();" because we want to operate not on this
    // object's own variables, but on the variables that were passed in.
    VarInfo v = vis[0];
#if 0
    Test was: #if (defined(ELTLOWER) || defined(ELTUPPER) || defined(ELTLOWERFLOAT) || defined(ELTUPPERFLOAT))
#endif
#ifdef IS_ELT
    // Look for the same property over a supersequence of this one.
    for (Iterator inv_itor = pptt.invariants_iterator(); inv_itor.hasNext(); ) {
      Invariant inv = (Invariant) inv_itor.next();
      if (inv == this) {
        continue;
      }
      if (inv instanceof LOWERBOUND) {
        LOWERBOUND other = (LOWERBOUND) inv;
        if (isSameFormula(other)
            && SUBSEQUENCE.isObviousSubSequenceDynamically(this, v, other.var())) {
          String varName = v.name.name();
          String otherName = other.var().name.name();
          String discardString = varName + " is a subsequence of " + otherName + " for which the invariant holds.";
          log (discardString);
          return new DiscardInfo(this, DiscardCode.obvious, discardString);
        }
      }
    }
#endif

#if defined(LOWER) || defined(LOWERFLOAT)
    if (v.isDerived() && (v.derived instanceof SequenceLength)) {
      // Invariants with over sequence lengths with vshift != 0 are
      // now no longer even instantiated.  However, the commented-out
      // assertion below would break reading old .inv files, so we'll
      // still do the check at runtime for the moment.
      int vshift = ((SequenceLength) v.derived).shift;
      // Assert.assertTrue(vshift == 0);
      if (vshift == 0 && MIN1 == 0) {
        // "size(a[]) >= 0" is obvious.
        return new DiscardInfo(this, DiscardCode.obvious, v.name.name()+" >=0 is obvious");
      }
    }
#endif

    // For each sequence variable, if this is an obvious member/subsequence, and
    // it has the same invariant, then this one is obvious.
    for (int i=0; i<pptt.var_infos.length; i++) {
      VarInfo vi = pptt.var_infos[i];
#ifndef IS_ELT
      if (MEMBER.isObviousMember(v, vi))
#else
      if (SUBSEQUENCE.isObviousSubSequenceDynamically(this, v, vi))
#endif
      {
        PptSlice1 other_slice = pptt.findSlice(vi);
        if (other_slice != null) {
          ELTLOWERBOUND eb = ELTLOWERBOUND.find(other_slice);
          if ((eb != null)
              && eb.enoughSamples()
              && eb.MIN1 == MIN1) {
            String otherName = other_slice.var_infos[0].name.name();
            String varName = v.name.name();
            String discardString = varName+" is a subsequence of "+otherName+" for which the invariant holds.";
            log (discardString);
            return new DiscardInfo(this, DiscardCode.obvious, discardString);
          }
        }
      }
    }

    return super.isObviousDynamically(vis);
  }


  public boolean isExclusiveFormula(Invariant other) {
    if (other instanceof UPPERBOUND) {
      if (MIN1 GT ((UPPERBOUND) other).MAX1)
        return true;
    }
    if (other instanceof ONEOFSCALAR) {
      return other.isExclusiveFormula(this);
    }
    return false;
  }

  // Look up a previously instantiated invariant.
  public static LOWERBOUND find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof LOWERBOUND)
        return (LOWERBOUND) inv;
    }
    return null;
  }

  /**
   * Not okay because this keeps track of samples seen at certain min/max values.
   **/
  public boolean inProcessSuppressOk() {
    return false;
  }

  /**
   * Bound can merge different formulas from lower points to create a single
   * formula at an upper point.  See merge() below.
   */
  public boolean mergeFormulasOk() {
    return (true);
  }

  /**
   * Merge the invariants in invs to form a new invariant.  Each must be
   * a LOWERBOUND invariant.  This code finds all of the min/max values
   * in each invariant, applies them to a new parent invariant and
   * returns the merged invariant (if any).
   *
   * @param invs    List of invariants to merge.  The invariants must all be
   *                of the same type and should come from the children of
   *                ppt.  They should also all be permuted to match the variable
   *                order in ppt.
   * @param ppt     program point that will contain the new invariant
   */
  public Invariant merge (List invs, PptSlice ppt) {

    // Create the initial parent invariant from the first child
    LOWERBOUND first = (LOWERBOUND) invs.get(0);
    LOWERBOUND result = (LOWERBOUND) first.clone();
    result.ppt = ppt;

    // Loop through the rest of the child invariants
    for (int i = 1; i < invs.size(); i++ ) {

      // Get this invariant
      LOWERBOUND inv = (LOWERBOUND) invs.get (i);

      // Pass each value and its count to this invariant's add_modified.  Since
      // bound is never destroyed, we don't need to check the results.
      if (inv.NUM_MIN1 > 0)
        result.core.add_modified (inv.MIN1, inv.NUM_MIN1);
      if (inv.NUM_MIN2 > 0)
        result.core.add_modified (inv.MIN2, inv.NUM_MIN2);
      if (inv.NUM_MIN3 > 0)
        result.core.add_modified (inv.MIN3, inv.NUM_MIN3);
      result.core.add_modified (inv.core.MAX, 1);
      if (Debug.logDetail())
        result.log ("Adding vals " + inv.NUM_MIN1 + " of " + inv.MIN1 + ","
                                   + inv.NUM_MIN2 + " of " + inv.MIN2 + ","
                                   + inv.NUM_MIN3 + " of " + inv.MIN3 + ", "
                                   + "1 of " + inv.core.MAX
                                   + "from ppt " + inv.ppt.ppt_name);
    }

    result.log ("Merged '" + result.format() + "' from " + invs.size()
                + " child invariants");
    return (result);
  }
}
