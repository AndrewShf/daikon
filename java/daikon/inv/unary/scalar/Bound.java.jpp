#if !(defined(LOWER) || defined(UPPER) || defined(ELTLOWER) || defined(ELTUPPER))
#error "LOWER, UPPER, ELTLOWER, or ELTUPPER should be defined"
#endif

#if defined(LOWER) || defined(ELTLOWER)
#define LT <
#define GT >
#define MIN1 core.min1
#define MAX max
#define LONGMAX Long.MAX_VALUE
#define LONGMIN Long.MIN_VALUE
#define SIGNADJUST
#define MINSTR "min"
#define MAXSTR "max"
#define GTSTR ">"
#define MAX1 core.max1
#define LOWERBOUNDCORE LowerBoundCore
#define ELTLOWERBOUND EltLowerBound
#if defined(LOWER)
#define LOWERBOUND LowerBound
#define LOWERBOUNDSTR "LowerBound"
#define UPPERBOUND UpperBound
#else
#define LOWERBOUND EltLowerBound
#define LOWERBOUNDSTR "EltLowerBound"
#define UPPERBOUND EltUpperBound
#endif
#elif defined(UPPER) || defined(ELTUPPER)
#define LT >
#define GT <
#define MIN1 core.max1
#define MAX min
#define LONGMAX Long.MIN_VALUE
#define LONGMIN Long.MAX_VALUE
#define SIGNADJUST -
#define MINSTR "max"
#define MAXSTR "min"
#define GTSTR "<"
#define MAX1 core.min1
#define LOWERBOUNDCORE UpperBoundCore
#define ELTLOWERBOUND EltUpperBound
#if defined(UPPER)
#define LOWERBOUND UpperBound
#define LOWERBOUNDSTR "UpperBound"
#define UPPERBOUND LowerBound
#else
#define LOWERBOUND EltUpperBound
#define LOWERBOUNDSTR "EltUpperBound"
#define UPPERBOUND EltLowerBound
#endif
#else
#error "LOWER, UPPER, ELTLOWER, or ELTUPPER should be defined"
#endif
#if defined(LOWER) || defined(UPPER)
#define SINGLESCALAR SingleScalar
#define SCALAR scalar
#define LONG long
#else
#define SINGLESCALAR SingleSequence
#define SCALAR sequence
#define LONG long[]
#endif

#if ! defined(LOWERBOUND)
#error "LOWERBOUND is not defined"
#endif


package daikon.inv.unary.SCALAR;

import daikon.*;
import daikon.inv.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.*;
import daikon.inv.binary.sequenceScalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.derive.unary.*;
import utilMDE.*;


import java.util.*;

// *****
// Automatically generated from Bound-cpp.java
// *****

// One reason not to combine LowerBound and Upperbound is that they have
// separate justifications:  one may be justified when the other is not.


// What should we do if there are few values in the range?
// This can make justifying that invariant easier, because with few values
// naturally there are more instances of each value.
// This might also make justifying that invariant harder, because to get more
// than (say) twice the expected number of samples (under the assumption of
// uniform distribution) requires many samples.
// Which of these dominates?  Is the behavior what I want?


public class LOWERBOUND extends SINGLESCALAR {

  public LOWERBOUNDCORE core;

  private LOWERBOUND(PptSlice ppt) {
    super(ppt);
    core = new LOWERBOUNDCORE(this);
  }

  public static LOWERBOUND instantiate(PptSlice ppt) {
    return new LOWERBOUND(ppt);
  }

  public String repr() {
    return LOWERBOUNDSTR + varNames() + ": "
      + core.repr();
  }

#if (defined(LOWER) || defined(UPPER))
  public String format() {
    return var().name + " " + GTSTR + "= " + MIN1;
  }

  public String format_esc() {
    String esc_name = var().esc_name;
    if (esc_name != null) {
      return esc_name + " " + GTSTR + "= " + MIN1;
    } else {
      return "format_esc " + this.getClass() + " could not speak about: " + format();
    }
  }
#else
  public String format() {
    return var().name + " elements " + GTSTR + "= " + MIN1;
  }

  public String format_esc() {
    String[] esc_forall = var().esc_forall();
    return "(" + esc_forall[0]
      + "(" + esc_forall[1] + " " + GTSTR + "= " + MIN1 + "))";
  }
#endif

  public void add_modified(LONG value, int count) {
    // System.out.println(LOWERBOUNDSTR + varNames() + ": "
    //                    + "add(" + value + ", " + modified + ", " + count + ")");
#if (defined(LOWER) || defined(UPPER))
    core.add_modified(value, count);
#elif (defined(ELTLOWER) || defined(ELTUPPER))
    for (int i=0; i<value.length; i++) {
      core.add_modified(value[i], count);
      if (no_invariant)
        return;
    }
#endif
  }

  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isExact() {
    return core.isExact();
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((LOWERBOUND) other).core);
  }

  public boolean isObviousDerived() {
    VarInfo v = var();
    if (v.isDerived() && (v.derived instanceof SequenceLength)) {
      int vshift = ((SequenceLength) v.derived).shift;
      if (vshift != 0) {
        return true;
#ifdef LOWER
      } else if (MIN1 == 0) {
        // vshift == 0
        return true;
#endif
      }
    }

    // For each sequence variable, if this is an obvious member/subsequence, and
    // it has the same invariant, then this one is obvious.
    PptTopLevel pptt = (PptTopLevel) ppt.parent;
    for (int i=0; i<pptt.var_infos.length; i++) {
      VarInfo vi = pptt.var_infos[i];
#if (defined(LOWER) || defined(UPPER))
      if (Member.isObviousMember(v, vi))
#else
      if (SubSequence.isObviousDerived(v, vi))
#endif
      {
        PptSlice1 other_slice = pptt.findSlice(vi);
        if (other_slice != null) {
          ELTLOWERBOUND eb = ELTLOWERBOUND.find(other_slice);
          if ((eb != null)
              && eb.justified()
              && eb.MIN1 == MIN1) {
            return true;
          }
        }
      }
    }

    return false;
  }


  public boolean isExclusiveFormula(Invariant other) {
    if (other instanceof UPPERBOUND) {
      if (MIN1 GT ((UPPERBOUND) other).MAX1)
        return true;
    }
    if (other instanceof OneOfScalar) {
      return other.isExclusiveFormula(this);
    }
    return false;
  }

  // Look up a previously instantiated invariant.
  public static LOWERBOUND find(PptSlice ppt) {
    Assert.assert(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof LOWERBOUND)
        return (LOWERBOUND) inv;
    }
    return null;
  }

}
