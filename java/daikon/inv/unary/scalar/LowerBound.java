package daikon.inv.unary.scalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.unary.*;
import daikon.inv.binary.sequenceScalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.derive.unary.*;
import utilMDE.*;

import java.util.*;

// *****
// Do not edit this file directly:
// it is automatically generated from Bound.java.jpp
// *****

// One reason not to combine LowerBound and Upperbound is that they have
// separate justifications:  one may be justified when the other is not.

// What should we do if there are few values in the range?
// This can make justifying that invariant easier, because with few values
// naturally there are more instances of each value.
// This might also make justifying that invariant harder, because to get more
// than (say) twice the expected number of samples (under the assumption of
// uniform distribution) requires many samples.
// Which of these dominates?  Is the behavior what I want?

public class LowerBound  extends SingleScalar  {

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  public static boolean dkconfig_enabled = true;
  // If the bound is not within these constraints, then don't report it.
  // For instance, these could be set to -1 and 2 to only permit output
  // of bounds in the range (-1,0,1,2).
  public static long dkconfig_minimal_interesting = Long.MIN_VALUE;
  public static long dkconfig_maximal_interesting = Long.MAX_VALUE;

  public LowerBoundCore  core;

  private LowerBound (PptSlice ppt) {
    super(ppt);
    core = new LowerBoundCore (this);
  }

  protected Object clone() {
    LowerBound  result = (LowerBound ) super.clone();
    result.core = (LowerBoundCore ) core.clone();
    result.core.wrapper = result;
    return result;
  }

  public static LowerBound  instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    return new LowerBound (ppt);
  }

  public String repr() {
    return "LowerBound"  + varNames() + ": "
      + core.repr();
  }

  public String format() {
    return var().name.name() + " >= " + core.min1 ;
  }

  public String format_esc() {
    String varname = var().name.esc_name();
    return varname + " >= " + core.min1 ;
  }

  public String format_ioa(String classname) {
    String varname = var().name.ioa_name(classname);
    return varname + " >= " + core.min1 ;
  }

  public String format_simplify() {
    String varname = var().name.simplify_name();
    return "(>= " + varname + " " + core.min1  + ")";
  }

  public void add_modified(long  value, int count) {
    // System.out.println("LowerBound"  + varNames() + ": "
    //                    + "add(" + value + ", " + modified + ", " + count + ")");

    core.add_modified(value, count);

  }

  public boolean enoughSamples() {
    return core.enoughSamples();
  }

  protected double computeProbability() {
    return core.computeProbability();
  }

  public boolean isExact() {
    return core.isExact();
  }

  public boolean isSameFormula(Invariant other)
  {
    return core.isSameFormula(((LowerBound ) other).core);
  }

  public boolean isInteresting() {
    return (-1 < core.min1  && core.min1  < 2);
  }

  public boolean isObviousImplied() {
    // if the value is not in some range (like -1,0,1,2) then say that it is obvious
    if ((core.min1  < dkconfig_minimal_interesting) ||
	(core.min1  > dkconfig_maximal_interesting)) {
      return true;
    }
    OneOfScalar  oo = OneOfScalar .find(ppt);
    if ((oo != null) && oo.enoughSamples()) {
      // Equivalently, core.min1  < = oo. max_elt ()
      if (! (((Long)oo. max_elt ()).longValue() >  core.min1 )) {
        return true;
      }
    }

    return super.isObviousImplied();
  }

  public boolean isObviousDerived() {
    VarInfo v = var();
    if (v.isDerived() && (v.derived instanceof SequenceLength)) {
      int vshift = ((SequenceLength) v.derived).shift;
      if (vshift != 0) {
        return true;

      } else if (core.min1  == 0) {
        // vshift == 0
        return true;

      }
    }

    // For each sequence variable, if this is an obvious member/subsequence, and
    // it has the same invariant, then this one is obvious.
    PptTopLevel pptt = (PptTopLevel) ppt.parent;
    for (int i=0; i<pptt.var_infos.length; i++) {
      VarInfo vi = pptt.var_infos[i];

      if (Member.isObviousMember(v, vi))

      {
        PptSlice1 other_slice = pptt.findSlice(vi);
        if (other_slice != null) {
          EltLowerBound  eb = EltLowerBound .find(other_slice);
          if ((eb != null)
              && eb.enoughSamples()
              && eb. core.min1  == core.min1 ) {
            return true;
          }
        }
      }
    }

    return false;
  }

  public boolean isExclusiveFormula(Invariant other) {
    if (other instanceof UpperBound ) {
      if (core.min1  >  ((UpperBound ) other). core.max1 )
        return true;
    }
    if (other instanceof OneOfScalar) {
      return other.isExclusiveFormula(this);
    }
    return false;
  }

  // Look up a previously instantiated invariant.
  public static LowerBound  find(PptSlice ppt) {
    Assert.assert(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof LowerBound )
        return (LowerBound ) inv;
    }
    return null;
  }

}

