#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif


#if !(defined(TYPEDOUBLE) || defined(TYPELONG))
  #error "TYPEDOUBLE or TYPELONG must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME CommonSequence
  #define SUPERCLASS SingleScalarSequence
  #define PRIMITIVE long
  #define CLASSSTRING "CommonSequence"
  #define INDEXOF ArraysMDE.indexOf
#elif defined(TYPEDOUBLE)
  #define CLASSNAME CommonFloatSequence
  #define SUPERCLASS SingleFloatSequence
  #define PRIMITIVE double
  #define CLASSSTRING "CommonFloatSequence"
  #define INDEXOF Global.fuzzy.indexOf
#endif

// ***** This file is automatically generated from CommonSequence.java.jpp

package daikon.inv.unary.sequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoSequence.*;

import utilMDE.*;

import java.util.*;


/**
 * Represents PRIMITIVE sequences that contain a common subset.  Prints as
 * "{e1, e2, e3, ...} subset of x[]"
 **/

public class CLASSNAME
  extends SUPERCLASS
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff CommonSequence invariants should be considered.
   **/
  public static boolean dkconfig_enabled = false;

  final static boolean debugCommonSequence = false;

  private int elts;
  private PRIMITIVE[] intersect = null;

  protected CLASSNAME(PptSlice ppt) {
    super(ppt);
  }

  public static CLASSNAME instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    return new CLASSNAME(ppt);
  }

  // this.intersect is read-only, so don't clone it
  // public Object clone();

  public String repr() {
    return CLASSSTRING + " " + varNames() + ": "
      + "elts=\"" + elts;
  }

  private String printIntersect() {
    if (intersect==null)
      return "{}";

    String result = "{";
    for (int i=0; i<intersect.length; i++) {
      result += intersect[i];
      if (i!=intersect.length-1)
        result += ", ";
    }
    result += "}";
    return result;
  }

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.DAIKON) return format_daikon();
    if (format == OutputFormat.IOA) return format_ioa();

    return format_unimplemented(format);
  }

  public String format_daikon() {
    return (printIntersect() + " subset of " + var().name.name());
  }

  /* IOA */
  public String format_ioa() {
    String vname = var().name.ioa_name();
    if (var().isIOASet())
      return printIntersect() + " \\in " + vname;
    else
      return "(" + printIntersect() + " \\in " + vname + ") ***";
  }

  public InvariantStatus add_modified(PRIMITIVE[] a, int count) {
    // System.out.println ("common: " + ArraysMDE.toString (a));
    if (intersect==null) {
      intersect = a;
      return InvariantStatus.NO_CHANGE;
    } else {
      PRIMITIVE[] tmp = new PRIMITIVE[intersect.length];
      int    size = 0;
      for (int i=0; i<a.length; i++) {

        // if (a[i] in intersect) && !(a[i] in tmp), add a[i] to tmp
        int ii = INDEXOF (intersect, a[i]);
        if ((ii != -1) &&
          (INDEXOF (ArraysMDE.subarray(tmp,0,size), a[i]) == -1)) {
          //System.out.println ("adding " + intersect[ii] + " at " + size);

          //carefully add the existing intersect value and not a[i].  These
          //are not necessarily the same when fuzzy floating point
          //comparisons are active
          tmp[size++] = intersect[ii];
        }
      }
      if (size==0) {
        VarInfo var = var();
        return InvariantStatus.FALSIFIED;
      }

      intersect = ArraysMDE.subarray(tmp, 0, size);
    }

    intersect = (PRIMITIVE[]) Intern.intern(intersect);
    elts++;
    return InvariantStatus.NO_CHANGE;
  }

  protected double computeProbability() {
    if (falsified) {
      return Invariant.PROBABILITY_NEVER;
    } else {
      return Math.pow(.9, elts);
    }
  }

  public boolean isSameFormula(Invariant other) {
    Assert.assertTrue(other instanceof CLASSNAME);
    return true;
  }
}
