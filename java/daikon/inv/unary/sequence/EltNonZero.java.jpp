#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define EQUAL(a,b) ((a) == (b))
  #define CLASSNAME EltNonZero
  #define SUPERCLASS SingleScalarSequence
  #define PRIMITIVE long
  #define NUMWRAPPER Long
  #define BASEISTYPE baseIsIntegral()
  #define PRIMITIVEVALUE longValue()
  #define ELTONEOF EltOneOf
  #define CLASSSTRING "EltNonZero"
#elif defined(TYPEDOUBLE)
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
  #define CLASSNAME EltNonZeroFloat
  #define SUPERCLASS SingleFloatSequence
  #define PRIMITIVE double
  #define NUMWRAPPER Double
  #define BASEISTYPE baseIsFloat()
  #define PRIMITIVEVALUE doubleValue()
  #define ELTONEOF EltOneOfFloat
  #define CLASSSTRING "EltNonZeroFloat"
#endif

// ***** This file is automatically generated from EltNonZero.java.jpp

package daikon.inv.unary.sequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoSequence.*;

import utilMDE.*;

import java.util.logging.Logger;
import java.util.logging.Level;

import java.util.*;



/**
 * Represents the invariant "x != 0" where x represents all of the elements
 * of a PRIMITIVE sequence.  Prints as 'x[] elements != 0'
 **/

public final class CLASSNAME
  extends SUPERCLASS
{
  /**
   * Debug tracer.
   **/
  public static final Logger debug =
    Logger.getLogger("daikon.inv.unary.sequence." + CLASSSTRING);


  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff EltNonZero invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  PRIMITIVE min = NUMWRAPPER.MAX_VALUE;
  PRIMITIVE max = NUMWRAPPER.MIN_VALUE;

  // If nonzero, use this as the range instead of the actual range.
  // This lets one use a specified probability of nonzero (say, 1/10
  // for pointers).
  int override_range = 0;
  boolean pointer_type = false;

  public CLASSNAME(PptSlice ppt) {
    super(ppt);
  }

  public static CLASSNAME instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    CLASSNAME result = new CLASSNAME(ppt);
    if (! ppt.var_infos[0].type.BASEISTYPE) {
      result.pointer_type = true;
      result.override_range = 3;
     }

    if (debug.isLoggable(Level.FINE)) {
      System.out.println(CLASSSTRING + ".instantiate: " + result.format());
    }
    return result;
  }

  public String repr() {
    return CLASSSTRING + varNames() + ": "
      + !falsified + ",min=" + min + ",max=" + max;
  }

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.DAIKON) return format_daikon();
    if (format == OutputFormat.ESCJAVA) return format_esc();
    if (format == OutputFormat.IOA) return format_ioa();
    if (format == OutputFormat.SIMPLIFY) return format_simplify();
    if (format == OutputFormat.JML) return format_jml();
    if (format == OutputFormat.DBCJAVA) return format_dbc();

    return format_unimplemented(format);
  }

  public String format_daikon() {
    return var().name.name() + " elements " + "!=" + " " + (pointer_type ? "null" : "0");
  }

  // We are a special case where a ghost field can actually talk about
  // array contents.
  public boolean isValidEscExpression() {
    return true;
  }

  public String format_esc() {
    // If this is an entire array or Collection (not VarInfoName.Slice), then
    //  * for arrays: use \nonnullelements(A)
    //  * for Collections: use collection.containsNull == false
    //    (the latter also requires that ghost field to get set)

    VarInfoName viname = var().name;
    if (viname instanceof VarInfoName.Elements) {
      VarInfoName term = ((VarInfoName.Elements) viname).term;
      if (var().type.isArray()) {
        return "\\nonnullelements(" + term.esc_name() + ")";
      } else {
        return term.esc_name() + ".containsNull == false";
      }
    }

    // If this is just part of an array or Collection (viname instanceof
    // VarInfoName.Slice), then calling viname.esc_name() will always throw
    // an exception, since var() is certainly a sequence.  So use the
    // standard quantification.

    String[] form =
      VarInfoName.QuantHelper.format_esc(new VarInfoName[]
        { var().name });
    return form[0] + "(" + form[1] + " != " + (pointer_type ? "null" : "0") + ")" + form[2];
  }

  public String format_jml() {
    // If this is an entire array or Collection (not VarInfoName.Slice), then
    //  * for arrays: use \nonnullelements(A)
    //  * for Collections: use collection.containsNull == false
    //    (the latter also requires that ghost field to get set)

    VarInfoName viname = var().name;
    if (viname instanceof VarInfoName.Elements) {
      VarInfoName term = ((VarInfoName.Elements) viname).term;
      if (var().type.isArray()) {
        return "\\nonnullelements(" + term.jml_name() + ")";
      } else {
        return term.jml_name() + ".containsNull == false";
      }
    }

    // If this is just part of an array or Collection (viname instanceof
    // VarInfoName.Slice), then calling viname.jml_name() will always throw
    // an exception, since var() is certainly a sequence.  So use the
    // standard quantification.

    String[] form =
      VarInfoName.QuantHelper.format_jml(new VarInfoName[]
        { var().name });
    return form[0] + form[1] + " != " + (pointer_type ? "null" : "0") + form[2];
  }


  /* modeled after format_jml, kind of */
  public String format_dbc() {
    VarInfo v = ppt.var_infos[0];
    VarInfoName viname = var().name;

    if (viname instanceof VarInfoName.Elements) {
      return
        "quant.Quant.elementsNotEqual(" + var().name.dbc_name(var())
        + (pointer_type ? ", null" : ", 0") + ")";
    }

    // If viname instanceof VarInfoName.Slice, return warning message.
    return "(warning: format_dbc() unable to format:"
      + var().name.repr();

  }

//   public String format_dbc() {
//     //@tx
//     VarInfoName name = var().name;
//     if (name instanceof VarInfoName.Elements) {
//       VarInfoName term = ((VarInfoName.Elements) name).term;

//       if (var().type.isArray()) {
//       return "{ for (int i = 0; "+ term.dbc_name(var()) + "!= null && i < "
//            + term.dbc_name(var())+".length; i++) $assert ("
//            + term.dbc_name(var())+"[i] != null); }";
//       } else {
//         String termname = term.dbc_name(var());
//         if (termname.startsWith("this.")) {
//           termname = termname.replaceFirst("this\\.","");
//         }

//         // RRNtodo: wow, is this really illegal?
//         if (termname.indexOf(".") != -1) {
//           return "$none"; //if the termname contains ., it is illegal in DBC to use forall
//         } else {
//           return "{ $assert (" + termname + " != null); " +
//                    "$assert (" + termname + ".$forall (Object e; e != null)); }";
//         }
//         // return term.dbc_name() + ".containsNull == false";
//       }
//     }

//     // If this is just part of an array or Collection (name instanceof
//     // VarInfoName.Slice), then calling name.dbc_name() will always throw
//     // an exception, since var() is certainly a sequence.  So use the
//     // standard quantification.

//     String[] form =
//       VarInfoName.QuantHelper.format_dbc(new VarInfoName[]
//       { var().name });
//       return form[0] + "(" + form[1] + " != " + (pointer_type ? "null" : "0") + ")" + form[2];
//   }

  /* IOA */
  public String format_ioa() {
    VarInfoName.QuantHelper.IOAQuantification quant = new VarInfoName.QuantHelper.IOAQuantification (var ());
    String result = quant.getQuantifierExp() + quant.getVarName(0).ioa_name() + " \\in " +
      var().name.ioa_name() + " => " + quant.getVarIndexedString(0) + "~=";
    if (pointer_type) {
      return result + "null" + quant.getClosingExp();
    } else {
      return result + "0" + quant.getClosingExp();
    }
  }

  public String format_simplify() {
    String[] form =
      VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
        { var().name });
    return form[0] + "(NEQ " + form[1] + " " + (pointer_type ? "null" : "0") + ")" + form[2];
  }

  public InvariantStatus add_modified(PRIMITIVE[] a, int count) {
    for (int ai=0; ai<a.length; ai++) {
      PRIMITIVE v = a[ai];

      // The min and max tests will simultaneously succeed exactly once (for
      // the first value).
      if (EQUAL (v, 0)) {
        return InvariantStatus.FALSIFIED;
      }
      // XXX; uh oh -- flowing these is bad stuff; maybe search for
      // upper / lower bound instead when computing probability
      if (v < min) min = v;
      if (v > max) max = v;
    }
    return InvariantStatus.NO_CHANGE;
  }

  protected double computeConfidence() {
    // Maybe just use 0 as the min or max instead, and see what happens:
    // see whether the "nonzero" invariant holds anyway.  (Perhaps only
    // makes sense to do if the {Lower,Upper}Bound invariant doesn't imply
    // the non-zeroness.)  In that case, do still check for no values yet
    // received.
    if ((override_range == 0) && ((min > 0) || (max < 0))) {
      return Invariant.PROBABILITY_UNJUSTIFIED;
    } else {
      double probability_one_elt_nonzero = 1 - confidence_one_elt_nonzero();
      // return 1 - Math.pow(probability_one_elt_nonzero, ppt.num_mod_samples());
      return 1 - Math.pow(probability_one_elt_nonzero, ppt.num_samples());
    }
  }

  protected double computeProbability() {
    // Maybe just use 0 as the min or max instead, and see what happens:
    // see whether the "nonzero" invariant holds anyway.  (Perhaps only
    // makes sense to do if the {Lower,Upper}Bound invariant doesn't imply
    // the non-zeroness.)  In that case, do still check for no values yet
    // received.
    if ((override_range == 0) && ((min > 0) || (max < 0))) {
      return Invariant.PROBABILITY_UNJUSTIFIED;
    } else {
      double probability_one_elt_nonzero = 1 - confidence_one_elt_nonzero();
      // return Math.pow(probability_one_elt_nonzero, ppt.num_mod_samples());
      return Math.pow(probability_one_elt_nonzero, ppt.num_samples());
    }
  }

  private double confidence_one_elt_nonzero() {
    PRIMITIVE range;
    if (override_range != 0) {
      range = override_range;
    } else {
      int modulus = 1;

      // I need to come back and make this work.
      // {
      //   for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      //     Invariant inv = (Invariant) itor.next();
      //     if ((inv instanceof Modulus) && inv.enoughSamples()) {
      //       modulus = ((Modulus) inv).modulus;
      //       break;
      //     }
      //   }
      // }

      // Perhaps I ought to check that it's possible (given the modulus
      // constraints) for the value to be zero; otherwise, the modulus
      // constraint implies non-zero.
      range = (max - min + 1) / modulus;
    }
    return 1.0/range;
  }


  public boolean isSameFormula(Invariant other)
  {
    Assert.assertTrue(other instanceof CLASSNAME);
    return true;
  }

  public boolean isExclusiveFormula(Invariant other)
  {
    if (other instanceof ELTONEOF) {
      ELTONEOF eoo = (ELTONEOF) other;
      if ((eoo.num_elts() == 1) && (((NUMWRAPPER)eoo.elt()).PRIMITIVEVALUE == 0)) {
        return true;
      }
    }
    return false;
  }

  public DiscardInfo isObviousStatically(VarInfo[] vis) {
    if (!vis[0].aux.getFlag(VarInfoAux.HAS_NULL)) {
      // If it's not a number and null doesn't have special meaning...
      return new DiscardInfo(this, DiscardCode.obvious, "'null' has no special meaning for " + vis[0].name.name());
    }
    return super.isObviousStatically (vis);
  }


  public DiscardInfo isObviousDynamically(VarInfo[] vis) {
    // For every other EltNonZero at this program point, see if there is a
    // subsequence relationship between that array and this one.

    VarInfo v1 = vis[0];
    if (debug.isLoggable(Level.FINE)) {
      debug.fine ("Testing isObviousDynamically for " + v1.name.name());
    }

    PptTopLevel parent = ppt.parent;
    for (Iterator itor = parent.invariants_iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if ((inv instanceof CLASSNAME) && (inv != this) && inv.enoughSamples()) {
        VarInfo v2 = inv.ppt.var_infos[0];
        if (debug.isLoggable(Level.FINE)) {
          debug.fine ("  Have to test: " + inv.repr());
        }

        // First see if the subsequence relationship can be determined from the VarInfos
        if (SubSequence.isObviousSubSequenceDynamically(this, v1, v2)) {
          String discardString = v1.name.name() + " is a subsequence of " + v2.name.name() + " for which the invariant holds";
          return new DiscardInfo(this, DiscardCode.obvious, discardString);
        }
        //     Otherwise, look for the actual SubSequence invariant
        boolean this_var_first = (v1.varinfo_index < v2.varinfo_index);
        PptSlice2 slice_2seq = parent.findSlice_unordered (v1, v2);
        if (slice_2seq == null) {
          // System.out.println(CLASSSTRING + ".isObviousImplied: no slice for " + v1.name + ", " + v2.name);
        } else if (slice_2seq.num_samples() > 0) {
          // slice_2seq != null
          SubSequence ss = SubSequence.find(slice_2seq);
          if (ss == null) {
            // System.out.println(CLASSSTRING + ".isObviousImplied: no SubSequence for " + v1.name + ", " + v2.name);
          } else if (ss.justified()) {
            // System.out.println(CLASSSTRING + ".isObviousImplied: found SubSequence: " + ss.repr());
            if (this_var_first
                ? ss.var1_in_var2
                : ss.var2_in_var1) {
              debug.fine ("  True from subsequence search");
              String discardString = "";
              if (this_var_first)
                discardString = v1.name.name()+" is a subsequence of " + v2.name.name() + " for which the result is known";
              else
                discardString = v2.name.name()+" is a subsequence of " + v1.name.name() + " for which the result is known";
              return new DiscardInfo(this, DiscardCode.obvious, discardString);
            }
          }
        }
      }
    }

    return super.isObviousDynamically(vis);
  }

  // Look up a previously instantiated invariant.
  public static CLASSNAME find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof CLASSNAME)
        return (CLASSNAME) inv;
    }
    return null;
  }
  /**
   * Merge the invariants in invs to form a new invariant.  Each must be
   * a CLASSNAME invariant.  This code takes the min/max values
   * in each invariant, applies them to a new parent invariant and
   * returns the merged invariant.
   *
   * @param invs    List of invariants to merge.  The invariants must all be
   *                of the same type and should come from the children of
   *                ppt.  They should also all be permuted to match the variable
   *                order in ppt.
   * @param ppt     program point that will contain the new invariant
   */
  public Invariant merge (List invs, PptSlice ppt) {

    // Create the initial parent invariant
    CLASSNAME result = instantiate (ppt);
    Assert.assertTrue (result != null);

    // Loop through the child invariants
    for (int i = 0; i < invs.size(); i++ ) {

      // Get this invariant
      CLASSNAME inv = (CLASSNAME) invs.get (i);

      // update the min/max
      result.min = Math.min (inv.min, result.min);
      result.max = Math.max (inv.max, result.max);
    }

    result.log ("Merged '" + result.format() + "' from " + invs.size()
                + " child invariants");
    return (result);
  }


}
