#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define EQUAL(a,b) ((a) == (b))
  #define CLASSNAME EltNonZero
  #define SUPERCLASS SingleScalarSequence
  #define PRIMITIVE long
  #define NUMWRAPPER Long
  #define BASEISTYPE baseIsIntegral()
  #define PRIMITIVEVALUE longValue()
  #define ELTONEOF EltOneOf
  #define CLASSSTRING "EltNonZero"
#elif defined(TYPEDOUBLE)
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
  #define CLASSNAME EltNonZeroFloat
  #define SUPERCLASS SingleFloatSequence
  #define PRIMITIVE double
  #define NUMWRAPPER Double
  #define BASEISTYPE baseIsFloat()
  #define PRIMITIVEVALUE doubleValue()
  #define ELTONEOF EltOneOfFloat
  #define CLASSSTRING "EltNonZeroFloat"
#endif

// ***** This file is automatically generated from EltNonZero.java.jpp

package daikon.inv.unary.sequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.Invariant.OutputFormat;
import daikon.inv.binary.twoSequence.*;

import utilMDE.*;

import java.util.logging.Logger;
import java.util.logging.Level;

import java.util.*;



/**
 * Represents the invariant "x != 0" where x represents all of the elements
 * of a PRIMITIVE sequence.  Prints as 'x[] elements != 0'
 **/

public final class CLASSNAME
  extends SUPERCLASS
{
  /**
   * Debug tracer.
   **/
  public static final Logger debug =
    Logger.getLogger("daikon.inv.unary.sequence." + CLASSSTRING);


  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020522L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff EltNonZero invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  PRIMITIVE min = NUMWRAPPER.MAX_VALUE;
  PRIMITIVE max = NUMWRAPPER.MIN_VALUE;

  // If nonzero, use this as the range instead of the actual range.
  // This lets one use a specified probability of nonzero (say, 1/10
  // for pointers).
  int override_range = 0;
  boolean pointer_type = false;

  public CLASSNAME(PptSlice ppt) {
    super(ppt);
  }

  public static CLASSNAME instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    CLASSNAME result = new CLASSNAME(ppt);
    if (! ppt.var_infos[0].type.BASEISTYPE) {
      result.pointer_type = true;
      result.override_range = 3;
     }

    if (debug.isLoggable(Level.FINE)) {
      System.out.println(CLASSSTRING + ".instantiate: " + result.format());
    }
    return result;
  }

  public String repr() {
    return CLASSSTRING + varNames() + ": "
      + !falsified + ",min=" + min + ",max=" + max;
  }

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.DAIKON) return format_daikon();
    if (format == OutputFormat.ESCJAVA) return format_esc();
    if (format == OutputFormat.IOA) return format_ioa();
    if (format == OutputFormat.SIMPLIFY) return format_simplify();
    if (format == OutputFormat.JML) return format_jml();

    return format_unimplemented(format);
  }

  public String format_daikon() {
    return var().name.name() + " elements != " + (pointer_type ? "null" : "0");
  }

  // We are a special case where a ghost field can actually talk about
  // array contents.
  public boolean isValidEscExpression() {
    return true;
  }

  public String format_esc() {
    // If this is an entire array or Collection (not VarInfoName.Slice), then
    //  * for arrays: use \nonnullelements(A)
    //  * for Collections: use collection.containsNull == false
    //    (the latter also requires that ghost field to get set)

    VarInfoName name = var().name;
    if (name instanceof VarInfoName.Elements) {
      VarInfoName term = ((VarInfoName.Elements) name).term;
      if (var().type.isArray()) {
        return "\\nonnullelements(" + term.esc_name() + ")";
      } else {
        return term.esc_name() + ".containsNull == false";
      }
    }

    // If this is just part of an array or Collection (name instanceof
    // VarInfoName.Slice), then calling name.esc_name() will always throw
    // an exception, since var() is certainly a sequence.  So use the
    // standard quantification.

    String[] form =
      VarInfoName.QuantHelper.format_esc(new VarInfoName[]
        { var().name });
    return form[0] + "(" + form[1] + " != " + (pointer_type ? "null" : "0") + ")" + form[2];
  }

  public String format_jml() {
    // If this is an entire array or Collection (not VarInfoName.Slice), then
    //  * for arrays: use \nonnullelements(A)
    //  * for Collections: use collection.containsNull == false
    //    (the latter also requires that ghost field to get set)

    VarInfoName name = var().name;
    if (name instanceof VarInfoName.Elements) {
      VarInfoName term = ((VarInfoName.Elements) name).term;
      if (var().type.isArray()) {
        return "\\nonnullelements(" + term.jml_name() + ")";
      } else {
        return term.jml_name() + ".containsNull == false";
      }
    }

    // If this is just part of an array or Collection (name instanceof
    // VarInfoName.Slice), then calling name.jml_name() will always throw
    // an exception, since var() is certainly a sequence.  So use the
    // standard quantification.

    String[] form =
      VarInfoName.QuantHelper.format_jml(new VarInfoName[]
        { var().name });
    return form[0] + form[1] + " != " + (pointer_type ? "null" : "0") + form[2];
  }

  /* IOA */
  public String format_ioa() {
    VarInfoName.QuantHelper.IOAQuantification quant = new VarInfoName.QuantHelper.IOAQuantification (var ());
    String result = quant.getQuantifierExp() + quant.getVarName(0).ioa_name() + " \\in " +
      var().name.ioa_name() + " => " + quant.getVarIndexedString(0) + "~=";
    if (pointer_type) {
      return result + "null" + quant.getClosingExp();
    } else {
      return result + "0" + quant.getClosingExp();
    }
  }

  public String format_simplify() {
    String[] form =
      VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
        { var().name });
    return form[0] + "(NEQ " + form[1] + " " + (pointer_type ? "null" : "0") + ")" + form[2];
  }

  public void add_modified(PRIMITIVE[] a, int count) {
    for (int ai=0; ai<a.length; ai++) {
      PRIMITIVE v = a[ai];

      // The min and max tests will simultaneously succeed exactly once (for
      // the first value).
      if (EQUAL (v, 0)) {
        destroyAndFlow();
        discardCode = DiscardCode.bad_sample;
        discardString = var().name.name()+"["+ai+"]==0";
        return;
      }
      // XXX; uh oh -- flowing these is bad stuff; maybe search for
      // upper / lower bound instead when computing probability
      if (v < min) min = v;
      if (v > max) max = v;
    }
  }

  protected double computeProbability() {
    Assert.assertTrue(! falsified);
    // Maybe just use 0 as the min or max instead, and see what happens:
    // see whether the "nonzero" invariant holds anyway.  (Perhaps only
    // makes sense to do if the {Lower,Upper}Bound invariant doesn't imply
    // the non-zeroness.)  In that case, do still check for no values yet
    // received.
    if ((override_range == 0) && ((min > 0) || (max < 0)))
      return Invariant.PROBABILITY_UNJUSTIFIED;
    else {
      PRIMITIVE range;
      if (override_range != 0) {
        range = override_range;
      } else {
        int modulus = 1;

        // I need to come back and make this work.
        // {
        //   for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
        //     Invariant inv = (Invariant) itor.next();
        //     if ((inv instanceof Modulus) && inv.enoughSamples()) {
        //       modulus = ((Modulus) inv).modulus;
        //       break;
        //     }
        //   }
        // }

        // Perhaps I ought to check that it's possible (given the modulus
        // constraints) for the value to be zero; otherwise, the modulus
        // constraint implies non-zero.
        range = (max - min + 1) / modulus;
      }
      double probability_one_elt_nonzero = 1 - 1.0/range;
      // This could underflow; so consider doing
      //   double log_probability = self.samples*math.log(probability);
      // then calling Math.exp (if the value is in the range that wouldn't
      // cause underflow).
      return Math.pow(probability_one_elt_nonzero, ppt.num_mod_non_missing_samples());
    }
  }

  public boolean isSameFormula(Invariant other)
  {
    Assert.assertTrue(other instanceof CLASSNAME);
    return true;
  }

  public boolean isExclusiveFormula(Invariant other)
  {
    if (other instanceof ELTONEOF) {
      ELTONEOF eoo = (ELTONEOF) other;
      if ((eoo.num_elts() == 1) && (((NUMWRAPPER)eoo.elt()).PRIMITIVEVALUE == 0)) {
        return true;
      }
    }
    return false;
  }

  public boolean isObviousStatically(VarInfo[] vis) {
    if (!vis[0].aux.getFlag(VarInfoAux.HAS_NULL)) {
      // If it's not a number and null doesn't have special meaning...
      return true;
    }
    return super.isObviousStatically (vis);
  }


  public boolean isObviousDynamically(VarInfo[] vis) {
    // For every other EltNonZero at this program point, see if there is a
    // subsequence relationship between that array and this one.

    VarInfo v1 = vis[0];
    if (debug.isLoggable(Level.FINE)) {
      debug.fine ("Testing isObviousDynamically for " + v1.name.name());
    }

    PptTopLevel parent = ppt.parent;
    for (Iterator itor = parent.invariants_iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if ((inv instanceof CLASSNAME) && (inv != this) && inv.enoughSamples()) {
        VarInfo v2 = inv.ppt.var_infos[0];
        if (debug.isLoggable(Level.FINE)) {
          debug.fine ("  Have to test: " + inv.repr());
        }

        // First see if the subsequence relationship can be determined from the VarInfos
        if (SubSequence.isObviousSubSequenceDynamically(this, v1, v2)) {
          discardCode = DiscardCode.obvious;
          discardString = v1.name.name()+" is a subsequence of "+v2.name.name()+" for which the result is known";
          return true;
        }
        //     Otherwise, look for the actual SubSequence invariant
        boolean this_var_first = (v1.varinfo_index < v2.varinfo_index);
        PptSlice2 slice_2seq = parent.findSlice_unordered (v1, v2);
        if (slice_2seq == null) {
          // System.out.println(CLASSSTRING + ".isObviousImplied: no slice for " + v1.name + ", " + v2.name);
        } else if (slice_2seq.num_samples() > 0) {
          // slice_2seq != null
          SubSequence ss = SubSequence.find(slice_2seq);
          if (ss == null) {
            // System.out.println(CLASSSTRING + ".isObviousImplied: no SubSequence for " + v1.name + ", " + v2.name);
          } else if (ss.justified()) {
            // System.out.println(CLASSSTRING + ".isObviousImplied: found SubSequence: " + ss.repr());
            if (this_var_first
                ? ss.var1_in_var2
                : ss.var2_in_var1) {
              debug.fine ("  True from subsequence search");
              discardCode = DiscardCode.obvious;
              if (this_var_first)
                discardString = v1.name.name()+" is a subsequence of "+v2.name.name()+" for which the result is known";
              else
                discardString = v2.name.name()+" is a subsequence of "+v1.name.name()+" for which the result is known";
              return true;
            }
          }
        }
      }
    }

    return super.isObviousDynamically(vis);
  }

  // Look up a previously instantiated invariant.
  public static CLASSNAME find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof CLASSNAME)
        return (CLASSNAME) inv;
    }
    return null;
  }

}
