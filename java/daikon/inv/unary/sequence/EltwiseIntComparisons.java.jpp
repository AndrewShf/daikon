package daikon.inv.unary.sequence;

#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

// New jpp logic (one class for each type of comparison, eg. <, >, =, etc.)

#if !(defined(EQUAL) || defined(NONEQUAL) || defined(LESSTHAN) || defined(LESSEQUAL) || defined(GREATERTHAN) || defined(GREATEREQUAL) || defined(EQUALFLOAT) || defined(NONEQUALFLOAT) || defined(LESSTHANFLOAT) || defined(LESSEQUALFLOAT) || defined(GREATERTHANFLOAT) || defined(GREATEREQUALFLOAT))
#error "EQUAL, NONEQUAL, LESSTHAN, LESSEQUAL, GREATERTHAN, or GREATEREQUAL should be defined"
#endif

#if defined(EQUAL) || defined(NONEQUAL) || defined(LESSTHAN) || defined(LESSEQUAL) || defined(GREATERTHAN) || defined(GREATEREQUAL)
#define TYPELONG
#else
#define TYPEDOUBLE
#endif

#if defined(TYPEDOUBLE)
#define SUPERCLASS EltwiseFloatComparison
#define PRIMITIVE double
#define ELTONEOF EltOneOfFloat
#elif defined(TYPELONG)
#define SUPERCLASS EltwiseIntComparison
#define PRIMITIVE long
#define ELTONEOF EltOneOf
#endif

  // These definitions are included such that the class names can be changed
  // easily and furthermore such that segments of this code can be easily
  // modified to work elsewhere.

#define EQUALCLASS EltwiseIntEqual
#define NONEQUALCLASS EltwiseIntNonEqual
#define LESSTHANCLASS EltwiseIntLessThan
#define LESSEQUALCLASS EltwiseIntLessEqual
#define GREATERTHANCLASS EltwiseIntGreaterThan
#define GREATEREQUALCLASS EltwiseIntGreaterEqual

#define EQUALFLOATCLASS EltwiseFloatEqual
#define NONEQUALFLOATCLASS EltwiseFloatNonEqual
#define LESSTHANFLOATCLASS EltwiseFloatLessThan
#define LESSEQUALFLOATCLASS EltwiseFloatLessEqual
#define GREATERTHANFLOATCLASS EltwiseFloatGreaterThan
#define GREATEREQUALFLOATCLASS EltwiseFloatGreaterEqual

#if defined(EQUAL)
#define CLASSNAME EQUALCLASS
#define CLASSSTRING "EltwiseIntEqual"
#define COMPARATOR ==
#define COMPARATORSTRING "=="
#elif defined(NONEQUAL)
#define CLASSNAME NONEQUALCLASS
#define CLASSSTRING "EltwiseIntNonEqual"
#define COMPARATOR !=
#define COMPARATORSTRING "!="
#elif defined(LESSTHAN)
#define CLASSNAME LESSTHANCLASS
#define CLASSSTRING "EltwiseIntLessThan"
#define COMPARATOR <
#define COMPARATORSTRING "<"
#elif defined(LESSEQUAL)
#define CLASSNAME LESSEQUALCLASS
#define CLASSSTRING "EltwiseIntLessEqual"
#define COMPARATOR <=
#define COMPARATORSTRING "<="
#elif defined(GREATERTHAN)
#define CLASSNAME GREATERTHANCLASS
#define CLASSSTRING "EltwiseIntGreaterThan"
#define COMPARATOR >
#define COMPARATORSTRING ">"
#elif defined(GREATEREQUAL)
#define CLASSNAME GREATEREQUALCLASS
#define CLASSSTRING "EltwiseIntGreaterEqual"
#define COMPARATOR >=
#define COMPARATORSTRING ">="
#elif defined(EQUALFLOAT)
#define CLASSNAME EQUALFLOATCLASS
#define CLASSSTRING "EltwiseFloatEqual"
#define COMPARATOR ==
#define COMPARATORSTRING "=="
#elif defined(NONEQUALFLOAT)
#define CLASSNAME NONEQUALFLOATCLASS
#define CLASSSTRING "EltwiseFloatNonEqual"
#define COMPARATOR !=
#define COMPARATORSTRING "!="
#elif defined(LESSTHANFLOAT)
#define CLASSNAME LESSTHANFLOATCLASS
#define CLASSSTRING "EltwiseFloatLessThan"
#define COMPARATOR <
#define COMPARATORSTRING "<"
#elif defined(LESSEQUALFLOAT)
#define CLASSNAME LESSEQUALFLOATCLASS
#define CLASSSTRING "EltwiseFloatLessEqual"
#define COMPARATOR <=
#define COMPARATORSTRING "<="
#elif defined(GREATERTHANFLOAT)
#define CLASSNAME GREATERTHANFLOATCLASS
#define CLASSSTRING "EltwiseFloatGreaterThan"
#define COMPARATOR >
#define COMPARATORSTRING ">"
#elif defined(GREATEREQUALFLOAT)
#define CLASSNAME GREATEREQUALFLOATCLASS
#define CLASSSTRING "EltwiseFloatGreaterEqual"
#define COMPARATOR >=
#define COMPARATORSTRING ">="
#endif

// Old jpp logic (one comparison type)

// #if !(defined(TYPELONG) || defined(TYPEDOUBLE))
// #error "ONE MUST BE DEFINED"
// #endif

// #if defined(TYPEDOUBLE)
// #define CLASSNAME EltwiseFloatComparison
// #define SUPERCLASS SingleFloatSequence
// #define PRIMITIVE double
// #define CORECLASS FloatComparisonCore
// #define CLASSSTRING "EltwiseFloatComparison"
// #define ELTONEOF EltOneOfFloat
// #elif defined(TYPELONG)
// #define CLASSNAME EltwiseIntComparison
// #define SUPERCLASS SingleScalarSequence
// #define PRIMITIVE long
// #define CORECLASS IntComparisonCore
// #define CLASSSTRING "EltwiseIntComparison"
// #define ELTONEOF EltOneOf
// #endif

// ***** This file is automatically generated from EltwiseIntComparison.java.jpp

import daikon.*;
import daikon.derive.*;
import daikon.derive.binary.*;
import daikon.inv.*;
// import daikon.inv.binary.twoScalar.CORECLASS;
import utilMDE.*;
import java.util.*;


/**
 * This compares adjacent elements in the sequence.
 **/
public class CLASSNAME
  extends SUPERCLASS
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030112L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff EltwiseIntComparison invariants should be considered.
   **/
  public static boolean dkconfig_enabled = true;

  final static boolean debugEltwiseIntComparison = false;

  // If no sample passes by that has 2 or more elements in an array then the
  // invariant is vacuously true; no comparison was ever made and thus the
  // invariant remains true by default. However, it is certainly not worth
  // printing in this case.
  private boolean seenNonTrivialSample = false;

  // Not using core after splitting invariant into different comparison types
  // public CORECLASS core;

  protected CLASSNAME(PptSlice ppt) {
    super(ppt);
  }

  public static CLASSNAME instantiate(PptSlice ppt) {
    if (!dkconfig_enabled) return null;
    // Don't compute ordering relationships over object addresses for
    // elements of a Vector.  (But do compute equality/constant!)

    // This check was before contained in the core
#if !(defined(EQUAL) || defined(EQUALFLOAT))
    if (!ppt.var_infos[0].type.baseIsIntegral())
      return null;
#endif
    return new CLASSNAME(ppt);
  }

  protected Object clone() {
    CLASSNAME result = (CLASSNAME) super.clone();
    return result;
  }

  public String repr() {
    return CLASSSTRING + varNames() + ": "
      + "falsified=" + falsified;
  }

  public String format_using(OutputFormat format) {
    if (format == OutputFormat.DAIKON) return format_daikon();
    if (format == OutputFormat.IOA) return format_ioa();
    if (format == OutputFormat.ESCJAVA) return format_esc();
    if (format == OutputFormat.SIMPLIFY) return format_simplify();
    if (format == OutputFormat.JML) return format_jml();

    return format_unimplemented(format);
  }

  public String format_daikon() {
    if (debugEltwiseIntComparison) {
      System.out.println(repr());
    }
#if defined(EQUAL) || defined(FLOATEQUAL)
    return var().name.name() + " elements are equal";
#else
    return (var().name.name() + " sorted by " + COMPARATORSTRING);
#endif
  }


  /* IOA */
  public String format_ioa() {
    VarInfoName.QuantHelper.IOAQuantification quant = new VarInfoName.QuantHelper.IOAQuantification(var(), var());

    String comparator = COMPARATORSTRING;
    String result = quant.getQuantifierExp() + "(" + quant.getMembershipRestriction(0) + " /\\ " + quant.getMembershipRestriction(1);
    if ("==".equals(comparator)) {
      // i \in X /\ j \in X => X[i] = X[j]
      result = result + ") => " + quant.getVarIndexed(0) + " = " + quant.getVarIndexed(1);
    } else {
      // i \in X /\ j \in X /\ i+1 = j => X[i] = X[j]
      result = result +
        " /\\ " + quant.getVarName(0) + "+1 = " + quant.getVarName(1) +
        ") => " +
        quant.getVarIndexed(0) + " = " + quant.getVarIndexed(1);
    }
    return result + quant.getClosingExp();
  }

  public String format_esc() {
    String[] form =
      VarInfoName.QuantHelper.format_esc(new VarInfoName[]
        { var().name, var().name });
    String comparator = COMPARATORSTRING;
    if ("==".equals(comparator)) {
      return form[0] + "(" + form[1] + " == " + form[2] + ")" + form[3];
    } else {
      return form[0] + "((i+1 == j) ==> (" + form[1] + " " + comparator + " " + form[2] + "))" + form[3];
    }
  }

  public String format_jml() {
    String[] form =
      VarInfoName.QuantHelper.format_jml(new VarInfoName[]
        { var().name, var().name });
    String comparator = COMPARATORSTRING;
    if ("==".equals(comparator)) {
      return form[0] + "(" + form[1] + " == " + form[2] + ")" + form[3];
    } else {
      return form[0] + "((i+1 == j) ==> (" + form[1] + " " + comparator + " " + form[2] + ")" + form[3];
    }
  }

  public String format_simplify() {
    String[] form =
      VarInfoName.QuantHelper.format_simplify(new VarInfoName[]
        { var().name, var().name });
    String comparator = COMPARATORSTRING;
    if ("==".equals(comparator)) {
      return form[0] + "(EQ " + form[1] + " " + form[2] + ")" + form[3];
    } else {
      return form[0] + "(IMPLIES (EQ (+ i 1) j) (" + comparator + " " + form[1] + " " + form[2] + "))" + form[3];
    }
  }

  public void add_modified(PRIMITIVE[] a, int count) {
    if (a.length >= 2)
      seenNonTrivialSample = true;
    for (int i=1; i<a.length; i++) {
      if (!(a[i-1] COMPARATOR a[i])) {
        destroyAndFlow();
        return;
      }
    }
  }

  // Perhaps check whether all the arrays of interest have length 0 or 1.

  protected double computeProbability() {
    if (falsified) {
      return Invariant.PROBABILITY_NEVER;
    }
#if defined(EQUAL) || defined(NONEQUAL) || defined(EQUALFLOAT) || defined(NONEQUALFLOAT)
    if (ppt.num_samples() != 0)
      return Invariant.PROBABILITY_JUSTIFIED;
    else
      return Invariant.PROBABILITY_UNJUSTIFIED;
#else
      return Math.pow(.5, ppt.num_samples());
#endif
  }

  public boolean isExact() {
#if defined(EQUAL) || defined(NONEQUAL) || defined(EQUALFLOAT) || defined(NONEQUALFLOAT)
    return true;
#else
    return false;
#endif
  }

  public boolean isSameFormula(Invariant other)
  {
    return (other instanceof CLASSNAME);
  }

  // Not pretty... is there another way?
  // Also, reasonably complicated, need to ensure exact correctness, not sure if the
  // regression tests test this functionality

  public boolean isExclusiveFormula(Invariant other)
  {
    if (other instanceof SUPERCLASS) {
#if defined(EQUAL) || defined(EQUALFLOAT)
      return !((other instanceof EQUALCLASS) || (other instanceof EQUALFLOATCLASS)
               || (other instanceof LESSEQUALCLASS) || (other instanceof LESSEQUALFLOATCLASS)
               || (other instanceof GREATEREQUALCLASS) || (other instanceof GREATEREQUALFLOATCLASS));
#elif defined(NONEQUAL) || defined(NONEQUALFLOAT)
      return (other instanceof EQUALCLASS) || (other instanceof EQUALFLOATCLASS);
#elif defined(LESSTHAN) || defined(LESSTHANFLOAT)
      return !((other instanceof LESSTHANCLASS) || (other instanceof LESSTHANFLOATCLASS)
               || (other instanceof LESSEQUALCLASS) || (other instanceof LESSEQUALFLOATCLASS)
               || (other instanceof NONEQUALCLASS) || (other instanceof NONEQUALFLOATCLASS));
#elif defined(LESSEQUAL) || defined(LESSEQUALFLOAT)
      return (other instanceof GREATERTHANCLASS) || (other instanceof GREATERTHANFLOATCLASS);
#elif defined(GREATERTHAN) || defined(GREATERTHANFLOAT)
      return !((other instanceof GREATERTHANCLASS) || (other instanceof GREATERTHANFLOATCLASS)
               || (other instanceof GREATEREQUALCLASS) || (other instanceof GREATEREQUALFLOATCLASS)
               || (other instanceof NONEQUALCLASS) || (other instanceof NONEQUALFLOATCLASS));
#else // defined(GREATEREQUAL) || defined(GREATEREQUALFLOATCLASS)
      return (other instanceof LESSTHANCLASS) || (other instanceof LESSTHANFLOATCLASS);
#endif
    }
    return false;
  }

  // Look up a previously instantiated invariant.
  public static CLASSNAME find(PptSlice ppt) {
    Assert.assertTrue(ppt.arity == 1);
    for (Iterator itor = ppt.invs.iterator(); itor.hasNext(); ) {
      Invariant inv = (Invariant) itor.next();
      if (inv instanceof CLASSNAME)
        return (CLASSNAME) inv;
    }
    return null;
  }



  // Copied from IntComparison.
  // public boolean isExclusiveFormula(Invariant other)
  // {
  //   if (other instanceof IntComparison) {
  //     return core.isExclusiveFormula(((IntComparison) other).core);
  //   }
  //   if (other instanceof IntNonEqual) {
  //     return isExact();
  //   }
  //   return false;
  // }

  /**
   * This function returns whether a sample has been seen by this Invariant
   * that includes two or more entries in an array. For a 0 or 1 element array
   * a, a[] sorted by any binary operation is "vacuously true" because no check
   * is ever made since the binary operation requires two operands.  Thus
   * although invariants of this type are true regarding 0 or 1 length arrays,
   * they are meaningless.  This function is meant to be used in isObviousImplied()
   * to prevent such meaningless invariants from being printed.
   */
  public boolean hasSeenNonTrivialSample() {
    return seenNonTrivialSample;
  }

  // Note to self: Be sure to port this back to version 2l

  public boolean isObviousImplied() {
    if (!hasSeenNonTrivialSample())
      return true;

    ELTONEOF eoo = ELTONEOF.find(ppt);
    if ((eoo != null) && eoo.enoughSamples() && (eoo.num_elts() == 1)) {
      return true;
    }

    {
    // some relations imply others as follows: < -> <=, > -> >=, > or < -> !=,
    // == -> <=, >=
    // also, a contains no duplicates -> !=

    // This code lets through some implied invariants, here is how:
    // In the ESC, JML, Java modes of output, the invariants are guarded before
    // printing.  This guarding makes some of the invariants that are searched for
    // (example, NoDuplicates) unable to be found since it won't find something of
    // the form (a -> NoDuplicates).  This can cause cases to exist, for example,
    // the invariants (a -> b[] sorted by !=), (a -> b[] has no duplicates) existing
    // in the same ppt where one is obviously implied by the other. I am not sure
    // currently of the best way with dealing with this, but I am going to allow
    // these other invariants to exist for now because they are not wrong, just
    // obvious.

#if defined(LESSEQUAL) || defined(LESSEQUALFLOAT)
    Iterator invs = ppt.invs.iterator();
    while (invs.hasNext()) {
      Invariant inv = (Invariant)invs.next();
      if ((inv instanceof LESSTHANCLASS) || (inv instanceof LESSTHANFLOATCLASS) ||
          (inv instanceof EQUALCLASS) || (inv instanceof EQUALFLOATCLASS))
        return true;
    }
#elif defined(GREATEREQUAL) || defined(GREATEREQUALFLOAT)
    Iterator invs = ppt.invs.iterator();
    while (invs.hasNext()) {
      Invariant inv = (Invariant)invs.next();
      if ((inv instanceof GREATERTHANCLASS) || (inv instanceof GREATERTHANFLOATCLASS) ||
          (inv instanceof EQUALCLASS) || (inv instanceof EQUALFLOATCLASS))
        return true;
    }
#elif defined(NONEQUAL) || defined(NONEQUALFLOAT)
    Iterator invs = ppt.invs.iterator();
    while (invs.hasNext()) {
      Invariant inv = (Invariant)invs.next();
      if ((inv instanceof LESSTHANCLASS) || (inv instanceof LESSTHANFLOATCLASS) ||
          (inv instanceof GREATERTHANCLASS) || (inv instanceof GREATERTHANFLOATCLASS) ||
          (inv instanceof NoDuplicates))
        return true;
    }
#endif
    }

    // sorted by (any operation) for an entire sequence -> sorted by that same
    // operation for a subsequence

    // Is there a better way to check if the VarInfo in this invariant is part
    // of a larger sequence?

    Derivation deriv = ppt.var_infos[0].derived;

    if (deriv != null && deriv instanceof SequenceSubsequence) {
      // Find the slice with the full sequence, check for an invariant of this type
      PptSlice sliceToCheck = ppt.parent.findSlice(((SequenceSubsequence)deriv).seqvar());
      if (sliceToCheck != null) {
        Iterator invs = sliceToCheck.invs.iterator();

        while (invs.hasNext()) {
          Invariant inv = (Invariant)invs.next();
          if (inv.getClass().equals(getClass()))
            return true;
        }
      }
    }

    return false;
  }
}
