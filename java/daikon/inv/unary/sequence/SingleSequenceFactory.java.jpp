#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME SingleScalarSequenceFactory
  #define ONEOFSEQUENCE OneOfSequence
  #define ELTONEOF EltOneOf
  #define ELTNONZERO EltNonZero
  #define NODUPLICATES NoDuplicates
  #if 0
    // #define ELTWISEINTCOMPARISON EltwiseIntComparison
  #endif
  #define ELTLOWERBOUND EltLowerBound
  #define ELTUPPERBOUND EltUpperBound
  #define ARRAY_TYPE INT_ARRAY
  #define ISTYPE elementIsIntegral()
  #define COMMONSEQUENCE CommonSequence
#elif defined(TYPEDOUBLE)
  #define CLASSNAME SingleFloatSequenceFactory
  #define ONEOFSEQUENCE OneOfFloatSequence
  #define ELTONEOF EltOneOfFloat
  #define ELTNONZERO EltNonZeroFloat
  #define NODUPLICATES NoDuplicatesFloat
  #if 0
    // #define ELTWISEINTCOMPARISON EltwiseFloatComparison
  #endif
  #define ELTLOWERBOUND EltLowerBoundFloat
  #define ELTUPPERBOUND EltUpperBoundFloat
  #define ARRAY_TYPE DOUBLE_ARRAY
  #define ISTYPE elementIsFloat()
  #define COMMONSEQUENCE CommonFloatSequence
#endif


// ***** This file is automatically generated from SingleSequenceFactory.java.jpp

package daikon.inv.unary.sequence;

import daikon.*;

import utilMDE.*;

import java.util.*;



public final class CLASSNAME {

  // Adds the appropriate new Invariant objects to the specified Invariants
  // collection.
  public static Vector instantiate(PptSlice ppt) {

    VarInfo var = ppt.var_infos[0];
    Assert.assertTrue(var.rep_type == ProglangType.ARRAY_TYPE);
    Assert.assertTrue(var.type.pseudoDimensions() > 0);

    Vector result = new Vector();
    { // previously (pass == 1)
      result.add(ONEOFSEQUENCE.instantiate(ppt));
      result.add(ELTONEOF.instantiate(ppt));
    }
    { // previously (pass == 2)
      // ELTONEOF eoo = ELTONEOF.find(ppt);
      // if (!((eoo != null) && (eoo.num_elts() == 1)))
      {
        result.add(ELTNONZERO.instantiate(ppt));
        result.add(NODUPLICATES.instantiate(ppt));
        result.add(COMMONSEQUENCE.instantiate(ppt));
        if (var.type.ISTYPE) {
          // result.add(ELTWISEINTCOMPARISON.instantiate(ppt));

          result.add(ELTLOWERBOUND.instantiate(ppt));
          result.add(ELTUPPERBOUND.instantiate(ppt));
          #if defined(TYPELONG)
            result.add(SeqIndexIntEqual.instantiate(ppt));
            result.add(SeqIndexIntNonEqual.instantiate(ppt));
            result.add(SeqIndexIntGreaterEqual.instantiate(ppt));
            result.add(SeqIndexIntGreaterThan.instantiate(ppt));
            result.add(SeqIndexIntLessEqual.instantiate(ppt));
            result.add(SeqIndexIntLessThan.instantiate(ppt));
          #else
            result.add(SeqIndexFloatEqual.instantiate(ppt));
            result.add(SeqIndexFloatNonEqual.instantiate(ppt));
            result.add(SeqIndexFloatGreaterEqual.instantiate(ppt));
            result.add(SeqIndexFloatGreaterThan.instantiate(ppt));
            result.add(SeqIndexFloatLessEqual.instantiate(ppt));
            result.add(SeqIndexFloatLessThan.instantiate(ppt));
          #endif
        }

        // Must now instantiate one of each type... perhaps this functionality
        // can be moved to their superclass EltwiseIntComparison.
#if defined(TYPELONG)
        result.add(EltwiseIntEqual.instantiate(ppt));
        result.add(EltwiseIntLessThan.instantiate(ppt));
        result.add(EltwiseIntLessEqual.instantiate(ppt));
        result.add(EltwiseIntGreaterThan.instantiate(ppt));
        result.add(EltwiseIntGreaterEqual.instantiate(ppt));
#elif defined(TYPEDOUBLE)
        result.add(EltwiseFloatEqual.instantiate(ppt));
        result.add(EltwiseFloatLessThan.instantiate(ppt));
        result.add(EltwiseFloatLessEqual.instantiate(ppt));
        result.add(EltwiseFloatGreaterThan.instantiate(ppt));
        result.add(EltwiseFloatGreaterEqual.instantiate(ppt));
#endif
      }
    }
    return result;
  }

  private CLASSNAME() {
  }

}
