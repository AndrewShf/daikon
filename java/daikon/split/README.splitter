         Finding Conditional Invariants and Implications
         ===============================================

@cindex splitting
@cindex splitting condition
@cindex conditional invariant
@cindex invariant, conditional
@cindex implication invariant
@cindex invariant, implication
@cindex splitter info file
@cindex .spinfo file

Conditional invariants are invariants that are true only part of the time.
For instance, the postcondition for the absolute value procedure is

  if arg < 0
    then return == -arg
    else return == arg

The invariant "return == -arg" is a conditional invariant because it
depends on the condition "arg < 0" being true.  The compound invariant that
includes both the condition and the conditional invariant is called an
implication.

Daikon must be supplied with the predicate for an implication.  Certain
such conditions are built into Daikon; examples are which return statement
was executed in a procedure and whether a boolean procedure returns true or
false.  Additionally, Daikon can read predicates from a file called a
Splitter info (.spinfo) file.  The splitter info file can be produced
automatically, such as by the createspinfo.pl script (see below).  Users
can also create splitter info files by hand or manually augment
automatically-created ones.

To detect condition invariants and implications:
1) Create the Splitter info file, either automatically or by hand.
2) Run Daikon with the .spinfo file as one of its arguments.  For example,
  java daikon.Daikon Foo.decls Foo.spinfo Foo.dtrace

The createspinfo.pl program take Java source code as input and creates a
Splitter info file; for instance, createspinfo.pl Foo.java creates the
Splitter info file Foo.spinfo.  The splitter file contains each boolean
expression that appears in the source code.  The conditions that the
programmer used are likely to be important semantic properties, so this
simple heuristic can be surprisingly effective.  Users may optionally edit
the Splitter info file to enhance it, or may create a splitter info file by
hand.

The term "splitter" comes from Daikon's technique for detecting
implications and conditional invariants.  Daikon creates new conditional
program points -- one each for the condition and its negation -- and splits
the data trace into parts based on a predicate called the splitting
condition (in the example above, it was "arg < 0").  Invariant detection is
then performed on the conditional program points (that is, the parts of the
data trace) separately and any invariants detected are reported as
conditional invariants (as implications).


The conditions can be specific to one program point, or Daikon can use them
...
(Give pros and cons of each.)


======================
The Splitter Info file
======================

A Splitter Info file contains the conditions that Daikon should use to
create conditional invariants.

Each section in the .spinfo consists of a sequence of non-blank lines;
sections are separated by blank lines.  Program point sections have a line
specifying a program point name followed by lines specifying the
condition(s) associated with that program point, each condition on its own
line.  For example, a typical entry is

PPT_NAME <ppt name>
condition1
condition2
.
.
.

Each condition is a Java expression of boolean type.  All variables that
appear in the condition must also appear in the declaration of the program
point in the .decls file.  (In other words, all the variables must be in
scope at the program point(s) where the Splitter is intended to
operate.

@c Exceptions to this are described in the REPLACEMENT section.


===========
REPLACEMENT
===========

Ordinarily, a splitting condition may not invoke user-defined methods,
because when Daikon reads data trace files, it does not have access to the
program source.  A replace section of the splitter info file can specify
the bodies of methods, permitting conditions to invoke those methods.  The
format is as follows:

REPLACE
procedure1
replacement1
procedure2
replacement2
.
.
.

where replacementi contains an expression representing the body of
procedurei.  In each condition, Daikon replaces procedure calls by their
replacements.  A replace section can appear anywhere in the Splitter Info
file.

========================
INDISCRIMINATE SPLITTING
========================

Ordinarily, each condition gives rise to conditional invariants only at the
program point in whose section the condition appears.  Alternately, every
condition can be used at every program point, regardless of where in the
.spinfo file the condition appeared; this latter approach is called
"indiscriminate splitting".  Indiscriminate splitting can result in Daikon
attempting to use many conditions that are inappropriate at certain program
points, for instance because the the program point does not have (in scope)
all the variables that are used in the condition.  For example, the
condition "myArray.length == x" is inapplicable at a program point if
either of 'myArray' and 'x' is not in scope at that program point.  In this
case, Daikon produces an error message and proceeds, using conditions
wherever they are valid.

To use indiscriminate splitting, set the value of the configuration option
variable daikon.split.SplitterList.all_splitters to a non-zero value in
file daikon/config/defaults.txt.

========
EXAMPLES
========

Below is an implementation of a simple Queue for positive integers and an
associated .spinfo file.

class simpleQueue {
 
 private int[] myArray;
  private int currentSize;
 
  public simpleQueue(int capacity) {
    myArray = new int[capacity];
    currentSize = 0;
  }
 
  /** adds an element to the back of the queue, if it's not empty.
   * returns true if this succeeds, false otherwise  **/
  public String enqueue(int x) {
    if ( !isFull() && x >= 0) {
      myArray[currentSize] = x;
      currentSize++;
      return (true);
    } else {
      return (false);
    }
  }
 
  /** takes the last element put into the queue or -1 if the queue is empty **/
  public int dequeue() {
    if ( !isEmpty() ) {
      currentSize--;
      return myArray[currentSize];
    } else {
      return -1;
    }
  }

 /** returns true if the queue is empty, false otherwise **/
  private boolean isEmpty() {
    return (currentSize == 0);
  }

  /** returns true if the queue is full, false otherwise **/
  private boolean isFull() {
    return (currentSize == myArray.length);
  }
}

=== below is the output of createspinfo.pl on simpleQueue.java ===

REPLACE
isFull()
currentSize == myArray.length
isEmpty()
currentSize == 0

PPT_NAME  simpleQueue.enqueue
!isFull() && x >= 0

PPT_NAME  simpleQueue.isFull
(currentSize == myArray.length - 1)

PPT_NAME  simpleQueue.isEmpty
(currentSize == 0)

PPT_NAME  simpleQueue.dequeue
!isEmpty()

=========
