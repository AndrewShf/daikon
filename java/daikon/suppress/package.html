<html> <body> 

Data structures for handling suppression.  Here is how suppression
works:

<br> <br>

An invariant is suppressed if it is implied by another invariant.  A
suppressed invariant is nor checked as long as its suppressor is true.
This saves time for checking long data trace files, and reduces output
spam for obvious invariants.  Suppression is NOT:

<br> <br>

<li> The non-instantiation of invariants that are obvious in and of
themselves.

<li> The hiding of invariants during printing for various other
reasons.  This is because suppression is mostly a checking-time
mechanism based on left hand sides that aren't known to be true yet.

<li> A mechanism for handling equality invariants.

<br> <br>

Invariants are suppressed by SuppressionLink's, each of which store a
suppressed invariant and a list of suppressors (since one may need
more than one invariant to suppress another).  The class that
generates SuppressionLink objects is a SuppressionFactory.  There are
many different kinds of SuppressionFactory's, one for each suppression
rule we have.  Most SuppressionFactory's are attached to the
invariants that they would suppress.

<br> <br>

Suppression itself happens at the PptTopLevel.  Initially (or after
some small set of samples are fed) a PptTopLevel iterates through its
invariants and attempts to suppress them by its attemptSuppression()
method, which asks the invariant's associated SuppressionFactory's to
attempt suppression.  Each SuppressionFactory in turn generates
SuppressionTemplates, which are lists of Invariant types and VarInfos
that would be able to make a valid SuppressionLink.  The
SuppressionFactory asks the potential suppressee's PptTopLevel to
fillSuppressionTemplate().  If a template is successfully filled, then
the invariant is suppressed.

<br> <br>

During dtrace file reading, when a sample is fed, suppression works
through PptTopLevel.add():

<li> Make a set of PptSlice's called toCheck that have to be given the
sample.  Initially, the set is all the PptSlice's.

<li> Check invariants in the toCheck by calling their add() method.
Attempt suppression on any invariants that fall/flow down and are
resurrected.

<li> For any falsified or flowed invariants, take the invariants they
were suppressing.  Attempt to re-suppress them.  If an invariant is in
the same PptTopLevel as its former suppressor, add their PptSlice to
the set of slices to check.  It is not necessary to check other slices
because a) The slice can't be higher than this and b) If the slice is
lower, it will be checked later in the data flow.

<li> Repeat while there are slices to check.

<br> <br>

The only interface for suppressing an invariant is through the
attemptSuppression() method in PptTopLevel (i.e. don't try to suppress
an Invariant any other way).  The only interface for finding
invariants that are potential suppressors is through
PptTopLevel.fillSuppressionTemplate().  SuppressionFactory's should
not attempt to find invariants on their own, because
fillSuppressionTemplate respects the global option of whether a
suppressed invariant may suppress another invariant (and later,
invariant cycle detection).

<br> <br>

How do we suppress derived variables?  We simply suppress any
invariant that contains a derived variable that merits suppression.
We use VarSuppressionFactory for this.

<br> <br>

How SuppressionFactory's are discovered by Daikon: every time an
Invariant is checked for whether it is suppressed, its
getSuppressionFactories() method is called.  Each Invariant subtype
implements getSuppressionFactories() to return the relevant
SuppressionFactory's.

<br> <br>

Suppression obeys an "ordering" property or properties.  A suppressee
is never checked, so it cannot fall down the Ppt partial order while
suppressed.  Further, a suppressed invariant must have at least one
suppressor in the same ppt (and the rest in a higher or same ppt).

<br> <br>

Suppression also relies on the invariant uniqueness property.  That
is, at each ppt, for a given set of VarInfos, there exists exactly one
instance of a type of invariant.  So if A and B are subsets of each
other, one invariant covers this.  With this property, when we search
for an invariant in suppression, we can be sure that the returned
invariant either has the property we are looking for, or no invariant
does.

<br> <br>

Additionally, suppression relies on the fact that invariants at lower
ppts will be stronger than invariants in their parents.  If this isn't
true, then the search in the ppt partial order for a potential
suppressor becomes intractable.

<br> <br>

Note for Invariant cloning: SuppressionLinks are shared between two
Invariants iff one is a clone of each other.  Otherwise, Invariants
have their own suppressor and suppressed fields.  The sharing is
necessary because a weakened Invariant doesn't flow itself, but a
clone of itself, and we only have the clone to recheck suppression on.

<br>
Suppression has two options, set by Daikon.suppress_with_suppressed.
When the flag is on, it means that suppressed invariants can suppress
others.  When off, only unsuppressed invariants can suppress.  The
latter is safer, but yields a lower suppression rate.  The former is
unsafe, because if there is a cyclic suppression pattern between
invariants, then all of them could be suppressed, giving very little
information to the user!  The ideal thing to do in the future is to
use proper cycle detection between invariant dependencies: the
invariants that remain from suppression must be able to logically get
the invariants that are suppressed, in some order.  Maybe this is a
way of saying "suppressors must have path cover".

<br><br>

Users can chose whether to use suppression during checking by using
the "--suppress" flag.  They can no longer choose whether to use
suppression during printing, because this is now handled by a filter
(i.e. let them use the GUI; it's on by default for printing).


<br><br>


</body>
</html>
