; Test the unary scalar invariants

; All greater than or equal to -6
daikon.inv.unary.scalar.LowerBound
int
Goal: a >= -6
5
7
-6
1
2
-3

; All equal to 1 mod 3
daikon.inv.unary.scalar.Modulus
int
Goal: warning: method daikon.inv.unary.scalar.Modulus.format(OutputFormat:ESC/Java)needs to be implemented: a == 1  (mod 3)
1
4
7
10

; All not equal to 2 mod 5
daikon.inv.unary.scalar.NonModulus
int
Goal: warning: method daikon.inv.unary.scalar.NonModulus.format(OutputFormat:ESC/Java)needs to be implemented: a != 2  (mod 5)
0
1
3
4
5
6
8
9
10
11
13
14

; NonZero requires no samples
daikon.inv.unary.scalar.NonZero
int
Goal: a != 0

; All the time it is 1, 5, or 9
daikon.inv.unary.scalar.OneOfScalar
int
Goal: a == 1 || a == 5 || a == 9
1
5
9
9
9
5
9
1
1
1
5
5
9

; Positive requires no samples
daikon.inv.unary.scalar.Positive
int
Goal: a > 0

; All less than or equal to 10
daikon.inv.unary.scalar.UpperBound
int
Goal: a <= 10
1
2
5
7
-3
-99
10

; Test the unary sequence invariants
; All greater than or equal to -57
daikon.inv.unary.sequence.EltLowerBound
int_array
Goal: (\forall int i; (0 <= i && i <= a.length-1) ==> (a[i] >= -57))
102 5 92 33 -54 -2 -57 -3 -24 29 93

; EltNonZero needs no samples
daikon.inv.unary.sequence.EltNonZero
int_array
Goal: \nonnullelements(a)

; All are 4, 5, or 6
daikon.inv.unary.sequence.EltOneOf
int_array
Goal: (\forall int i; (0 <= i && i <= a.length-1) ==> (a[i] == 4 || a[i] == 5 || a[i] == 6))
4 5 6 5 4 5 6 5 4 4 4 5 5 5 6 6 6

; All less than 895
daikon.inv.unary.sequence.EltUpperBound
int_array
Goal: (\forall int i; (0 <= i && i <= a.length-1) ==> (a[i] <= 895))
1 -99 2 456 895 673 2 -23 -123 -9824 23

; Sorted ascending
; Prints incorrectly
daikon.inv.unary.sequence.EltwiseIntComparison
int_array
Goal: (\forall int i, j; (0 <= i && i <= a.length-1 && 0 <= j && j <= a.length-1) ==> ((i+1 == j) ==> (a[i] < a[j])))
1 2 3 5 7 8 9 100

; No duplicates in array
daikon.inv.unary.sequence.NoDuplicates
int_array
Goal: warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java)needs to be implemented: a[] contains no duplicates
1 55 2 -123 873 24 99 239

; OneOfSequence not currently implemented

; array[index] > index
; Causes an error now - not exactly sure what the statements inside mean
daikon.inv.unary.sequence.SeqIndexComparison
int_array
Goal: (\forall int i; (0 <= i && i <= a.length-1) ==> (a[i] > i))
5 10 15 20 25 30 35 40

; array[index] != index
daikon.inv.unary.sequence.SeqIndexNonEqual
int_array
Goal: (\forall int i; (0 <= i && i <= a.length-1) ==> (a[i] != i))
5 10 15 20 25 30 35 40

; Testing unary string invariants
; Always equal to "testString"
daikon.inv.unary.string.OneOfString
string
Goal: a == \type(testString)
testString

; Testing unary stringsequence invariants

; CommonStringSequence not yet implemented in JML... not sure what it does...

; Each element is one of the following: "testString" or "gnirtStset"
; Prints incorrectly
daikon.inv.unary.stringsequence.EltOneOfString
string_array
Goal: (\forall int i; (0 <= i && i <= a.length-1) ==> (warning: method daikon.inv.unary.stringsequence.EltOneOfString.format(OutputFormat:ESC/Java)needs to be implemented: a[] elements one of { "gnirtStset", "testString" }))
testString testString gnirtStset gnirtStset testString gnirtStset

; OneOfStringSequence not yet implemented in JML

; Test the binary twoScalar invariants

; Unable to test FunctionUnary with this testing framework: it needs extra data than can be easily supplied

; IntEqual does not need any samples
daikon.inv.binary.twoScalar.IntEqual
int int
Goal: a == b

; IntGreaterEqual does not need any samples
daikon.inv.binary.twoScalar.IntGreaterEqual
int int
Goal: a >= b

; IntGreaterThan does not need any samples
daikon.inv.binary.twoScalar.IntGreaterThan
int int
Goal: a > b

; IntLessEqual does not need any samples
daikon.inv.binary.twoScalar.IntLessEqual
int int
Goal: a <= b

; IntNonEqual does not need any samples
daikon.inv.binary.twoScalar.IntNonEqual
int int
Goal: a != b

; b = -3*a + 1
daikon.inv.binary.twoScalar.LinearBinary
int int
Goal: b == - 3 * a + 1
1
-2
10
-29
-20
61
7
-20

; Testing binary twoSequence invariants

; Unable to test PairwiseFunctionUnary with this testing framework: it needs extra data than can be easily supplied

; a[i] > b[i]
daikon.inv.binary.twoSequence.PairwiseIntComparison
int_array int_array
Goal: (\forall int i, j; (0 <= i && i <= a.length-1 && 0 <= j && j <= b.length-1 && i == j) ==> (a[i] > b[j]))
5 10 15 20 25 30 35 40
-5 0 5 10 15 20 25 30

; a[i] = b[b.length-i]
daikon.inv.binary.twoSequence.Reverse
int_array int_array
Goal: warning: method daikon.inv.binary.twoSequence.Reverse.format(OutputFormat:ESC/Java)needs to be implemented: a[] is the reverse of b[]

; a is subsequence of b
; Error in formatting currently, fix later
daikon.inv.binary.twoSequence.SubSequence
int_array int_array
Goal: warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:ESC/Java)needs to be implemented: b[] is a subsequence of a[]
1 2 3 4 5 6
7 8 1 2 3 4 5 6 7 8

; SubSet currently unimplemented in JML

; a == b (string format)
daikon.inv.binary.twoString.StringComparison
string string
Goal: a == b
aString
aString

; Testing binary sequenceScalar invariants

; a is in b
daikon.inv.binary.sequenceScalar.Member
int_array int
Goal: !(\forall int i; (0 <= i && i <= a.length-1) ==> (a[i] != b))
5 -6 7 -8 9 1 -2 3 -4 5
7

; a[i] > b
daikon.inv.binary.sequenceScalar.SeqIntComparison
int_array int
Goal: (\forall int i; (0 <= i && i <= a.length-1) ==> (a[i] > b))
-9 8 -7 6 -5 4 -3 2 -1 0
-20

; Testing binary sequenceString invariants

; a is in b
daikon.inv.binary.sequenceString.Member
string_array string
Goal: !(\forall int i; (0 <= i && i <= a.length-1) ==> (a[i] != b))
A b C longerString under_score findMe various other strings involved in the array
findMe

; Testing ternary threeScalar invariants

; Cannot test FunctionBinary within this framework

; c = 2a + 3b - 6
daikon.inv.ternary.threeScalar.LinearTernary
int int int
Goal: c == 2 * a + 3 * b - 6
1
1
-1
2
3
7
-5
-10
-46
4
9
29
0
0
-6
10
10
44

