#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#include "MathMDE-help.java.jpp"

  /** Return z such that (z == x mod y) and (0 <= z < abs(y)). */
  public static final INT mod_positive(INT x, INT y) {
    INT result = x % y;
    if (result < 0)
      result += Math.abs(y);
    return result;
  }


  /**
   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).
   * The largest possible modulus is used, and the trivial constraint that all
   * integers are equal to 0 mod 1 is not returned (null is returned instead).
   **/
  public static INT[] modulus(INT[] nums) {
    if (nums.length < 3)
    return null;

    INT modulus = Math.abs(gcd_differences(nums));
    if (modulus == 1)
      return null;

    INT remainder = nums[0] % modulus;
    if (remainder < 0)
      remainder += modulus;

    return new INT[] { remainder, modulus };
  }

  /**
   * The iterator produces INTEGER values.
   * This can be more efficient than modulus(INT[]) if the INT[] doesn't already
   * exist, because this does not necessarily examine every value produced by
   * its iterator.
   **/
  public static INT[] modulus_INT(Iterator itor) {
    if (!itor.hasNext())
      return null;
    INT avalue = ((INTEGER)itor.next()).INTValue();
    if (!itor.hasNext())
      return null;
    INT modulus = Math.abs(avalue - ((INTEGER)itor.next()).INTValue());
    if (modulus == 1)
      return null;
    int count = 2;
    while (itor.hasNext()) {
      INT i = ((INTEGER)itor.next()).INTValue();
      if (i == avalue)
	continue;
      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));
      count++;
      if (modulus == 1)
	return null;
      }
    if (count < 3)
      return null;
    return new INT[] { MathMDE.mod_positive(avalue, modulus), modulus } ;
  }


  /**
   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).
   * The largest possible modulus is used, and the trivial constraint that all
   * integers are equal to 0 mod 1 is not returned (null is returned instead).
   *
   * This "_strict" version requires its input to be sorted, and no element
   * may be missing.
   **/
  public static INT[] modulus_strict(INT[] nums) {
    if (nums.length < 3)
    return null;

    INT modulus = nums[1] - nums[0];
    if (modulus == 1)
      return null;
    for (int i=2; i<nums.length; i++)
      if (nums[i] - nums[i-1] != modulus)
	return null;

    return new INT[] { mod_positive(nums[0], modulus), modulus };
  }

  /**
   * The iterator produces INTEGER values.
   * This can be more efficient than modulus(INT[]) if the INT[] doesn't already
   * exist, because this does not necessarily examine every value produced by
   * its iterator.
   *
   * This "_strict" version requires its input to be sorted, and no element
   * may be missing.
   **/
  public static INT[] modulus_strict_INT(Iterator itor) {
    if (!itor.hasNext())
      return null;
    INT prev = ((INTEGER)itor.next()).INTValue();
    if (!itor.hasNext())
      return null;
    INT next = ((INTEGER)itor.next()).INTValue();
    INT modulus = next-prev;
    if (modulus == 1)
      return null;
    int count = 2;
    while (itor.hasNext()) {
      prev = next;
      next = ((INTEGER)itor.next()).INTValue();
      if (next - prev != modulus)
	return null;
      count++;
    }
    if (count < 3)
      return null;
    return new INT[] { MathMDE.mod_positive(next, modulus), modulus } ;
  }


#include "MathMDE-helpend.java.jpp"


#if 0
// Local Variables:
// mode: java
// End:
#endif
