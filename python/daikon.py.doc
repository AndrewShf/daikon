This file contains implementation and design notes on the Python
implementation of the Daikon invariant engine.  For user documentation, see
the daikon.html file in the distribution.  For documentation of the data
trace file format, see file 

Contents:
 * Data structures: mapping tuples of values to occurrence counts
 * Data strucures: creating maps from sub-tuples of values to occurrence counts


Data structures: mapping tuples of values to occurrence counts
==============================================================

The primary datastructure used in daikon.py is a dictionary (a
hashtable; "dictionary" is the Python term) from tuples of values to the
number of occurrences of those tuples in the input.

For instance, suppose the input is as follows.

  foo	i 2	j 3
  foo	i 7	j 3
  bar	x 5	y 6	z 90210
  foo	i 7	j 3
  bar	x 3	y 6	z 9
  foo	i 2	j 3
  foo	i 7	j 3

Two dictionaries are created, one for the "foo" tag and one for the "bar"
tag.  The dictionary for foo looks like

  (2,3) -> 2
  (7,3) -> 3

(where "->" separates keys from values) because the tuple (2,3) occurs
twice in the input and the tuple (7,3) occurs thrice.  There are two tuples
for bar, each occurring once:

  (5, 6, 90210) -> 1
  (3, 6, 9) -> 1


Data strucures: creating maps from sub-tuples of values to occurrence counts
============================================================================

Invariant detection also works over dictionaries mapping tuples to
occurrence counts.  There are currently three types of invariants to
detect:  those involving one variable, those involving two variables, and
those involving three variables.  Their input dictionaries differ in the
arity of their keys.  For instance, the foo dictionary would be a
reasonable input to the binary invariant checker, and the bar dictionary
could be provided to the ternary invariant checker, but neither of these is
appropriate for the unary invariant checker as is.

In order to detect invariants over a subset of the available variables, we
produce a new dictionary with keys of smaller arity.  For instance, suppose
we start with a dictionary mapping pairs of elements to the number of their
occurrences.

  (1,1) -> 3
  (1,2) -> 4
  (1,7) -> 1
  (2,2) -> 5

We can convert this to a dictionary mapping single elements to the number
of their occurrences in two ways:  by examining the first element of the
pair, or by examining the second element of the pair.  The two resulting
dictionaries are, respectively:

  1 -> 8
  2 -> 5

and

  1 -> 3
  2 -> 9
  7 -> 1

Now these can be fed to the single-variable invariant discoverer.

Similarly, given dictionary

  (1,2,3) -> 4
  (1,2,7) -> 2
  (1,3,6) -> 5
  (7,2,3) -> 1

there are three different ways to associate pairs of variables with counts:

 columns 1 and 2:
  (1,2) -> 6
  (1,3) -> 5
  (7,2) -> 1

 columns 1 and 3:
  (1,3) -> 4
  (1,7) -> 2
  (1,6) -> 5
  (7,3) -> 1

 columns 2 and 3:
  (2,3) -> 5
  (2,7) -> 2
  (3,6) -> 5

This reduction of arity is performed by two different routines.  Function
dict_of_tuples_to_tuple_of_dicts converts a single dictionary from tuples
to counts into a collection of dictionaries, each from a single value to a
count; this is the first example given above.  Function
dict_of_tuples_slice takes a dictionary and a list of indices and returns a
dictionary whose keys contain only those elements (those columns, if you
will) of the original one's keys; this is the second example given above.
