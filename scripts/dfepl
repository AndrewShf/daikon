#!/usr/bin/env perl

# Convenient interface to the Daikon annotation front-end for Perl programs
# $Id$

use strict;
use 5.006;
use warnings;
BEGIN {
    require English;
    if ($^V ge 5.8.0) {
        English->import("-no_match_vars"); # avoid speed penaly
    } else {
        English->import();
    }
}

use Getopt::Long ();
#use Carp ('carp', 'croak', 'cluck', 'confess');
use File::Path 'mkpath';
use File::Basename;
use File::Spec::Functions 'rel2abs';
use File::Find;
use Cwd 'getcwd';

my $verbose = 0;
my $perl = $^X;

my @types_files = ();
my $types_search = undef;
my $accessors_search = undef;

my $instr_basedir = "daikon-instrumented";
my $types_basedir = undef;
my $decls_basedir = "daikon-output";
my $dtrace_basedir = "daikon-output";

#my $instr_style = "tree";
my $types_style = "tree";
my $decls_style = "tree";
my $dtrace_style = "tree";

my $types_append = 1;
my $decls_append = 1;
my $dtrace_append = 0;

my $absolute = undef;
my $instr_absolute = undef;
my $types_absolute = undef;
my $decls_absolute = undef;
my $dtrace_absolute = undef;

my $reference_depth = 3;
my $accessor_depth = 1.5;
my $list_depth = 3;

sub careful_system {
    my @cmd = @_;
    if ($verbose) {
        print join(" ", @cmd), "\n";
    }
    my $result = system(@cmd);
    if ($result != 0) {
        die "External command failed: " . join(" ", @cmd);
    }
    return $result;
}

sub file_id {
    my($fname) = @_;
    my($dev, $inode) = stat($fname) or die "Couldn't stat $fname: $!\n";
    return "$dev:$inode";
}

my @found_modules = ();

sub is_module {
    my ($dev,$ino,$mode,$nlink,$uid,$gid);

    if ((($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
        -f _ && /^.*\.pm\z/s) {
        push @found_modules, $File::Find::name;
        print "Found module $File::Find::name\n" if $verbose;
        return 1;
    }
}

unless (exists $ENV{"INV"}) {
    my $str = "The INV environment variable was not found.\n";
    $str .= "Please make sure it is set to the location of the ";
    $str .= "Daikon invariants/ directory.\n";
    $str .= "Usually, you would do this by running the daikon.bashrc or ";
    $str .= "daikon.cshrc script\nin your shell startup file.\n";
    die $str;
}

my $opt_parse = new Getopt::Long::Parser;
$opt_parse->configure("bundling_override");
my $parsed =
  $opt_parse->getoptions("instrsourcedir|instr-basedir=s" => \$instr_basedir,
                         "types-basedir=s" => \$types_basedir,
                         "decls-basedir=s" => \$decls_basedir,
                         "dtrace-basedir=s" => \$dtrace_basedir,
#                        "instr-style=s" => \$instr_style,
                         "types-style=s" => \$types_style,
                         "decls-style=s" => \$decls_style,
                         "dtrace-style=s" => \$dtrace_style,
                         "types-append!" => \$types_append,
                         "decls-append!" => \$decls_append,
                         "dtrace-append!" => \$dtrace_append,
                         "types-files|t=s" => \@types_files,
                         "types-dir|T:s" => \$types_search,
                         "accessors-dir|A:s" => \$accessors_search,
                         "verbose|v+" => \$verbose,
                         "absolute!" => \$absolute,
                         "reference-depth=f", => \$reference_depth,
                         "accessor-depth=f", => \$accessor_depth,
                         "list-depth=n", => \$list_depth,
# This is probably more control than anyone needs
#                        "types-absolute!" => \$types_absolute,
#                        "decls-absolute!" => \$decls_absolute,
#                        "dtrace-absolute!" => \$dtrace_absolute,
                         "perl=s", \$perl,
                        );

exit(1) unless $parsed;

$types_basedir = $instr_basedir if not defined($types_basedir);

if (defined $absolute) {
    $instr_absolute = $absolute unless defined $instr_absolute;
    $types_absolute = $absolute unless defined $types_absolute;
    $decls_absolute = $absolute unless defined $decls_absolute;
    $dtrace_absolute = $absolute unless defined $dtrace_absolute;
}

$instr_absolute = 0 unless defined $instr_absolute;
$types_absolute = 1 unless defined $types_absolute;
$decls_absolute = 0 unless defined $decls_absolute;
$dtrace_absolute = 0 unless defined $dtrace_absolute;

if ($instr_absolute) {
    $instr_basedir = rel2abs($instr_basedir);
}

if ($types_absolute) {
    $types_basedir = rel2abs($types_basedir);
}

if ($decls_absolute) {
    $decls_basedir = rel2abs($decls_basedir);
}

if ($dtrace_absolute) {
    $dtrace_basedir = rel2abs($dtrace_basedir);
}

#unless ($instr_style =~ /^tree|flat|combined\z/) {
#    die "instr-style should be one of tree, flat, or combined\n";
#}

unless ($types_style =~ /^tree|flat|combined\z/) {
    die "types-style should be one of tree, flat, or combined\n";
}

unless ($decls_style =~ /^tree|flat|combined\z/) {
    die "decls-style should be one of tree, flat, or combined\n";
}

unless ($dtrace_style =~ /^tree|flat|combined\z/) {
    die "dtrace-style should be one of tree, flat, or combined\n";
}

if ($reference_depth < 0) {
    die "reference_depth should be non-negative\n";
}

if ($accessor_depth < 0) {
    die "accessor_depth should be non-negative\n";
}

if ($list_depth < 0) {
    die "list_depth should be non-negative\n";
}

if (defined($types_search) and $types_search eq "") {
    $types_search = $types_basedir;
}

if (defined($accessors_search) and $accessors_search eq "") {
    $accessors_search = ".";
}

if ($verbose) {
    print STDERR "Verbosity level $verbose\n";
    print STDERR "Instrumented sources in $instr_basedir\n";
    print STDERR "Reading types from @types_files\n" if @types_files;
    print STDERR "Looking for types in $types_search\n" if $types_search;
    print STDERR "Looking for accessors in $accessors_search\n"
      if $accessors_search;
}

my $types = "";
for my $tfile (@types_files) {
    if (-e $tfile) {
        $types .= ",$tfile";
    } else {
        warn "Types file $tfile does not exist\n";
    }
}
my $output_opt = ",-O,$types_basedir,$types_style,$types_append";
$output_opt .= ",$decls_basedir,$decls_style,$decls_append";
$output_opt .= ",$dtrace_basedir,$dtrace_style,$dtrace_append";
$output_opt .= ",-D,$reference_depth,$accessor_depth,$list_depth";

$types = ",-t" . $types if $types;
my $deparse_opt = "-MO=DeparseDaikon$types$output_opt";
my $perl_lib = "-I$ENV{INV}/front-end/perl/lib";

sub process_file_relative_to {
    my($prog, $dir) = @_;
    my $from;

    my $olddir = undef;
    if ($dir ne ".") {
        $olddir = getcwd();
        chdir($dir);
        print "Changing to directory $dir\n";
    }

    $prog =~ s,\Q$dir\E[/]?,,;

    if (! -d $instr_basedir) {
        mkdir($instr_basedir)
          or die "Can't create directory $instr_basedir: $!\n";
    }

    my $inplace = file_id($instr_basedir) eq file_id(".");
    print STDERR "Annotating in place? ", $inplace ? "yes" : "no", "\n"
      if $verbose;

    if ($inplace) {
        $from = "$prog.uninst";
        if (! -e $from) {
            print STDERR "Renaming $prog to $from\n" if $verbose;
            rename($prog, $from) or die "Can't move $prog to $from: $!\n";
        }
    } else {
        $from = $prog;
    }
    my $more_opts = "";
    my $bprog = dirname($prog) . "/" . basename($prog, ".pm");
    (my $pack = $bprog) =~ s[/][::]g;
    if (defined $types_search) {
        print STDERR "Looking at $types_search/combined.types\n" if $verbose;
        if (-e "$types_search/combined.types") {
            $more_opts .= ",-t,$types_search/combined.types";
        }
        print STDERR "Looking at $types_search/$bprog.types\n" if $verbose;
        if (-e "$types_search/$bprog.types") {
            $more_opts .= ",-t,$types_search/$bprog.types";
        }
        $pack =~ s[\.::][]g;
        print STDERR "Looking at $types_search/$pack.types\n" if $verbose;
        if (-e "$types_search/$pack.types") {
            $more_opts .= ",-t,$types_search/$pack.types";
        }
    }
    if (defined $accessors_search) {
        print STDERR "Looking at $accessors_search/$bprog.accessors\n"
          if $verbose;
        if (-e "$accessors_search/$bprog.accessors") {
            $more_opts .= ",-a,$accessors_search/$bprog.accessors";
        }
        $pack =~ s[\.::][]g;
        print STDERR "Looking at $accessors_search/$pack.accessors\n"
          if $verbose;
        if (-e "$accessors_search/$pack.accessors") {
            $more_opts .= ",-a,$accessors_search/$pack.accessors";
        }
    }
    my $outfile = "$instr_basedir/$prog";
    my $outpath = dirname($outfile);
    if (not -d $outpath) {
        print STDERR "Making $outpath\n" if $verbose;
        mkpath($outpath, $verbose) or die "Couldn't create $outpath: $!\n";
    } else {
        print STDERR "$outpath exists\n" if $verbose;
    }
    careful_system($perl, $perl_lib, "$deparse_opt,-o,$outfile$more_opts",
                   $from);
    if (defined($olddir)) {
        print "Changing back to $olddir\n";
        chdir($olddir);
    }
}

for my $arg (@ARGV) {
    if (-f $arg) {
        process_file_relative_to($arg, ".");
    } elsif (-d $arg) {
        File::Find::find({wanted => \&is_module}, $arg);
        for my $file (@found_modules) {
            process_file_relative_to($file, $arg);
        }
        @found_modules = ();
    }
}
