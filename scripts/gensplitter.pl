#!/uns/bin/perl

# gensplitter.pl
#
# Usage: gensplitter.pl CLASSNAME [PACKAGE]
#
# This script generates splitters for Java programs. This program
# requires .conds file for input, which is generated by extractcond.pl.
# This script scans the .conds file for each original Java files and 
# produces splitter class files.
# This script will accept two arguments; the first argument is the name
# of the target class, or the filename without .java suffix, and the
# second argument is the package name in which the resulted splitters
# belongs. The first argument is reauired; the second argument is
# optional. If there is no second argument, the "package" line will not
# be output. The second argument must be the relative expression to the
# 'daikon.split' package; if the second argument is 'dsaa,' the output
# will be 'package daikon.split.dsaa.'
#
# Author: Josh
# Version 1.0 released on November 8, 1999
#

$operator = "\\*\\%\\/\\+\\-\\!\\>\\<\\=\\|\\&";
$paren = "\\(\\)";
$bracket = "\\[\\]";
$period = "\\.";
$number = "0-9\\.";
$nonalpha = "$operator$paren$bracket$period\\s";
$alphabet = "^$nonalpha";
$null = "0";

$array_bit = 4;
$method_bit = 2;
$int_bit = 1;

$filename = $ARGV[0];
$filename =~ s/([^\/]+)\.java/$1/ if ($filename =~ /\.java$/);

$package = $ARGV[1];
$replace_rule = 0;

$SPLS = 0;
$VARS = 1;

$DEBUG = 0;

&read_cond;
&output_splitter;

# %methods: Hash of methods. Each element is an array with three items.
# $methods{$method}[$SPLS]: Hash of conditions corresponding to the method.
# $methods{$method}[$VARS]: Array of variables used in all of the conditions.

# @splitters: Array of splitters(conditions). Each element has two fields.
#             One is the condition expression itself. The other is alternative
#             expression for condition using a boolean method.

sub read_cond {
    open(INFILE, "$filename\.java.conds") || die "$filename\.java.conds: $!\n";
    while (<INFILE>) {
	chop;
	if (/^import/) {
	    push @import, $_;
	} elsif (/^replace:/) {
	    if ($method ne "") {
		$m = $method;
# Duplicate methods could be exist. 
# So I have to identify them by suffix.		
		for ($i = 1;
		     $methods{$m};
		     $i++) {
		    $m = "$method$i";
		}
# Here, $m may be with suffix.
		$methods{$m}[$SPLS] = [ @splitters ];
		$methods{$m}[$VARS] = { %variables };
	    }
	    if ($class ne "") {
		$classes{$class} = { %methods };
	    }
	    %variables = {};
	    @splitters = ();
	    $method = $1;
	    $num = 0;
	    $replace_rule = 1;
	} elsif (/In class\s+(\S+)\s*:/) {
	    if ($method ne "") {
		$m = $method;
		for ($i = 1;
		     $methods{$m};
		     $i++) {
		    $m = "$method$i";
		}
		$methods{$m}[$SPLS] = [ @splitters ];
		$methods{$m}[$VARS] = { %variables };
	    }
	    if ($class ne "") {
		$classes{$class} = { %methods };
	    }
	    %variables = {};
	    @splitters = ();
	    $method = $1;
	    $num = 0;
	    $methods = {};
	    $class = $1;
	} elsif (/In function\s+(\S+)\s*:/) {
	    if ($method ne "") {
		$m = $method;
		for ($i = 1;
		     $methods{$m};
		     $i++) {
		    $m = "$method$i";
		}
		$methods{$m}[$SPLS] = [ @splitters ];
		$methods{$m}[$VARS] = { %variables };
	    }
	    %variables = {};
	    @splitters = ();
	    $method = $1;
	    $num = 0;
	} elsif (/\S+/) {
	    $replacable = "";
	    $expression = $_;
	    if ($replace_rule) {
		if (/^(\S+)\s:\s(.*)$/) {
		    $replace{$1} = $2;
		    $replacable = $1;
		    $expression = "";
		    $_ = $2;
		}
	    }
	    $num_of_vars = 0;
	    s/\s//g; # space elimination
	    if (/(^|[$nonalpha])\([$alphabet]+\)(.*)$/) {
		$num_of_vars = -1;
	    }
	    if (/([\)\]])$period/) {
		$num_of_vars = -1;
	    }
	    if (/^\s*(!|)\s*([$alphabet]+)[$paren]+\s*$/) {
		$_ = "";
		$replacable = $2;
	    }
	    if ($DEBUG) {
		print "start expression: $_\n";
	    }
	    while (/\S+/ && $num_of_vars >= 0) {
		if (/^(([$alphabet]|$period)+)\[(.*)$/) {
		    if ($DEBUG) {
			print "array: $1 | $3\n";
		    }
		    $var = $1;
		    $_ = $3;
		    $variables{$var} |= $array_bit;
		    $num_of_vars++;
		} elsif (/^(([$alphabet]|$period)+)(.*)$/) {
		    if ($DEBUG) {
			print "int: $1 | $3\n";
		    }
		    $var = $1;
		    $_ = $3;
		    if ($var =~ /^[$number]+$/
			|| $var =~ /^null$/) {
			$variables{$var} = 0;
			$num_of_vars++;
		    } elsif (/^\(/) {
			$num_of_vars = -1;
		    } else {
			$variables{$var} |= $int_bit;
			$num_of_vars++;
		    }
		} elsif (/^([$operator$bracket$paren]+)(.*)$/) {
		    if ($DEBUG) {
			print "operator: $1 | $2\n";
		    }
		    $_ = $2;
		} else {
		    if ($DEBUG) {
			print "none: $_\n";
		    }
		}
	    }
	    if ($num_of_vars >= 0 && $expression ne "") {
		if ($DEBUG) {
		    print "splitter: $expression\n";
		}
		$splitters[$num][0] = $expression;
		$splitters[$num][1] = $replacable;
		$num++;
	    }
	    if ($replacable ne "") {
		&replace_method($replacable);
	    }
	}
    }
    close(INFILE);
}

sub replace_method {
    my ($replacable) = @_;

    foreach $classe (keys %classes) {
	foreach $method (keys %{ $classes{$class} }) {
	    for ($i = 0;
		 $classes{$class}{$method}[$SPLS][$i];
		 $i++) {
		if ($classes{$class}{$method}[$SPLS][$i][1] eq $replacable) {
		    if ($num_of_vars >= 0) {
			&merge_variables;
		    } else {
			undef $classes{$class}{$method}[$SPLS][$i];
		    }
		}
	    }
	}
    }
}

sub merge_variables {
    foreach $new_var (keys %variables) {
	if (!$classes{$class}{$method}[$VARS]{$new_var}) {
	    $classes{$class}{$method}[$VARS]{$new_var} = $variables{$new_var};
	}
    }
}

sub output_splitter {
    foreach $class (keys %classes) {
	foreach $method (keys %{ $classes{$class} }) {
	    for ($i = 0;
		 $expression = $classes{$class}{$method}[$SPLS][$i][0];
		 $i++) {
		if ($classes{$class}{$method}[$SPLS][1]) {
		    $suffix = "_$i";
		} else {
		    $suffix = "";
		}
		$original_expression = $expression;
		if ($expression =~ /^\s*(!|)\s*([$alphabet]+)[$paren]+\s*$/) {
		    if ($DEBUG) {
			print "$expression: replaced with \"$replace{$2}\"\n";
		    }
		    if ($replace{$2} ne "") {
			$expression = "$1\($replace{$2}\)";
		    } else {
			$expression = "";
		    }
		}
		if ($expression ne "") {
		    &output_class($suffix, $filename, $class, $method);
		}
	    }
	}
    }
}

sub output_class {
    my ($suffix, $filename, $class, $method) = @_;

    my $classname = "$filename\Splitter_$method$suffix";

    $outfile = "$classname\.java";
    open(SPLITTER, ">$outfile") || die "Cannot open output file\n";

# Output header information.
    if ($package ne "") {
	print SPLITTER "package daikon.split.$package;\n\n";
    }
    print SPLITTER <<EOF;
import daikon.*;
import daikon.split.*;

EOF
# Output class header
    print SPLITTER <<EOF;
class $classname extends Splitter \{

EOF

# Output variable definitions
    foreach $var (keys %{ $classes{$class}{$method}[$VARS] }) {
	if ($classes{$class}{$method}[$VARS]{$var}
	    && $expression =~ /$var/) {
	    $var =~ s/$period/\_/g;
	    print SPLITTER <<EOF;
    VarInfo $var\_varinfo\;
EOF
	}
    }
    print SPLITTER "\n";

# Output constructor with no parameter
    print SPLITTER <<EOF;
// Constructor: $classname()
// This is a constructor. But I don't know how this could be used...

    public $classname() {}

EOF

# Output constructor (takes a program pointer as a parameter)
    print SPLITTER <<EOF;
// Constructor: $classname(Ppt ppt)
// This instantiates the splitter for a given program point. This
// also initializes the variable information used in the current
// splitter.

    public $classname(Ppt ppt) {
EOF
# Output variable initializations.
    foreach $var (keys %{ $classes{$class}{$method}[$VARS] }) {
	if ($classes{$class}{$method}[$VARS]{$var}
	    && $expression =~ /$var/) {
	    $tmp = $var;
	    $tmp =~ s/$period/\_/g;
	    print SPLITTER "\t$tmp\_varinfo = ppt.findVar(\"$var\")\;\n";
	}
    }
    print SPLITTER <<EOF;
    }

EOF

# Output valid method.
    print SPLITTER <<EOF;
// Method: valid()
// This method returns whether all the variables used in the condition
// are valid at the context or not.

    public boolean valid() {
EOF
    print SPLITTER "\treturn (";
    foreach $var (keys %{ $classes{$class}{$method}[$VARS] }) {
	if ($classes{$class}{$method}[$VARS]{$var}
	    && $expression =~ /$var/) {
	    $tmp = $var;
	    $tmp =~ s/$period/\_/g;
	    print SPLITTER "($tmp\_varinfo != null) && ";
	}
    }
    print SPLITTER "true);\n";
    print SPLITTER <<EOF;
    }

EOF

# Output instantiator. (Simply invokes the constructor)
    print SPLITTER <<EOF;
// Method: instantiate(Ppt ppt)
// This method instantiates the splitter for the given program point.
// This simply invokes the constructor.

    public Splitter instantiate(Ppt ppt) {
	return new $classname(ppt);
    }

EOF

# Output condition method.
# eliminate spaces before and after the expression.
    $expression =~ s/^\s*(\S.*\S|\S)\s*$/$1/;
    print SPLITTER <<EOF;
// Method: condition()
// This method returns a String object which contains the original
// expression of the condition. The word "original" means that if
// the condition was expressed as a simple boolean method call,
// this method will return the boolean method call itself though
// the evaluation might be done in another form.

    public String condition() {
	return "$original_expression";
    }

EOF

# Output test method.
    print SPLITTER <<EOF;
// Method: test(ValueTuple vt)
// This method returns whether the condition is true or false at
// the given program point. A single boolean method condition can
// be evaluated by replacing the method with the corresponding
// expression in the boolean method definition.

    public boolean test(ValueTuple vt) {
EOF

# Replacement should be done in the decendent order of the variable
# name length.
    foreach $var (sort { -(length $a <=> length $b) }
		  keys %{ $classes{$class}{$method}[$VARS] }) {
	if ($classes{$class}{$method}[$VARS]{$var} & $array_bit) {
# Array replacement.
	    $tmp = $var;
	    $tmp =~ s/$period/\_/g;
	    $expression =~
		s/([$nonalpha]|^)$var($|[$nonalpha])/
		    $1$tmp\_varinfo.getIntArrayValue(vt)$2/g;
	} elsif ($classes{$class}{$method}[$VARS]{$var} & $int_bit) {
# Integer replacement.
	    $tmp = $var;
	    $tmp =~ s/$period/\_/g;
	    $expression =~
		s/([$nonalpha]|^)$var($|[$nonalpha])/
		    $1$tmp\_varinfo.getIntValue(vt)$2/g;
	} elsif ($var eq "null") {
# Replace null with 0 (integer value).
	    $expression =~
		s/([$nonalpha]|^)$var($|[$nonalpha])/
		    $1$null$2/g;
	}
	$expression =~ s/\s*(\S.*)/$1/;
    }
    $expression =~ s/\s+/ /g;
    print SPLITTER "\treturn ($expression);\n";

    print SPLITTER <<EOF;
    }
}
EOF

# End of class definition.
    close(SPLITTER);
}
