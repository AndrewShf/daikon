===========================================================================
std.addstr(char;char *;int *;int;)int:::ENTER
    Variables: c outset outset[] j *j maxset
outset != null
j != null
*j >= 0
maxset == 100
*j <= maxset
===========================================================================
std.addstr(char;char *;int *;int;)int:::EXIT
    Variables: c outset outset[] j *j maxset return orig(c) orig(outset) orig(outset[]) orig(j) orig(*j) orig(maxset)
assignable outset[*], *j
c == \old(c)
outset == \old(outset)
j == \old(j)
maxset == \old(maxset)
outset != null
j != null
*j >= 1
maxset == 100
\result == 0 || \result == 1
*j <= maxset
*j >= \old(*j)
maxset >= \old(*j)
===========================================================================
std.amatch(char *;int;char *;int;)int:::ENTER
    Variables: lin lin[] offset pat pat[] j
lin != null
offset >= 0
pat != null
j >= 0
===========================================================================
std.amatch(char *;int;char *;int;)int:::EXIT
    Variables: lin lin[] offset pat pat[] j return orig(lin) orig(lin[]) orig(offset) orig(pat) orig(pat[]) orig(j)
assignable lin[*], offset, j
lin == \old(lin)
offset == \result
pat == \old(pat)
lin != null
offset >= -1
pat != null
j >= 0
lin.compareTo(\old(lin)) >= 0
lin.contains(\old(lin))
(!(offset == 0)) || (\old(offset) == 0)
pat.equals(\old(pat))
(!(j == 0)) || (\old(j) == 0)
j >= \old(j)
===========================================================================
std.change(char *;char *;)void:::ENTER
    Variables: pat pat[] sub sub[]
pat != null
sub != null
===========================================================================
std.change(char *;char *;)void:::EXIT
    Variables: pat pat[] sub sub[] orig(pat) orig(pat[]) orig(sub) orig(sub[])
pat == \old(pat)
sub == \old(sub)
pat != null
sub != null
pat.equals(\old(pat))
sub.equals(\old(sub))
===========================================================================
std.dodash(char;char *;int *;char *;int *;int;)void:::ENTER
    Variables: delim src src[] i *i dest dest[] j *j maxset
delim == 93
src != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: src[] is printable
i != null
*i >= 2
dest != null
j != null
maxset == 100
delim != *j
*j <= maxset
===========================================================================
std.dodash(char;char *;int *;char *;int *;int;)void:::EXIT
    Variables: delim src src[] i *i dest dest[] j *j maxset orig(delim) orig(src) orig(src[]) orig(i) orig(*i) orig(dest) orig(dest[]) orig(j) orig(*j) orig(maxset)
assignable *i, *j
delim == \old(delim)
src == \old(src)
i == \old(i)
dest == \old(dest)
j == \old(j)
maxset == \old(maxset)
delim == 93
src != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: src[] is printable
i != null
dest != null
j != null
maxset == 100
delim != *j
delim != \old(*j)
src.equals(\old(src))
*i >= \old(*i)
dest.equals(\old(dest))
*j <= maxset
*j >= \old(*j)
maxset >= \old(*j)
===========================================================================
std.esc(char *;int *;)char:::ENTER
    Variables: s s[] i *i
s != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: s[] is printable
i != null
*i >= 0
===========================================================================
std.esc(char *;int *;)char:::EXIT
    Variables: s s[] i *i return orig(s) orig(s[]) orig(i) orig(*i)
assignable *i
s == \old(s)
i == \old(i)
s != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: s[] is printable
i != null
*i >= 0
s.equals(\old(s))
(!(*i == 0)) || (\old(*i) == 0)
*i >= \old(*i)
===========================================================================
std.getccl(char *;int *;char *;int *;)boolean:::ENTER
    Variables: arg arg[] i *i pat pat[] j *j
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
i != null
pat != null
j != null
===========================================================================
std.getccl(char *;int *;char *;int *;)boolean:::EXIT
    Variables: arg arg[] i *i pat pat[] j *j return orig(arg) orig(arg[]) orig(i) orig(*i) orig(pat) orig(pat[]) orig(j) orig(*j)
assignable *i, pat[*], *j
arg == \old(arg)
i == \old(i)
pat == \old(pat)
j == \old(j)
(\result == 0)  ==>  (\old(*i) >= 1)
(\result == 0)  ==>  (pat.compareTo(\old(pat)) > 0)
(\result == 0)  ==>  (\result  isPointer)
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
i != null
pat != null
j != null
\result == 0 || \result == 1
arg.equals(\old(arg))
*i > \old(*i)
(\old(pat) != null)  ==>  (pat.contains(\old(pat)))
(\old(pat) != null)  ==>  (pat.compareTo(\old(pat)) >= 0)
*j > \old(*j)
===========================================================================
std.getline(char *;int;)boolean:::ENTER
    Variables: s s[] maxsize
s != null
maxsize == 100
===========================================================================
std.getline(char *;int;)boolean:::EXIT
    Variables: s s[] maxsize return orig(s) orig(s[]) orig(maxsize)
assignable s[*]
s == \old(s)
maxsize == \old(maxsize)
(\result == 0)  ==>  (\result  isPointer)
(\result == 0)  ==>  (s.equals(\old(s)))
s != null
maxsize == 100
\result == 0 || \result == 1
===========================================================================
std.getpat(char *;char *;)int:::ENTER
    Variables: arg arg[] pat pat[]
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
pat != null
===========================================================================
std.getpat(char *;char *;)int:::EXIT
    Variables: arg arg[] pat pat[] return orig(arg) orig(arg[]) orig(pat) orig(pat[])
assignable pat[*]
arg == \old(arg)
pat == \old(pat)
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
pat != null
\result == 0 || \result == 1
arg.equals(\old(arg))
===========================================================================
std.getsub(char *;char *;)boolean:::ENTER
    Variables: arg arg[] sub sub[]
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
sub != null
===========================================================================
std.getsub(char *;char *;)boolean:::EXIT
    Variables: arg arg[] sub sub[] return orig(arg) orig(arg[]) orig(sub) orig(sub[])
assignable sub[*]
arg == \old(arg)
sub == \old(sub)
(\result == 0)  ==>  (\result  isPointer)
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
sub != null
\result == 0 || \result == 1
arg.equals(\old(arg))
===========================================================================
std.in_pat_set(char;)boolean:::ENTER
    Variables: c
===========================================================================
std.in_pat_set(char;)boolean:::EXIT
    Variables: c return orig(c)
c == \old(c)
\result == 1
===========================================================================
std.in_set_2(char;)boolean:::ENTER
    Variables: c
===========================================================================
std.in_set_2(char;)boolean:::EXIT
    Variables: c return orig(c)
c == \old(c)
(\result == 0)  ==>  (c % 2 == 1)
(\result == 0)  ==>  (\result  isPointer)
(\result == 1)  ==>  (c % 5 == 2)
(\result == 1)  ==>  (c == 37 || c == 42)
\result == 0 || \result == 1
===========================================================================
std.locate(character;char *;int;)boolean:::ENTER
    Variables: c pat pat[] offset
pat != null
offset >= 1
===========================================================================
std.locate(character;char *;int;)boolean:::EXIT
    Variables: c pat pat[] offset return orig(c) orig(pat) orig(pat[]) orig(offset)
c == \old(c)
pat == \old(pat)
offset == \old(offset)
(\result == 0)  ==>  (\result  isPointer)
pat != null
offset >= 1
\result == 0 || \result == 1
pat.equals(\old(pat))
===========================================================================
std.main(int;char **;)int:::ENTER
    Variables: argc argv
argc == 2 || argc == 3
argv != null
===========================================================================
std.main(int;char **;)int:::EXIT
    Variables: argc argv return orig(argc) orig(argv)
argc == \old(argc)
argv == \old(argv)
argc == 2 || argc == 3
argv != null
\result == 0
===========================================================================
std.makepat(char *;int;char;char *;)int:::ENTER
    Variables: arg arg[] start delim pat pat[]
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
start == 0
delim == 0
pat != null
===========================================================================
std.makepat(char *;int;char;char *;)int:::EXIT
    Variables: arg arg[] start delim pat pat[] return orig(arg) orig(arg[]) orig(start) orig(delim) orig(pat) orig(pat[])
assignable pat[*]
arg == \old(arg)
start == \old(start)
delim == \old(delim)
pat == \old(pat)
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
start == 0
delim == 0
pat != null
\result >= 0
arg.equals(\old(arg))
start <= \result
===========================================================================
std.makesub(char *;int;character;char *;)int:::ENTER
    Variables: arg arg[] from delim sub sub[]
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
from == 0
delim == 0
sub != null
===========================================================================
std.makesub(char *;int;character;char *;)int:::EXIT
    Variables: arg arg[] from delim sub sub[] return orig(arg) orig(arg[]) orig(from) orig(delim) orig(sub) orig(sub[])
assignable sub[*]
arg == \old(arg)
from == \old(from)
delim == \old(delim)
sub == \old(sub)
arg != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: arg[] is printable
from == 0
delim == 0
sub != null
\result >= 0
arg.equals(\old(arg))
from <= \result
===========================================================================
std.omatch(char *;int *;char *;int;)boolean:::ENTER
    Variables: lin lin[] i *i pat pat[] j
lin != null
i != null
*i >= 0
pat != null
j >= 0
===========================================================================
std.omatch(char *;int *;char *;int;)boolean:::EXIT
    Variables: lin lin[] i *i pat pat[] j return orig(lin) orig(lin[]) orig(i) orig(*i) orig(pat) orig(pat[]) orig(j)
assignable lin[*], *i
lin == \old(lin)
i == \old(i)
pat == \old(pat)
j == \old(j)
(\result == 0)  ==>  (*i == \old(*i))
(\result == 0)  ==>  (\result  isPointer)
lin != null
i != null
*i >= 0
pat != null
j >= 0
\result == 0 || \result == 1
lin.compareTo(\old(lin)) >= 0
lin.contains(\old(lin))
(!(*i == 0)) || (\old(*i) == 0)
*i >= \old(*i)
pat.equals(\old(pat))
===========================================================================
std.patsize(char *;int;)int:::ENTER
    Variables: pat pat[] n
pat != null
n >= 0
===========================================================================
std.patsize(char *;int;)int:::EXIT
    Variables: pat pat[] n return orig(pat) orig(pat[]) orig(n)
pat == \old(pat)
n == \old(n)
pat != null
n >= 0
\result >= 1
pat.equals(\old(pat))
===========================================================================
std.putsub(char *;int;int;char *;)void:::ENTER
    Variables: lin lin[] s1 s2 sub sub[]
lin != null
s1 >= 0
s2 >= 0
sub != null
(!(s2 == 0)) || (s1 == 0)
s1 <= s2
===========================================================================
std.putsub(char *;int;int;char *;)void:::EXIT
    Variables: lin lin[] s1 s2 sub sub[] orig(lin) orig(lin[]) orig(s1) orig(s2) orig(sub) orig(sub[])
lin == \old(lin)
s1 == \old(s1)
s2 == \old(s2)
sub == \old(sub)
lin != null
s1 >= 0
s2 >= 0
sub != null
lin.equals(\old(lin))
(!(s2 == 0)) || (s1 == 0)
s1 <= s2
sub.equals(\old(sub))
===========================================================================
std.stclose(char *;int *;int;)void:::ENTER
    Variables: pat pat[] j *j lastj
pat != null
j != null
*j >= 2
lastj >= 0
*j > lastj
===========================================================================
std.stclose(char *;int *;int;)void:::EXIT
    Variables: pat pat[] j *j lastj orig(pat) orig(pat[]) orig(j) orig(*j) orig(lastj)
assignable pat[*], *j
pat == \old(pat)
j == \old(j)
lastj == \old(lastj)
pat != null
j != null
lastj >= 0
!pat.equals(\old(pat))
*j > lastj
*j - \old(*j) - 1 == 0
lastj < \old(*j)
===========================================================================
std.subline(char *;char *;char *;)void:::ENTER
    Variables: lin lin[] pat pat[] sub sub[]
lin != null
pat != null
sub != null
===========================================================================
std.subline(char *;char *;char *;)void:::EXIT
    Variables: lin lin[] pat pat[] sub sub[] orig(lin) orig(lin[]) orig(pat) orig(pat[]) orig(sub) orig(sub[])
assignable lin[*]
lin == \old(lin)
pat == \old(pat)
sub == \old(sub)
lin != null
pat != null
sub != null
lin.compareTo(\old(lin)) >= 0
lin.contains(\old(lin))
pat.equals(\old(pat))
sub.equals(\old(sub))
