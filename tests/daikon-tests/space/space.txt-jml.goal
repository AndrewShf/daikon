===========================================================================
std.Get1Real(charac *;charac **;double *;)int:::ENTER
    Variables: pp2 ureal_ptr ureal_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(ureal_ptr[]) size(ureal_ptr[])-1
pp2 != null
ureal_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.Get1Real(charac *;charac **;double *;)int:::EXIT120
    Variables: pp2 ureal_ptr ureal_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(ureal_ptr) orig(ureal_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(ureal_ptr[]) size(ureal_ptr[])-1 orig(size(ureal_ptr[])) orig(size(ureal_ptr[]))-1
assignable ureal_ptr[*]
\result == 12
===========================================================================
std.Get1Real(charac *;charac **;double *;)int:::EXIT121
    Variables: pp2 ureal_ptr ureal_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(ureal_ptr) orig(ureal_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(ureal_ptr[]) size(ureal_ptr[])-1 orig(size(ureal_ptr[])) orig(size(ureal_ptr[]))-1
assignable ureal_ptr[*]
\result == 0
===========================================================================
std.Get1Real(charac *;charac **;double *;)int:::EXIT
    Variables: pp2 ureal_ptr ureal_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(ureal_ptr) orig(ureal_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(ureal_ptr[]) size(ureal_ptr[])-1 orig(size(ureal_ptr[])) orig(size(ureal_ptr[]))-1
assignable ureal_ptr[*]
pp2 == \old(pp2)
ureal_ptr == \old(ureal_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
ureal_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 12
daikon.Quant.size(ureal_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.GetInt(charac *;charac **;int *;)int:::ENTER
    Variables: pp2 intero intero[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(intero[]) size(intero[])-1
pp2 != null
intero != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(intero != null)  ==>  (daikon.Quant.size(intero) == 1)
===========================================================================
std.GetInt(charac *;charac **;int *;)int:::EXIT124
    Variables: pp2 intero intero[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(intero) orig(intero[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(intero[]) size(intero[])-1 orig(size(intero[])) orig(size(intero[]))-1
assignable intero[*]
daikon.Quant.size(intero) == \old(daikon.Quant.size(intero))
\old(daikon.Quant.size(intero)) == 1
===========================================================================
std.GetInt(charac *;charac **;int *;)int:::EXIT
    Variables: pp2 intero intero[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(intero) orig(intero[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(intero[]) size(intero[])-1 orig(size(intero[])) orig(size(intero[]))-1
assignable intero[*]
pp2 == \old(pp2)
intero == \old(intero)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\old(intero) != null)  ==>  (daikon.Quant.size(intero) == \old(daikon.Quant.size(intero)))
pp2 != null
intero != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(intero) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.GetKeyword(char *;charac **;)int:::ENTER
    Variables: kw kw[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
kw != null
tp != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.GetKeyword(char *;charac **;)int:::EXIT125
    Variables: kw kw[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(kw) orig(kw[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable kw[*]
\result == 0
===========================================================================
std.GetKeyword(char *;charac **;)int:::EXIT126
    Variables: kw kw[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(kw) orig(kw[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable kw[*]
\result == 1
===========================================================================
std.GetKeyword(char *;charac **;)int:::EXIT
    Variables: kw kw[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(kw) orig(kw[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable kw[*]
kw == \old(kw)
tp == \old(tp)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (\result  isPointer)
kw != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: kw[] is printable
tp != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.GetNatur(charac *;charac **;int *;)int:::ENTER
    Variables: pp2 natur_ptr natur_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(natur_ptr[]) size(natur_ptr[])-1
pp2 != null
natur_ptr != null
(natur_ptr != null)  ==>  (daikon.Quant.eltsGTE(natur_ptr, 1))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(natur_ptr != null)  ==>  (daikon.Quant.size(natur_ptr) == 1)
===========================================================================
std.GetNatur(charac *;charac **;int *;)int:::EXIT130
    Variables: pp2 natur_ptr natur_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(natur_ptr) orig(natur_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(natur_ptr[]) size(natur_ptr[])-1 orig(size(natur_ptr[])) orig(size(natur_ptr[]))-1
assignable natur_ptr[*]
daikon.Quant.size(natur_ptr) == \old(daikon.Quant.size(natur_ptr))
\old(daikon.Quant.size(natur_ptr)) == 1
===========================================================================
std.GetNatur(charac *;charac **;int *;)int:::EXIT
    Variables: pp2 natur_ptr natur_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(natur_ptr) orig(natur_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(natur_ptr[]) size(natur_ptr[])-1 orig(size(natur_ptr[])) orig(size(natur_ptr[]))-1
assignable natur_ptr[*]
pp2 == \old(pp2)
natur_ptr == \old(natur_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\old(natur_ptr) != null)  ==>  (daikon.Quant.size(natur_ptr) == \old(daikon.Quant.size(natur_ptr)))
pp2 != null
natur_ptr != null
daikon.Quant.eltsGTE(natur_ptr, 1)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(natur_ptr) == 1
(\old(natur_ptr) != null)  ==>  (warning: method daikon.inv.binary.twoSequence.PairwiseLinearBinary.format(OutputFormat:JML) needs to be implemented: natur_ptr[] - orig(natur_ptr[]) - 1 == 0)
(\old(natur_ptr) != null)  ==>  (daikon.Quant.pairwiseGT(natur_ptr, \old(natur_ptr)))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.GetReal(double *;charac **;)int:::ENTER
    Variables: reale reale[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(reale[]) size(reale[])-1
reale != null
(reale != null)  ==>  (daikon.Quant.subsetOf(reale, new double[] { 0.0, 90.0 }))
(reale != null)  ==>  (daikon.Quant.pairwiseEqual(reale, new double[] { 0.0 }) || daikon.Quant.pairwiseEqual(reale, new double[] { 90.0 }))
tp != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(reale != null)  ==>  (daikon.Quant.size(reale) == 1)
===========================================================================
std.GetReal(double *;charac **;)int:::EXIT131
    Variables: reale reale[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(reale) orig(reale[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(reale[]) size(reale[])-1 orig(size(reale[])) orig(size(reale[]))-1
assignable reale[*]
::GLOBLE_FILENAME.equals("inputs/gr13462") || ::GLOBLE_FILENAME.equals("inputs/gr13463") || ::GLOBLE_FILENAME.equals("inputs/gr13525")
\result == 13
===========================================================================
std.GetReal(double *;charac **;)int:::EXIT132
    Variables: reale reale[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(reale) orig(reale[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(reale[]) size(reale[])-1 orig(size(reale[])) orig(size(reale[]))-1
assignable reale[*]
daikon.Quant.size(reale) == \old(daikon.Quant.size(reale))
\result == 0
daikon.Quant.size(reale) == 1
\old(daikon.Quant.size(reale)) == 1
===========================================================================
std.GetReal(double *;charac **;)int:::EXIT
    Variables: reale reale[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(reale) orig(reale[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(reale[]) size(reale[])-1 orig(size(reale[])) orig(size(reale[]))-1
assignable reale[*]
reale == \old(reale)
tp == \old(tp)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
((reale != null) && (\old(reale) != null))  ==>  (daikon.Quant.size(reale) == \old(daikon.Quant.size(reale)))
(\result == 0)  ==>  (daikon.Quant.subsetOf(\old(reale), new double[] { 0.0, 90.0 }))
(\result == 0)  ==>  (daikon.Quant.pairwiseEqual(\old(reale), new double[] { 0.0 }) || daikon.Quant.pairwiseEqual(\old(reale), new double[] { 90.0 }))
(\result == 0)  ==>  (\result  isPointer)
(\result == 13)  ==>  (::GLOBLE_FILENAME.equals("inputs/gr13462") || ::GLOBLE_FILENAME.equals("inputs/gr13463") || ::GLOBLE_FILENAME.equals("inputs/gr13525"))
reale != null
tp != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 13
(reale != null)  ==>  (daikon.Quant.size(reale) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.GetUName(char *;charac **;)int:::ENTER
    Variables: word word[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
word != null
tp != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.GetUName(char *;charac **;)int:::EXIT135
    Variables: word word[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(word) orig(word[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable word[*]
word.equals("GEOMETRY")
\result == 6
===========================================================================
std.GetUName(char *;charac **;)int:::EXIT136
    Variables: word word[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(word) orig(word[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable word[*]
word.equals("test") || word.equals("testgroup")
\result == 0
===========================================================================
std.GetUName(char *;charac **;)int:::EXIT
    Variables: word word[] tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(word) orig(word[]) orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable word[*]
word == \old(word)
tp == \old(tp)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
word != null
word.equals("GEOMETRY") || word.equals("test") || word.equals("testgroup")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: word[] is printable
tp != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 6
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.GetUReal(charac *;charac **;double *;)int:::ENTER
    Variables: pp2 ureal_ptr ureal_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(ureal_ptr[]) size(ureal_ptr[])-1
pp2 != null
ureal_ptr != null
daikon.Quant.pairwiseEqual(ureal_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(ureal_ptr, 0.0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(ureal_ptr) == 1
===========================================================================
std.GetUReal(charac *;charac **;double *;)int:::EXIT139
    Variables: pp2 ureal_ptr ureal_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(ureal_ptr) orig(ureal_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(ureal_ptr[]) size(ureal_ptr[])-1 orig(size(ureal_ptr[])) orig(size(ureal_ptr[]))-1
assignable ureal_ptr[*]
===========================================================================
std.GetUReal(charac *;charac **;double *;)int:::EXIT
    Variables: pp2 ureal_ptr ureal_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(ureal_ptr) orig(ureal_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(ureal_ptr[]) size(ureal_ptr[])-1 orig(size(ureal_ptr[])) orig(size(ureal_ptr[]))-1
assignable ureal_ptr[*]
pp2 == \old(pp2)
ureal_ptr == \old(ureal_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(ureal_ptr) == \old(daikon.Quant.size(ureal_ptr))
pp2 != null
ureal_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(ureal_ptr) == 1
daikon.Quant.pairwiseGT(ureal_ptr, \old(ureal_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.InKWords(char *;)int:::ENTER
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
WORD != null
WORD.equals("GEOMETRY") || WORD.equals("test") || WORD.equals("testgroup")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: WORD[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.InKWords(char *;)int:::EXIT195
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(WORD) orig(WORD[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
WORD.equals("GEOMETRY")
\result == 1
===========================================================================
std.InKWords(char *;)int:::EXIT196
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(WORD) orig(WORD[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
WORD.equals("test") || WORD.equals("testgroup")
\result == 0
===========================================================================
std.InKWords(char *;)int:::EXIT
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(WORD) orig(WORD[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
WORD == \old(WORD)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(WORD.equals("GEOMETRY"))  <==>  (\result == 1)
(WORD.equals("test") || WORD.equals("testgroup"))  <==>  (\result == 0)
(WORD.equals("test") || WORD.equals("testgroup"))  ==>  (\result  isPointer)
WORD != null
WORD.equals("GEOMETRY") || WORD.equals("test") || WORD.equals("testgroup")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: WORD[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
WORD.equals(\old(WORD))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.InUNames(char *;)int:::ENTER
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
WORD != null
WORD.equals("test") || WORD.equals("testgroup")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: WORD[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.InUNames(char *;)int:::EXIT205
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(WORD) orig(WORD[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
===========================================================================
std.InUNames(char *;)int:::EXIT
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(WORD) orig(WORD[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
WORD == \old(WORD)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
WORD != null
WORD.equals("test") || WORD.equals("testgroup")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: WORD[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
WORD.equals(\old(WORD))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.InserUN(char *;)int:::ENTER
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
WORD != null
WORD.equals("test") || WORD.equals("testgroup")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: WORD[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.InserUN(char *;)int:::EXIT197
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(WORD) orig(WORD[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
===========================================================================
std.InserUN(char *;)int:::EXIT
    Variables: WORD WORD[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(WORD) orig(WORD[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
WORD == \old(WORD)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
WORD != null
WORD.equals("test") || WORD.equals("testgroup")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: WORD[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
WORD.equals(\old(WORD))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.TapeGet(charac **;)char:::ENTER
    Variables: tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
tp != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.TapeGet(charac **;)char:::EXIT
    Variables: tp ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(tp) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
tp == \old(tp)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
tp != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.adddef(charac *;charac **;AddRem **;)int:::ENTER
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.adddef(charac *;charac **;AddRem **;)int:::EXIT10
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.adddef(charac *;charac **;AddRem **;)int:::EXIT11
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME.equals("inputs/gr114") || ::GLOBLE_FILENAME.equals("inputs/gr42")
\result == 17
===========================================================================
std.adddef(charac *;charac **;AddRem **;)int:::EXIT2
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 1
===========================================================================
std.adddef(charac *;charac **;AddRem **;)int:::EXIT4
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.adddef(charac *;charac **;AddRem **;)int:::EXIT6
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.adddef(charac *;charac **;AddRem **;)int:::EXIT
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
addrem_ptr == \old(addrem_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.addscan(Group *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.addscan(Group *;)int:::EXIT12
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 7
===========================================================================
std.addscan(Group *;)int:::EXIT13
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.addscan(Group *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (\result  isPointer)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 7
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.adremdef(charac *;charac **;AddRem **;)int:::ENTER
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.adremdef(charac *;charac **;AddRem **;)int:::EXIT14
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.adremdef(charac *;charac **;AddRem **;)int:::EXIT15
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr114")
\result == 17
===========================================================================
std.adremdef(charac *;charac **;AddRem **;)int:::EXIT18
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 1
===========================================================================
std.adremdef(charac *;charac **;AddRem **;)int:::EXIT
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
addrem_ptr == \old(addrem_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.ampunit(charac **;int *;)int:::ENTER
    Variables: tp unit_ptr unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(unit_ptr[]) size(unit_ptr[])-1
tp != null
unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.ampunit(charac **;int *;)int:::EXIT20
    Variables: tp unit_ptr unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(tp) orig(unit_ptr) orig(unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unit_ptr[]) size(unit_ptr[])-1 orig(size(unit_ptr[])) orig(size(unit_ptr[]))-1
assignable unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(unit_ptr, 0)
\result == 1
===========================================================================
std.ampunit(charac **;int *;)int:::EXIT21
    Variables: tp unit_ptr unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(tp) orig(unit_ptr) orig(unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unit_ptr[]) size(unit_ptr[])-1 orig(size(unit_ptr[])) orig(size(unit_ptr[]))-1
assignable unit_ptr[*]
daikon.Quant.subsetOf(unit_ptr, new long[] { 1, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME.equals("inputs/gr13462") || ::GLOBLE_FILENAME.equals("inputs/gr13463") || ::GLOBLE_FILENAME.equals("inputs/gr13523")
\result == 0
===========================================================================
std.ampunit(charac **;int *;)int:::EXIT
    Variables: tp unit_ptr unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(tp) orig(unit_ptr) orig(unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unit_ptr[]) size(unit_ptr[])-1 orig(size(unit_ptr[])) orig(size(unit_ptr[]))-1
assignable unit_ptr[*]
tp == \old(tp)
unit_ptr == \old(unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(("oneOf.java.jpp: SEQUENCE unimplemented" != null))  <==>  (\result == 1)
(("oneOf.java.jpp: SEQUENCE unimplemented" != null))  <==>  (daikon.Quant.eltsEqual(unit_ptr, 0))
(("oneOf.java.jpp: SEQUENCE unimplemented" != null))  <==>  (\result == 0)
(("oneOf.java.jpp: SEQUENCE unimplemented" != null))  <==>  (daikon.Quant.subsetOf(unit_ptr, new long[] { 1, 2 }))
(("oneOf.java.jpp: SEQUENCE unimplemented" != null))  ==>  (::GLOBLE_FILENAME.equals("inputs/gr13462") || ::GLOBLE_FILENAME.equals("inputs/gr13463") || ::GLOBLE_FILENAME.equals("inputs/gr13523"))
(("oneOf.java.jpp: SEQUENCE unimplemented" != null))  ==>  (\result  isPointer)
tp != null
unit_ptr != null
daikon.Quant.subsetOf(unit_ptr, new long[] { 0, 1, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(unit_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.ampval(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 amp_ptr amp_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(amp_ptr[]) size(amp_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1
pp2 != null
amp_ptr != null
amp_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.ampval(charac *;charac **;double *;int *;)int:::EXIT22
    Variables: pp2 amp_ptr amp_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(amp_ptr) orig(amp_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(amp_ptr[]) size(amp_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(amp_ptr[])) orig(size(amp_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable amp_ptr[*], amp_unit_ptr[*]
pp2 != null
amp_ptr != null
amp_unit_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr13525")
\result == 1
===========================================================================
std.ampval(charac *;charac **;double *;int *;)int:::EXIT23
    Variables: pp2 amp_ptr amp_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(amp_ptr) orig(amp_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(amp_ptr[]) size(amp_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(amp_ptr[])) orig(size(amp_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable amp_ptr[*], amp_unit_ptr[*]
daikon.Quant.eltsNotEqual(amp_ptr, 0)
daikon.Quant.subsetOf(amp_unit_ptr, new long[] { 0, 1, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
daikon.Quant.size(amp_ptr) == 1
daikon.Quant.size(amp_unit_ptr) == 1
===========================================================================
std.ampval(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 amp_ptr amp_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(amp_ptr) orig(amp_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(amp_ptr[]) size(amp_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(amp_ptr[])) orig(size(amp_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable amp_ptr[*], amp_unit_ptr[*]
pp2 == \old(pp2)
amp_ptr == \old(amp_ptr)
amp_unit_ptr == \old(amp_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (daikon.Quant.eltsNotEqual(amp_ptr, 0))
(\result == 0)  ==>  (daikon.Quant.subsetOf(amp_unit_ptr, new long[] { 0, 1, 2 }))
(\result == 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == 0)  ==>  (\result  isPointer)
(\result == 1)  ==>  (::GLOBLE_FILENAME != null)
(\result == 1)  ==>  (::GLOBLE_FILENAME.equals("inputs/gr13525"))
(\result == 1)  ==>  (amp_ptr != null)
(\result == 1)  ==>  (amp_unit_ptr != null)
(\result == 1)  ==>  (pp2 != null)
pp2 != null
amp_ptr != null
(amp_ptr != null)  ==>  (daikon.Quant.eltsNotEqual(amp_ptr, 0))
amp_unit_ptr != null
(amp_unit_ptr != null)  ==>  (daikon.Quant.subsetOf(amp_unit_ptr, new long[] { 0, 1, 2 }))
(amp_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(amp_ptr != null)  ==>  (daikon.Quant.size(amp_ptr) == 1)
(amp_unit_ptr != null)  ==>  (daikon.Quant.size(amp_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.angclaus(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
pp2 != null
angle_ptr != null
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(angle_ptr, 0.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
===========================================================================
std.angclaus(charac *;charac **;double *;int *;)int:::EXIT24
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(angle_ptr, \old(angle_ptr))
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(angle_ptr, 0.0)
\result == 1
===========================================================================
std.angclaus(charac *;charac **;double *;int *;)int:::EXIT26
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
\result == 0
daikon.Quant.pairwiseGT(angle_ptr, \old(angle_ptr))
===========================================================================
std.angclaus(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
pp2 == \old(pp2)
angle_ptr == \old(angle_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
daikon.Quant.pairwiseEqual(angle_unit_ptr, \old(angle_unit_ptr))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(angle_ptr) == \old(daikon.Quant.size(angle_ptr))
pp2 != null
angle_ptr != null
daikon.Quant.eltsGTE(angle_ptr, 0.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
daikon.Quant.pairwiseGTE(angle_ptr, \old(angle_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.angledir(charac *;charac **;double *;double *;int *;)int:::ENTER
    Variables: pp2 theta_ptr theta_ptr[] phi_ptr phi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
::GLOBLE_FILENAME.equals("inputs/gr192") || ::GLOBLE_FILENAME.equals("inputs/gr82")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.angledir(charac *;charac **;double *;double *;int *;)int:::EXIT27
    Variables: pp2 theta_ptr theta_ptr[] phi_ptr phi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(theta_ptr) orig(theta_ptr[]) orig(phi_ptr) orig(phi_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(theta_ptr[])) orig(size(theta_ptr[]))-1 orig(size(phi_ptr[])) orig(size(phi_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable theta_ptr[*], phi_ptr[*], angle_unit_ptr[*]
===========================================================================
std.angledir(charac *;charac **;double *;double *;int *;)int:::EXIT
    Variables: pp2 theta_ptr theta_ptr[] phi_ptr phi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(theta_ptr) orig(theta_ptr[]) orig(phi_ptr) orig(phi_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(theta_ptr[])) orig(size(theta_ptr[]))-1 orig(size(phi_ptr[])) orig(size(phi_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable theta_ptr[*], phi_ptr[*], angle_unit_ptr[*]
pp2 == \old(pp2)
theta_ptr == \old(theta_ptr)
phi_ptr == \old(phi_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME.equals("inputs/gr192") || ::GLOBLE_FILENAME.equals("inputs/gr82")
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.anglerot(charac *;charac **;double *;double *;int *;)int:::ENTER
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
pp2 != null
angle_start_ptr != null
angle_step_ptr != null
angle_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.anglerot(charac *;charac **;double *;double *;int *;)int:::EXIT32
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_start_ptr[*], angle_step_ptr[*], angle_unit_ptr[*]
\result == 1
===========================================================================
std.anglerot(charac *;charac **;double *;double *;int *;)int:::EXIT35
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_start_ptr[*], angle_step_ptr[*], angle_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
\result == 0
daikon.Quant.size(angle_start_ptr) == 1
daikon.Quant.size(angle_step_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
===========================================================================
std.anglerot(charac *;charac **;double *;double *;int *;)int:::EXIT
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_start_ptr[*], angle_step_ptr[*], angle_unit_ptr[*]
pp2 == \old(pp2)
angle_start_ptr == \old(angle_start_ptr)
angle_step_ptr == \old(angle_step_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
angle_start_ptr != null
angle_step_ptr != null
angle_unit_ptr != null
(angle_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(angle_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(angle_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(angle_start_ptr != null)  ==>  (daikon.Quant.size(angle_start_ptr) == 1)
(angle_step_ptr != null)  ==>  (daikon.Quant.size(angle_step_ptr) == 1)
(angle_unit_ptr != null)  ==>  (daikon.Quant.size(angle_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.angstep(charac *;charac **;double *;int *;double *;double *;int *;)int:::ENTER
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1
pp2 != null
angle_ptr != null
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(angle_ptr, 0.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
pstep_ptr != null
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
qstep_ptr != null
daikon.Quant.pairwiseEqual(qstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qstep_ptr, 0.0)
pqstep_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(qstep_ptr) == 1
daikon.Quant.size(pqstep_unit_ptr) == 1
===========================================================================
std.angstep(charac *;charac **;double *;int *;double *;double *;int *;)int:::EXIT36
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(angle_ptr, \old(angle_ptr))
daikon.Quant.pairwiseEqual(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseEqual(qstep_ptr, \old(qstep_ptr))
daikon.Quant.pairwiseEqual(pqstep_unit_ptr, \old(pqstep_unit_ptr))
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(angle_ptr, 0.0)
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
daikon.Quant.pairwiseEqual(qstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qstep_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
\result == 1
===========================================================================
std.angstep(charac *;charac **;double *;int *;double *;double *;int *;)int:::EXIT38
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
assignable angle_ptr[*], pstep_ptr[*], qstep_ptr[*], pqstep_unit_ptr[*]
\result == 0
daikon.Quant.pairwiseGT(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseGT(qstep_ptr, \old(qstep_ptr))
===========================================================================
std.angstep(charac *;charac **;double *;int *;double *;double *;int *;)int:::EXIT
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
assignable angle_ptr[*], pstep_ptr[*], qstep_ptr[*], pqstep_unit_ptr[*]
pp2 == \old(pp2)
angle_ptr == \old(angle_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
daikon.Quant.pairwiseEqual(angle_unit_ptr, \old(angle_unit_ptr))
pstep_ptr == \old(pstep_ptr)
qstep_ptr == \old(qstep_ptr)
pqstep_unit_ptr == \old(pqstep_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(angle_ptr) == \old(daikon.Quant.size(angle_ptr))
daikon.Quant.size(pstep_ptr) == \old(daikon.Quant.size(pstep_ptr))
daikon.Quant.size(qstep_ptr) == \old(daikon.Quant.size(qstep_ptr))
daikon.Quant.size(pqstep_unit_ptr) == \old(daikon.Quant.size(pqstep_unit_ptr))
pp2 != null
angle_ptr != null
daikon.Quant.eltsGTE(angle_ptr, 0.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
pstep_ptr != null
daikon.Quant.eltsGTE(pstep_ptr, 0.0)
qstep_ptr != null
daikon.Quant.eltsGTE(qstep_ptr, 0.0)
pqstep_unit_ptr != null
daikon.Quant.subsetOf(pqstep_unit_ptr, new long[] { 0, 3 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(qstep_ptr) == 1
daikon.Quant.size(pqstep_unit_ptr) == 1
daikon.Quant.pairwiseGTE(angle_ptr, \old(angle_ptr))
daikon.Quant.pairwiseGTE(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseGTE(qstep_ptr, \old(qstep_ptr))
daikon.Quant.pairwiseGTE(pqstep_unit_ptr, \old(pqstep_unit_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.angunit(charac *;charac **;int *;)int:::ENTER
    Variables: pp2 angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
pp2 != null
angle_unit_ptr != null
(angle_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(angle_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(angle_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(angle_unit_ptr != null)  ==>  (daikon.Quant.size(angle_unit_ptr) == 1)
===========================================================================
std.angunit(charac *;charac **;int *;)int:::EXIT39
    Variables: pp2 angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
\result == 20
\old(daikon.Quant.size(angle_unit_ptr)) == 1
===========================================================================
std.angunit(charac *;charac **;int *;)int:::EXIT40
    Variables: pp2 angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
\result == 0
\old(daikon.Quant.size(angle_unit_ptr)) == 1
===========================================================================
std.angunit(charac *;charac **;int *;)int:::EXIT
    Variables: pp2 angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
pp2 == \old(pp2)
angle_unit_ptr == \old(angle_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (daikon.Quant.subsetOf(angle_unit_ptr, new long[] { 0, 1 }))
(\result == 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == 0)  ==>  (\result  isPointer)
(\result == 20)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == 20)  ==>  (daikon.Quant.eltsEqual(angle_unit_ptr, 0))
pp2 != null
angle_unit_ptr != null
daikon.Quant.subsetOf(angle_unit_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 20
daikon.Quant.size(angle_unit_ptr) == 1
(\old(angle_unit_ptr) != null)  ==>  (daikon.Quant.pairwiseEqual(angle_unit_ptr, \old(angle_unit_ptr)))
(\old(angle_unit_ptr) != null)  ==>  (daikon.Quant.isReverse(angle_unit_ptr, \old(angle_unit_ptr)))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.angval(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
pp2 != null
angle_ptr != null
(angle_ptr != null)  ==>  (daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 90.0 }))
(angle_ptr != null)  ==>  (daikon.Quant.eltsEqual(angle_ptr, 90.0))
angle_unit_ptr != null
(angle_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(angle_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(angle_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(angle_ptr != null)  ==>  (daikon.Quant.size(angle_ptr) == 1)
(angle_unit_ptr != null)  ==>  (daikon.Quant.size(angle_unit_ptr) == 1)
===========================================================================
std.angval(charac *;charac **;double *;int *;)int:::EXIT41
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*], angle_unit_ptr[*]
::GLOBLE_FILENAME.equals("inputs/gr13462") || ::GLOBLE_FILENAME.equals("inputs/gr13463")
\result == 1
===========================================================================
std.angval(charac *;charac **;double *;int *;)int:::EXIT42
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
daikon.Quant.size(angle_ptr) == \old(daikon.Quant.size(angle_ptr))
daikon.Quant.subsetOf(angle_unit_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
\old(daikon.Quant.size(angle_ptr)) == 1
\old(daikon.Quant.size(angle_unit_ptr)) == 1
(\old(angle_ptr) != null)  ==>  (daikon.Quant.pairwiseLT(angle_ptr, \old(angle_ptr)))
(\old(angle_unit_ptr) != null)  ==>  (daikon.Quant.pairwiseEqual(angle_unit_ptr, \old(angle_unit_ptr)))
(\old(angle_unit_ptr) != null)  ==>  (daikon.Quant.isReverse(angle_unit_ptr, \old(angle_unit_ptr)))
===========================================================================
std.angval(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
pp2 == \old(pp2)
angle_ptr == \old(angle_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
((angle_ptr != null) && (\old(angle_ptr) != null))  ==>  (daikon.Quant.size(angle_ptr) == \old(daikon.Quant.size(angle_ptr)))
(\result == 0)  ==>  (daikon.Quant.pairwiseLT(angle_ptr, \old(angle_ptr)))
(\result == 0)  ==>  (daikon.Quant.pairwiseEqual(angle_unit_ptr, \old(angle_unit_ptr)))
(\result == 0)  ==>  (daikon.Quant.subsetOf(angle_unit_ptr, new long[] { 0, 1 }))
(\result == 0)  ==>  (daikon.Quant.isReverse(angle_unit_ptr, \old(angle_unit_ptr)))
(\result == 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == 0)  ==>  (daikon.Quant.pairwiseEqual(\old(angle_ptr), new double[] { 90.0 }))
(\result == 0)  ==>  (daikon.Quant.eltsEqual(\old(angle_ptr), 90.0))
(\result == 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == 0)  ==>  (daikon.Quant.eltsEqual(\old(angle_unit_ptr), 0))
(\result == 0)  ==>  (\result  isPointer)
(\result == 1)  ==>  (::GLOBLE_FILENAME.equals("inputs/gr13462") || ::GLOBLE_FILENAME.equals("inputs/gr13463"))
pp2 != null
angle_ptr != null
angle_unit_ptr != null
(angle_unit_ptr != null)  ==>  (daikon.Quant.subsetOf(angle_unit_ptr, new long[] { 0, 1 }))
(angle_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(angle_ptr != null)  ==>  (daikon.Quant.size(angle_ptr) == 1)
(angle_unit_ptr != null)  ==>  (daikon.Quant.size(angle_unit_ptr) == 1)
((angle_ptr != null) && (\old(angle_ptr) != null))  ==>  (daikon.Quant.pairwiseLT(angle_ptr, \old(angle_ptr)))
((angle_unit_ptr != null) && (\old(angle_unit_ptr) != null))  ==>  (daikon.Quant.pairwiseEqual(angle_unit_ptr, \old(angle_unit_ptr)))
((angle_unit_ptr != null) && (\old(angle_unit_ptr) != null))  ==>  (daikon.Quant.isReverse(angle_unit_ptr, \old(angle_unit_ptr)))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.beampha(charac *;charac **;double *;double *;double *;double *;int *;)int:::ENTER
    Variables: pp2 u_ptr u_ptr[] v_ptr v_ptr[] theta_ptr theta_ptr[] phi_ptr phi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(u_ptr[]) size(u_ptr[])-1 size(v_ptr[]) size(v_ptr[])-1 size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.beampha(charac *;charac **;double *;double *;double *;double *;int *;)int:::EXIT45
    Variables: pp2 u_ptr u_ptr[] v_ptr v_ptr[] theta_ptr theta_ptr[] phi_ptr phi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(u_ptr) orig(u_ptr[]) orig(v_ptr) orig(v_ptr[]) orig(theta_ptr) orig(theta_ptr[]) orig(phi_ptr) orig(phi_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(u_ptr[]) size(u_ptr[])-1 size(v_ptr[]) size(v_ptr[])-1 size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(u_ptr[])) orig(size(u_ptr[]))-1 orig(size(v_ptr[])) orig(size(v_ptr[]))-1 orig(size(theta_ptr[])) orig(size(theta_ptr[]))-1 orig(size(phi_ptr[])) orig(size(phi_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable u_ptr[*], v_ptr[*], theta_ptr[*], phi_ptr[*], angle_unit_ptr[*]
daikon.Quant.pairwiseEqual(u_ptr, new double[] { 0.5 })
daikon.Quant.eltsEqual(u_ptr, 0.5)
daikon.Quant.pairwiseEqual(v_ptr, new double[] { 0.5 })
daikon.Quant.eltsEqual(v_ptr, 0.5)
\result == 0
===========================================================================
std.beampha(charac *;charac **;double *;double *;double *;double *;int *;)int:::EXIT49
    Variables: pp2 u_ptr u_ptr[] v_ptr v_ptr[] theta_ptr theta_ptr[] phi_ptr phi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(u_ptr) orig(u_ptr[]) orig(v_ptr) orig(v_ptr[]) orig(theta_ptr) orig(theta_ptr[]) orig(phi_ptr) orig(phi_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(u_ptr[]) size(u_ptr[])-1 size(v_ptr[]) size(v_ptr[])-1 size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(u_ptr[])) orig(size(u_ptr[]))-1 orig(size(v_ptr[])) orig(size(v_ptr[]))-1 orig(size(theta_ptr[])) orig(size(theta_ptr[]))-1 orig(size(phi_ptr[])) orig(size(phi_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable u_ptr[*], v_ptr[*], theta_ptr[*], phi_ptr[*], angle_unit_ptr[*]
::GLOBLE_FILENAME.equals("inputs/gr192") || ::GLOBLE_FILENAME.equals("inputs/gr82")
\result == 17
===========================================================================
std.beampha(charac *;charac **;double *;double *;double *;double *;int *;)int:::EXIT
    Variables: pp2 u_ptr u_ptr[] v_ptr v_ptr[] theta_ptr theta_ptr[] phi_ptr phi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(u_ptr) orig(u_ptr[]) orig(v_ptr) orig(v_ptr[]) orig(theta_ptr) orig(theta_ptr[]) orig(phi_ptr) orig(phi_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(u_ptr[]) size(u_ptr[])-1 size(v_ptr[]) size(v_ptr[])-1 size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(u_ptr[])) orig(size(u_ptr[]))-1 orig(size(v_ptr[])) orig(size(v_ptr[]))-1 orig(size(theta_ptr[])) orig(size(theta_ptr[]))-1 orig(size(phi_ptr[])) orig(size(phi_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable u_ptr[*], v_ptr[*], theta_ptr[*], phi_ptr[*], angle_unit_ptr[*]
pp2 == \old(pp2)
u_ptr == \old(u_ptr)
v_ptr == \old(v_ptr)
theta_ptr == \old(theta_ptr)
phi_ptr == \old(phi_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(u_ptr != null)  ==>  (daikon.Quant.pairwiseEqual(u_ptr, new double[] { 0.5 }))
(u_ptr != null)  ==>  (daikon.Quant.eltsEqual(u_ptr, 0.5))
(v_ptr != null)  ==>  (daikon.Quant.pairwiseEqual(v_ptr, new double[] { 0.5 }))
(v_ptr != null)  ==>  (daikon.Quant.eltsEqual(v_ptr, 0.5))
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 17
daikon.Quant.size(u_ptr) == 1
daikon.Quant.size(v_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.blockdef(charac *;charac **;Node **;)int:::ENTER
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
node_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.blockdef(charac *;charac **;Node **;)int:::EXIT50
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 1
===========================================================================
std.blockdef(charac *;charac **;Node **;)int:::EXIT55
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.blockdef(charac *;charac **;Node **;)int:::EXIT
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
node_ptr == \old(node_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
node_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.circpol(charac *;charac **;int *;)int:::ENTER
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(direction_ptr[]) size(direction_ptr[])-1
pp2 != null
direction_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(direction_ptr) == 1
===========================================================================
std.circpol(charac *;charac **;int *;)int:::EXIT56
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
daikon.Quant.pairwiseEqual(direction_ptr, \old(direction_ptr))
pp2 != null
direction_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 0)
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr13461")
\result == 1
===========================================================================
std.circpol(charac *;charac **;int *;)int:::EXIT57
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
daikon.Quant.pairwiseEqual(direction_ptr, \old(direction_ptr))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 0)
\result == 0
===========================================================================
std.circpol(charac *;charac **;int *;)int:::EXIT58
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable direction_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 1)
\result == 0
daikon.Quant.pairwiseGT(direction_ptr, \old(direction_ptr))
===========================================================================
std.circpol(charac *;charac **;int *;)int:::EXIT59
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
daikon.Quant.pairwiseEqual(direction_ptr, \old(direction_ptr))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 0)
\result == 0
===========================================================================
std.circpol(charac *;charac **;int *;)int:::EXIT
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable direction_ptr[*]
pp2 == \old(pp2)
direction_ptr == \old(direction_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(direction_ptr) == \old(daikon.Quant.size(direction_ptr))
pp2 != null
direction_ptr != null
daikon.Quant.subsetOf(direction_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(direction_ptr) == 1
daikon.Quant.pairwiseGTE(direction_ptr, \old(direction_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.circspec(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1
pp2 != null
radius_ptr != null
radius_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.circspec(charac *;charac **;double *;int *;)int:::EXIT60
    Variables: pp2 radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(radius_ptr) orig(radius_ptr[]) orig(radius_unit_ptr) orig(radius_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 orig(size(radius_ptr[])) orig(size(radius_ptr[]))-1 orig(size(radius_unit_ptr[])) orig(size(radius_unit_ptr[]))-1
assignable radius_ptr[*], radius_unit_ptr[*]
::GLOBLE_FILENAME.equals("inputs/gr150") || ::GLOBLE_FILENAME.equals("inputs/gr2") || ::GLOBLE_FILENAME.equals("inputs/gr54")
\result == 1
===========================================================================
std.circspec(charac *;charac **;double *;int *;)int:::EXIT62
    Variables: pp2 radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(radius_ptr) orig(radius_ptr[]) orig(radius_unit_ptr) orig(radius_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 orig(size(radius_ptr[])) orig(size(radius_ptr[]))-1 orig(size(radius_unit_ptr[])) orig(size(radius_unit_ptr[]))-1
assignable radius_ptr[*], radius_unit_ptr[*]
daikon.Quant.eltsGTE(radius_unit_ptr, 0)
\result == 0
daikon.Quant.size(radius_ptr) == 1
daikon.Quant.size(radius_unit_ptr) == 1
===========================================================================
std.circspec(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(radius_ptr) orig(radius_ptr[]) orig(radius_unit_ptr) orig(radius_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 orig(size(radius_ptr[])) orig(size(radius_ptr[]))-1 orig(size(radius_unit_ptr[])) orig(size(radius_unit_ptr[]))-1
assignable radius_ptr[*], radius_unit_ptr[*]
pp2 == \old(pp2)
radius_ptr == \old(radius_ptr)
radius_unit_ptr == \old(radius_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
radius_ptr != null
radius_unit_ptr != null
(radius_unit_ptr != null)  ==>  (daikon.Quant.eltsGTE(radius_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(radius_ptr != null)  ==>  (daikon.Quant.size(radius_ptr) == 1)
(radius_unit_ptr != null)  ==>  (daikon.Quant.size(radius_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.dacos(double;)double:::ENTER
    Variables: x ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
daikon.Quant.fuzzy.ne(x, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.dacos(double;)double:::EXIT
    Variables: x ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(x) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(x, \old(x))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.fuzzy.ne(x, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.fuzzy.ne(x, \result)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.datan(double;)double:::ENTER
    Variables: x ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.datan(double;)double:::EXIT
    Variables: x ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(x) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(x, \old(x))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.dcos(double;)double:::ENTER
    Variables: x ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.dcos(double;)double:::EXIT
    Variables: x ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(x) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable x
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.fuzzy.ne(\result, 0)
daikon.Quant.fuzzy.ne(x, \result)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
daikon.Quant.fuzzy.ne(\result, \old(x))
===========================================================================
std.degconv(double *;int;)int:::ENTER
    Variables: x_ptr x_ptr[] unit ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(x_ptr[]) size(x_ptr[])-1
x_ptr != null
(x_ptr != null)  ==>  (daikon.Quant.eltsGTE(x_ptr, 0.0))
unit == 0 || unit == 1
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(x_ptr != null)  ==>  (daikon.Quant.size(x_ptr) == 1)
===========================================================================
std.degconv(double *;int;)int:::EXIT
    Variables: x_ptr x_ptr[] unit ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(x_ptr) orig(x_ptr[]) orig(unit) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(x_ptr[]) size(x_ptr[])-1 orig(size(x_ptr[])) orig(size(x_ptr[]))-1
x_ptr == \old(x_ptr)
unit == \old(unit)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
x_ptr != null
(x_ptr != null)  ==>  (daikon.Quant.eltsGTE(x_ptr, 0.0))
unit == 0 || unit == 1
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
(x_ptr != null)  ==>  (daikon.Quant.size(x_ptr) == 1)
((x_ptr != null) && (\old(x_ptr) != null))  ==>  (daikon.Quant.pairwiseEqual(x_ptr, \old(x_ptr)))
((x_ptr != null) && (\old(x_ptr) != null))  ==>  (daikon.Quant.isReverse(x_ptr, \old(x_ptr)))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.doubmax(double;double;)double:::ENTER
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.doubmax(double;double;)double:::EXIT71
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(a, \result)
daikon.Quant.fuzzy.gt(a, b)
===========================================================================
std.doubmax(double;double;)double:::EXIT72
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(b, \result)
daikon.Quant.fuzzy.lte(a, b)
===========================================================================
std.doubmax(double;double;)double:::EXIT
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(a, \old(a))
daikon.Quant.fuzzy.eq(b, \old(b))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(daikon.Quant.fuzzy.lte(a, b))  <==>  (daikon.Quant.fuzzy.eq(b, \result))
(daikon.Quant.fuzzy.gt(a, b))  <==>  (daikon.Quant.fuzzy.lt(b, \result))
(daikon.Quant.fuzzy.gt(a, b))  ==>  (daikon.Quant.fuzzy.eq(a, \result))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.fuzzy.lte(a, \result)
daikon.Quant.fuzzy.lte(b, \result)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
\result == (java.lang.Math.max(a, b))
===========================================================================
std.doubstep(charac *;charac **;double *;double *;int *;)int:::ENTER
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1
pp2 != null
pstep_ptr != null
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
qstep_ptr != null
daikon.Quant.pairwiseEqual(qstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qstep_ptr, 0.0)
pqstep_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(qstep_ptr) == 1
daikon.Quant.size(pqstep_unit_ptr) == 1
===========================================================================
std.doubstep(charac *;charac **;double *;double *;int *;)int:::EXIT75
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseEqual(qstep_ptr, \old(qstep_ptr))
daikon.Quant.pairwiseEqual(pqstep_unit_ptr, \old(pqstep_unit_ptr))
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
daikon.Quant.pairwiseEqual(qstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qstep_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
\result == 1
===========================================================================
std.doubstep(charac *;charac **;double *;double *;int *;)int:::EXIT79
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
assignable pstep_ptr[*], qstep_ptr[*], pqstep_unit_ptr[*]
\result == 0
daikon.Quant.pairwiseGT(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseGT(qstep_ptr, \old(qstep_ptr))
===========================================================================
std.doubstep(charac *;charac **;double *;double *;int *;)int:::EXIT
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
assignable pstep_ptr[*], qstep_ptr[*], pqstep_unit_ptr[*]
pp2 == \old(pp2)
pstep_ptr == \old(pstep_ptr)
qstep_ptr == \old(qstep_ptr)
pqstep_unit_ptr == \old(pqstep_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(pstep_ptr) == \old(daikon.Quant.size(pstep_ptr))
daikon.Quant.size(qstep_ptr) == \old(daikon.Quant.size(qstep_ptr))
daikon.Quant.size(pqstep_unit_ptr) == \old(daikon.Quant.size(pqstep_unit_ptr))
pp2 != null
pstep_ptr != null
daikon.Quant.eltsGTE(pstep_ptr, 0.0)
qstep_ptr != null
daikon.Quant.eltsGTE(qstep_ptr, 0.0)
pqstep_unit_ptr != null
daikon.Quant.subsetOf(pqstep_unit_ptr, new long[] { 0, 2, 3 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(qstep_ptr) == 1
daikon.Quant.size(pqstep_unit_ptr) == 1
daikon.Quant.pairwiseGTE(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseGTE(qstep_ptr, \old(qstep_ptr))
daikon.Quant.pairwiseGTE(pqstep_unit_ptr, \old(pqstep_unit_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.dsin(double;)double:::ENTER
    Variables: x ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.dsin(double;)double:::EXIT
    Variables: x ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(x) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable x
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result <= 1.0
daikon.Quant.fuzzy.ne(x, \result)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
daikon.Quant.fuzzy.ne(\result, \old(x))
===========================================================================
std.elemdef(charac *;charac **;Elem **;)int:::ENTER
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
elem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.elemdef(charac *;charac **;Elem **;)int:::EXIT81
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 1
===========================================================================
std.elemdef(charac *;charac **;Elem **;)int:::EXIT83
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.elemdef(charac *;charac **;Elem **;)int:::EXIT84
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.elemdef(charac *;charac **;Elem **;)int:::EXIT
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
elem_ptr == \old(elem_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
elem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.emsginit()void:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.emsginit()void:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.extremes(Geomnode *;int *;int *;)int:::ENTER
    Variables: pnum_ptr pnum_ptr[] qnum_ptr qnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(pnum_ptr[]) size(pnum_ptr[])-1 size(qnum_ptr[]) size(qnum_ptr[])-1
pnum_ptr != null
qnum_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.extremes(Geomnode *;int *;int *;)int:::EXIT
    Variables: pnum_ptr pnum_ptr[] qnum_ptr qnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pnum_ptr) orig(pnum_ptr[]) orig(qnum_ptr) orig(qnum_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pnum_ptr[]) size(pnum_ptr[])-1 size(qnum_ptr[]) size(qnum_ptr[])-1 orig(size(pnum_ptr[])) orig(size(pnum_ptr[]))-1 orig(size(qnum_ptr[])) orig(size(qnum_ptr[]))-1
assignable pnum_ptr[*], qnum_ptr[*]
pnum_ptr == \old(pnum_ptr)
qnum_ptr == \old(qnum_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pnum_ptr != null
daikon.Quant.eltsGTE(pnum_ptr, 1)
qnum_ptr != null
daikon.Quant.eltsGTE(qnum_ptr, 1)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(pnum_ptr) == 1
daikon.Quant.size(qnum_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.extsize(Geomnode *;double;double;double *;double *;)int:::ENTER
    Variables: elem_pdim elem_qdim xsize_ptr xsize_ptr[] ysize_ptr ysize_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(xsize_ptr[]) size(xsize_ptr[])-1 size(ysize_ptr[]) size(ysize_ptr[])-1
xsize_ptr != null
ysize_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.extsize(Geomnode *;double;double;double *;double *;)int:::EXIT
    Variables: elem_pdim elem_qdim xsize_ptr xsize_ptr[] ysize_ptr ysize_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(elem_pdim) orig(elem_qdim) orig(xsize_ptr) orig(xsize_ptr[]) orig(ysize_ptr) orig(ysize_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(xsize_ptr[]) size(xsize_ptr[])-1 size(ysize_ptr[]) size(ysize_ptr[])-1 orig(size(xsize_ptr[])) orig(size(xsize_ptr[]))-1 orig(size(ysize_ptr[])) orig(size(ysize_ptr[]))-1
assignable xsize_ptr[*], ysize_ptr[*]
daikon.Quant.fuzzy.eq(elem_pdim, \old(elem_pdim))
daikon.Quant.fuzzy.eq(elem_qdim, \old(elem_qdim))
xsize_ptr == \old(xsize_ptr)
ysize_ptr == \old(ysize_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
xsize_ptr != null
ysize_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(xsize_ptr) == 1
daikon.Quant.size(ysize_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.fixgramp(GrAmpExc *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.fixgramp(GrAmpExc *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.fixgrpha(GrPhaExc *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.fixgrpha(GrPhaExc *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.fixnodor(Node *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.fixnodor(Node *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.fixport(Elem *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.fixport(Elem *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.fixselem(Elem *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.fixselem(Elem *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.fixsgrel(Group *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.fixsgrel(Group *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.fixsgrid(Grid *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.fixsgrid(Grid *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.floatsup()void:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.floatsup()void:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.geomspec(charac *;charac **;int *;double *;int *;double *;double *;int *;)int:::ENTER
    Variables: pp2 geometry_ptr geometry_ptr[] radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(geometry_ptr[]) size(geometry_ptr[])-1 size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1
pp2 != null
geometry_ptr != null
radius_ptr != null
radius_unit_ptr != null
pdim_ptr != null
qdim_ptr != null
pqdim_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.geomspec(charac *;charac **;int *;double *;int *;double *;double *;int *;)int:::EXIT114
    Variables: pp2 geometry_ptr geometry_ptr[] radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(geometry_ptr) orig(geometry_ptr[]) orig(radius_ptr) orig(radius_ptr[]) orig(radius_unit_ptr) orig(radius_unit_ptr[]) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(geometry_ptr[]) size(geometry_ptr[])-1 size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(geometry_ptr[])) orig(size(geometry_ptr[]))-1 orig(size(radius_ptr[])) orig(size(radius_ptr[]))-1 orig(size(radius_unit_ptr[])) orig(size(radius_unit_ptr[]))-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable geometry_ptr[*], radius_ptr[*], radius_unit_ptr[*], pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(geometry_ptr, 0)
daikon.Quant.subsetOf(pqdim_unit_ptr, new long[] { 0, 1, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
===========================================================================
std.geomspec(charac *;charac **;int *;double *;int *;double *;double *;int *;)int:::EXIT115
    Variables: pp2 geometry_ptr geometry_ptr[] radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(geometry_ptr) orig(geometry_ptr[]) orig(radius_ptr) orig(radius_ptr[]) orig(radius_unit_ptr) orig(radius_unit_ptr[]) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(geometry_ptr[]) size(geometry_ptr[])-1 size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(geometry_ptr[])) orig(size(geometry_ptr[]))-1 orig(size(radius_ptr[])) orig(size(radius_ptr[]))-1 orig(size(radius_unit_ptr[])) orig(size(radius_unit_ptr[]))-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable geometry_ptr[*], radius_ptr[*], radius_unit_ptr[*], pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(geometry_ptr, 0)
\result == 17
===========================================================================
std.geomspec(charac *;charac **;int *;double *;int *;double *;double *;int *;)int:::EXIT116
    Variables: pp2 geometry_ptr geometry_ptr[] radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(geometry_ptr) orig(geometry_ptr[]) orig(radius_ptr) orig(radius_ptr[]) orig(radius_unit_ptr) orig(radius_unit_ptr[]) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(geometry_ptr[]) size(geometry_ptr[])-1 size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(geometry_ptr[])) orig(size(geometry_ptr[]))-1 orig(size(radius_ptr[])) orig(size(radius_ptr[]))-1 orig(size(radius_unit_ptr[])) orig(size(radius_unit_ptr[]))-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable geometry_ptr[*], radius_ptr[*], radius_unit_ptr[*], pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(geometry_ptr, 1)
daikon.Quant.eltsGTE(radius_unit_ptr, 0)
\result == 0
===========================================================================
std.geomspec(charac *;charac **;int *;double *;int *;double *;double *;int *;)int:::EXIT118
    Variables: pp2 geometry_ptr geometry_ptr[] radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(geometry_ptr) orig(geometry_ptr[]) orig(radius_ptr) orig(radius_ptr[]) orig(radius_unit_ptr) orig(radius_unit_ptr[]) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(geometry_ptr[]) size(geometry_ptr[])-1 size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(geometry_ptr[])) orig(size(geometry_ptr[]))-1 orig(size(radius_ptr[])) orig(size(radius_ptr[]))-1 orig(size(radius_unit_ptr[])) orig(size(radius_unit_ptr[]))-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable geometry_ptr[*], radius_ptr[*], radius_unit_ptr[*], pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(geometry_ptr, 1)
::GLOBLE_FILENAME.equals("inputs/gr150") || ::GLOBLE_FILENAME.equals("inputs/gr2") || ::GLOBLE_FILENAME.equals("inputs/gr54")
\result == 17
===========================================================================
std.geomspec(charac *;charac **;int *;double *;int *;double *;double *;int *;)int:::EXIT
    Variables: pp2 geometry_ptr geometry_ptr[] radius_ptr radius_ptr[] radius_unit_ptr radius_unit_ptr[] pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(geometry_ptr) orig(geometry_ptr[]) orig(radius_ptr) orig(radius_ptr[]) orig(radius_unit_ptr) orig(radius_unit_ptr[]) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(geometry_ptr[]) size(geometry_ptr[])-1 size(radius_ptr[]) size(radius_ptr[])-1 size(radius_unit_ptr[]) size(radius_unit_ptr[])-1 size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(geometry_ptr[])) orig(size(geometry_ptr[]))-1 orig(size(radius_ptr[])) orig(size(radius_ptr[]))-1 orig(size(radius_unit_ptr[])) orig(size(radius_unit_ptr[]))-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable geometry_ptr[*], radius_ptr[*], radius_unit_ptr[*], pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
pp2 == \old(pp2)
geometry_ptr == \old(geometry_ptr)
radius_ptr == \old(radius_ptr)
radius_unit_ptr == \old(radius_unit_ptr)
pdim_ptr == \old(pdim_ptr)
qdim_ptr == \old(qdim_ptr)
pqdim_unit_ptr == \old(pqdim_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
geometry_ptr != null
daikon.Quant.subsetOf(geometry_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
radius_ptr != null
radius_unit_ptr != null
(radius_unit_ptr != null)  ==>  (daikon.Quant.eltsGTE(radius_unit_ptr, 0))
pdim_ptr != null
qdim_ptr != null
pqdim_unit_ptr != null
(pqdim_unit_ptr != null)  ==>  (daikon.Quant.subsetOf(pqdim_unit_ptr, new long[] { 0, 1, 2 }))
(pqdim_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 17
daikon.Quant.size(geometry_ptr) == 1
daikon.Quant.size(radius_ptr) == 1
daikon.Quant.size(radius_unit_ptr) == 1
daikon.Quant.size(pdim_ptr) == 1
daikon.Quant.size(qdim_ptr) == 1
daikon.Quant.size(pqdim_unit_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.glvainit()void:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.glvainit()void:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.gnodevis(int;int;double;double;Geomnode *;)void:::ENTER
    Variables: p q angle phase ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
daikon.Quant.fuzzy.eq(angle, phase)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.gnodevis(int;int;double;double;Geomnode *;)void:::EXIT
    Variables: p q angle phase ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(p) orig(q) orig(angle) orig(phase) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
p == \old(p)
q == \old(q)
daikon.Quant.fuzzy.eq(angle, phase)
daikon.Quant.fuzzy.eq(angle, \old(angle))
daikon.Quant.fuzzy.eq(angle, \old(phase))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.gnodfind(Geomnode *;Geomnode **;int;int;)int:::ENTER
    Variables: gnode_ptr p q ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
gnode_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.gnodfind(Geomnode *;Geomnode **;int;int;)int:::EXIT143
    Variables: gnode_ptr p q ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(gnode_ptr) orig(p) orig(q) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
===========================================================================
std.gnodfind(Geomnode *;Geomnode **;int;int;)int:::EXIT
    Variables: gnode_ptr p q ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(gnode_ptr) orig(p) orig(q) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
gnode_ptr == \old(gnode_ptr)
p == \old(p)
q == \old(q)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
gnode_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.grampexc(charac *;charac **;GrAmpExc **;)int:::ENTER
    Variables: pp2 grampexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
grampexc_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.grampexc(charac *;charac **;GrAmpExc **;)int:::EXIT145
    Variables: pp2 grampexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grampexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.grampexc(charac *;charac **;GrAmpExc **;)int:::EXIT147
    Variables: pp2 grampexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grampexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.grampexc(charac *;charac **;GrAmpExc **;)int:::EXIT148
    Variables: pp2 grampexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grampexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME.equals("inputs/gr127") || ::GLOBLE_FILENAME.equals("inputs/gr143") || ::GLOBLE_FILENAME.equals("inputs/gr27")
\result == 17
===========================================================================
std.grampexc(charac *;charac **;GrAmpExc **;)int:::EXIT
    Variables: pp2 grampexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grampexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
grampexc_ptr == \old(grampexc_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
grampexc_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.greldef(charac *;charac **;Grid **;Elem **;)int:::ENTER
    Variables: pp2 grid_ptr elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
grid_ptr != null
elem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.greldef(charac *;charac **;Grid **;Elem **;)int:::EXIT150
    Variables: pp2 grid_ptr elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grid_ptr) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 != null
grid_ptr != null
elem_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr29")
\result == 17
===========================================================================
std.greldef(charac *;charac **;Grid **;Elem **;)int:::EXIT151
    Variables: pp2 grid_ptr elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grid_ptr) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 1
===========================================================================
std.greldef(charac *;charac **;Grid **;Elem **;)int:::EXIT152
    Variables: pp2 grid_ptr elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grid_ptr) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.greldef(charac *;charac **;Grid **;Elem **;)int:::EXIT153
    Variables: pp2 grid_ptr elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grid_ptr) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.greldef(charac *;charac **;Grid **;Elem **;)int:::EXIT
    Variables: pp2 grid_ptr elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grid_ptr) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
grid_ptr == \old(grid_ptr)
elem_ptr == \old(elem_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
grid_ptr != null
elem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.grexcdef(charac *;charac **;GrAmpExc **;GrPhaExc **;)int:::ENTER
    Variables: pp2 grampexc_ptr grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
grampexc_ptr != null
grphaexc_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.grexcdef(charac *;charac **;GrAmpExc **;GrPhaExc **;)int:::EXIT155
    Variables: pp2 grampexc_ptr grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grampexc_ptr) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME.equals("inputs/gr127") || ::GLOBLE_FILENAME.equals("inputs/gr143") || ::GLOBLE_FILENAME.equals("inputs/gr27")
\result == 17
===========================================================================
std.grexcdef(charac *;charac **;GrAmpExc **;GrPhaExc **;)int:::EXIT156
    Variables: pp2 grampexc_ptr grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grampexc_ptr) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.grexcdef(charac *;charac **;GrAmpExc **;GrPhaExc **;)int:::EXIT157
    Variables: pp2 grampexc_ptr grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grampexc_ptr) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.grexcdef(charac *;charac **;GrAmpExc **;GrPhaExc **;)int:::EXIT
    Variables: pp2 grampexc_ptr grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grampexc_ptr) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
grampexc_ptr == \old(grampexc_ptr)
grphaexc_ptr == \old(grphaexc_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
grampexc_ptr != null
grphaexc_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.grgeodef(charac *;charac **;AddRem **;)int:::ENTER
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.grgeodef(charac *;charac **;AddRem **;)int:::EXIT158
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.grgeodef(charac *;charac **;AddRem **;)int:::EXIT159
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr42")
\result == 17
===========================================================================
std.grgeodef(charac *;charac **;AddRem **;)int:::EXIT160
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.grgeodef(charac *;charac **;AddRem **;)int:::EXIT161
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr114")
\result == 17
===========================================================================
std.grgeodef(charac *;charac **;AddRem **;)int:::EXIT
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
addrem_ptr == \old(addrem_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.griddef1(charac *;charac **;Grid **;)int:::ENTER
    Variables: pp2 grid_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
grid_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.griddef1(charac *;charac **;Grid **;)int:::EXIT167
    Variables: pp2 grid_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grid_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 != null
grid_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr29")
\result == 17
===========================================================================
std.griddef1(charac *;charac **;Grid **;)int:::EXIT168
    Variables: pp2 grid_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grid_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.griddef1(charac *;charac **;Grid **;)int:::EXIT
    Variables: pp2 grid_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grid_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
grid_ptr == \old(grid_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
grid_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.groupdef(charac *;charac **;Group **;)int:::ENTER
    Variables: pp2 group_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
group_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.groupdef(charac *;charac **;Group **;)int:::EXIT172
    Variables: pp2 group_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(group_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.groupdef(charac *;charac **;Group **;)int:::EXIT173
    Variables: pp2 group_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(group_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.groupdef(charac *;charac **;Group **;)int:::EXIT174
    Variables: pp2 group_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(group_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.groupdef(charac *;charac **;Group **;)int:::EXIT176
    Variables: pp2 group_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(group_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.groupdef(charac *;charac **;Group **;)int:::EXIT
    Variables: pp2 group_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(group_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
group_ptr == \old(group_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
group_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.grphaexc(charac *;charac **;GrPhaExc **;)int:::ENTER
    Variables: pp2 grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
grphaexc_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.grphaexc(charac *;charac **;GrPhaExc **;)int:::EXIT177
    Variables: pp2 grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 1
===========================================================================
std.grphaexc(charac *;charac **;GrPhaExc **;)int:::EXIT178
    Variables: pp2 grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.grphaexc(charac *;charac **;GrPhaExc **;)int:::EXIT180
    Variables: pp2 grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.grphaexc(charac *;charac **;GrPhaExc **;)int:::EXIT182
    Variables: pp2 grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.grphaexc(charac *;charac **;GrPhaExc **;)int:::EXIT183
    Variables: pp2 grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME.equals("inputs/gr192") || ::GLOBLE_FILENAME.equals("inputs/gr82")
\result == 17
===========================================================================
std.grphaexc(charac *;charac **;GrPhaExc **;)int:::EXIT184
    Variables: pp2 grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.grphaexc(charac *;charac **;GrPhaExc **;)int:::EXIT
    Variables: pp2 grphaexc_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(grphaexc_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
grphaexc_ptr == \old(grphaexc_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
grphaexc_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.grwrite(Group *;char *;)int:::ENTER
    Variables: filename filename[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
filename != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: filename[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.grwrite(Group *;char *;)int:::EXIT
    Variables: filename filename[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(filename) orig(filename[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
filename == \old(filename)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
filename != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: filename[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
filename.equals(\old(filename))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.hexdef(charac *;charac **;Node **;)int:::ENTER
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
node_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.hexdef(charac *;charac **;Node **;)int:::EXIT187
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME.equals("inputs/gr114") || ::GLOBLE_FILENAME.equals("inputs/gr42")
\result == 1
===========================================================================
std.hexdef(charac *;charac **;Node **;)int:::EXIT190
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.hexdef(charac *;charac **;Node **;)int:::EXIT
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
node_ptr == \old(node_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
node_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.hexgrdef(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1
pp2 != null
pstep_ptr != null
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
pstep_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pstep_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(pstep_unit_ptr) == 1
===========================================================================
std.hexgrdef(charac *;charac **;double *;int *;)int:::EXIT191
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(pstep_unit_ptr) orig(pstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(pstep_unit_ptr[])) orig(size(pstep_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseEqual(pstep_unit_ptr, \old(pstep_unit_ptr))
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pstep_unit_ptr, 0)
\result == 1
===========================================================================
std.hexgrdef(charac *;charac **;double *;int *;)int:::EXIT192
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(pstep_unit_ptr) orig(pstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(pstep_unit_ptr[])) orig(size(pstep_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseEqual(pstep_unit_ptr, \old(pstep_unit_ptr))
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pstep_unit_ptr, 0)
\result == 0
===========================================================================
std.hexgrdef(charac *;charac **;double *;int *;)int:::EXIT194
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(pstep_unit_ptr) orig(pstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(pstep_unit_ptr[])) orig(size(pstep_unit_ptr[]))-1
assignable pstep_ptr[*], pstep_unit_ptr[*]
\result == 0
daikon.Quant.pairwiseGT(pstep_ptr, \old(pstep_ptr))
===========================================================================
std.hexgrdef(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(pstep_unit_ptr) orig(pstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(pstep_unit_ptr[])) orig(size(pstep_unit_ptr[]))-1
assignable pstep_ptr[*], pstep_unit_ptr[*]
pp2 == \old(pp2)
pstep_ptr == \old(pstep_ptr)
pstep_unit_ptr == \old(pstep_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(pstep_ptr) == \old(daikon.Quant.size(pstep_ptr))
daikon.Quant.size(pstep_unit_ptr) == \old(daikon.Quant.size(pstep_unit_ptr))
pp2 != null
pstep_ptr != null
daikon.Quant.eltsGTE(pstep_ptr, 0.0)
pstep_unit_ptr != null
daikon.Quant.subsetOf(pstep_unit_ptr, new long[] { 0, 1, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(pstep_unit_ptr) == 1
daikon.Quant.pairwiseGTE(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseGTE(pstep_unit_ptr, \old(pstep_unit_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.intmax(int;int;)int:::ENTER
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.intmax(int;int;)int:::EXIT200
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
a == \result
a > b
===========================================================================
std.intmax(int;int;)int:::EXIT201
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
b == \result
a <= b
===========================================================================
std.intmax(int;int;)int:::EXIT
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
a == \old(a)
b == \old(b)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(a <= b)  <==>  (b == \result)
(a > b)  <==>  (b < \result)
(a > b)  ==>  (a == \result)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
a <= \result
b <= \result
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
\result == (java.lang.Math.max(a, b))
===========================================================================
std.intmin(int;int;)int:::ENTER
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.intmin(int;int;)int:::EXIT202
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
a == \result
a < b
===========================================================================
std.intmin(int;int;)int:::EXIT203
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
b == \result
a >= b
===========================================================================
std.intmin(int;int;)int:::EXIT
    Variables: a b ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
a == \old(a)
b == \old(b)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(a < b)  <==>  (b > \result)
(a < b)  ==>  (a == \result)
(a >= b)  <==>  (b == \result)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
a >= \result
b >= \result
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
\result == (java.lang.Math.min(a, b))
===========================================================================
std.isletter(char;)int:::ENTER
    Variables: ch ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.isletter(char;)int:::EXIT206
    Variables: ch ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(ch) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 1
===========================================================================
std.isletter(char;)int:::EXIT207
    Variables: ch ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(ch) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
ch == 32
\result == 0
===========================================================================
std.isletter(char;)int:::EXIT
    Variables: ch ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(ch) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
ch == \old(ch)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(ch == 32)  <==>  (\result == 0)
(ch == 32)  ==>  (\result  isPointer)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.kwdsinit()void:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.kwdsinit()void:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.lenunit(charac **;int *;)int:::ENTER
    Variables: tp unit unit[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(unit[]) size(unit[])-1
tp != null
unit != null
(unit != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(unit != null)  ==>  (daikon.Quant.eltsEqual(unit, 0))
(unit != null)  ==>  (warning: method daikon.inv.unary.sequence.CommonSequence.format(OutputFormat:JML) needs to be implemented: {0} subset of unit[])
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(unit != null)  ==>  (daikon.Quant.size(unit) == 1)
===========================================================================
std.lenunit(charac **;int *;)int:::EXIT209
    Variables: tp unit unit[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(tp) orig(unit) orig(unit[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unit[]) size(unit[])-1 orig(size(unit[])) orig(size(unit[]))-1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(unit, 0)
\result == 14
\old(daikon.Quant.size(unit)) == 1
(\old(unit) != null)  ==>  (daikon.Quant.pairwiseEqual(unit, \old(unit)))
(\old(unit) != null)  ==>  (daikon.Quant.isReverse(unit, \old(unit)))
===========================================================================
std.lenunit(charac **;int *;)int:::EXIT210
    Variables: tp unit unit[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(tp) orig(unit) orig(unit[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unit[]) size(unit[])-1 orig(size(unit[])) orig(size(unit[]))-1
assignable unit[*]
daikon.Quant.size(unit) == \old(daikon.Quant.size(unit))
\result == 0
\old(daikon.Quant.size(unit)) == 1
===========================================================================
std.lenunit(charac **;int *;)int:::EXIT
    Variables: tp unit unit[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(tp) orig(unit) orig(unit[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unit[]) size(unit[])-1 orig(size(unit[])) orig(size(unit[]))-1
assignable unit[*]
tp == \old(tp)
unit == \old(unit)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\old(unit) != null)  ==>  (daikon.Quant.size(unit) == \old(daikon.Quant.size(unit)))
(\result == 0)  ==>  (\result  isPointer)
(\result == 14)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == 14)  ==>  (daikon.Quant.pairwiseEqual(unit, \old(unit)))
(\result == 14)  ==>  (daikon.Quant.eltsEqual(unit, 0))
(\result == 14)  ==>  (daikon.Quant.isReverse(unit, \old(unit)))
tp != null
unit != null
daikon.Quant.eltsGTE(unit, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 14
daikon.Quant.size(unit) == 1
(\old(unit) != null)  ==>  (daikon.Quant.pairwiseGTE(unit, \old(unit)))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.linconv(double *;int;)int:::ENTER
    Variables: x_ptr x_ptr[] unit ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(x_ptr[]) size(x_ptr[])-1
x_ptr != null
unit == 0 || unit == 2
unit % 2 == 0
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.linconv(double *;int;)int:::EXIT
    Variables: x_ptr x_ptr[] unit ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(x_ptr) orig(x_ptr[]) orig(unit) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(x_ptr[]) size(x_ptr[])-1 orig(size(x_ptr[])) orig(size(x_ptr[]))-1
assignable x_ptr[*]
x_ptr == \old(x_ptr)
unit == \old(unit)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
x_ptr != null
(x_ptr != null)  ==>  (daikon.Quant.pairwiseEqual(x_ptr, new double[] { 1.12202 }))
(x_ptr != null)  ==>  (daikon.Quant.eltsEqual(x_ptr, 1.12202))
unit == 0 || unit == 2
unit % 2 == 0
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
(x_ptr != null)  ==>  (daikon.Quant.size(x_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.linpol(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
pp2 != null
angle_ptr != null
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(angle_ptr, 90.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
===========================================================================
std.linpol(charac *;charac **;double *;int *;)int:::EXIT212
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(angle_ptr, \old(angle_ptr))
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(angle_ptr, 90.0)
\result == 1
===========================================================================
std.linpol(charac *;charac **;double *;int *;)int:::EXIT213
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(angle_ptr, \old(angle_ptr))
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(angle_ptr, 90.0)
\result == 0
===========================================================================
std.linpol(charac *;charac **;double *;int *;)int:::EXIT215
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
\result == 0
===========================================================================
std.linpol(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
pp2 == \old(pp2)
angle_ptr == \old(angle_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
daikon.Quant.pairwiseEqual(angle_unit_ptr, \old(angle_unit_ptr))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(angle_ptr) == \old(daikon.Quant.size(angle_ptr))
pp2 != null
angle_ptr != null
daikon.Quant.eltsGTE(angle_ptr, 0.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
daikon.Quant.pairwiseLTE(angle_ptr, \old(angle_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.main(int;char **;)int:::ENTER
    Variables: argc argv ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
argc == 2
argv != null
::GLOBLE_FILENAME != null
===========================================================================
std.main(int;char **;)int:::EXIT
    Variables: argc argv ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(argc) orig(argv) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable ::GLOBLE_FILENAME[*]
argc == \old(argc)
argv == \old(argv)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
argc == 2
argv != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
===========================================================================
std.mksblock(AddRem *;Geomnode **;Geomnode **;double;double;double;int *;int;double;double;)int:::ENTER
    Variables: first_node_ptr last_node_ptr pstep qstep angle nodes_num_ptr nodes_num_ptr[] elem_shape elem_pdim elem_qdim ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(nodes_num_ptr[]) size(nodes_num_ptr[])-1
first_node_ptr != null
last_node_ptr != null
nodes_num_ptr != null
(nodes_num_ptr != null)  ==>  (daikon.Quant.eltsGTE(nodes_num_ptr, 1))
elem_shape == 2 || elem_shape == 3
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(nodes_num_ptr != null)  ==>  (daikon.Quant.size(nodes_num_ptr) == 1)
===========================================================================
std.mksblock(AddRem *;Geomnode **;Geomnode **;double;double;double;int *;int;double;double;)int:::EXIT
    Variables: first_node_ptr last_node_ptr pstep qstep angle nodes_num_ptr nodes_num_ptr[] elem_shape elem_pdim elem_qdim ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(first_node_ptr) orig(last_node_ptr) orig(pstep) orig(qstep) orig(angle) orig(nodes_num_ptr) orig(nodes_num_ptr[]) orig(elem_shape) orig(elem_pdim) orig(elem_qdim) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(nodes_num_ptr[]) size(nodes_num_ptr[])-1 orig(size(nodes_num_ptr[])) orig(size(nodes_num_ptr[]))-1
assignable angle, nodes_num_ptr[*]
first_node_ptr == \old(first_node_ptr)
last_node_ptr == \old(last_node_ptr)
daikon.Quant.fuzzy.eq(pstep, \old(pstep))
daikon.Quant.fuzzy.eq(qstep, \old(qstep))
nodes_num_ptr == \old(nodes_num_ptr)
elem_shape == \old(elem_shape)
daikon.Quant.fuzzy.eq(elem_pdim, \old(elem_pdim))
daikon.Quant.fuzzy.eq(elem_qdim, \old(elem_qdim))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\old(nodes_num_ptr) != null)  ==>  (daikon.Quant.size(nodes_num_ptr) == \old(daikon.Quant.size(nodes_num_ptr)))
first_node_ptr != null
last_node_ptr != null
nodes_num_ptr != null
daikon.Quant.eltsGTE(nodes_num_ptr, 1)
elem_shape == 2 || elem_shape == 3
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(nodes_num_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.mkshex(AddRem *;Geomnode **;Geomnode **;double;double;double;int *;int;double;double;)int:::ENTER
    Variables: first_node_ptr last_node_ptr pstep qstep angle nodes_num_ptr nodes_num_ptr[] elem_shape elem_pdim elem_qdim ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(nodes_num_ptr[]) size(nodes_num_ptr[])-1
daikon.Quant.fuzzy.eq(elem_pdim, elem_qdim)
first_node_ptr != null
last_node_ptr != null
nodes_num_ptr != null
(nodes_num_ptr != null)  ==>  (daikon.Quant.eltsGTE(nodes_num_ptr, 1))
elem_shape == 2
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(nodes_num_ptr != null)  ==>  (daikon.Quant.size(nodes_num_ptr) == 1)
===========================================================================
std.mkshex(AddRem *;Geomnode **;Geomnode **;double;double;double;int *;int;double;double;)int:::EXIT
    Variables: first_node_ptr last_node_ptr pstep qstep angle nodes_num_ptr nodes_num_ptr[] elem_shape elem_pdim elem_qdim ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(first_node_ptr) orig(last_node_ptr) orig(pstep) orig(qstep) orig(angle) orig(nodes_num_ptr) orig(nodes_num_ptr[]) orig(elem_shape) orig(elem_pdim) orig(elem_qdim) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(nodes_num_ptr[]) size(nodes_num_ptr[])-1 orig(size(nodes_num_ptr[])) orig(size(nodes_num_ptr[]))-1
assignable angle, nodes_num_ptr[*]
first_node_ptr == \old(first_node_ptr)
last_node_ptr == \old(last_node_ptr)
daikon.Quant.fuzzy.eq(pstep, \old(pstep))
daikon.Quant.fuzzy.eq(qstep, \old(qstep))
nodes_num_ptr == \old(nodes_num_ptr)
elem_shape == \old(elem_shape)
daikon.Quant.fuzzy.eq(elem_pdim, elem_qdim)
daikon.Quant.fuzzy.eq(elem_pdim, \old(elem_pdim))
daikon.Quant.fuzzy.eq(elem_pdim, \old(elem_qdim))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\old(nodes_num_ptr) != null)  ==>  (daikon.Quant.size(nodes_num_ptr) == \old(daikon.Quant.size(nodes_num_ptr)))
first_node_ptr != null
last_node_ptr != null
nodes_num_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(nodes_num_ptr, 7)
elem_shape == 2
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(nodes_num_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.mksnode(AddRem *;Geomnode **;Geomnode **;double;double;double;int *;int;double;double;)int:::ENTER
    Variables: first_node_ptr last_node_ptr pstep qstep angle nodes_num_ptr nodes_num_ptr[] elem_shape elem_pdim elem_qdim ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(nodes_num_ptr[]) size(nodes_num_ptr[])-1
first_node_ptr != null
last_node_ptr != null
nodes_num_ptr != null
(nodes_num_ptr != null)  ==>  (daikon.Quant.eltsGTE(nodes_num_ptr, 1))
elem_shape == 2 || elem_shape == 3
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(nodes_num_ptr != null)  ==>  (daikon.Quant.size(nodes_num_ptr) == 1)
===========================================================================
std.mksnode(AddRem *;Geomnode **;Geomnode **;double;double;double;int *;int;double;double;)int:::EXIT
    Variables: first_node_ptr last_node_ptr pstep qstep angle nodes_num_ptr nodes_num_ptr[] elem_shape elem_pdim elem_qdim ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(first_node_ptr) orig(last_node_ptr) orig(pstep) orig(qstep) orig(angle) orig(nodes_num_ptr) orig(nodes_num_ptr[]) orig(elem_shape) orig(elem_pdim) orig(elem_qdim) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(nodes_num_ptr[]) size(nodes_num_ptr[])-1 orig(size(nodes_num_ptr[])) orig(size(nodes_num_ptr[]))-1
assignable angle, nodes_num_ptr[*]
first_node_ptr == \old(first_node_ptr)
last_node_ptr == \old(last_node_ptr)
daikon.Quant.fuzzy.eq(pstep, \old(pstep))
daikon.Quant.fuzzy.eq(qstep, \old(qstep))
nodes_num_ptr == \old(nodes_num_ptr)
elem_shape == \old(elem_shape)
daikon.Quant.fuzzy.eq(elem_pdim, \old(elem_pdim))
daikon.Quant.fuzzy.eq(elem_qdim, \old(elem_qdim))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\old(nodes_num_ptr) != null)  ==>  (daikon.Quant.size(nodes_num_ptr) == \old(daikon.Quant.size(nodes_num_ptr)))
first_node_ptr != null
last_node_ptr != null
nodes_num_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(nodes_num_ptr, 1)
elem_shape == 2 || elem_shape == 3
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(nodes_num_ptr) == 1
(\old(nodes_num_ptr) != null)  ==>  (daikon.Quant.pairwiseLTE(nodes_num_ptr, \old(nodes_num_ptr)))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.mmconv(double *;int;)int:::ENTER
    Variables: x_ptr x_ptr[] unit ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(x_ptr[]) size(x_ptr[])-1
x_ptr != null
unit >= 0
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.mmconv(double *;int;)int:::EXIT
    Variables: x_ptr x_ptr[] unit ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(x_ptr) orig(x_ptr[]) orig(unit) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(x_ptr[]) size(x_ptr[])-1 orig(size(x_ptr[])) orig(size(x_ptr[]))-1
assignable x_ptr[*]
x_ptr == \old(x_ptr)
unit == \old(unit)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
x_ptr != null
unit >= 0
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
(x_ptr != null)  ==>  (daikon.Quant.size(x_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.moseinit()void:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.moseinit()void:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.nodecoor(charac *;charac **;int *;int *;)int:::ENTER
    Variables: pp2 pcoord_ptr pcoord_ptr[] qcoord_ptr qcoord_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(pcoord_ptr[]) size(pcoord_ptr[])-1 size(qcoord_ptr[]) size(qcoord_ptr[])-1
pp2 != null
pcoord_ptr != null
qcoord_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(pcoord_ptr != null)  ==>  (daikon.Quant.size(pcoord_ptr) == 1)
(qcoord_ptr != null)  ==>  (daikon.Quant.size(qcoord_ptr) == 1)
===========================================================================
std.nodecoor(charac *;charac **;int *;int *;)int:::EXIT231
    Variables: pp2 pcoord_ptr pcoord_ptr[] qcoord_ptr qcoord_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pcoord_ptr) orig(pcoord_ptr[]) orig(qcoord_ptr) orig(qcoord_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pcoord_ptr[]) size(pcoord_ptr[])-1 size(qcoord_ptr[]) size(qcoord_ptr[])-1 orig(size(pcoord_ptr[])) orig(size(pcoord_ptr[]))-1 orig(size(qcoord_ptr[])) orig(size(qcoord_ptr[]))-1
assignable pcoord_ptr[*], qcoord_ptr[*]
daikon.Quant.size(pcoord_ptr) == \old(daikon.Quant.size(pcoord_ptr))
daikon.Quant.size(qcoord_ptr) == \old(daikon.Quant.size(qcoord_ptr))
\old(daikon.Quant.size(pcoord_ptr)) == 1
\old(daikon.Quant.size(qcoord_ptr)) == 1
===========================================================================
std.nodecoor(charac *;charac **;int *;int *;)int:::EXIT
    Variables: pp2 pcoord_ptr pcoord_ptr[] qcoord_ptr qcoord_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pcoord_ptr) orig(pcoord_ptr[]) orig(qcoord_ptr) orig(qcoord_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pcoord_ptr[]) size(pcoord_ptr[])-1 size(qcoord_ptr[]) size(qcoord_ptr[])-1 orig(size(pcoord_ptr[])) orig(size(pcoord_ptr[]))-1 orig(size(qcoord_ptr[])) orig(size(qcoord_ptr[]))-1
assignable pcoord_ptr[*], qcoord_ptr[*]
pp2 == \old(pp2)
pcoord_ptr == \old(pcoord_ptr)
qcoord_ptr == \old(qcoord_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\old(pcoord_ptr) != null)  ==>  (daikon.Quant.size(pcoord_ptr) == \old(daikon.Quant.size(pcoord_ptr)))
(\old(qcoord_ptr) != null)  ==>  (daikon.Quant.size(qcoord_ptr) == \old(daikon.Quant.size(qcoord_ptr)))
pp2 != null
pcoord_ptr != null
qcoord_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(pcoord_ptr) == 1
daikon.Quant.size(qcoord_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.nodedef(charac *;charac **;Node **;)int:::ENTER
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
node_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.nodedef(charac *;charac **;Node **;)int:::EXIT232
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 1
===========================================================================
std.nodedef(charac *;charac **;Node **;)int:::EXIT236
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.nodedef(charac *;charac **;Node **;)int:::EXIT
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
node_ptr == \old(node_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
node_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.nodorien(charac *;charac **;double *;double *;double *;int *;)int:::ENTER
    Variables: pp2 theta_ptr theta_ptr[] phi_ptr phi_ptr[] psi_ptr psi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(psi_ptr[]) size(psi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
pp2 != null
theta_ptr != null
phi_ptr != null
psi_ptr != null
angle_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.nodorien(charac *;charac **;double *;double *;double *;int *;)int:::EXIT237
    Variables: pp2 theta_ptr theta_ptr[] phi_ptr phi_ptr[] psi_ptr psi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(theta_ptr) orig(theta_ptr[]) orig(phi_ptr) orig(phi_ptr[]) orig(psi_ptr) orig(psi_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(psi_ptr[]) size(psi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(theta_ptr[])) orig(size(theta_ptr[]))-1 orig(size(phi_ptr[])) orig(size(phi_ptr[]))-1 orig(size(psi_ptr[])) orig(size(psi_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable theta_ptr[*], phi_ptr[*], psi_ptr[*], angle_unit_ptr[*]
\result == 1
===========================================================================
std.nodorien(charac *;charac **;double *;double *;double *;int *;)int:::EXIT241
    Variables: pp2 theta_ptr theta_ptr[] phi_ptr phi_ptr[] psi_ptr psi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(theta_ptr) orig(theta_ptr[]) orig(phi_ptr) orig(phi_ptr[]) orig(psi_ptr) orig(psi_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(psi_ptr[]) size(psi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(theta_ptr[])) orig(size(theta_ptr[]))-1 orig(size(phi_ptr[])) orig(size(phi_ptr[]))-1 orig(size(psi_ptr[])) orig(size(psi_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable theta_ptr[*], phi_ptr[*], psi_ptr[*], angle_unit_ptr[*]
daikon.Quant.subsetOf(angle_unit_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
daikon.Quant.size(theta_ptr) == 1
daikon.Quant.size(phi_ptr) == 1
daikon.Quant.size(psi_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
===========================================================================
std.nodorien(charac *;charac **;double *;double *;double *;int *;)int:::EXIT
    Variables: pp2 theta_ptr theta_ptr[] phi_ptr phi_ptr[] psi_ptr psi_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(theta_ptr) orig(theta_ptr[]) orig(phi_ptr) orig(phi_ptr[]) orig(psi_ptr) orig(psi_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(theta_ptr[]) size(theta_ptr[])-1 size(phi_ptr[]) size(phi_ptr[])-1 size(psi_ptr[]) size(psi_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(theta_ptr[])) orig(size(theta_ptr[]))-1 orig(size(phi_ptr[])) orig(size(phi_ptr[]))-1 orig(size(psi_ptr[])) orig(size(psi_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable theta_ptr[*], phi_ptr[*], psi_ptr[*], angle_unit_ptr[*]
pp2 == \old(pp2)
theta_ptr == \old(theta_ptr)
phi_ptr == \old(phi_ptr)
psi_ptr == \old(psi_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
theta_ptr != null
phi_ptr != null
psi_ptr != null
angle_unit_ptr != null
(angle_unit_ptr != null)  ==>  (daikon.Quant.subsetOf(angle_unit_ptr, new long[] { 0, 1 }))
(angle_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(theta_ptr != null)  ==>  (daikon.Quant.size(theta_ptr) == 1)
(phi_ptr != null)  ==>  (daikon.Quant.size(phi_ptr) == 1)
(psi_ptr != null)  ==>  (daikon.Quant.size(psi_ptr) == 1)
(angle_unit_ptr != null)  ==>  (daikon.Quant.size(angle_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.nomefile(char *;)void:::ENTER
    Variables: fn fn[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
fn != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.nomefile(char *;)void:::EXIT
    Variables: fn fn[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(fn) orig(fn[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
assignable fn[*]
fn == \old(fn)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
fn != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: fn[] is printable
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.parserro(charac *;int;char *;)void:::ENTER
    Variables: errcode s s[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
errcode >= 1
s != null
(s != null)  ==>  (s.equals("testgroup"))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.parserro(charac *;int;char *;)void:::EXIT
    Variables: errcode s s[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(errcode) orig(s) orig(s[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
errcode == \old(errcode)
s == \old(s)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
errcode >= 1
s != null
(s != null)  ==>  (s.equals("testgroup"))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
((s != null) && (\old(s) != null))  ==>  (s.equals(\old(s)))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.phaserot(charac *;charac **;double *;double *;int *;)int:::ENTER
    Variables: pp2 phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1
pp2 != null
phase_start_ptr != null
phase_step_ptr != null
phase_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.phaserot(charac *;charac **;double *;double *;int *;)int:::EXIT244
    Variables: pp2 phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable phase_start_ptr[*], phase_step_ptr[*], phase_unit_ptr[*]
\result == 1
===========================================================================
std.phaserot(charac *;charac **;double *;double *;int *;)int:::EXIT247
    Variables: pp2 phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable phase_start_ptr[*], phase_step_ptr[*], phase_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(phase_unit_ptr, 0)
\result == 0
daikon.Quant.size(phase_start_ptr) == 1
daikon.Quant.size(phase_step_ptr) == 1
daikon.Quant.size(phase_unit_ptr) == 1
===========================================================================
std.phaserot(charac *;charac **;double *;double *;int *;)int:::EXIT
    Variables: pp2 phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable phase_start_ptr[*], phase_step_ptr[*], phase_unit_ptr[*]
pp2 == \old(pp2)
phase_start_ptr == \old(phase_start_ptr)
phase_step_ptr == \old(phase_step_ptr)
phase_unit_ptr == \old(phase_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
phase_start_ptr != null
phase_step_ptr != null
phase_unit_ptr != null
(phase_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(phase_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(phase_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(phase_start_ptr != null)  ==>  (daikon.Quant.size(phase_start_ptr) == 1)
(phase_step_ptr != null)  ==>  (daikon.Quant.size(phase_step_ptr) == 1)
(phase_unit_ptr != null)  ==>  (daikon.Quant.size(phase_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.polor(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1
pp2 != null
angle_ptr != null
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(angle_ptr, 90.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
===========================================================================
std.polor(charac *;charac **;double *;int *;)int:::EXIT248
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(angle_ptr, \old(angle_ptr))
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(angle_ptr, 90.0)
\result == 1
===========================================================================
std.polor(charac *;charac **;double *;int *;)int:::EXIT249
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(angle_ptr, 0.0)
\result == 0
daikon.Quant.pairwiseLT(angle_ptr, \old(angle_ptr))
===========================================================================
std.polor(charac *;charac **;double *;int *;)int:::EXIT250
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(angle_ptr, \old(angle_ptr))
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(angle_ptr, 90.0)
\result == 0
===========================================================================
std.polor(charac *;charac **;double *;int *;)int:::EXIT251
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
\result == 0
===========================================================================
std.polor(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1
assignable angle_ptr[*]
pp2 == \old(pp2)
angle_ptr == \old(angle_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
daikon.Quant.pairwiseEqual(angle_unit_ptr, \old(angle_unit_ptr))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(angle_ptr) == \old(daikon.Quant.size(angle_ptr))
pp2 != null
angle_ptr != null
daikon.Quant.eltsGTE(angle_ptr, 0.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
daikon.Quant.pairwiseLTE(angle_ptr, \old(angle_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.polorbis(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1
pp2 != null
phepol_ptr != null
phepol_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.polorbis(charac *;charac **;double *;int *;)int:::EXIT254
    Variables: pp2 phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1
assignable phepol_ptr[*], phepol_unit_ptr[*]
daikon.Quant.pairwiseEqual(phepol_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(phepol_ptr, 90.0)
\result == 1
===========================================================================
std.polorbis(charac *;charac **;double *;int *;)int:::EXIT255
    Variables: pp2 phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1
assignable phepol_ptr[*], phepol_unit_ptr[*]
daikon.Quant.pairwiseEqual(phepol_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(phepol_ptr, 0.0)
\result == 0
===========================================================================
std.polorbis(charac *;charac **;double *;int *;)int:::EXIT256
    Variables: pp2 phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1
assignable phepol_ptr[*], phepol_unit_ptr[*]
daikon.Quant.pairwiseEqual(phepol_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(phepol_ptr, 90.0)
\result == 0
===========================================================================
std.polorbis(charac *;charac **;double *;int *;)int:::EXIT257
    Variables: pp2 phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1
assignable phepol_ptr[*], phepol_unit_ptr[*]
\result == 0
===========================================================================
std.polorbis(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1
assignable phepol_ptr[*], phepol_unit_ptr[*]
pp2 == \old(pp2)
phepol_ptr == \old(phepol_ptr)
phepol_unit_ptr == \old(phepol_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
phepol_ptr != null
daikon.Quant.eltsGTE(phepol_ptr, 0.0)
phepol_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(phepol_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(phepol_ptr) == 1
daikon.Quant.size(phepol_unit_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.polspec(charac *;charac **;int *;double *;int *;int *;)int:::ENTER
    Variables: pp2 polarization_ptr polarization_ptr[] phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(polarization_ptr[]) size(polarization_ptr[])-1 size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 size(direction_ptr[]) size(direction_ptr[])-1
pp2 != null
polarization_ptr != null
phepol_ptr != null
phepol_unit_ptr != null
direction_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.polspec(charac *;charac **;int *;double *;int *;int *;)int:::EXIT260
    Variables: pp2 polarization_ptr polarization_ptr[] phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(polarization_ptr) orig(polarization_ptr[]) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(polarization_ptr[]) size(polarization_ptr[])-1 size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 size(direction_ptr[]) size(direction_ptr[])-1 orig(size(polarization_ptr[])) orig(size(polarization_ptr[]))-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable polarization_ptr[*], phepol_ptr[*], phepol_unit_ptr[*], direction_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(polarization_ptr, 0)
daikon.Quant.pairwiseEqual(phepol_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(phepol_ptr, 90.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 0)
\result == 1
===========================================================================
std.polspec(charac *;charac **;int *;double *;int *;int *;)int:::EXIT261
    Variables: pp2 polarization_ptr polarization_ptr[] phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(polarization_ptr) orig(polarization_ptr[]) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(polarization_ptr[]) size(polarization_ptr[])-1 size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 size(direction_ptr[]) size(direction_ptr[])-1 orig(size(polarization_ptr[])) orig(size(polarization_ptr[]))-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable polarization_ptr[*], phepol_ptr[*], phepol_unit_ptr[*], direction_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(polarization_ptr, 0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 0)
\result == 0
===========================================================================
std.polspec(charac *;charac **;int *;double *;int *;int *;)int:::EXIT263
    Variables: pp2 polarization_ptr polarization_ptr[] phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(polarization_ptr) orig(polarization_ptr[]) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(polarization_ptr[]) size(polarization_ptr[])-1 size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 size(direction_ptr[]) size(direction_ptr[])-1 orig(size(polarization_ptr[])) orig(size(polarization_ptr[]))-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable polarization_ptr[*], phepol_ptr[*], phepol_unit_ptr[*], direction_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(polarization_ptr, 1)
daikon.Quant.pairwiseEqual(phepol_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(phepol_ptr, 90.0)
\result == 0
===========================================================================
std.polspec(charac *;charac **;int *;double *;int *;int *;)int:::EXIT265
    Variables: pp2 polarization_ptr polarization_ptr[] phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(polarization_ptr) orig(polarization_ptr[]) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(polarization_ptr[]) size(polarization_ptr[])-1 size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 size(direction_ptr[]) size(direction_ptr[])-1 orig(size(polarization_ptr[])) orig(size(polarization_ptr[]))-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable polarization_ptr[*], phepol_ptr[*], phepol_unit_ptr[*], direction_ptr[*]
pp2 != null
polarization_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(polarization_ptr, 1)
phepol_ptr != null
daikon.Quant.pairwiseEqual(phepol_ptr, new double[] { 90.0 })
daikon.Quant.eltsEqual(phepol_ptr, 90.0)
phepol_unit_ptr != null
direction_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 0)
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr13461")
\result == 17
===========================================================================
std.polspec(charac *;charac **;int *;double *;int *;int *;)int:::EXIT
    Variables: pp2 polarization_ptr polarization_ptr[] phepol_ptr phepol_ptr[] phepol_unit_ptr phepol_unit_ptr[] direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(polarization_ptr) orig(polarization_ptr[]) orig(phepol_ptr) orig(phepol_ptr[]) orig(phepol_unit_ptr) orig(phepol_unit_ptr[]) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(polarization_ptr[]) size(polarization_ptr[])-1 size(phepol_ptr[]) size(phepol_ptr[])-1 size(phepol_unit_ptr[]) size(phepol_unit_ptr[])-1 size(direction_ptr[]) size(direction_ptr[])-1 orig(size(polarization_ptr[])) orig(size(polarization_ptr[]))-1 orig(size(phepol_ptr[])) orig(size(phepol_ptr[]))-1 orig(size(phepol_unit_ptr[])) orig(size(phepol_unit_ptr[]))-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable polarization_ptr[*], phepol_ptr[*], phepol_unit_ptr[*], direction_ptr[*]
pp2 == \old(pp2)
polarization_ptr == \old(polarization_ptr)
phepol_ptr == \old(phepol_ptr)
phepol_unit_ptr == \old(phepol_unit_ptr)
direction_ptr == \old(direction_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
polarization_ptr != null
daikon.Quant.subsetOf(polarization_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
phepol_ptr != null
phepol_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(phepol_unit_ptr, 0)
direction_ptr != null
daikon.Quant.subsetOf(direction_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
daikon.Quant.size(polarization_ptr) == 1
daikon.Quant.size(phepol_ptr) == 1
daikon.Quant.size(phepol_unit_ptr) == 1
daikon.Quant.size(direction_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.polydef(charac *;charac **;Node **;)int:::ENTER
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
node_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.polydef(charac *;charac **;Node **;)int:::EXIT266
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
===========================================================================
std.polydef(charac *;charac **;Node **;)int:::EXIT
    Variables: pp2 node_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(node_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
node_ptr == \old(node_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
node_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.portamp(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 amp_ptr amp_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(amp_ptr[]) size(amp_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1
pp2 != null
amp_ptr != null
amp_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.portamp(charac *;charac **;double *;int *;)int:::EXIT269
    Variables: pp2 amp_ptr amp_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(amp_ptr) orig(amp_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(amp_ptr[]) size(amp_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(amp_ptr[])) orig(size(amp_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable amp_ptr[*], amp_unit_ptr[*]
::GLOBLE_FILENAME.equals("inputs/gr133") || ::GLOBLE_FILENAME.equals("inputs/gr152") || ::GLOBLE_FILENAME.equals("inputs/gr205")
\result == 1
===========================================================================
std.portamp(charac *;charac **;double *;int *;)int:::EXIT271
    Variables: pp2 amp_ptr amp_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(amp_ptr) orig(amp_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(amp_ptr[]) size(amp_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(amp_ptr[])) orig(size(amp_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable amp_ptr[*], amp_unit_ptr[*]
daikon.Quant.subsetOf(amp_unit_ptr, new long[] { 0, 1, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
daikon.Quant.size(amp_ptr) == 1
daikon.Quant.size(amp_unit_ptr) == 1
===========================================================================
std.portamp(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 amp_ptr amp_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(amp_ptr) orig(amp_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(amp_ptr[]) size(amp_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(amp_ptr[])) orig(size(amp_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable amp_ptr[*], amp_unit_ptr[*]
pp2 == \old(pp2)
amp_ptr == \old(amp_ptr)
amp_unit_ptr == \old(amp_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
amp_ptr != null
amp_unit_ptr != null
(amp_unit_ptr != null)  ==>  (daikon.Quant.subsetOf(amp_unit_ptr, new long[] { 0, 1, 2 }))
(amp_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(amp_ptr != null)  ==>  (daikon.Quant.size(amp_ptr) == 1)
(amp_unit_ptr != null)  ==>  (daikon.Quant.size(amp_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.portdef(charac *;charac **;Port *;int *;)int:::ENTER
    Variables: pp2 portnum_ptr portnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(portnum_ptr[]) size(portnum_ptr[])-1
pp2 != null
portnum_ptr != null
(portnum_ptr != null)  ==>  (daikon.Quant.eltsGTE(portnum_ptr, 1))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(portnum_ptr != null)  ==>  (daikon.Quant.size(portnum_ptr) == 1)
===========================================================================
std.portdef(charac *;charac **;Port *;int *;)int:::EXIT272
    Variables: pp2 portnum_ptr portnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(portnum_ptr) orig(portnum_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(portnum_ptr[]) size(portnum_ptr[])-1 orig(size(portnum_ptr[])) orig(size(portnum_ptr[]))-1
daikon.Quant.pairwiseEqual(portnum_ptr, \old(portnum_ptr))
\result == 1
===========================================================================
std.portdef(charac *;charac **;Port *;int *;)int:::EXIT275
    Variables: pp2 portnum_ptr portnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(portnum_ptr) orig(portnum_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(portnum_ptr[]) size(portnum_ptr[])-1 orig(size(portnum_ptr[])) orig(size(portnum_ptr[]))-1
assignable portnum_ptr[*]
daikon.Quant.size(portnum_ptr) == \old(daikon.Quant.size(portnum_ptr))
daikon.Quant.subsetOf(portnum_ptr, new long[] { 1, 2, 3 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME.equals("inputs/gr133") || ::GLOBLE_FILENAME.equals("inputs/gr152") || ::GLOBLE_FILENAME.equals("inputs/gr205")
\result == 17
(\old(portnum_ptr) != null)  ==>  (daikon.Quant.subsetOf(\old(portnum_ptr), new long[] { 1, 2 }))
(\old(portnum_ptr) != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
\old(daikon.Quant.size(portnum_ptr)) == 1
===========================================================================
std.portdef(charac *;charac **;Port *;int *;)int:::EXIT276
    Variables: pp2 portnum_ptr portnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(portnum_ptr) orig(portnum_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(portnum_ptr[]) size(portnum_ptr[])-1 orig(size(portnum_ptr[])) orig(size(portnum_ptr[]))-1
assignable portnum_ptr[*]
pp2 != null
portnum_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(portnum_ptr, 1)
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr13462")
\result == 17
===========================================================================
std.portdef(charac *;charac **;Port *;int *;)int:::EXIT277
    Variables: pp2 portnum_ptr portnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(portnum_ptr) orig(portnum_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(portnum_ptr[]) size(portnum_ptr[])-1 orig(size(portnum_ptr[])) orig(size(portnum_ptr[]))-1
assignable portnum_ptr[*]
pp2 != null
portnum_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(portnum_ptr, 1)
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr13463")
\result == 17
===========================================================================
std.portdef(charac *;charac **;Port *;int *;)int:::EXIT279
    Variables: pp2 portnum_ptr portnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(portnum_ptr) orig(portnum_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(portnum_ptr[]) size(portnum_ptr[])-1 orig(size(portnum_ptr[])) orig(size(portnum_ptr[]))-1
assignable portnum_ptr[*]
daikon.Quant.size(portnum_ptr) == \old(daikon.Quant.size(portnum_ptr))
\result == 0
\old(daikon.Quant.size(portnum_ptr)) == 1
(\old(portnum_ptr) != null)  ==>  (warning: method daikon.inv.binary.twoSequence.PairwiseLinearBinary.format(OutputFormat:JML) needs to be implemented: portnum_ptr[] - orig(portnum_ptr[]) - 1 == 0)
(\old(portnum_ptr) != null)  ==>  (daikon.Quant.pairwiseGT(portnum_ptr, \old(portnum_ptr)))
===========================================================================
std.portdef(charac *;charac **;Port *;int *;)int:::EXIT
    Variables: pp2 portnum_ptr portnum_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(portnum_ptr) orig(portnum_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(portnum_ptr[]) size(portnum_ptr[])-1 orig(size(portnum_ptr[])) orig(size(portnum_ptr[]))-1
assignable portnum_ptr[*]
pp2 == \old(pp2)
portnum_ptr == \old(portnum_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\old(portnum_ptr) != null)  ==>  (daikon.Quant.size(portnum_ptr) == \old(daikon.Quant.size(portnum_ptr)))
pp2 != null
portnum_ptr != null
daikon.Quant.eltsGTE(portnum_ptr, 1)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
daikon.Quant.size(portnum_ptr) == 1
(\old(portnum_ptr) != null)  ==>  (daikon.Quant.pairwiseGTE(portnum_ptr, \old(portnum_ptr)))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.portspec(charac *;charac **;int *;Port **;)int:::ENTER
    Variables: pp2 nports_ptr nports_ptr[] port_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(nports_ptr[]) size(nports_ptr[])-1
pp2 != null
nports_ptr != null
port_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.portspec(charac *;charac **;int *;Port **;)int:::EXIT280
    Variables: pp2 nports_ptr nports_ptr[] port_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(nports_ptr) orig(nports_ptr[]) orig(port_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(nports_ptr[]) size(nports_ptr[])-1 orig(size(nports_ptr[])) orig(size(nports_ptr[]))-1
assignable nports_ptr[*]
\result == 1
===========================================================================
std.portspec(charac *;charac **;int *;Port **;)int:::EXIT282
    Variables: pp2 nports_ptr nports_ptr[] port_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(nports_ptr) orig(nports_ptr[]) orig(port_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(nports_ptr[]) size(nports_ptr[])-1 orig(size(nports_ptr[])) orig(size(nports_ptr[]))-1
assignable nports_ptr[*]
\result == 17
daikon.Quant.size(nports_ptr) == 1
===========================================================================
std.portspec(charac *;charac **;int *;Port **;)int:::EXIT283
    Variables: pp2 nports_ptr nports_ptr[] port_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(nports_ptr) orig(nports_ptr[]) orig(port_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(nports_ptr[]) size(nports_ptr[])-1 orig(size(nports_ptr[])) orig(size(nports_ptr[]))-1
assignable nports_ptr[*]
daikon.Quant.subsetOf(nports_ptr, new long[] { 1, 3 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 17
daikon.Quant.size(nports_ptr) == 1
===========================================================================
std.portspec(charac *;charac **;int *;Port **;)int:::EXIT284
    Variables: pp2 nports_ptr nports_ptr[] port_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(nports_ptr) orig(nports_ptr[]) orig(port_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(nports_ptr[]) size(nports_ptr[])-1 orig(size(nports_ptr[])) orig(size(nports_ptr[]))-1
assignable nports_ptr[*]
daikon.Quant.eltsGTE(nports_ptr, 1)
\result == 0
daikon.Quant.size(nports_ptr) == 1
===========================================================================
std.portspec(charac *;charac **;int *;Port **;)int:::EXIT
    Variables: pp2 nports_ptr nports_ptr[] port_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(nports_ptr) orig(nports_ptr[]) orig(port_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(nports_ptr[]) size(nports_ptr[])-1 orig(size(nports_ptr[])) orig(size(nports_ptr[]))-1
assignable nports_ptr[*]
pp2 == \old(pp2)
nports_ptr == \old(nports_ptr)
port_ptr == \old(port_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
nports_ptr != null
(nports_ptr != null)  ==>  (daikon.Quant.eltsGTE(nports_ptr, 1))
port_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
(nports_ptr != null)  ==>  (daikon.Quant.size(nports_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.ppadef1(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 ppa_ptr ppa_ptr[] ppa_unit_ptr ppa_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(ppa_ptr[]) size(ppa_ptr[])-1 size(ppa_unit_ptr[]) size(ppa_unit_ptr[])-1
pp2 != null
ppa_ptr != null
ppa_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.ppadef1(charac *;charac **;double *;int *;)int:::EXIT285
    Variables: pp2 ppa_ptr ppa_ptr[] ppa_unit_ptr ppa_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(ppa_ptr) orig(ppa_ptr[]) orig(ppa_unit_ptr) orig(ppa_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(ppa_ptr[]) size(ppa_ptr[])-1 size(ppa_unit_ptr[]) size(ppa_unit_ptr[])-1 orig(size(ppa_ptr[])) orig(size(ppa_ptr[]))-1 orig(size(ppa_unit_ptr[])) orig(size(ppa_unit_ptr[]))-1
assignable ppa_ptr[*], ppa_unit_ptr[*]
\result == 1
===========================================================================
std.ppadef1(charac *;charac **;double *;int *;)int:::EXIT287
    Variables: pp2 ppa_ptr ppa_ptr[] ppa_unit_ptr ppa_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(ppa_ptr) orig(ppa_ptr[]) orig(ppa_unit_ptr) orig(ppa_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(ppa_ptr[]) size(ppa_ptr[])-1 size(ppa_unit_ptr[]) size(ppa_unit_ptr[])-1 orig(size(ppa_ptr[])) orig(size(ppa_ptr[]))-1 orig(size(ppa_unit_ptr[])) orig(size(ppa_unit_ptr[]))-1
assignable ppa_ptr[*], ppa_unit_ptr[*]
daikon.Quant.subsetOf(ppa_unit_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
daikon.Quant.size(ppa_ptr) == 1
daikon.Quant.size(ppa_unit_ptr) == 1
===========================================================================
std.ppadef1(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 ppa_ptr ppa_ptr[] ppa_unit_ptr ppa_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(ppa_ptr) orig(ppa_ptr[]) orig(ppa_unit_ptr) orig(ppa_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(ppa_ptr[]) size(ppa_ptr[])-1 size(ppa_unit_ptr[]) size(ppa_unit_ptr[])-1 orig(size(ppa_ptr[])) orig(size(ppa_ptr[]))-1 orig(size(ppa_unit_ptr[])) orig(size(ppa_unit_ptr[]))-1
assignable ppa_ptr[*], ppa_unit_ptr[*]
pp2 == \old(pp2)
ppa_ptr == \old(ppa_ptr)
ppa_unit_ptr == \old(ppa_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
ppa_ptr != null
ppa_unit_ptr != null
(ppa_unit_ptr != null)  ==>  (daikon.Quant.subsetOf(ppa_unit_ptr, new long[] { 0, 1 }))
(ppa_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(ppa_ptr != null)  ==>  (daikon.Quant.size(ppa_ptr) == 1)
(ppa_unit_ptr != null)  ==>  (daikon.Quant.size(ppa_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.pqlimits(Geomnode *;Geomnode **;Geomnode **;Geomnode **;Geomnode **;)int:::ENTER
    Variables: pmin_ptr pmax_ptr qmin_ptr qmax_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pmin_ptr != null
pmax_ptr != null
qmin_ptr != null
qmax_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.pqlimits(Geomnode *;Geomnode **;Geomnode **;Geomnode **;Geomnode **;)int:::EXIT
    Variables: pmin_ptr pmax_ptr qmin_ptr qmax_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pmin_ptr) orig(pmax_ptr) orig(qmin_ptr) orig(qmax_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pmin_ptr == \old(pmin_ptr)
pmax_ptr == \old(pmax_ptr)
qmin_ptr == \old(qmin_ptr)
qmax_ptr == \old(qmax_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pmin_ptr != null
pmax_ptr != null
qmin_ptr != null
qmax_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.prnfile(charac *;)void:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.prnfile(charac *;)void:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.pscdef1(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 psc_ptr psc_ptr[] psc_unit_ptr psc_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(psc_ptr[]) size(psc_ptr[])-1 size(psc_unit_ptr[]) size(psc_unit_ptr[])-1
pp2 != null
psc_ptr != null
psc_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.pscdef1(charac *;charac **;double *;int *;)int:::EXIT290
    Variables: pp2 psc_ptr psc_ptr[] psc_unit_ptr psc_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(psc_ptr) orig(psc_ptr[]) orig(psc_unit_ptr) orig(psc_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(psc_ptr[]) size(psc_ptr[])-1 size(psc_unit_ptr[]) size(psc_unit_ptr[])-1 orig(size(psc_ptr[])) orig(size(psc_ptr[]))-1 orig(size(psc_unit_ptr[])) orig(size(psc_unit_ptr[]))-1
assignable psc_ptr[*], psc_unit_ptr[*]
\result == 1
===========================================================================
std.pscdef1(charac *;charac **;double *;int *;)int:::EXIT291
    Variables: pp2 psc_ptr psc_ptr[] psc_unit_ptr psc_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(psc_ptr) orig(psc_ptr[]) orig(psc_unit_ptr) orig(psc_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(psc_ptr[]) size(psc_ptr[])-1 size(psc_unit_ptr[]) size(psc_unit_ptr[])-1 orig(size(psc_ptr[])) orig(size(psc_ptr[]))-1 orig(size(psc_unit_ptr[])) orig(size(psc_unit_ptr[]))-1
assignable psc_ptr[*], psc_unit_ptr[*]
pp2 != null
psc_ptr != null
psc_unit_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr13463")
\result == 17
===========================================================================
std.pscdef1(charac *;charac **;double *;int *;)int:::EXIT292
    Variables: pp2 psc_ptr psc_ptr[] psc_unit_ptr psc_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(psc_ptr) orig(psc_ptr[]) orig(psc_unit_ptr) orig(psc_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(psc_ptr[]) size(psc_ptr[])-1 size(psc_unit_ptr[]) size(psc_unit_ptr[])-1 orig(size(psc_ptr[])) orig(size(psc_ptr[]))-1 orig(size(psc_unit_ptr[])) orig(size(psc_unit_ptr[]))-1
assignable psc_ptr[*], psc_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(psc_unit_ptr, 0)
\result == 0
daikon.Quant.size(psc_ptr) == 1
daikon.Quant.size(psc_unit_ptr) == 1
===========================================================================
std.pscdef1(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 psc_ptr psc_ptr[] psc_unit_ptr psc_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(psc_ptr) orig(psc_ptr[]) orig(psc_unit_ptr) orig(psc_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(psc_ptr[]) size(psc_ptr[])-1 size(psc_unit_ptr[]) size(psc_unit_ptr[])-1 orig(size(psc_ptr[])) orig(size(psc_ptr[]))-1 orig(size(psc_unit_ptr[])) orig(size(psc_unit_ptr[]))-1
assignable psc_ptr[*], psc_unit_ptr[*]
pp2 == \old(pp2)
psc_ptr == \old(psc_ptr)
psc_unit_ptr == \old(psc_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
psc_ptr != null
psc_unit_ptr != null
(psc_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(psc_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(psc_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
(psc_ptr != null)  ==>  (daikon.Quant.size(psc_ptr) == 1)
(psc_unit_ptr != null)  ==>  (daikon.Quant.size(psc_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.pshdef1(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 psh_ptr psh_ptr[] psh_unit_ptr psh_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(psh_ptr[]) size(psh_ptr[])-1 size(psh_unit_ptr[]) size(psh_unit_ptr[])-1
pp2 != null
psh_ptr != null
psh_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.pshdef1(charac *;charac **;double *;int *;)int:::EXIT293
    Variables: pp2 psh_ptr psh_ptr[] psh_unit_ptr psh_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(psh_ptr) orig(psh_ptr[]) orig(psh_unit_ptr) orig(psh_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(psh_ptr[]) size(psh_ptr[])-1 size(psh_unit_ptr[]) size(psh_unit_ptr[])-1 orig(size(psh_ptr[])) orig(size(psh_ptr[]))-1 orig(size(psh_unit_ptr[])) orig(size(psh_unit_ptr[]))-1
assignable psh_ptr[*], psh_unit_ptr[*]
\result == 1
===========================================================================
std.pshdef1(charac *;charac **;double *;int *;)int:::EXIT294
    Variables: pp2 psh_ptr psh_ptr[] psh_unit_ptr psh_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(psh_ptr) orig(psh_ptr[]) orig(psh_unit_ptr) orig(psh_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(psh_ptr[]) size(psh_ptr[])-1 size(psh_unit_ptr[]) size(psh_unit_ptr[])-1 orig(size(psh_ptr[])) orig(size(psh_ptr[]))-1 orig(size(psh_unit_ptr[])) orig(size(psh_unit_ptr[]))-1
assignable psh_ptr[*], psh_unit_ptr[*]
pp2 != null
psh_ptr != null
psh_unit_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr13462")
\result == 17
===========================================================================
std.pshdef1(charac *;charac **;double *;int *;)int:::EXIT295
    Variables: pp2 psh_ptr psh_ptr[] psh_unit_ptr psh_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(psh_ptr) orig(psh_ptr[]) orig(psh_unit_ptr) orig(psh_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(psh_ptr[]) size(psh_ptr[])-1 size(psh_unit_ptr[]) size(psh_unit_ptr[])-1 orig(size(psh_ptr[])) orig(size(psh_ptr[]))-1 orig(size(psh_unit_ptr[])) orig(size(psh_unit_ptr[]))-1
assignable psh_ptr[*], psh_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(psh_unit_ptr, 0)
\result == 0
daikon.Quant.size(psh_ptr) == 1
daikon.Quant.size(psh_unit_ptr) == 1
===========================================================================
std.pshdef1(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 psh_ptr psh_ptr[] psh_unit_ptr psh_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(psh_ptr) orig(psh_ptr[]) orig(psh_unit_ptr) orig(psh_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(psh_ptr[]) size(psh_ptr[])-1 size(psh_unit_ptr[]) size(psh_unit_ptr[])-1 orig(size(psh_ptr[])) orig(size(psh_ptr[]))-1 orig(size(psh_unit_ptr[])) orig(size(psh_unit_ptr[]))-1
assignable psh_ptr[*], psh_unit_ptr[*]
pp2 == \old(pp2)
psh_ptr == \old(psh_ptr)
psh_unit_ptr == \old(psh_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
psh_ptr != null
psh_unit_ptr != null
(psh_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(psh_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(psh_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
(psh_ptr != null)  ==>  (daikon.Quant.size(psh_ptr) == 1)
(psh_unit_ptr != null)  ==>  (daikon.Quant.size(psh_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.readfil3(char *;charac **;charac **;)int:::ENTER
    Variables: filename filename[] firstel lastel ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
filename != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: filename[] is printable
firstel != null
lastel != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.readfil3(char *;charac **;charac **;)int:::EXIT296
    Variables: filename filename[] firstel lastel ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(filename) orig(filename[]) orig(firstel) orig(lastel) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 21
===========================================================================
std.readfil3(char *;charac **;charac **;)int:::EXIT301
    Variables: filename filename[] firstel lastel ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(filename) orig(filename[]) orig(firstel) orig(lastel) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.readfil3(char *;charac **;charac **;)int:::EXIT
    Variables: filename filename[] firstel lastel ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(filename) orig(filename[]) orig(firstel) orig(lastel) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
filename == \old(filename)
firstel == \old(firstel)
lastel == \old(lastel)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
filename != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: filename[] is printable
firstel != null
lastel != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 21
filename.equals(\old(filename))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.recgrdef(charac *;charac **;double *;double *;int *;)int:::ENTER
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1
pp2 != null
pstep_ptr != null
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
qstep_ptr != null
pqstep_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(pqstep_unit_ptr) == 1
===========================================================================
std.recgrdef(charac *;charac **;double *;double *;int *;)int:::EXIT302
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
assignable qstep_ptr[*]
daikon.Quant.pairwiseEqual(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseEqual(pqstep_unit_ptr, \old(pqstep_unit_ptr))
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
daikon.Quant.pairwiseEqual(qstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qstep_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
\result == 1
===========================================================================
std.recgrdef(charac *;charac **;double *;double *;int *;)int:::EXIT303
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
assignable qstep_ptr[*]
daikon.Quant.pairwiseEqual(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseEqual(pqstep_unit_ptr, \old(pqstep_unit_ptr))
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
daikon.Quant.pairwiseEqual(qstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qstep_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
\result == 0
===========================================================================
std.recgrdef(charac *;charac **;double *;double *;int *;)int:::EXIT305
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
assignable pstep_ptr[*], qstep_ptr[*], pqstep_unit_ptr[*]
\result == 0
daikon.Quant.pairwiseGT(pstep_ptr, \old(pstep_ptr))
===========================================================================
std.recgrdef(charac *;charac **;double *;double *;int *;)int:::EXIT
    Variables: pp2 pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1
assignable pstep_ptr[*], qstep_ptr[*], pqstep_unit_ptr[*]
pp2 == \old(pp2)
pstep_ptr == \old(pstep_ptr)
qstep_ptr == \old(qstep_ptr)
pqstep_unit_ptr == \old(pqstep_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(pstep_ptr) == \old(daikon.Quant.size(pstep_ptr))
daikon.Quant.size(pqstep_unit_ptr) == \old(daikon.Quant.size(pqstep_unit_ptr))
pp2 != null
pstep_ptr != null
daikon.Quant.eltsGTE(pstep_ptr, 0.0)
qstep_ptr != null
daikon.Quant.eltsGTE(qstep_ptr, 0.0)
pqstep_unit_ptr != null
daikon.Quant.subsetOf(pqstep_unit_ptr, new long[] { 0, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(qstep_ptr) == 1
daikon.Quant.size(pqstep_unit_ptr) == 1
daikon.Quant.pairwiseGTE(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseGTE(pqstep_unit_ptr, \old(pqstep_unit_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.recspec(charac *;charac **;double *;double *;int *;)int:::ENTER
    Variables: pp2 pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1
pp2 != null
pdim_ptr != null
qdim_ptr != null
pqdim_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.recspec(charac *;charac **;double *;double *;int *;)int:::EXIT306
    Variables: pp2 pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
\result == 1
===========================================================================
std.recspec(charac *;charac **;double *;double *;int *;)int:::EXIT307
    Variables: pp2 pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
\result == 17
daikon.Quant.size(pdim_ptr) == 1
===========================================================================
std.recspec(charac *;charac **;double *;double *;int *;)int:::EXIT308
    Variables: pp2 pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
\result == 17
daikon.Quant.size(pdim_ptr) == 1
daikon.Quant.size(qdim_ptr) == 1
===========================================================================
std.recspec(charac *;charac **;double *;double *;int *;)int:::EXIT309
    Variables: pp2 pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
daikon.Quant.subsetOf(pqdim_unit_ptr, new long[] { 0, 1, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
daikon.Quant.size(pdim_ptr) == 1
daikon.Quant.size(qdim_ptr) == 1
daikon.Quant.size(pqdim_unit_ptr) == 1
===========================================================================
std.recspec(charac *;charac **;double *;double *;int *;)int:::EXIT
    Variables: pp2 pdim_ptr pdim_ptr[] qdim_ptr qdim_ptr[] pqdim_unit_ptr pqdim_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pdim_ptr) orig(pdim_ptr[]) orig(qdim_ptr) orig(qdim_ptr[]) orig(pqdim_unit_ptr) orig(pqdim_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pdim_ptr[]) size(pdim_ptr[])-1 size(qdim_ptr[]) size(qdim_ptr[])-1 size(pqdim_unit_ptr[]) size(pqdim_unit_ptr[])-1 orig(size(pdim_ptr[])) orig(size(pdim_ptr[]))-1 orig(size(qdim_ptr[])) orig(size(qdim_ptr[]))-1 orig(size(pqdim_unit_ptr[])) orig(size(pqdim_unit_ptr[]))-1
assignable pdim_ptr[*], qdim_ptr[*], pqdim_unit_ptr[*]
pp2 == \old(pp2)
pdim_ptr == \old(pdim_ptr)
qdim_ptr == \old(qdim_ptr)
pqdim_unit_ptr == \old(pqdim_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
pdim_ptr != null
qdim_ptr != null
pqdim_unit_ptr != null
(pqdim_unit_ptr != null)  ==>  (daikon.Quant.subsetOf(pqdim_unit_ptr, new long[] { 0, 1, 2 }))
(pqdim_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1 || \result == 17
(pdim_ptr != null)  ==>  (daikon.Quant.size(pdim_ptr) == 1)
(qdim_ptr != null)  ==>  (daikon.Quant.size(qdim_ptr) == 1)
(pqdim_unit_ptr != null)  ==>  (daikon.Quant.size(pqdim_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.remdef(charac *;charac **;AddRem **;)int:::ENTER
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.remdef(charac *;charac **;AddRem **;)int:::EXIT310
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
===========================================================================
std.remdef(charac *;charac **;AddRem **;)int:::EXIT
    Variables: pp2 addrem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(addrem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
addrem_ptr == \old(addrem_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
addrem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.secoramp(charac *;charac **;double *;double *;double *;double *;double *;int *;)int:::ENTER
    Variables: pp2 centre_ptr centre_ptr[] p1_et_ptr p1_et_ptr[] p2_et_ptr p2_et_ptr[] q1_et_ptr q1_et_ptr[] q2_et_ptr q2_et_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(centre_ptr[]) size(centre_ptr[])-1 size(p1_et_ptr[]) size(p1_et_ptr[])-1 size(p2_et_ptr[]) size(p2_et_ptr[])-1 size(q1_et_ptr[]) size(q1_et_ptr[])-1 size(q2_et_ptr[]) size(q2_et_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1
pp2 != null
centre_ptr != null
p1_et_ptr != null
p2_et_ptr != null
q1_et_ptr != null
q2_et_ptr != null
amp_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.secoramp(charac *;charac **;double *;double *;double *;double *;double *;int *;)int:::EXIT320
    Variables: pp2 centre_ptr centre_ptr[] p1_et_ptr p1_et_ptr[] p2_et_ptr p2_et_ptr[] q1_et_ptr q1_et_ptr[] q2_et_ptr q2_et_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(centre_ptr) orig(centre_ptr[]) orig(p1_et_ptr) orig(p1_et_ptr[]) orig(p2_et_ptr) orig(p2_et_ptr[]) orig(q1_et_ptr) orig(q1_et_ptr[]) orig(q2_et_ptr) orig(q2_et_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(centre_ptr[]) size(centre_ptr[])-1 size(p1_et_ptr[]) size(p1_et_ptr[])-1 size(p2_et_ptr[]) size(p2_et_ptr[])-1 size(q1_et_ptr[]) size(q1_et_ptr[])-1 size(q2_et_ptr[]) size(q2_et_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(centre_ptr[])) orig(size(centre_ptr[]))-1 orig(size(p1_et_ptr[])) orig(size(p1_et_ptr[]))-1 orig(size(p2_et_ptr[])) orig(size(p2_et_ptr[]))-1 orig(size(q1_et_ptr[])) orig(size(q1_et_ptr[]))-1 orig(size(q2_et_ptr[])) orig(size(q2_et_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable centre_ptr[*], p1_et_ptr[*], p2_et_ptr[*], q1_et_ptr[*], q2_et_ptr[*], amp_unit_ptr[*]
::GLOBLE_FILENAME.equals("inputs/gr127") || ::GLOBLE_FILENAME.equals("inputs/gr143") || ::GLOBLE_FILENAME.equals("inputs/gr27")
\result == 1
===========================================================================
std.secoramp(charac *;charac **;double *;double *;double *;double *;double *;int *;)int:::EXIT326
    Variables: pp2 centre_ptr centre_ptr[] p1_et_ptr p1_et_ptr[] p2_et_ptr p2_et_ptr[] q1_et_ptr q1_et_ptr[] q2_et_ptr q2_et_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(centre_ptr) orig(centre_ptr[]) orig(p1_et_ptr) orig(p1_et_ptr[]) orig(p2_et_ptr) orig(p2_et_ptr[]) orig(q1_et_ptr) orig(q1_et_ptr[]) orig(q2_et_ptr) orig(q2_et_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(centre_ptr[]) size(centre_ptr[])-1 size(p1_et_ptr[]) size(p1_et_ptr[])-1 size(p2_et_ptr[]) size(p2_et_ptr[])-1 size(q1_et_ptr[]) size(q1_et_ptr[])-1 size(q2_et_ptr[]) size(q2_et_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(centre_ptr[])) orig(size(centre_ptr[]))-1 orig(size(p1_et_ptr[])) orig(size(p1_et_ptr[]))-1 orig(size(p2_et_ptr[])) orig(size(p2_et_ptr[]))-1 orig(size(q1_et_ptr[])) orig(size(q1_et_ptr[]))-1 orig(size(q2_et_ptr[])) orig(size(q2_et_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable centre_ptr[*], p1_et_ptr[*], p2_et_ptr[*], q1_et_ptr[*], q2_et_ptr[*], amp_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(amp_unit_ptr, 0)
\result == 0
daikon.Quant.size(centre_ptr) == 1
daikon.Quant.size(p1_et_ptr) == 1
daikon.Quant.size(p2_et_ptr) == 1
daikon.Quant.size(q1_et_ptr) == 1
daikon.Quant.size(q2_et_ptr) == 1
daikon.Quant.size(amp_unit_ptr) == 1
===========================================================================
std.secoramp(charac *;charac **;double *;double *;double *;double *;double *;int *;)int:::EXIT
    Variables: pp2 centre_ptr centre_ptr[] p1_et_ptr p1_et_ptr[] p2_et_ptr p2_et_ptr[] q1_et_ptr q1_et_ptr[] q2_et_ptr q2_et_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(centre_ptr) orig(centre_ptr[]) orig(p1_et_ptr) orig(p1_et_ptr[]) orig(p2_et_ptr) orig(p2_et_ptr[]) orig(q1_et_ptr) orig(q1_et_ptr[]) orig(q2_et_ptr) orig(q2_et_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(centre_ptr[]) size(centre_ptr[])-1 size(p1_et_ptr[]) size(p1_et_ptr[])-1 size(p2_et_ptr[]) size(p2_et_ptr[])-1 size(q1_et_ptr[]) size(q1_et_ptr[])-1 size(q2_et_ptr[]) size(q2_et_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(centre_ptr[])) orig(size(centre_ptr[]))-1 orig(size(p1_et_ptr[])) orig(size(p1_et_ptr[]))-1 orig(size(p2_et_ptr[])) orig(size(p2_et_ptr[]))-1 orig(size(q1_et_ptr[])) orig(size(q1_et_ptr[]))-1 orig(size(q2_et_ptr[])) orig(size(q2_et_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable centre_ptr[*], p1_et_ptr[*], p2_et_ptr[*], q1_et_ptr[*], q2_et_ptr[*], amp_unit_ptr[*]
pp2 == \old(pp2)
centre_ptr == \old(centre_ptr)
p1_et_ptr == \old(p1_et_ptr)
p2_et_ptr == \old(p2_et_ptr)
q1_et_ptr == \old(q1_et_ptr)
q2_et_ptr == \old(q2_et_ptr)
amp_unit_ptr == \old(amp_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
centre_ptr != null
p1_et_ptr != null
p2_et_ptr != null
q1_et_ptr != null
q2_et_ptr != null
amp_unit_ptr != null
(amp_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(amp_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(amp_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(centre_ptr != null)  ==>  (daikon.Quant.size(centre_ptr) == 1)
(p1_et_ptr != null)  ==>  (daikon.Quant.size(p1_et_ptr) == 1)
(p2_et_ptr != null)  ==>  (daikon.Quant.size(p2_et_ptr) == 1)
(q1_et_ptr != null)  ==>  (daikon.Quant.size(q1_et_ptr) == 1)
(q2_et_ptr != null)  ==>  (daikon.Quant.size(q2_et_ptr) == 1)
(amp_unit_ptr != null)  ==>  (daikon.Quant.size(amp_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.secorder(double;double;double;double;double;double;double;)double:::ENTER
    Variables: a b c d e x y ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(!(c == 0)) || (a == 0)
daikon.Quant.fuzzy.ne(a, e)
(!(d == 0)) || (b == 0)
daikon.Quant.fuzzy.ne(b, e)
daikon.Quant.fuzzy.ne(b, x)
daikon.Quant.fuzzy.ne(c, e)
daikon.Quant.fuzzy.ne(c, x)
daikon.Quant.fuzzy.ne(d, e)
daikon.Quant.fuzzy.ne(d, x)
daikon.Quant.fuzzy.ne(e, x)
daikon.Quant.fuzzy.ne(e, y)
(!(x == 0)) || (y == 0)
===========================================================================
std.secorder(double;double;double;double;double;double;double;)double:::EXIT
    Variables: a b c d e x y ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(a) orig(b) orig(c) orig(d) orig(e) orig(x) orig(y) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(a, \old(a))
daikon.Quant.fuzzy.eq(b, \old(b))
daikon.Quant.fuzzy.eq(c, \old(c))
daikon.Quant.fuzzy.eq(d, \old(d))
daikon.Quant.fuzzy.eq(e, \old(e))
daikon.Quant.fuzzy.eq(x, \old(x))
daikon.Quant.fuzzy.eq(y, \old(y))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
(!(c == 0)) || (a == 0)
daikon.Quant.fuzzy.ne(a, e)
daikon.Quant.fuzzy.lt(a, \result)
(!(d == 0)) || (b == 0)
daikon.Quant.fuzzy.ne(b, e)
daikon.Quant.fuzzy.ne(b, x)
daikon.Quant.fuzzy.lt(b, \result)
daikon.Quant.fuzzy.ne(c, e)
daikon.Quant.fuzzy.ne(c, x)
daikon.Quant.fuzzy.lt(c, \result)
daikon.Quant.fuzzy.ne(d, e)
daikon.Quant.fuzzy.ne(d, x)
daikon.Quant.fuzzy.lt(d, \result)
daikon.Quant.fuzzy.ne(e, x)
daikon.Quant.fuzzy.ne(e, y)
(!(x == 0)) || (y == 0)
daikon.Quant.fuzzy.ne(x, \result)
daikon.Quant.fuzzy.ne(y, \result)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.secorpha(charac *;charac **;double *;double *;double *;double *;double *;int *;)int:::ENTER
    Variables: pp2 centre_ptr centre_ptr[] p1_ep_ptr p1_ep_ptr[] p2_ep_ptr p2_ep_ptr[] q1_ep_ptr q1_ep_ptr[] q2_ep_ptr q2_ep_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(centre_ptr[]) size(centre_ptr[])-1 size(p1_ep_ptr[]) size(p1_ep_ptr[])-1 size(p2_ep_ptr[]) size(p2_ep_ptr[])-1 size(q1_ep_ptr[]) size(q1_ep_ptr[])-1 size(q2_ep_ptr[]) size(q2_ep_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1
pp2 != null
centre_ptr != null
p1_ep_ptr != null
p2_ep_ptr != null
q1_ep_ptr != null
q2_ep_ptr != null
phase_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.secorpha(charac *;charac **;double *;double *;double *;double *;double *;int *;)int:::EXIT328
    Variables: pp2 centre_ptr centre_ptr[] p1_ep_ptr p1_ep_ptr[] p2_ep_ptr p2_ep_ptr[] q1_ep_ptr q1_ep_ptr[] q2_ep_ptr q2_ep_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(centre_ptr) orig(centre_ptr[]) orig(p1_ep_ptr) orig(p1_ep_ptr[]) orig(p2_ep_ptr) orig(p2_ep_ptr[]) orig(q1_ep_ptr) orig(q1_ep_ptr[]) orig(q2_ep_ptr) orig(q2_ep_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(centre_ptr[]) size(centre_ptr[])-1 size(p1_ep_ptr[]) size(p1_ep_ptr[])-1 size(p2_ep_ptr[]) size(p2_ep_ptr[])-1 size(q1_ep_ptr[]) size(q1_ep_ptr[])-1 size(q2_ep_ptr[]) size(q2_ep_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(centre_ptr[])) orig(size(centre_ptr[]))-1 orig(size(p1_ep_ptr[])) orig(size(p1_ep_ptr[]))-1 orig(size(p2_ep_ptr[])) orig(size(p2_ep_ptr[]))-1 orig(size(q1_ep_ptr[])) orig(size(q1_ep_ptr[]))-1 orig(size(q2_ep_ptr[])) orig(size(q2_ep_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable centre_ptr[*], p1_ep_ptr[*], p2_ep_ptr[*], q1_ep_ptr[*], q2_ep_ptr[*], phase_unit_ptr[*]
\result == 1
===========================================================================
std.secorpha(charac *;charac **;double *;double *;double *;double *;double *;int *;)int:::EXIT334
    Variables: pp2 centre_ptr centre_ptr[] p1_ep_ptr p1_ep_ptr[] p2_ep_ptr p2_ep_ptr[] q1_ep_ptr q1_ep_ptr[] q2_ep_ptr q2_ep_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(centre_ptr) orig(centre_ptr[]) orig(p1_ep_ptr) orig(p1_ep_ptr[]) orig(p2_ep_ptr) orig(p2_ep_ptr[]) orig(q1_ep_ptr) orig(q1_ep_ptr[]) orig(q2_ep_ptr) orig(q2_ep_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(centre_ptr[]) size(centre_ptr[])-1 size(p1_ep_ptr[]) size(p1_ep_ptr[])-1 size(p2_ep_ptr[]) size(p2_ep_ptr[])-1 size(q1_ep_ptr[]) size(q1_ep_ptr[])-1 size(q2_ep_ptr[]) size(q2_ep_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(centre_ptr[])) orig(size(centre_ptr[]))-1 orig(size(p1_ep_ptr[])) orig(size(p1_ep_ptr[]))-1 orig(size(p2_ep_ptr[])) orig(size(p2_ep_ptr[]))-1 orig(size(q1_ep_ptr[])) orig(size(q1_ep_ptr[]))-1 orig(size(q2_ep_ptr[])) orig(size(q2_ep_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable centre_ptr[*], p1_ep_ptr[*], p2_ep_ptr[*], q1_ep_ptr[*], q2_ep_ptr[*], phase_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(phase_unit_ptr, 0)
\result == 0
daikon.Quant.size(centre_ptr) == 1
daikon.Quant.size(p1_ep_ptr) == 1
daikon.Quant.size(p2_ep_ptr) == 1
daikon.Quant.size(q1_ep_ptr) == 1
daikon.Quant.size(q2_ep_ptr) == 1
daikon.Quant.size(phase_unit_ptr) == 1
===========================================================================
std.secorpha(charac *;charac **;double *;double *;double *;double *;double *;int *;)int:::EXIT
    Variables: pp2 centre_ptr centre_ptr[] p1_ep_ptr p1_ep_ptr[] p2_ep_ptr p2_ep_ptr[] q1_ep_ptr q1_ep_ptr[] q2_ep_ptr q2_ep_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(centre_ptr) orig(centre_ptr[]) orig(p1_ep_ptr) orig(p1_ep_ptr[]) orig(p2_ep_ptr) orig(p2_ep_ptr[]) orig(q1_ep_ptr) orig(q1_ep_ptr[]) orig(q2_ep_ptr) orig(q2_ep_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(centre_ptr[]) size(centre_ptr[])-1 size(p1_ep_ptr[]) size(p1_ep_ptr[])-1 size(p2_ep_ptr[]) size(p2_ep_ptr[])-1 size(q1_ep_ptr[]) size(q1_ep_ptr[])-1 size(q2_ep_ptr[]) size(q2_ep_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(centre_ptr[])) orig(size(centre_ptr[]))-1 orig(size(p1_ep_ptr[])) orig(size(p1_ep_ptr[]))-1 orig(size(p2_ep_ptr[])) orig(size(p2_ep_ptr[]))-1 orig(size(q1_ep_ptr[])) orig(size(q1_ep_ptr[]))-1 orig(size(q2_ep_ptr[])) orig(size(q2_ep_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable centre_ptr[*], p1_ep_ptr[*], p2_ep_ptr[*], q1_ep_ptr[*], q2_ep_ptr[*], phase_unit_ptr[*]
pp2 == \old(pp2)
centre_ptr == \old(centre_ptr)
p1_ep_ptr == \old(p1_ep_ptr)
p2_ep_ptr == \old(p2_ep_ptr)
q1_ep_ptr == \old(q1_ep_ptr)
q2_ep_ptr == \old(q2_ep_ptr)
phase_unit_ptr == \old(phase_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
centre_ptr != null
p1_ep_ptr != null
p2_ep_ptr != null
q1_ep_ptr != null
q2_ep_ptr != null
phase_unit_ptr != null
(phase_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(phase_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(phase_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(centre_ptr != null)  ==>  (daikon.Quant.size(centre_ptr) == 1)
(p1_ep_ptr != null)  ==>  (daikon.Quant.size(p1_ep_ptr) == 1)
(p2_ep_ptr != null)  ==>  (daikon.Quant.size(p2_ep_ptr) == 1)
(q1_ep_ptr != null)  ==>  (daikon.Quant.size(q1_ep_ptr) == 1)
(q2_ep_ptr != null)  ==>  (daikon.Quant.size(q2_ep_ptr) == 1)
(phase_unit_ptr != null)  ==>  (daikon.Quant.size(phase_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.seqrothg(double;double;double;double;Geomnode *;)void:::ENTER
    Variables: angle_start angle_step phase_start phase_step ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
daikon.Quant.fuzzy.eq(angle_start, 0.0) || daikon.Quant.fuzzy.eq(angle_start, 111.0)
daikon.Quant.fuzzy.eq(phase_start, -109.0) || daikon.Quant.fuzzy.eq(phase_start, 0.0)
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.fuzzy.ne(angle_start, angle_step)
daikon.Quant.fuzzy.gte(angle_start, phase_start)
daikon.Quant.fuzzy.ne(angle_start, phase_step)
daikon.Quant.fuzzy.ne(angle_step, phase_start)
daikon.Quant.fuzzy.gte(angle_step, phase_step)
daikon.Quant.fuzzy.ne(phase_start, phase_step)
daikon.Quant.fuzzy.eq(11 * angle_start - 111 * angle_step + 111 * phase_step + 1, 1)
daikon.Quant.fuzzy.eq(109 * angle_step + 11 * phase_start - 109 * phase_step + 1, 1)
===========================================================================
std.seqrothg(double;double;double;double;Geomnode *;)void:::EXIT
    Variables: angle_start angle_step phase_start phase_step ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(angle_start) orig(angle_step) orig(phase_start) orig(phase_step) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(angle_start, \old(angle_start))
daikon.Quant.fuzzy.eq(angle_step, \old(angle_step))
daikon.Quant.fuzzy.eq(phase_start, \old(phase_start))
daikon.Quant.fuzzy.eq(phase_step, \old(phase_step))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.fuzzy.eq(angle_start, 0.0) || daikon.Quant.fuzzy.eq(angle_start, 111.0)
daikon.Quant.fuzzy.eq(phase_start, -109.0) || daikon.Quant.fuzzy.eq(phase_start, 0.0)
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.fuzzy.ne(angle_start, angle_step)
daikon.Quant.fuzzy.gte(angle_start, phase_start)
daikon.Quant.fuzzy.ne(angle_start, phase_step)
daikon.Quant.fuzzy.ne(angle_step, phase_start)
daikon.Quant.fuzzy.gte(angle_step, phase_step)
daikon.Quant.fuzzy.ne(phase_start, phase_step)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
daikon.Quant.fuzzy.eq(11 * angle_start - 111 * angle_step + 111 * phase_step + 1, 1)
daikon.Quant.fuzzy.eq(109 * angle_step + 11 * phase_start - 109 * phase_step + 1, 1)
===========================================================================
std.seqrotrg(double;double;double;double;Geomnode *;)void:::ENTER
    Variables: angle_start angle_step phase_start phase_step ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
daikon.Quant.fuzzy.eq(angle_start, phase_start)
daikon.Quant.fuzzy.eq(angle_step, phase_step)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.fuzzy.ne(angle_start, angle_step)
===========================================================================
std.seqrotrg(double;double;double;double;Geomnode *;)void:::EXIT
    Variables: angle_start angle_step phase_start phase_step ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(angle_start) orig(angle_step) orig(phase_start) orig(phase_step) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(angle_start, phase_start)
daikon.Quant.fuzzy.eq(angle_start, \old(angle_start))
daikon.Quant.fuzzy.eq(angle_start, \old(phase_start))
daikon.Quant.fuzzy.eq(angle_step, phase_step)
daikon.Quant.fuzzy.eq(angle_step, \old(angle_step))
daikon.Quant.fuzzy.eq(angle_step, \old(phase_step))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.fuzzy.ne(angle_start, angle_step)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.serotdir(charac *;charac **;int *;)int:::ENTER
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(direction_ptr[]) size(direction_ptr[])-1
pp2 != null
direction_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.serotdir(charac *;charac **;int *;)int:::EXIT337
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable direction_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 0)
\result == 0
===========================================================================
std.serotdir(charac *;charac **;int *;)int:::EXIT338
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable direction_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(direction_ptr, 1)
\result == 0
===========================================================================
std.serotdir(charac *;charac **;int *;)int:::EXIT339
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable direction_ptr[*]
\result == 1
===========================================================================
std.serotdir(charac *;charac **;int *;)int:::EXIT
    Variables: pp2 direction_ptr direction_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1
assignable direction_ptr[*]
pp2 == \old(pp2)
direction_ptr == \old(direction_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
direction_ptr != null
(direction_ptr != null)  ==>  (daikon.Quant.subsetOf(direction_ptr, new long[] { 0, 1 }))
(direction_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(direction_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.serotpar(charac *;charac **;double *;double *;int *;double *;double *;int *;int *;)int:::ENTER
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1
pp2 != null
angle_start_ptr != null
angle_step_ptr != null
omit_phase_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(omit_phase_ptr, 0)
phase_start_ptr != null
phase_step_ptr != null
angle_unit_ptr != null
phase_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(omit_phase_ptr) == 1
===========================================================================
std.serotpar(charac *;charac **;double *;double *;int *;double *;double *;int *;int *;)int:::EXIT341
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(omit_phase_ptr) orig(omit_phase_ptr[]) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(omit_phase_ptr[])) orig(size(omit_phase_ptr[]))-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable angle_start_ptr[*], angle_step_ptr[*], omit_phase_ptr[*], phase_start_ptr[*], phase_step_ptr[*], angle_unit_ptr[*], phase_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(omit_phase_ptr, 1)
\result == 1
daikon.Quant.pairwiseGT(omit_phase_ptr, \old(omit_phase_ptr))
===========================================================================
std.serotpar(charac *;charac **;double *;double *;int *;double *;double *;int *;int *;)int:::EXIT343
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(omit_phase_ptr) orig(omit_phase_ptr[]) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(omit_phase_ptr[])) orig(size(omit_phase_ptr[]))-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable angle_start_ptr[*], angle_step_ptr[*], omit_phase_ptr[*], phase_start_ptr[*], phase_step_ptr[*], angle_unit_ptr[*], phase_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(omit_phase_ptr, 1)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
\result == 0
daikon.Quant.pairwiseGT(omit_phase_ptr, \old(omit_phase_ptr))
===========================================================================
std.serotpar(charac *;charac **;double *;double *;int *;double *;double *;int *;int *;)int:::EXIT344
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(omit_phase_ptr) orig(omit_phase_ptr[]) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(omit_phase_ptr[])) orig(size(omit_phase_ptr[]))-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable angle_start_ptr[*], angle_step_ptr[*], phase_start_ptr[*], phase_step_ptr[*], angle_unit_ptr[*], phase_unit_ptr[*]
daikon.Quant.pairwiseEqual(omit_phase_ptr, \old(omit_phase_ptr))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(omit_phase_ptr, 0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(phase_unit_ptr, 0)
\result == 0
===========================================================================
std.serotpar(charac *;charac **;double *;double *;int *;double *;double *;int *;int *;)int:::EXIT
    Variables: pp2 angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(omit_phase_ptr) orig(omit_phase_ptr[]) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(omit_phase_ptr[])) orig(size(omit_phase_ptr[]))-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable angle_start_ptr[*], angle_step_ptr[*], omit_phase_ptr[*], phase_start_ptr[*], phase_step_ptr[*], angle_unit_ptr[*], phase_unit_ptr[*]
pp2 == \old(pp2)
angle_start_ptr == \old(angle_start_ptr)
angle_step_ptr == \old(angle_step_ptr)
omit_phase_ptr == \old(omit_phase_ptr)
phase_start_ptr == \old(phase_start_ptr)
phase_step_ptr == \old(phase_step_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
phase_unit_ptr == \old(phase_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(omit_phase_ptr) == \old(daikon.Quant.size(omit_phase_ptr))
pp2 != null
angle_start_ptr != null
angle_step_ptr != null
omit_phase_ptr != null
daikon.Quant.subsetOf(omit_phase_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
phase_start_ptr != null
phase_step_ptr != null
angle_unit_ptr != null
(angle_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(angle_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(angle_unit_ptr, 0))
phase_unit_ptr != null
(phase_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(phase_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(phase_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(angle_start_ptr) == 1
daikon.Quant.size(angle_step_ptr) == 1
daikon.Quant.size(omit_phase_ptr) == 1
daikon.Quant.size(phase_start_ptr) == 1
daikon.Quant.size(phase_step_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
daikon.Quant.size(phase_unit_ptr) == 1
daikon.Quant.pairwiseGTE(omit_phase_ptr, \old(omit_phase_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.serotpha(charac *;charac **;int *;int *;double *;double *;int *;double *;double *;int *;int *;)int:::ENTER
    Variables: pp2 direction_ptr direction_ptr[] omit_angle_ptr omit_angle_ptr[] angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(direction_ptr[]) size(direction_ptr[])-1 size(omit_angle_ptr[]) size(omit_angle_ptr[])-1 size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1
pp2 != null
direction_ptr != null
omit_angle_ptr != null
angle_start_ptr != null
angle_step_ptr != null
omit_phase_ptr != null
phase_start_ptr != null
phase_step_ptr != null
angle_unit_ptr != null
phase_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.serotpha(charac *;charac **;int *;int *;double *;double *;int *;double *;double *;int *;int *;)int:::EXIT345
    Variables: pp2 direction_ptr direction_ptr[] omit_angle_ptr omit_angle_ptr[] angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(omit_angle_ptr) orig(omit_angle_ptr[]) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(omit_phase_ptr) orig(omit_phase_ptr[]) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 size(omit_angle_ptr[]) size(omit_angle_ptr[])-1 size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1 orig(size(omit_angle_ptr[])) orig(size(omit_angle_ptr[]))-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(omit_phase_ptr[])) orig(size(omit_phase_ptr[]))-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable direction_ptr[*], omit_angle_ptr[*], angle_start_ptr[*], angle_step_ptr[*], omit_phase_ptr[*], phase_start_ptr[*], phase_step_ptr[*], angle_unit_ptr[*], phase_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(omit_angle_ptr, 0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(omit_phase_ptr, 0)
\result == 1
===========================================================================
std.serotpha(charac *;charac **;int *;int *;double *;double *;int *;double *;double *;int *;int *;)int:::EXIT348
    Variables: pp2 direction_ptr direction_ptr[] omit_angle_ptr omit_angle_ptr[] angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(omit_angle_ptr) orig(omit_angle_ptr[]) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(omit_phase_ptr) orig(omit_phase_ptr[]) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 size(omit_angle_ptr[]) size(omit_angle_ptr[])-1 size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1 orig(size(omit_angle_ptr[])) orig(size(omit_angle_ptr[]))-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(omit_phase_ptr[])) orig(size(omit_phase_ptr[]))-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable direction_ptr[*], omit_angle_ptr[*], angle_start_ptr[*], angle_step_ptr[*], omit_phase_ptr[*], phase_start_ptr[*], phase_step_ptr[*], angle_unit_ptr[*], phase_unit_ptr[*]
daikon.Quant.subsetOf(direction_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
daikon.Quant.size(direction_ptr) == 1
daikon.Quant.size(angle_start_ptr) == 1
daikon.Quant.size(angle_step_ptr) == 1
daikon.Quant.size(phase_start_ptr) == 1
daikon.Quant.size(phase_step_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
daikon.Quant.size(phase_unit_ptr) == 1
===========================================================================
std.serotpha(charac *;charac **;int *;int *;double *;double *;int *;double *;double *;int *;int *;)int:::EXIT
    Variables: pp2 direction_ptr direction_ptr[] omit_angle_ptr omit_angle_ptr[] angle_start_ptr angle_start_ptr[] angle_step_ptr angle_step_ptr[] omit_phase_ptr omit_phase_ptr[] phase_start_ptr phase_start_ptr[] phase_step_ptr phase_step_ptr[] angle_unit_ptr angle_unit_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(direction_ptr) orig(direction_ptr[]) orig(omit_angle_ptr) orig(omit_angle_ptr[]) orig(angle_start_ptr) orig(angle_start_ptr[]) orig(angle_step_ptr) orig(angle_step_ptr[]) orig(omit_phase_ptr) orig(omit_phase_ptr[]) orig(phase_start_ptr) orig(phase_start_ptr[]) orig(phase_step_ptr) orig(phase_step_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(direction_ptr[]) size(direction_ptr[])-1 size(omit_angle_ptr[]) size(omit_angle_ptr[])-1 size(angle_start_ptr[]) size(angle_start_ptr[])-1 size(angle_step_ptr[]) size(angle_step_ptr[])-1 size(omit_phase_ptr[]) size(omit_phase_ptr[])-1 size(phase_start_ptr[]) size(phase_start_ptr[])-1 size(phase_step_ptr[]) size(phase_step_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(direction_ptr[])) orig(size(direction_ptr[]))-1 orig(size(omit_angle_ptr[])) orig(size(omit_angle_ptr[]))-1 orig(size(angle_start_ptr[])) orig(size(angle_start_ptr[]))-1 orig(size(angle_step_ptr[])) orig(size(angle_step_ptr[]))-1 orig(size(omit_phase_ptr[])) orig(size(omit_phase_ptr[]))-1 orig(size(phase_start_ptr[])) orig(size(phase_start_ptr[]))-1 orig(size(phase_step_ptr[])) orig(size(phase_step_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable direction_ptr[*], omit_angle_ptr[*], angle_start_ptr[*], angle_step_ptr[*], omit_phase_ptr[*], phase_start_ptr[*], phase_step_ptr[*], angle_unit_ptr[*], phase_unit_ptr[*]
pp2 == \old(pp2)
direction_ptr == \old(direction_ptr)
omit_angle_ptr == \old(omit_angle_ptr)
angle_start_ptr == \old(angle_start_ptr)
angle_step_ptr == \old(angle_step_ptr)
omit_phase_ptr == \old(omit_phase_ptr)
phase_start_ptr == \old(phase_start_ptr)
phase_step_ptr == \old(phase_step_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
phase_unit_ptr == \old(phase_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
direction_ptr != null
(direction_ptr != null)  ==>  (daikon.Quant.subsetOf(direction_ptr, new long[] { 0, 1 }))
(direction_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
omit_angle_ptr != null
daikon.Quant.subsetOf(omit_angle_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
angle_start_ptr != null
angle_step_ptr != null
omit_phase_ptr != null
daikon.Quant.subsetOf(omit_phase_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
phase_start_ptr != null
phase_step_ptr != null
angle_unit_ptr != null
(angle_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(angle_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(angle_unit_ptr, 0))
phase_unit_ptr != null
(phase_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(phase_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(phase_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(direction_ptr != null)  ==>  (daikon.Quant.size(direction_ptr) == 1)
daikon.Quant.size(omit_angle_ptr) == 1
(angle_start_ptr != null)  ==>  (daikon.Quant.size(angle_start_ptr) == 1)
(angle_step_ptr != null)  ==>  (daikon.Quant.size(angle_step_ptr) == 1)
daikon.Quant.size(omit_phase_ptr) == 1
(phase_start_ptr != null)  ==>  (daikon.Quant.size(phase_start_ptr) == 1)
(phase_step_ptr != null)  ==>  (daikon.Quant.size(phase_step_ptr) == 1)
(angle_unit_ptr != null)  ==>  (daikon.Quant.size(angle_unit_ptr) == 1)
(phase_unit_ptr != null)  ==>  (daikon.Quant.size(phase_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.sgramp2n(GrAmpExc *;Geomnode *;Port *;int;)int:::ENTER
    Variables: group_shape ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
group_shape == 2 || group_shape == 3 || group_shape == 5
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.sgramp2n(GrAmpExc *;Geomnode *;Port *;int;)int:::EXIT349
    Variables: group_shape ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(group_shape) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
group_shape == 5
\result == 5
===========================================================================
std.sgramp2n(GrAmpExc *;Geomnode *;Port *;int;)int:::EXIT350
    Variables: group_shape ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(group_shape) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
group_shape == 2 || group_shape == 3
\result == 0
===========================================================================
std.sgramp2n(GrAmpExc *;Geomnode *;Port *;int;)int:::EXIT
    Variables: group_shape ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(group_shape) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
group_shape == \old(group_shape)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(group_shape == 5)  <==>  (\result == 5)
(group_shape == 2 || group_shape == 3)  <==>  (\result == 0)
(group_shape == 2 || group_shape == 3)  ==>  (\result  isPointer)
group_shape == 2 || group_shape == 3 || group_shape == 5
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 5
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.sgrampun(GrAmpExc *;Geomnode *;Port *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.sgrampun(GrAmpExc *;Geomnode *;Port *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.sgrpha2n(GrPhaExc *;Geomnode *;Port *;int;)int:::ENTER
    Variables: group_shape ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
group_shape == 2 || group_shape == 3 || group_shape == 5
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.sgrpha2n(GrPhaExc *;Geomnode *;Port *;int;)int:::EXIT352
    Variables: group_shape ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(group_shape) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
group_shape == 5
\result == 5
===========================================================================
std.sgrpha2n(GrPhaExc *;Geomnode *;Port *;int;)int:::EXIT353
    Variables: group_shape ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(group_shape) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
group_shape == 2 || group_shape == 3
\result == 0
===========================================================================
std.sgrpha2n(GrPhaExc *;Geomnode *;Port *;int;)int:::EXIT
    Variables: group_shape ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(group_shape) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
group_shape == \old(group_shape)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(group_shape == 5)  <==>  (\result == 5)
(group_shape == 2 || group_shape == 3)  <==>  (\result == 0)
(group_shape == 2 || group_shape == 3)  ==>  (\result  isPointer)
group_shape == 2 || group_shape == 3 || group_shape == 5
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 5
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.sgrphasr(Group *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.sgrphasr(Group *;)int:::EXIT354
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 10
===========================================================================
std.sgrphasr(Group *;)int:::EXIT355
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 11
===========================================================================
std.sgrphasr(Group *;)int:::EXIT356
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.sgrphasr(Group *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 10 || \result == 11
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.sgrphaun(GrPhaExc *;Geomnode *;Port *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.sgrphaun(GrPhaExc *;Geomnode *;Port *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.sgrrot(Geomnode *;double;double;double;)int:::ENTER
    Variables: XC YC phi ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
daikon.Quant.fuzzy.eq(XC, YC)
daikon.Quant.fuzzy.eq(XC, 0.0)
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.fuzzy.lt(XC, phi)
===========================================================================
std.sgrrot(Geomnode *;double;double;double;)int:::EXIT
    Variables: XC YC phi ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(XC) orig(YC) orig(phi) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
daikon.Quant.fuzzy.eq(XC, YC)
daikon.Quant.fuzzy.eq(XC, \old(XC))
daikon.Quant.fuzzy.eq(XC, \old(YC))
daikon.Quant.fuzzy.eq(phi, \old(phi))
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.fuzzy.eq(XC, 0.0)
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.fuzzy.lt(XC, phi)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.simamp(Group *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.simamp(Group *;)int:::EXIT359
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 6
===========================================================================
std.simamp(Group *;)int:::EXIT360
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.simamp(Group *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (\result  isPointer)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 6
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.simgroup(Group *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.simgroup(Group *;)int:::EXIT361
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 8
===========================================================================
std.simgroup(Group *;)int:::EXIT362
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.simgroup(Group *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (\result  isPointer)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 8
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.simpha(Group *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.simpha(Group *;)int:::EXIT363
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 9
===========================================================================
std.simpha(Group *;)int:::EXIT364
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.simpha(Group *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (\result  isPointer)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 9
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.simpol(Group *;)int:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.simpol(Group *;)int:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.sinelem(charac *;charac **;Elem **;)int:::ENTER
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
pp2 != null
elem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.sinelem(charac *;charac **;Elem **;)int:::EXIT367
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.sinelem(charac *;charac **;Elem **;)int:::EXIT368
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 != null
elem_ptr != null
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr13461")
\result == 17
===========================================================================
std.sinelem(charac *;charac **;Elem **;)int:::EXIT369
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 17
===========================================================================
std.sinelem(charac *;charac **;Elem **;)int:::EXIT370
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
\result == 0
===========================================================================
std.sinelem(charac *;charac **;Elem **;)int:::EXIT
    Variables: pp2 elem_ptr ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(elem_ptr) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
pp2 == \old(pp2)
elem_ptr == \old(elem_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
elem_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 17
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.sinstep(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 step_ptr step_ptr[] step_unit_ptr step_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(step_ptr[]) size(step_ptr[])-1 size(step_unit_ptr[]) size(step_unit_ptr[])-1
pp2 != null
step_ptr != null
daikon.Quant.pairwiseEqual(step_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(step_ptr, 0.0)
step_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(step_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(step_ptr) == 1
daikon.Quant.size(step_unit_ptr) == 1
===========================================================================
std.sinstep(charac *;charac **;double *;int *;)int:::EXIT371
    Variables: pp2 step_ptr step_ptr[] step_unit_ptr step_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(step_ptr) orig(step_ptr[]) orig(step_unit_ptr) orig(step_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(step_ptr[]) size(step_ptr[])-1 size(step_unit_ptr[]) size(step_unit_ptr[])-1 orig(size(step_ptr[])) orig(size(step_ptr[]))-1 orig(size(step_unit_ptr[])) orig(size(step_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(step_ptr, \old(step_ptr))
daikon.Quant.pairwiseEqual(step_unit_ptr, \old(step_unit_ptr))
daikon.Quant.pairwiseEqual(step_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(step_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(step_unit_ptr, 0)
\result == 1
===========================================================================
std.sinstep(charac *;charac **;double *;int *;)int:::EXIT373
    Variables: pp2 step_ptr step_ptr[] step_unit_ptr step_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(step_ptr) orig(step_ptr[]) orig(step_unit_ptr) orig(step_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(step_ptr[]) size(step_ptr[])-1 size(step_unit_ptr[]) size(step_unit_ptr[])-1 orig(size(step_ptr[])) orig(size(step_ptr[]))-1 orig(size(step_unit_ptr[])) orig(size(step_unit_ptr[]))-1
assignable step_ptr[*], step_unit_ptr[*]
\result == 0
daikon.Quant.pairwiseGT(step_ptr, \old(step_ptr))
===========================================================================
std.sinstep(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 step_ptr step_ptr[] step_unit_ptr step_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(step_ptr) orig(step_ptr[]) orig(step_unit_ptr) orig(step_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(step_ptr[]) size(step_ptr[])-1 size(step_unit_ptr[]) size(step_unit_ptr[])-1 orig(size(step_ptr[])) orig(size(step_ptr[]))-1 orig(size(step_unit_ptr[])) orig(size(step_unit_ptr[]))-1
assignable step_ptr[*], step_unit_ptr[*]
pp2 == \old(pp2)
step_ptr == \old(step_ptr)
step_unit_ptr == \old(step_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(step_ptr) == \old(daikon.Quant.size(step_ptr))
daikon.Quant.size(step_unit_ptr) == \old(daikon.Quant.size(step_unit_ptr))
pp2 != null
step_ptr != null
daikon.Quant.eltsGTE(step_ptr, 0.0)
step_unit_ptr != null
daikon.Quant.eltsGTE(step_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(step_ptr) == 1
daikon.Quant.size(step_unit_ptr) == 1
daikon.Quant.pairwiseGTE(step_ptr, \old(step_ptr))
daikon.Quant.pairwiseGTE(step_unit_ptr, \old(step_unit_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.squgrdef(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1
pp2 != null
pstep_ptr != null
pstep_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.squgrdef(charac *;charac **;double *;int *;)int:::EXIT374
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(pstep_unit_ptr) orig(pstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(pstep_unit_ptr[])) orig(size(pstep_unit_ptr[]))-1
assignable pstep_ptr[*], pstep_unit_ptr[*]
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pstep_unit_ptr, 0)
\result == 1
===========================================================================
std.squgrdef(charac *;charac **;double *;int *;)int:::EXIT375
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(pstep_unit_ptr) orig(pstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(pstep_unit_ptr[])) orig(size(pstep_unit_ptr[]))-1
assignable pstep_ptr[*], pstep_unit_ptr[*]
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pstep_unit_ptr, 0)
\result == 0
===========================================================================
std.squgrdef(charac *;charac **;double *;int *;)int:::EXIT377
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(pstep_unit_ptr) orig(pstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(pstep_unit_ptr[])) orig(size(pstep_unit_ptr[]))-1
assignable pstep_ptr[*], pstep_unit_ptr[*]
\result == 0
===========================================================================
std.squgrdef(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 pstep_ptr pstep_ptr[] pstep_unit_ptr pstep_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(pstep_ptr) orig(pstep_ptr[]) orig(pstep_unit_ptr) orig(pstep_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(pstep_ptr[]) size(pstep_ptr[])-1 size(pstep_unit_ptr[]) size(pstep_unit_ptr[])-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(pstep_unit_ptr[])) orig(size(pstep_unit_ptr[]))-1
assignable pstep_ptr[*], pstep_unit_ptr[*]
pp2 == \old(pp2)
pstep_ptr == \old(pstep_ptr)
pstep_unit_ptr == \old(pstep_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
pp2 != null
pstep_ptr != null
daikon.Quant.eltsGTE(pstep_ptr, 0.0)
pstep_unit_ptr != null
daikon.Quant.subsetOf(pstep_unit_ptr, new long[] { 0, 1, 3 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(pstep_unit_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.trigrdef(charac *;charac **;double *;int *;double *;double *;int *;double *;double *;double *;double *;int *;)int:::ENTER
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] px_ptr px_ptr[] py_ptr py_ptr[] qx_ptr qx_ptr[] qy_ptr qy_ptr[] pqxy_unit_ptr pqxy_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 size(px_ptr[]) size(px_ptr[])-1 size(py_ptr[]) size(py_ptr[])-1 size(qx_ptr[]) size(qx_ptr[])-1 size(qy_ptr[]) size(qy_ptr[])-1 size(pqxy_unit_ptr[]) size(pqxy_unit_ptr[])-1
pp2 != null
angle_ptr != null
angle_unit_ptr != null
pstep_ptr != null
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
qstep_ptr != null
daikon.Quant.pairwiseEqual(qstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qstep_ptr, 0.0)
pqstep_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
px_ptr != null
py_ptr != null
qx_ptr != null
qy_ptr != null
pqxy_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(qstep_ptr) == 1
daikon.Quant.size(pqstep_unit_ptr) == 1
===========================================================================
std.trigrdef(charac *;charac **;double *;int *;double *;double *;int *;double *;double *;double *;double *;int *;)int:::EXIT379
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] px_ptr px_ptr[] py_ptr py_ptr[] qx_ptr qx_ptr[] qy_ptr qy_ptr[] pqxy_unit_ptr pqxy_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(px_ptr) orig(px_ptr[]) orig(py_ptr) orig(py_ptr[]) orig(qx_ptr) orig(qx_ptr[]) orig(qy_ptr) orig(qy_ptr[]) orig(pqxy_unit_ptr) orig(pqxy_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 size(px_ptr[]) size(px_ptr[])-1 size(py_ptr[]) size(py_ptr[])-1 size(qx_ptr[]) size(qx_ptr[])-1 size(qy_ptr[]) size(qy_ptr[])-1 size(pqxy_unit_ptr[]) size(pqxy_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1 orig(size(px_ptr[])) orig(size(px_ptr[]))-1 orig(size(py_ptr[])) orig(size(py_ptr[]))-1 orig(size(qx_ptr[])) orig(size(qx_ptr[]))-1 orig(size(qy_ptr[])) orig(size(qy_ptr[]))-1 orig(size(pqxy_unit_ptr[])) orig(size(pqxy_unit_ptr[]))-1
assignable angle_ptr[*], angle_unit_ptr[*], px_ptr[*], py_ptr[*], qx_ptr[*], qy_ptr[*], pqxy_unit_ptr[*]
daikon.Quant.pairwiseEqual(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseEqual(qstep_ptr, \old(qstep_ptr))
daikon.Quant.pairwiseEqual(pqstep_unit_ptr, \old(pqstep_unit_ptr))
pp2 != null
angle_ptr != null
daikon.Quant.pairwiseEqual(angle_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(angle_ptr, 0.0)
angle_unit_ptr != null
pstep_ptr != null
daikon.Quant.pairwiseEqual(pstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(pstep_ptr, 0.0)
qstep_ptr != null
daikon.Quant.pairwiseEqual(qstep_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qstep_ptr, 0.0)
pqstep_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqstep_unit_ptr, 0)
px_ptr != null
daikon.Quant.pairwiseEqual(px_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(px_ptr, 0.0)
py_ptr != null
daikon.Quant.pairwiseEqual(py_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(py_ptr, 0.0)
qx_ptr != null
daikon.Quant.pairwiseEqual(qx_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qx_ptr, 0.0)
qy_ptr != null
daikon.Quant.pairwiseEqual(qy_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qy_ptr, 0.0)
pqxy_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqxy_unit_ptr, 0)
::GLOBLE_FILENAME != null
::GLOBLE_FILENAME.equals("inputs/gr29")
\result == 1
===========================================================================
std.trigrdef(charac *;charac **;double *;int *;double *;double *;int *;double *;double *;double *;double *;int *;)int:::EXIT382
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] px_ptr px_ptr[] py_ptr py_ptr[] qx_ptr qx_ptr[] qy_ptr qy_ptr[] pqxy_unit_ptr pqxy_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(px_ptr) orig(px_ptr[]) orig(py_ptr) orig(py_ptr[]) orig(qx_ptr) orig(qx_ptr[]) orig(qy_ptr) orig(qy_ptr[]) orig(pqxy_unit_ptr) orig(pqxy_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 size(px_ptr[]) size(px_ptr[])-1 size(py_ptr[]) size(py_ptr[])-1 size(qx_ptr[]) size(qx_ptr[])-1 size(qy_ptr[]) size(qy_ptr[])-1 size(pqxy_unit_ptr[]) size(pqxy_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1 orig(size(px_ptr[])) orig(size(px_ptr[]))-1 orig(size(py_ptr[])) orig(size(py_ptr[]))-1 orig(size(qx_ptr[])) orig(size(qx_ptr[]))-1 orig(size(qy_ptr[])) orig(size(qy_ptr[]))-1 orig(size(pqxy_unit_ptr[])) orig(size(pqxy_unit_ptr[]))-1
assignable angle_ptr[*], angle_unit_ptr[*], pstep_ptr[*], qstep_ptr[*], pqstep_unit_ptr[*], px_ptr[*], py_ptr[*], qx_ptr[*], qy_ptr[*], pqxy_unit_ptr[*]
\result == 0
===========================================================================
std.trigrdef(charac *;charac **;double *;int *;double *;double *;int *;double *;double *;double *;double *;int *;)int:::EXIT
    Variables: pp2 angle_ptr angle_ptr[] angle_unit_ptr angle_unit_ptr[] pstep_ptr pstep_ptr[] qstep_ptr qstep_ptr[] pqstep_unit_ptr pqstep_unit_ptr[] px_ptr px_ptr[] py_ptr py_ptr[] qx_ptr qx_ptr[] qy_ptr qy_ptr[] pqxy_unit_ptr pqxy_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(angle_ptr) orig(angle_ptr[]) orig(angle_unit_ptr) orig(angle_unit_ptr[]) orig(pstep_ptr) orig(pstep_ptr[]) orig(qstep_ptr) orig(qstep_ptr[]) orig(pqstep_unit_ptr) orig(pqstep_unit_ptr[]) orig(px_ptr) orig(px_ptr[]) orig(py_ptr) orig(py_ptr[]) orig(qx_ptr) orig(qx_ptr[]) orig(qy_ptr) orig(qy_ptr[]) orig(pqxy_unit_ptr) orig(pqxy_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(angle_ptr[]) size(angle_ptr[])-1 size(angle_unit_ptr[]) size(angle_unit_ptr[])-1 size(pstep_ptr[]) size(pstep_ptr[])-1 size(qstep_ptr[]) size(qstep_ptr[])-1 size(pqstep_unit_ptr[]) size(pqstep_unit_ptr[])-1 size(px_ptr[]) size(px_ptr[])-1 size(py_ptr[]) size(py_ptr[])-1 size(qx_ptr[]) size(qx_ptr[])-1 size(qy_ptr[]) size(qy_ptr[])-1 size(pqxy_unit_ptr[]) size(pqxy_unit_ptr[])-1 orig(size(angle_ptr[])) orig(size(angle_ptr[]))-1 orig(size(angle_unit_ptr[])) orig(size(angle_unit_ptr[]))-1 orig(size(pstep_ptr[])) orig(size(pstep_ptr[]))-1 orig(size(qstep_ptr[])) orig(size(qstep_ptr[]))-1 orig(size(pqstep_unit_ptr[])) orig(size(pqstep_unit_ptr[]))-1 orig(size(px_ptr[])) orig(size(px_ptr[]))-1 orig(size(py_ptr[])) orig(size(py_ptr[]))-1 orig(size(qx_ptr[])) orig(size(qx_ptr[]))-1 orig(size(qy_ptr[])) orig(size(qy_ptr[]))-1 orig(size(pqxy_unit_ptr[])) orig(size(pqxy_unit_ptr[]))-1
assignable angle_ptr[*], angle_unit_ptr[*], pstep_ptr[*], qstep_ptr[*], pqstep_unit_ptr[*], px_ptr[*], py_ptr[*], qx_ptr[*], qy_ptr[*], pqxy_unit_ptr[*]
pp2 == \old(pp2)
angle_ptr == \old(angle_ptr)
angle_unit_ptr == \old(angle_unit_ptr)
pstep_ptr == \old(pstep_ptr)
qstep_ptr == \old(qstep_ptr)
pqstep_unit_ptr == \old(pqstep_unit_ptr)
px_ptr == \old(px_ptr)
py_ptr == \old(py_ptr)
qx_ptr == \old(qx_ptr)
qy_ptr == \old(qy_ptr)
pqxy_unit_ptr == \old(pqxy_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(pstep_ptr) == \old(daikon.Quant.size(pstep_ptr))
daikon.Quant.size(qstep_ptr) == \old(daikon.Quant.size(qstep_ptr))
daikon.Quant.size(pqstep_unit_ptr) == \old(daikon.Quant.size(pqstep_unit_ptr))
pp2 != null
angle_ptr != null
daikon.Quant.eltsGTE(angle_ptr, 0.0)
angle_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(angle_unit_ptr, 0)
pstep_ptr != null
daikon.Quant.eltsGTE(pstep_ptr, 0.0)
qstep_ptr != null
daikon.Quant.eltsGTE(qstep_ptr, 0.0)
pqstep_unit_ptr != null
daikon.Quant.subsetOf(pqstep_unit_ptr, new long[] { 0, 3 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
px_ptr != null
py_ptr != null
qx_ptr != null
qy_ptr != null
pqxy_unit_ptr != null
daikon.Quant.eltsGTE(pqxy_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(angle_ptr) == 1
daikon.Quant.size(angle_unit_ptr) == 1
daikon.Quant.size(pstep_ptr) == 1
daikon.Quant.size(qstep_ptr) == 1
daikon.Quant.size(pqstep_unit_ptr) == 1
daikon.Quant.size(px_ptr) == 1
daikon.Quant.size(py_ptr) == 1
daikon.Quant.size(qx_ptr) == 1
daikon.Quant.size(qy_ptr) == 1
daikon.Quant.size(pqxy_unit_ptr) == 1
daikon.Quant.pairwiseGTE(pstep_ptr, \old(pstep_ptr))
daikon.Quant.pairwiseGTE(qstep_ptr, \old(qstep_ptr))
daikon.Quant.pairwiseGTE(pqstep_unit_ptr, \old(pqstep_unit_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.unaminit()void:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.unaminit()void:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.unifamp(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 unif_val_ptr unif_val_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(unif_val_ptr[]) size(unif_val_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1
pp2 != null
unif_val_ptr != null
amp_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.unifamp(charac *;charac **;double *;int *;)int:::EXIT384
    Variables: pp2 unif_val_ptr unif_val_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(unif_val_ptr) orig(unif_val_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unif_val_ptr[]) size(unif_val_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(unif_val_ptr[])) orig(size(unif_val_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable unif_val_ptr[*], amp_unit_ptr[*]
\result == 1
===========================================================================
std.unifamp(charac *;charac **;double *;int *;)int:::EXIT385
    Variables: pp2 unif_val_ptr unif_val_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(unif_val_ptr) orig(unif_val_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unif_val_ptr[]) size(unif_val_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(unif_val_ptr[])) orig(size(unif_val_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable unif_val_ptr[*], amp_unit_ptr[*]
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(amp_unit_ptr, 0)
\result == 0
daikon.Quant.size(unif_val_ptr) == 1
daikon.Quant.size(amp_unit_ptr) == 1
===========================================================================
std.unifamp(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 unif_val_ptr unif_val_ptr[] amp_unit_ptr amp_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(unif_val_ptr) orig(unif_val_ptr[]) orig(amp_unit_ptr) orig(amp_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unif_val_ptr[]) size(unif_val_ptr[])-1 size(amp_unit_ptr[]) size(amp_unit_ptr[])-1 orig(size(unif_val_ptr[])) orig(size(unif_val_ptr[]))-1 orig(size(amp_unit_ptr[])) orig(size(amp_unit_ptr[]))-1
assignable unif_val_ptr[*], amp_unit_ptr[*]
pp2 == \old(pp2)
unif_val_ptr == \old(unif_val_ptr)
amp_unit_ptr == \old(amp_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == 0)  ==>  (daikon.Quant.eltsEqual(amp_unit_ptr, 0))
(\result == 0)  ==>  (\result  isPointer)
pp2 != null
unif_val_ptr != null
amp_unit_ptr != null
(amp_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(amp_unit_ptr != null)  ==>  (daikon.Quant.eltsEqual(amp_unit_ptr, 0))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(unif_val_ptr != null)  ==>  (daikon.Quant.size(unif_val_ptr) == 1)
(amp_unit_ptr != null)  ==>  (daikon.Quant.size(amp_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.unifpha(charac *;charac **;double *;int *;)int:::ENTER
    Variables: pp2 unif_val_ptr unif_val_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(unif_val_ptr[]) size(unif_val_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1
pp2 != null
unif_val_ptr != null
phase_unit_ptr != null
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.unifpha(charac *;charac **;double *;int *;)int:::EXIT386
    Variables: pp2 unif_val_ptr unif_val_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(unif_val_ptr) orig(unif_val_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unif_val_ptr[]) size(unif_val_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(unif_val_ptr[])) orig(size(unif_val_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable unif_val_ptr[*], phase_unit_ptr[*]
\result == 1
===========================================================================
std.unifpha(charac *;charac **;double *;int *;)int:::EXIT387
    Variables: pp2 unif_val_ptr unif_val_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(unif_val_ptr) orig(unif_val_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unif_val_ptr[]) size(unif_val_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(unif_val_ptr[])) orig(size(unif_val_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable unif_val_ptr[*], phase_unit_ptr[*]
daikon.Quant.subsetOf(phase_unit_ptr, new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
\result == 0
daikon.Quant.size(unif_val_ptr) == 1
daikon.Quant.size(phase_unit_ptr) == 1
===========================================================================
std.unifpha(charac *;charac **;double *;int *;)int:::EXIT
    Variables: pp2 unif_val_ptr unif_val_ptr[] phase_unit_ptr phase_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(unif_val_ptr) orig(unif_val_ptr[]) orig(phase_unit_ptr) orig(phase_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(unif_val_ptr[]) size(unif_val_ptr[])-1 size(phase_unit_ptr[]) size(phase_unit_ptr[])-1 orig(size(unif_val_ptr[])) orig(size(unif_val_ptr[]))-1 orig(size(phase_unit_ptr[])) orig(size(phase_unit_ptr[]))-1
assignable unif_val_ptr[*], phase_unit_ptr[*]
pp2 == \old(pp2)
unif_val_ptr == \old(unif_val_ptr)
phase_unit_ptr == \old(phase_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(\result == 0)  ==>  (daikon.Quant.subsetOf(phase_unit_ptr, new long[] { 0, 1 }))
(\result == 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == 0)  ==>  (\result  isPointer)
pp2 != null
unif_val_ptr != null
phase_unit_ptr != null
(phase_unit_ptr != null)  ==>  (daikon.Quant.subsetOf(phase_unit_ptr, new long[] { 0, 1 }))
(phase_unit_ptr != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(unif_val_ptr != null)  ==>  (daikon.Quant.size(unif_val_ptr) == 1)
(phase_unit_ptr != null)  ==>  (daikon.Quant.size(phase_unit_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.uvdir(charac *;charac **;double *;double *;)int:::ENTER
    Variables: pp2 u_ptr u_ptr[] v_ptr v_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(u_ptr[]) size(u_ptr[])-1 size(v_ptr[]) size(v_ptr[])-1
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.uvdir(charac *;charac **;double *;double *;)int:::EXIT388
    Variables: pp2 u_ptr u_ptr[] v_ptr v_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(u_ptr) orig(u_ptr[]) orig(v_ptr) orig(v_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(u_ptr[]) size(u_ptr[])-1 size(v_ptr[]) size(v_ptr[])-1 orig(size(u_ptr[])) orig(size(u_ptr[]))-1 orig(size(v_ptr[])) orig(size(v_ptr[]))-1
assignable u_ptr[*], v_ptr[*]
::GLOBLE_FILENAME.equals("inputs/gr192") || ::GLOBLE_FILENAME.equals("inputs/gr82")
\result == 1
===========================================================================
std.uvdir(charac *;charac **;double *;double *;)int:::EXIT392
    Variables: pp2 u_ptr u_ptr[] v_ptr v_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(u_ptr) orig(u_ptr[]) orig(v_ptr) orig(v_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(u_ptr[]) size(u_ptr[])-1 size(v_ptr[]) size(v_ptr[])-1 orig(size(u_ptr[])) orig(size(u_ptr[]))-1 orig(size(v_ptr[])) orig(size(v_ptr[]))-1
assignable u_ptr[*], v_ptr[*]
daikon.Quant.pairwiseEqual(u_ptr, new double[] { 0.5 })
daikon.Quant.eltsEqual(u_ptr, 0.5)
daikon.Quant.pairwiseEqual(v_ptr, new double[] { 0.5 })
daikon.Quant.eltsEqual(v_ptr, 0.5)
\result == 0
daikon.Quant.size(u_ptr) == 1
daikon.Quant.size(v_ptr) == 1
===========================================================================
std.uvdir(charac *;charac **;double *;double *;)int:::EXIT
    Variables: pp2 u_ptr u_ptr[] v_ptr v_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(u_ptr) orig(u_ptr[]) orig(v_ptr) orig(v_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(u_ptr[]) size(u_ptr[])-1 size(v_ptr[]) size(v_ptr[])-1 orig(size(u_ptr[])) orig(size(u_ptr[]))-1 orig(size(v_ptr[])) orig(size(v_ptr[]))-1
assignable u_ptr[*], v_ptr[*]
pp2 == \old(pp2)
u_ptr == \old(u_ptr)
v_ptr == \old(v_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
(u_ptr != null)  ==>  (daikon.Quant.pairwiseEqual(u_ptr, new double[] { 0.5 }))
(u_ptr != null)  ==>  (daikon.Quant.eltsEqual(u_ptr, 0.5))
(v_ptr != null)  ==>  (daikon.Quant.pairwiseEqual(v_ptr, new double[] { 0.5 }))
(v_ptr != null)  ==>  (daikon.Quant.eltsEqual(v_ptr, 0.5))
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
(u_ptr != null)  ==>  (daikon.Quant.size(u_ptr) == 1)
(v_ptr != null)  ==>  (daikon.Quant.size(v_ptr) == 1)
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.uvval(charac *;charac **;double *;)int:::ENTER
    Variables: pp2 val_ptr val_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(val_ptr[]) size(val_ptr[])-1
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.uvval(charac *;charac **;double *;)int:::EXIT395
    Variables: pp2 val_ptr val_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(val_ptr) orig(val_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(val_ptr[]) size(val_ptr[])-1 orig(size(val_ptr[])) orig(size(val_ptr[]))-1
assignable val_ptr[*]
===========================================================================
std.uvval(charac *;charac **;double *;)int:::EXIT
    Variables: pp2 val_ptr val_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(val_ptr) orig(val_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(val_ptr[]) size(val_ptr[])-1 orig(size(val_ptr[])) orig(size(val_ptr[]))-1
assignable val_ptr[*]
pp2 == \old(pp2)
val_ptr == \old(val_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.pairwiseEqual(val_ptr, new double[] { 0.5 })
daikon.Quant.eltsEqual(val_ptr, 0.5)
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0
daikon.Quant.size(val_ptr) == 1
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.versdef(charac *;charac **;double *;double *;double *;double *;int *;)int:::ENTER
    Variables: pp2 px_ptr px_ptr[] py_ptr py_ptr[] qx_ptr qx_ptr[] qy_ptr qy_ptr[] pqxy_unit_ptr pqxy_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] size(px_ptr[]) size(px_ptr[])-1 size(py_ptr[]) size(py_ptr[])-1 size(qx_ptr[]) size(qx_ptr[])-1 size(qy_ptr[]) size(qy_ptr[])-1 size(pqxy_unit_ptr[]) size(pqxy_unit_ptr[])-1
pp2 != null
px_ptr != null
daikon.Quant.pairwiseEqual(px_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(px_ptr, 0.0)
py_ptr != null
daikon.Quant.pairwiseEqual(py_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(py_ptr, 0.0)
qx_ptr != null
daikon.Quant.pairwiseEqual(qx_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qx_ptr, 0.0)
qy_ptr != null
daikon.Quant.pairwiseEqual(qy_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qy_ptr, 0.0)
pqxy_unit_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqxy_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
daikon.Quant.size(px_ptr) == 1
daikon.Quant.size(py_ptr) == 1
daikon.Quant.size(qx_ptr) == 1
daikon.Quant.size(qy_ptr) == 1
daikon.Quant.size(pqxy_unit_ptr) == 1
===========================================================================
std.versdef(charac *;charac **;double *;double *;double *;double *;int *;)int:::EXIT396
    Variables: pp2 px_ptr px_ptr[] py_ptr py_ptr[] qx_ptr qx_ptr[] qy_ptr qy_ptr[] pqxy_unit_ptr pqxy_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(px_ptr) orig(px_ptr[]) orig(py_ptr) orig(py_ptr[]) orig(qx_ptr) orig(qx_ptr[]) orig(qy_ptr) orig(qy_ptr[]) orig(pqxy_unit_ptr) orig(pqxy_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(px_ptr[]) size(px_ptr[])-1 size(py_ptr[]) size(py_ptr[])-1 size(qx_ptr[]) size(qx_ptr[])-1 size(qy_ptr[]) size(qy_ptr[])-1 size(pqxy_unit_ptr[]) size(pqxy_unit_ptr[])-1 orig(size(px_ptr[])) orig(size(px_ptr[]))-1 orig(size(py_ptr[])) orig(size(py_ptr[]))-1 orig(size(qx_ptr[])) orig(size(qx_ptr[]))-1 orig(size(qy_ptr[])) orig(size(qy_ptr[]))-1 orig(size(pqxy_unit_ptr[])) orig(size(pqxy_unit_ptr[]))-1
daikon.Quant.pairwiseEqual(px_ptr, \old(px_ptr))
daikon.Quant.pairwiseEqual(py_ptr, \old(py_ptr))
daikon.Quant.pairwiseEqual(qx_ptr, \old(qx_ptr))
daikon.Quant.pairwiseEqual(qy_ptr, \old(qy_ptr))
daikon.Quant.pairwiseEqual(pqxy_unit_ptr, \old(pqxy_unit_ptr))
daikon.Quant.pairwiseEqual(px_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(px_ptr, 0.0)
daikon.Quant.pairwiseEqual(py_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(py_ptr, 0.0)
daikon.Quant.pairwiseEqual(qx_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qx_ptr, 0.0)
daikon.Quant.pairwiseEqual(qy_ptr, new double[] { 0.0 })
daikon.Quant.eltsEqual(qy_ptr, 0.0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(pqxy_unit_ptr, 0)
\result == 1
===========================================================================
std.versdef(charac *;charac **;double *;double *;double *;double *;int *;)int:::EXIT404
    Variables: pp2 px_ptr px_ptr[] py_ptr py_ptr[] qx_ptr qx_ptr[] qy_ptr qy_ptr[] pqxy_unit_ptr pqxy_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(px_ptr) orig(px_ptr[]) orig(py_ptr) orig(py_ptr[]) orig(qx_ptr) orig(qx_ptr[]) orig(qy_ptr) orig(qy_ptr[]) orig(pqxy_unit_ptr) orig(pqxy_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(px_ptr[]) size(px_ptr[])-1 size(py_ptr[]) size(py_ptr[])-1 size(qx_ptr[]) size(qx_ptr[])-1 size(qy_ptr[]) size(qy_ptr[])-1 size(pqxy_unit_ptr[]) size(pqxy_unit_ptr[])-1 orig(size(px_ptr[])) orig(size(px_ptr[]))-1 orig(size(py_ptr[])) orig(size(py_ptr[]))-1 orig(size(qx_ptr[])) orig(size(qx_ptr[]))-1 orig(size(qy_ptr[])) orig(size(qy_ptr[]))-1 orig(size(pqxy_unit_ptr[])) orig(size(pqxy_unit_ptr[]))-1
assignable px_ptr[*], py_ptr[*], qx_ptr[*], qy_ptr[*], pqxy_unit_ptr[*]
\result == 0
===========================================================================
std.versdef(charac *;charac **;double *;double *;double *;double *;int *;)int:::EXIT
    Variables: pp2 px_ptr px_ptr[] py_ptr py_ptr[] qx_ptr qx_ptr[] qy_ptr qy_ptr[] pqxy_unit_ptr pqxy_unit_ptr[] ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] return orig(pp2) orig(px_ptr) orig(px_ptr[]) orig(py_ptr) orig(py_ptr[]) orig(qx_ptr) orig(qx_ptr[]) orig(qy_ptr) orig(qy_ptr[]) orig(pqxy_unit_ptr) orig(pqxy_unit_ptr[]) orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[]) size(px_ptr[]) size(px_ptr[])-1 size(py_ptr[]) size(py_ptr[])-1 size(qx_ptr[]) size(qx_ptr[])-1 size(qy_ptr[]) size(qy_ptr[])-1 size(pqxy_unit_ptr[]) size(pqxy_unit_ptr[])-1 orig(size(px_ptr[])) orig(size(px_ptr[]))-1 orig(size(py_ptr[])) orig(size(py_ptr[]))-1 orig(size(qx_ptr[])) orig(size(qx_ptr[]))-1 orig(size(qy_ptr[])) orig(size(qy_ptr[]))-1 orig(size(pqxy_unit_ptr[])) orig(size(pqxy_unit_ptr[]))-1
assignable px_ptr[*], py_ptr[*], qx_ptr[*], qy_ptr[*], pqxy_unit_ptr[*]
pp2 == \old(pp2)
px_ptr == \old(px_ptr)
py_ptr == \old(py_ptr)
qx_ptr == \old(qx_ptr)
qy_ptr == \old(qy_ptr)
pqxy_unit_ptr == \old(pqxy_unit_ptr)
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
daikon.Quant.size(px_ptr) == \old(daikon.Quant.size(px_ptr))
daikon.Quant.size(py_ptr) == \old(daikon.Quant.size(py_ptr))
daikon.Quant.size(qx_ptr) == \old(daikon.Quant.size(qx_ptr))
daikon.Quant.size(qy_ptr) == \old(daikon.Quant.size(qy_ptr))
daikon.Quant.size(pqxy_unit_ptr) == \old(daikon.Quant.size(pqxy_unit_ptr))
pp2 != null
px_ptr != null
py_ptr != null
qx_ptr != null
qy_ptr != null
pqxy_unit_ptr != null
daikon.Quant.eltsGTE(pqxy_unit_ptr, 0)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
\result == 0 || \result == 1
daikon.Quant.size(px_ptr) == 1
daikon.Quant.size(py_ptr) == 1
daikon.Quant.size(qx_ptr) == 1
daikon.Quant.size(qy_ptr) == 1
daikon.Quant.size(pqxy_unit_ptr) == 1
daikon.Quant.pairwiseGTE(pqxy_unit_ptr, \old(pqxy_unit_ptr))
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
===========================================================================
std.waitcont()void:::ENTER
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[]
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
===========================================================================
std.waitcont()void:::EXIT
    Variables: ::GLOBLE_FILENAME ::GLOBLE_FILENAME[] orig(::GLOBLE_FILENAME) orig(::GLOBLE_FILENAME[])
::GLOBLE_FILENAME == \old(::GLOBLE_FILENAME)
::GLOBLE_FILENAME != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ::GLOBLE_FILENAME[] is printable
::GLOBLE_FILENAME.equals(\old(::GLOBLE_FILENAME))
